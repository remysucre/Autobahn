
==================== Demand analysis ====================
2016-11-06 20:04:56.886247153 UTC

Result size of Demand analysis
  = {terms: 222, types: 171, coercions: 21}

-- RHS size: {terms: 20, types: 19, coercions: 2}
$sread_s3ob :: String -> Int
[LclId,
 Arity=1,
 Str=DmdType <L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (s_a3jl [Occ=Once] :: String) ->
                 case Text.Read.readEither @ Int GHC.Read.$fReadInt s_a3jl
                 of _ [Occ=Dead] {
                   Left x_a3mf [Occ=Once] ->
                     errorWithoutStackTrace @ 'GHC.Types.PtrRepLifted @ Int x_a3mf;
                   Right y_a3mi [Occ=Once] -> y_a3mi
                 }}]
$sread_s3ob =
  \ (s_a3jl :: String) ->
    case Text.Read.readEither6
           @ Int
           (Text.ParserCombinators.ReadP.run
              @ Int
              (((GHC.Read.$fReadInt3
                   GHC.Read.$fReadInt_$sconvertInt
                   Text.ParserCombinators.ReadPrec.minPrec)
                `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <Int>_R
                        :: (Text.ParserCombinators.ReadP.ReadP Int :: *)
                           ~R#
                           ((forall b_a3oN.
                             (Int -> Text.ParserCombinators.ReadP.P b_a3oN)
                             -> Text.ParserCombinators.ReadP.P b_a3oN) :: *)))
                 @ Int (Text.Read.readEither5 @ Int))
              s_a3jl)
    of _ [Occ=Dead, Dmd=<L,A>] {
      [] ->
        errorWithoutStackTrace
          @ 'GHC.Types.PtrRepLifted @ Int Text.Read.readEither4;
      : x_a3nW [Dmd=<S,1*U(U)>] ds_a3nX [Dmd=<S,1*U>] ->
        case ds_a3nX of _ [Occ=Dead, Dmd=<L,A>] {
          [] -> x_a3nW;
          : ipv_a3oF [Dmd=<B,A>] ipv1_a3oG [Dmd=<B,A>] ->
            errorWithoutStackTrace
              @ 'GHC.Types.PtrRepLifted @ Int Text.Read.readEither2
        }
    }

-- RHS size: {terms: 1, types: 0, coercions: 0}
lvl_s3oq :: Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_s3oq = 1

-- RHS size: {terms: 1, types: 0, coercions: 0}
lvl_s3oo :: Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_s3oo = 1

Rec {
-- RHS size: {terms: 22, types: 4, coercions: 0}
fib_s3oe [Occ=LoopBreaker] :: Int -> Integer
[LclId,
 Arity=1,
 CallArity=1,
 Str=DmdType <S(S),1*U(1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 132 0}]
fib_s3oe =
  \ (ds_d3iY [Dmd=<S(S),1*U(1*U)>] :: Int) ->
    case ds_d3iY
    of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.I# x_a3r0 [Dmd=<S,1*U>] ->
    case x_a3r0 of wild_Xy {
      __DEFAULT ->
        integer-gmp-1.0.0.1:GHC.Integer.Type.plusInteger
          (fib_s3oe (GHC.Types.I# (GHC.Prim.-# wild_Xy 1#)))
          (fib_s3oe (GHC.Types.I# (GHC.Prim.-# wild_Xy 2#)));
      0# -> lvl_s3oq;
      1# -> lvl_s3oo
    }
    }
end Rec }

-- RHS size: {terms: 3, types: 1, coercions: 0}
$sfib_s3nE :: Int -> Integer
[LclId,
 Arity=1,
 Str=DmdType <S(S),1*U(1*U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
$sfib_s3nE =
  \ (eta_B1 [Dmd=<S(S),1*U(1*U)>] :: Int) -> fib_s3oe eta_B1

-- RHS size: {terms: 1, types: 0, coercions: 0}
lvl_s3ov :: Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_s3ov = 1

-- RHS size: {terms: 1, types: 0, coercions: 0}
lvl_s3ox :: Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_s3ox = 2

-- RHS size: {terms: 1, types: 0, coercions: 0}
lvl_s3oz :: Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_s3oz = 1

-- RHS size: {terms: 1, types: 0, coercions: 0}
lvl_s3ot :: Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_s3ot = 1

-- RHS size: {terms: 1, types: 0, coercions: 0}
lvl_s3oB :: Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_s3oB = 1

-- RHS size: {terms: 1, types: 0, coercions: 0}
lvl_s3or :: Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 100 0}]
lvl_s3or = 0

-- RHS size: {terms: 62, types: 33, coercions: 0}
fib
  :: forall t_aTh a_a1Z1.
     (Num a_a1Z1, Num t_aTh, Eq a_a1Z1) =>
     a_a1Z1 -> t_aTh
[LclIdX,
 Arity=4,
 Str=DmdType <L,U(A,C(C1(U)),A,A,A,A,C(U))><S,U(C(C1(U)),A,A,A,A,A,C(U))><S(C(C(S))L),U(C(C1(U)),A)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [180 90 60 0] 560 0},
 RULES: "SPEC fib @ Integer @ Int" [ALWAYS]
            forall ($dNum_s3nB :: Num Int)
                   ($dNum_s3nC :: Num Integer)
                   ($dEq_s3nD :: Eq Int).
              fib @ Integer @ Int $dNum_s3nB $dNum_s3nC $dEq_s3nD
              = $sfib_s3nE]
fib =
  \ (@ t_aTh)
    (@ a_a1Z1)
    ($dNum_a25J [Dmd=<L,U(A,C(C1(U)),A,A,A,A,C(U))>] :: Num a_a1Z1)
    ($dNum_a25K [Dmd=<S,U(C(C1(U)),A,A,A,A,A,C(U))>] :: Num t_aTh)
    ($dEq_a25L [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>] :: Eq a_a1Z1)
    (eta_B1 :: a_a1Z1) ->
    let {
      lvl_s3os :: a_a1Z1
      [LclId,
       Str=DmdType {a25J-><S(LLLLLLC(S)),A>},
       Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
               WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
      lvl_s3os = fromInteger @ a_a1Z1 $dNum_a25J lvl_s3or } in
    let {
      lvl_s3oC :: t_aTh
      [LclId,
       Str=DmdType {a25K-><S(LLLLLLC(S)),A>},
       Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
               WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
      lvl_s3oC = fromInteger @ t_aTh $dNum_a25K lvl_s3oB } in
    let {
      lvl_s3ou :: a_a1Z1
      [LclId,
       Str=DmdType {a25J-><S(LLLLLLC(S)),A>},
       Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
               WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
      lvl_s3ou = fromInteger @ a_a1Z1 $dNum_a25J lvl_s3ot } in
    let {
      lvl_s3oA :: t_aTh
      [LclId,
       Str=DmdType {a25K-><S(LLLLLLC(S)),A>},
       Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
               WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
      lvl_s3oA = fromInteger @ t_aTh $dNum_a25K lvl_s3oz } in
    let {
      lvl_s3oy :: a_a1Z1
      [LclId,
       Str=DmdType {a25J-><S(LLLLLLC(S)),A>},
       Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
               WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
      lvl_s3oy = fromInteger @ a_a1Z1 $dNum_a25J lvl_s3ox } in
    let {
      lvl_s3ow :: a_a1Z1
      [LclId,
       Str=DmdType {a25J-><S(LLLLLLC(S)),A>},
       Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
               WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
      lvl_s3ow = fromInteger @ a_a1Z1 $dNum_a25J lvl_s3ov } in
    letrec {
      fib_s3nA [Occ=LoopBreaker] :: a_a1Z1 -> t_aTh
      [LclId,
       Arity=1,
       CallArity=1,
       Str=DmdType <L,U> {a25K-><S,U(C(C1(U)),A,A,A,A,A,A)>
                          a25L-><S(C(C(S))L),U(C(C1(U)),A)>},
       Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
               WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 280 0}]
      fib_s3nA =
        \ (ds_d3iY :: a_a1Z1) ->
          case == @ a_a1Z1 $dEq_a25L ds_d3iY lvl_s3os
          of _ [Occ=Dead, Dmd=<L,A>] {
            False ->
              case == @ a_a1Z1 $dEq_a25L ds_d3iY lvl_s3ou
              of _ [Occ=Dead, Dmd=<L,A>] {
                False ->
                  + @ t_aTh
                    $dNum_a25K
                    (fib_s3nA (- @ a_a1Z1 $dNum_a25J ds_d3iY lvl_s3ow))
                    (fib_s3nA (- @ a_a1Z1 $dNum_a25J ds_d3iY lvl_s3oy));
                True -> lvl_s3oA
              };
            True -> lvl_s3oC
          }; } in
    fib_s3nA eta_B1

-- RHS size: {terms: 77, types: 64, coercions: 10}
main_s5wa
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 573 0}]
main_s5wa =
  \ (s_a5w3 [Dmd=<S,U>, OS=OneShot]
       :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    case System.Environment.getArgs1 s_a5w3
    of _ [Occ=Dead, Dmd=<L,A>]
    { (# ipv_a5w6 [Dmd=<S,U>], ipv1_a5w7 [Dmd=<L,1*U>] #) ->
    let {
      a_s3ny [Dmd=<L,U(U)>] :: Int
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
               WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 201 0}]
      a_s3ny =
        case Text.Read.readEither6
               @ Int
               (Text.ParserCombinators.ReadP.run
                  @ Int
                  (((GHC.Read.$fReadInt3
                       GHC.Read.$fReadInt_$sconvertInt
                       Text.ParserCombinators.ReadPrec.minPrec)
                    `cast` (Text.ParserCombinators.ReadP.N:ReadP[0] <Int>_R
                            :: (Text.ParserCombinators.ReadP.ReadP Int :: *)
                               ~R#
                               ((forall b_a3oN.
                                 (Int -> Text.ParserCombinators.ReadP.P b_a3oN)
                                 -> Text.ParserCombinators.ReadP.P b_a3oN) :: *)))
                     @ Int (Text.Read.readEither5 @ Int))
                  (case ipv1_a5w7 of _ [Occ=Dead, Dmd=<L,A>] {
                     [] -> GHC.List.badHead @ String;
                     : x_a3jd [Dmd=<S,1*U>] ds1_a3je [Dmd=<L,A>] -> x_a3jd
                   }))
        of _ [Occ=Dead, Dmd=<L,A>] {
          [] ->
            error
              @ 'GHC.Types.PtrRepLifted
              @ Int
              (GHC.Err.errorWithoutStackTrace_wild1
               `cast` (Sym
                         (GHC.Classes.N:IP[0] <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                       :: (GHC.Stack.Types.CallStack :: *)
                          ~R#
                          ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)))
              Text.Read.readEither4;
          : x_a3nW [Dmd=<S,1*U(U)>] ds_a3nX [Dmd=<S,1*U>] ->
            case ds_a3nX of _ [Occ=Dead, Dmd=<L,A>] {
              [] -> x_a3nW;
              : ipv_a3oF [Dmd=<B,A>] ipv1_a3oG [Dmd=<B,A>] ->
                error
                  @ 'GHC.Types.PtrRepLifted
                  @ Int
                  (GHC.Err.errorWithoutStackTrace_wild1
                   `cast` (Sym
                             (GHC.Classes.N:IP[0] <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                           :: (GHC.Stack.Types.CallStack :: *)
                              ~R#
                              ((?callStack::GHC.Stack.Types.CallStack) :: Constraint)))
                  Text.Read.readEither2
            }
        } } in
    case GHC.IO.Handle.Text.hPutStr2
           GHC.IO.Handle.FD.stdout
           (GHC.Show.$fShowInt_$cshow a_s3ny)
           GHC.Types.True
           ipv_a5w6
    of _ [Occ=Dead, Dmd=<L,A>]
    { (# ipv_a3Oe [Dmd=<S,U>], ipv1_a3Of [Dmd=<L,A>] #) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout
      (letrec {
         fib_s3nA [Occ=LoopBreaker] :: Int -> Integer
         [LclId,
          Arity=1,
          CallArity=1,
          Str=DmdType <S(S),1*U(1*U)>,
          Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                  WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 132 0}]
         fib_s3nA =
           \ (ds_d3iY [Dmd=<S(S),1*U(1*U)>] :: Int) ->
             case ds_d3iY
             of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.I# x_a3r0 [Dmd=<S,1*U>] ->
             case x_a3r0 of wild_XY {
               __DEFAULT ->
                 integer-gmp-1.0.0.1:GHC.Integer.Type.plusInteger
                   (fib_s3nA (GHC.Types.I# (GHC.Prim.-# wild_XY 1#)))
                   (fib_s3nA (GHC.Types.I# (GHC.Prim.-# wild_XY 2#)));
               0# -> lvl_s3oB;
               1# -> lvl_s3oz
             }
             }; } in
       case GHC.Show.$w$cshowsPrec3
              0# (fib_s3nA a_s3ny) (GHC.Types.[] @ Char)
       of _ [Occ=Dead, Dmd=<L,A>] { (# ww3_a3NV, ww4_a3NW #) ->
       GHC.Types.: @ Char ww3_a3NV ww4_a3NW
       })
      GHC.Types.True
      ipv_a3Oe
    }
    }

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
main =
  main_s5wa
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s6ca
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
main_s6ca =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s5wa
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
:Main.main =
  main_s6ca
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s3nr :: GHC.Types.TrName
[LclId,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s3nr = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s3ns :: GHC.Types.TrName
[LclId,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s3ns = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s3nr $trModule_s3ns


------ Local rules for imported ids --------
"SPEC/Main read @ Int" [ALWAYS]
    forall ($dRead_s3nI :: Read Int).
      read @ Int $dRead_s3nI
      = $sread_s3ob

