
==================== Demand analysis ====================
2017-02-20 02:21:45.872108 UTC

Result size of Demand analysis
  = {terms: 367, types: 227, coercions: 0}

-- RHS size: {terms: 2, types: 0, coercions: 0}
lvl_s4yI :: Double
[LclId,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
lvl_s4yI = GHC.Types.D# 0.0##

-- RHS size: {terms: 3, types: 2, coercions: 0}
$ssum_s4yK [InlPrag=INLINE (sat-args=0)] :: [Double] -> Double
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= GHC.List.foldl
                 @ Double @ Double GHC.Float.$fNumDouble_$c+ (GHC.Types.D# 0.0##)}]
$ssum_s4yK =
  GHC.List.foldl @ Double @ Double GHC.Float.plusDouble lvl_s4yI

-- RHS size: {terms: 9, types: 11, coercions: 0}
ints :: [Double]
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 60 30}]
ints =
  case GHC.Real.$wnumericEnumFrom
         @ Double GHC.Float.$fFractionalDouble (GHC.Types.D# 1.0##)
  of _ [Occ=Dead, Dmd=<L,A>] { (# ww1_a4sO, ww2_a4sP #) ->
  GHC.Types.: @ Double ww1_a4sO ww2_a4sP
  }

-- RHS size: {terms: 14, types: 5, coercions: 0}
is :: [Double]
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 63 0}]
is =
  map
    @ Double
    @ Double
    (\ (ds_d4nY [Dmd=<S(S),1*U(U)>, OS=ProbOneShot] :: Double) ->
       case ds_d4nY
       of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# x_a4zs [Dmd=<S,U>] ->
       GHC.Types.D#
         (GHC.Prim.*##
            (GHC.Prim.*## (GHC.Prim.*## x_a4zs x_a4zs) x_a4zs) x_a4zs)
       })
    ints

-- RHS size: {terms: 6, types: 6, coercions: 0}
itotals_s4vH :: Double
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
itotals_s4vH =
  case is of _ [Occ=Dead, Dmd=<L,A>] {
    [] -> GHC.List.badHead @ Double;
    : x_a4ru [Dmd=<S,1*U(U)>] ds1_a4rv [Dmd=<L,A>] -> x_a4ru
  }

Rec {
-- RHS size: {terms: 3, types: 1, coercions: 0}
itotals :: [Double]
[LclIdX,
 Str=DmdType m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
itotals = GHC.Types.: @ Double itotals_s4vH itotals_s4vI

-- RHS size: {terms: 10, types: 12, coercions: 0}
itotals_s4vI [Occ=LoopBreaker] :: [Double]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 60 0}]
itotals_s4vI =
  case is of _ [Occ=Dead, Dmd=<L,A>] {
    [] -> case GHC.List.scanl2 of wild_00 [Dmd=<B,A>] { };
    : ds1_a4rD [Dmd=<L,A>] xs_a4rE [Dmd=<S,1*U>] ->
      zipWith
        @ Double @ Double @ Double GHC.Float.plusDouble xs_a4rE itotals
  }
end Rec }

-- RHS size: {terms: 7, types: 4, coercions: 0}
itotal :: Int -> Double
[LclIdX,
 Arity=1,
 Str=DmdType <S(S),1*U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 40 0}]
itotal =
  \ (n_a16P [Dmd=<S(S),1*U(U)>] :: Int) ->
    case n_a16P
    of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.I# ipv_s4vK [Dmd=<S,U>] ->
    GHC.List.$w!! @ Double itotals ipv_s4vK
    }

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s4vM :: GHC.Types.TrName
[LclId,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s4vM = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s4vN :: GHC.Types.TrName
[LclId,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s4vN = GHC.Types.TrNameS "Dum"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Dum.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Dum.$trModule = GHC.Types.Module $trModule_s4vM $trModule_s4vN

-- RHS size: {terms: 109, types: 29, coercions: 0}
integrate1D :: Double -> Double -> (Double -> Double) -> Double
[LclIdX,
 Arity=3,
 Str=DmdType <S(S),1*U(U)><S(S),1*U(U)><S,1*U>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 20 20] 405 20}]
integrate1D =
  \ (l_azc [Dmd=<S(S),1*U(U)>] :: Double)
    (u_azd [Dmd=<S(S),1*U(U)>] :: Double)
    (f_aze [Dmd=<S,1*U>] :: Double -> Double) ->
    case l_azc of l_Xzl { GHC.Types.D# ipv_s4vP [Dmd=<S,U>] ->
    case f_aze of f_Xzo [Dmd=<C(S(S)),C(U(U))>] { __DEFAULT ->
    case u_azd of wild_a4zR { GHC.Types.D# x_a4zT [Dmd=<S,U>] ->
    case f_Xzo l_Xzl
    of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# x_X4B2 [Dmd=<S,U>] ->
    let {
      ipv_s4Bc [Dmd=<S,U>] :: GHC.Prim.Double#
      [LclId,
       Str=DmdType {a4zT-><S,A> s4vP-><S,A>},
       Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
               WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 2 0}]
      ipv_s4Bc = GHC.Prim./## (GHC.Prim.-## x_a4zT ipv_s4vP) 8.0## } in
    case f_Xzo (GHC.Types.D# (GHC.Prim.+## ipv_s4vP ipv_s4Bc))
    of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# y_X4CL [Dmd=<S,U>] ->
    case f_Xzo
           (GHC.Types.D#
              (GHC.Prim.+## ipv_s4vP (GHC.Prim.+## ipv_s4Bc ipv_s4Bc)))
    of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# y_X4B6 [Dmd=<S,U>] ->
    case f_Xzo
           (GHC.Types.D#
              (GHC.Prim.+## ipv_s4vP (GHC.Prim.*## 3.0## ipv_s4Bc)))
    of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# y_X4Ba [Dmd=<S,U>] ->
    case f_Xzo
           (GHC.Types.D#
              (GHC.Prim.+## ipv_s4vP (GHC.Prim.*## 4.0## ipv_s4Bc)))
    of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# y_X4Be [Dmd=<S,U>] ->
    case f_Xzo
           (GHC.Types.D# (GHC.Prim.-## x_a4zT (GHC.Prim.*## 3.0## ipv_s4Bc)))
    of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# y_X4Bi [Dmd=<S,U>] ->
    case f_Xzo
           (GHC.Types.D#
              (GHC.Prim.-## x_a4zT (GHC.Prim.+## ipv_s4Bc ipv_s4Bc)))
    of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# y_X4Bm [Dmd=<S,U>] ->
    case f_Xzo (GHC.Types.D# (GHC.Prim.-## x_a4zT ipv_s4Bc))
    of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# y_X4Bq [Dmd=<S,U>] ->
    case f_Xzo wild_a4zR
    of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# x_X4Dd [Dmd=<S,U>] ->
    GHC.Types.D#
      (GHC.Prim.*##
         ipv_s4Bc
         (GHC.Prim.+##
            (GHC.Prim.+##
               (GHC.Prim.+##
                  (GHC.Prim.+##
                     (GHC.Prim.+##
                        (GHC.Prim.+##
                           (GHC.Prim.+##
                              (GHC.Prim.+## (GHC.Prim.*## x_X4B2 0.5##) y_X4CL) y_X4B6)
                           y_X4Ba)
                        y_X4Be)
                     y_X4Bi)
                  y_X4Bm)
               y_X4Bq)
            (GHC.Prim.*## x_X4Dd 0.5##)))
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }

-- RHS size: {terms: 25, types: 15, coercions: 0}
integrate2D
  :: Double
     -> Double
     -> Double
     -> Double
     -> (Double -> Double -> Double)
     -> Double
[LclIdX,
 Arity=5,
 Str=DmdType <L,U(U)><L,U(U)><S(S),1*U(U)><S(S),1*U(U)><L,C(C1(U))>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 20 20 60] 160 0}]
integrate2D =
  \ (l1_a12X [Dmd=<L,U(U)>] :: Double)
    (u1_a12Y [Dmd=<L,U(U)>] :: Double)
    (l2_a12Z [Dmd=<S(S),1*U(U)>] :: Double)
    (u2_a130 [Dmd=<S(S),1*U(U)>] :: Double)
    (f_a131 [Dmd=<L,C(C1(U))>] :: Double -> Double -> Double) ->
    case l2_a12Z
    of l2_X13b [Dmd=<S(S),1*U(U)>]
    { GHC.Types.D# ipv_s4wJ [Dmd=<S,U>] ->
    case u2_a130
    of u2_X13d [Dmd=<S(S),1*U(U)>]
    { GHC.Types.D# ipv_s4wM [Dmd=<S,U>] ->
    integrate1D
      l2_X13b
      u2_X13d
      (\ (y_a132 [Dmd=<S,1*U(U)>] :: Double) ->
         case y_a132 of y_X13h { GHC.Types.D# ipv_s4wP ->
         integrate1D
           l1_a12X u1_a12Y (\ (x_a133 :: Double) -> f_a131 x_a133 y_X13h)
         })
    }
    }

-- RHS size: {terms: 2, types: 0, coercions: 0}
lvl_s4yX :: Double
[LclId,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
lvl_s4yX = GHC.Types.D# 0.0##

-- RHS size: {terms: 2, types: 0, coercions: 0}
lvl_s4yY :: Double
[LclId,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
lvl_s4yY = GHC.Types.D# 0.0##

-- RHS size: {terms: 23, types: 10, coercions: 0}
zark :: Double -> Double -> Double
[LclIdX,
 Arity=2,
 Str=DmdType <L,U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 20] 141 0}]
zark =
  \ (u_a134 [Dmd=<L,U(U)>] :: Double)
    (v_a135 [Dmd=<S(S),1*U(U)>] :: Double) ->
    case v_a135
    of u2_X13d [Dmd=<S(S),1*U(U)>]
    { GHC.Types.D# ipv_s4wM [Dmd=<S,U>] ->
    integrate1D
      lvl_s4yY
      u2_X13d
      (\ (y_a132 [Dmd=<S,1*U(U)>] :: Double) ->
         case y_a132 of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# ipv_s4wP ->
         integrate1D
           lvl_s4yX
           u_a134
           (\ (x_a133 [Dmd=<S(S),1*U(U)>] :: Double) ->
              case x_a133
              of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# x_a4zs [Dmd=<S,U>] ->
              GHC.Types.D# (GHC.Prim.*## x_a4zs ipv_s4wP)
              })
         })
    }

-- RHS size: {terms: 13, types: 8, coercions: 0}
zarks :: [Double]
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 101 0}]
zarks =
  zipWith
    @ Double
    @ Double
    @ Double
    zark
    ints
    (map
       @ Double
       @ Double
       (\ (ds1_a4zp [Dmd=<S(S),1*U(U)>, OS=ProbOneShot] :: Double) ->
          case ds1_a4zp
          of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# y_a4zw [Dmd=<S,U>] ->
          GHC.Types.D# (GHC.Prim.+## y_a4zw y_a4zw)
          })
       ints)

-- RHS size: {terms: 6, types: 6, coercions: 0}
rtotals_s4x5 :: Double
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
rtotals_s4x5 =
  case zarks of _ [Occ=Dead, Dmd=<L,A>] {
    [] -> GHC.List.badHead @ Double;
    : x_a4ru [Dmd=<S,1*U(U)>] ds1_a4rv [Dmd=<L,A>] -> x_a4ru
  }

Rec {
-- RHS size: {terms: 3, types: 1, coercions: 0}
rtotals :: [Double]
[LclIdX,
 Str=DmdType m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
rtotals = GHC.Types.: @ Double rtotals_s4x5 rtotals_s4x6

-- RHS size: {terms: 10, types: 12, coercions: 0}
rtotals_s4x6 [Occ=LoopBreaker] :: [Double]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 60 0}]
rtotals_s4x6 =
  case zarks of _ [Occ=Dead, Dmd=<L,A>] {
    [] -> case GHC.List.scanl2 of wild_00 [Dmd=<B,A>] { };
    : ds1_a4rD [Dmd=<L,A>] xs_a4rE [Dmd=<S,1*U>] ->
      zipWith
        @ Double @ Double @ Double GHC.Float.plusDouble xs_a4rE rtotals
  }
end Rec }

-- RHS size: {terms: 7, types: 4, coercions: 0}
rtotal :: Int -> Double
[LclIdX,
 Arity=1,
 Str=DmdType <S(S),1*U(U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 40 0}]
rtotal =
  \ (n_a16O [Dmd=<S(S),1*U(U)>] :: Int) ->
    case n_a16O
    of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.I# ww1_a4oB [Dmd=<S,U>] ->
    GHC.List.$w!! @ Double rtotals ww1_a4oB
    }

Rec {
-- RHS size: {terms: 30, types: 22, coercions: 0}
go_a4ve [Occ=LoopBreaker] :: [Double] -> [Double] -> [Double]
[LclId,
 Arity=2,
 CallArity=2,
 Str=DmdType <S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 30] 151 50}]
go_a4ve =
  \ (ds_a4vf [Dmd=<S,1*U>] :: [Double])
    (_ys_a4vg [Dmd=<L,1*U>] :: [Double]) ->
    case ds_a4vf of _ [Occ=Dead, Dmd=<L,A>] {
      [] -> GHC.Types.[] @ Double;
      : ipv_a4vl [Dmd=<L,1*U(U)>] ipv1_a4vm [Dmd=<L,1*U>] ->
        case _ys_a4vg of _ [Occ=Dead, Dmd=<L,A>] {
          [] -> GHC.Types.[] @ Double;
          : ipv2_a4vs [Dmd=<L,1*U(U)>] ipv3_a4vt [Dmd=<L,1*U>] ->
            GHC.Types.:
              @ Double
              (let {
                 x_a4tT [Dmd=<S(S),U(U)>] :: Double
                 [LclId,
                  Str=DmdType m {a4vl-><S(S),A> a4vs-><S(S),A>},
                  Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                          WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 31 20}]
                 x_a4tT =
                   case ipv_a4vl
                   of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# x_a4zT [Dmd=<S,U>] ->
                   case ipv2_a4vs
                   of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.D# y_a4zX [Dmd=<S,U>] ->
                   GHC.Types.D# (GHC.Prim.-## x_a4zT y_a4zX)
                   }
                   } } in
               GHC.Float.timesDouble x_a4tT x_a4tT)
              (go_a4ve ipv1_a4vm ipv3_a4vt)
        }
    }
end Rec }

-- RHS size: {terms: 3, types: 0, coercions: 0}
es :: [Double]
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
es = go_a4ve rtotals itotals

-- RHS size: {terms: 49, types: 24, coercions: 0}
etotal :: Int -> Double
[LclIdX,
 Arity=1,
 Str=DmdType <S(S),1*U(U)>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20] 303 20}]
etotal =
  \ (n_a16Q [Dmd=<S(S),1*U(U)>] :: Int) ->
    case n_a16Q
    of n_X174 [Dmd=<L,1*U(1*U)>] { GHC.Types.I# ipv_s4x9 [Dmd=<S,U>] ->
    case GHC.Prim.tagToEnum# @ Bool (GHC.Prim.<# 0# ipv_s4x9)
    of _ [Occ=Dead, Dmd=<L,A>] {
      False -> GHC.Types.D# 0.0##;
      True ->
        letrec {
          go_a4tF [Occ=LoopBreaker] :: [Double] -> Int -> Double -> Double
          [LclId,
           Arity=3,
           CallArity=3,
           Str=DmdType <S,1*U><S,1*U(1*U)><S,1*U(U)>m,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                   WorkFree=True, Expandable=True, Guidance=IF_ARGS [40 40 0] 171 0}]
          go_a4tF =
            \ (ds_a4tG [Dmd=<S,1*U>] :: [Double])
              (eta_B1 [Dmd=<S,1*U(1*U)>] :: Int)
              (eta_X2 [Dmd=<S,1*U(U)>] :: Double) ->
              case ds_a4tG of _ [Occ=Dead, Dmd=<L,A>] {
                [] ->
                  case eta_B1
                  of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.I# ipv_a4y0 [Dmd=<L,A>] ->
                  eta_X2
                  };
                : y_a4tL [Dmd=<S(S),1*U(U)>] ys_a4tM [Dmd=<L,1*U>] ->
                  case eta_B1
                  of _ [Occ=Dead, Dmd=<L,A>] { GHC.Types.I# ds_a4xS [Dmd=<S,1*U>] ->
                  case ds_a4xS of ds1_a4xU {
                    __DEFAULT ->
                      go_a4tF
                        ys_a4tM
                        (GHC.Types.I# (GHC.Prim.-# ds1_a4xU 1#))
                        (GHC.Float.plusDouble eta_X2 y_a4tL);
                    1# -> GHC.Float.plusDouble eta_X2 y_a4tL
                  }
                  }
              }; } in
        go_a4tF es n_X174 (GHC.Types.D# 0.0##)
    }
    }


------ Local rules for imported ids --------
"SPEC/Dum sum @ Double" [ALWAYS]
    forall ($dNum_s4yw :: Num Double).
      GHC.List.sum @ Double $dNum_s4yw
      = $ssum_s4yK

