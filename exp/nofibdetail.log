
==================== Renamer ====================
Geomfuns.swapxy :: [Int] -> [Int]
Geomfuns.swapxy [x1_apZ, y1_aq0, (!x2_aq1), y2_aq2]
  = [y1_aq0, x1_apZ, y2_aq2, x2_aq1]
Geomfuns.mapx, Geomfuns.mapy :: (Int -> Int) -> [Int] -> [Int]
Geomfuns.mapx f_aq3 [x1_aq4, y1_aq5, x2_aq6, (!y2_aq7)]
  = [f_aq3 x1_aq4, y1_aq5, f_aq3 x2_aq6, y2_aq7]
Geomfuns.mapy f_aq8 (![(!x1_aq9), (!y1_aqa), (!x2_aqb), (!y2_aqc)])
  = [x1_aq9, f_aq8 y1_aqa, x2_aqb, f_aq8 y2_aqc]
Geomfuns.toright, Geomfuns.down :: Int -> [[Int]] -> [[Int]]
Geomfuns.toright = map . Geomfuns.mapx . (+)
Geomfuns.down = map . Geomfuns.mapy . (+)
Geomfuns.origin :: Int -> Int -> [[Int]] -> [[Int]]
Geomfuns.origin (!x_arb) y_arc
  = (Geomfuns.toright x_arb) . (Geomfuns.down y_arc)
Geomfuns.place :: Int -> Int -> [[Int]] -> [Char]
Geomfuns.place (!x_ard) (!y_are)
  = drawlines . (Geomfuns.origin x_ard y_are)
Geomfuns.xymax :: Int
Geomfuns.xymax = 72
Geomfuns.lrinvert, Geomfuns.tbinvert, Geomfuns.rotatecw, Geomfuns.antirotate ::
  Int -> [[Int]] -> [[Int]]
Geomfuns.lrinvert m_arf
  = map (Geomfuns.mapx (\ x_arg -> m_arf - x_arg))
Geomfuns.tbinvert (!m_arh)
  = map (Geomfuns.mapy (\ x_ari -> m_arh - x_ari))
Geomfuns.rotatecw (!m_arj)
  = map
      (Geomfuns.swapxy . (Geomfuns.mapy (\ x_ark -> m_arj - x_ark)))
Geomfuns.antirotate m_arl
  = map
      (Geomfuns.swapxy . (Geomfuns.mapx (\ (!x_arm) -> m_arl - x_arm)))
Geomfuns.t4 :: [[[Int]]] -> [[Int]]
Geomfuns.t4 [c1_arn, c2_aro, (!c3_arp), c4_arq]
  = c1_arn
    ++
      Geomfuns.toright ss_arr c2_aro
      ++
        Geomfuns.down ss_arr c3_arp
        ++ (Geomfuns.down ss_arr . Geomfuns.toright ss_arr) c4_arq
  where
      (!ss_arr) = Geomfuns.xymax
Geomfuns.tile :: Int -> Int -> Int -> Int -> [[Int]] -> [Char]
Geomfuns.tile _ _ _ 0 coords_ars = ""
Geomfuns.tile _ (!_) 0 _ coords_art = ""
Geomfuns.tile (!x_aru) y_arv (!c_arw) (!r_arx) (!coords_ary)
  = Geomfuns.col x_aru y_arv r_arx coords_ary
    ++
      Geomfuns.row
        (x_aru + 2 * Geomfuns.xymax) y_arv (c_arw - 1) coords_ary
      ++
        Geomfuns.tile
          (x_aru + 2 * Geomfuns.xymax)
          (y_arv + 2 * Geomfuns.xymax)
          (c_arw - 1)
          (r_arx - 1)
          coords_ary
Geomfuns.col, Geomfuns.row ::
  Int -> Int -> Int -> [[Int]] -> [Char]
Geomfuns.col x_arz y_arA (!0) coords_arB = ""
Geomfuns.col x_arC y_arD (!n_arE) coords_arF
  = Geomfuns.place x_arC y_arD coords_arF
    ++ Geomfuns.col x_arC y'_arG (n_arE - 1) coords_arF
  where
      y'_arG = y_arD + (2 * Geomfuns.xymax)
Geomfuns.row (!x_arH) (!y_arI) 0 coords_arJ = ""
Geomfuns.row x_arK y_arL (!n_arM) (!coords_arN)
  = Geomfuns.place x_arK y_arL coords_arN
    ++ Geomfuns.row x'_arO y_arL (n_arM - 1) coords_arN
  where
      x'_arO = x_arK + (2 * Geomfuns.xymax)


["x1_apZ","y1_aq0","x2_aq1","safebang@!x2_aq1","(!x2_aq1)","y2_aq2","[x1_apZ, y1_aq0, (!x2_aq1), y2_aq2]","f_aq3","x1_aq4","y1_aq5","x2_aq6","y2_aq7","safebang@!y2_aq7","(!y2_aq7)","[x1_aq4, y1_aq5, x2_aq6, (!y2_aq7)]","f_aq8","x1_aq9","safebang@!x1_aq9","(!x1_aq9)","y1_aqa","safebang@!y1_aqa","(!y1_aqa)","x2_aqb","safebang@!x2_aqb","(!x2_aqb)","y2_aqc","safebang@!y2_aqc","(!y2_aqc)","[(!x1_aq9), (!y1_aqa), (!x2_aqb), (!y2_aqc)]","![(!x1_aq9), (!y1_aqa), (!x2_aqb), (!y2_aqc)]","(![(!x1_aq9), (!y1_aqa), (!x2_aqb), (!y2_aqc)])","toright","down","x_arb","!x_arb","(!x_arb)","y_arc","x_ard","safebang@!x_ard","(!x_ard)","y_are","safebang@!y_are","(!y_are)","xymax","m_arf","x_arg","m_arh","safebang@!m_arh","(!m_arh)","x_ari","m_arj","safebang@!m_arj","(!m_arj)","x_ark","m_arl","x_arm","!x_arm","(!x_arm)","c1_arn","c2_aro","c3_arp","safebang@!c3_arp","(!c3_arp)","c4_arq","[c1_arn, c2_aro, (!c3_arp), c4_arq]","ss_arr","!ss_arr","(!ss_arr)","_","_","_","0","coords_ars","_","_","!_","(!_)","0","_","coords_art","x_aru","!x_aru","(!x_aru)","y_arv","c_arw","!c_arw","(!c_arw)","r_arx","!r_arx","(!r_arx)","coords_ary","!coords_ary","(!coords_ary)","x_arz","y_arA","0","!0","(!0)","coords_arB","x_arC","y_arD","n_arE","!n_arE","(!n_arE)","coords_arF","y'_arG","x_arH","safebang@!x_arH","(!x_arH)","y_arI","safebang@!y_arI","(!y_arI)","0","coords_arJ","x_arK","y_arL","n_arM","!n_arM","(!n_arM)","coords_arN","!coords_arN","(!coords_arN)","x'_arO"]
module Geomfuns
       (mapx, mapy, col, row, lrinvert, antirotate, place, rotatecw,
        tbinvert, tile, t4, xymax)
       where
import Mgrfuns
import Drawfuns

swapxy :: [Int] -> [Int]
swapxy [x1_apZ, y1_aq0, (!x2_aq1), y2_aq2]
  = [y1_aq0, x1_apZ, y2_aq2, x2_aq1]

mapx, mapy :: (Int -> Int) -> [Int] -> [Int]
mapx f_aq3 [x1_aq4, y1_aq5, x2_aq6, (!y2_aq7)]
  = [f_aq3 x1_aq4, y1_aq5, f_aq3 x2_aq6, y2_aq7]
mapy f_aq8 (norecord@[(!x1_aq9), (!y1_aqa), (!x2_aqb), (!y2_aqc)])
  = [x1_aq9, f_aq8 y1_aqa, x2_aqb, f_aq8 y2_aqc]

toright, down :: Int -> [[Int]] -> [[Int]]
toright = map . mapx . (+)
down = map . mapy . (+)

origin :: Int -> Int -> [[Int]] -> [[Int]]
origin (norecord@x_arb) y_arc = (toright x_arb) . (down y_arc)

place :: Int -> Int -> [[Int]] -> [Char]
place (!x_ard) (!y_are) = drawlines . (origin x_ard y_are)

xymax :: Int
xymax = 72

lrinvert, tbinvert, rotatecw, antirotate ::
          Int -> [[Int]] -> [[Int]]
lrinvert m_arf = map (mapx (\ x_arg -> m_arf - x_arg))
tbinvert (!m_arh) = map (mapy (\ x_ari -> m_arh - x_ari))
rotatecw (!m_arj)
  = map (swapxy . (mapy (\ x_ark -> m_arj - x_ark)))
antirotate m_arl
  = map (swapxy . (mapx (\ (norecord@x_arm) -> m_arl - x_arm)))

t4 :: [[[Int]]] -> [[Int]]
t4 [c1_arn, c2_aro, (!c3_arp), c4_arq]
  = c1_arn ++ toright ss_arr c2_aro ++ down ss_arr c3_arp ++
      (down ss_arr . toright ss_arr) c4_arq
  where (norecord@ss_arr) = xymax

tile :: Int -> Int -> Int -> Int -> [[Int]] -> [Char]
tile _ _ _ 0 coords_ars = ""
tile _ (norecord@_) 0 _ coords_art = ""
tile (norecord@x_aru) y_arv (norecord@c_arw) (norecord@r_arx)
  (norecord@coords_ary)
  = col x_aru y_arv r_arx coords_ary ++
      row (x_aru + 2 * xymax) y_arv (c_arw - 1) coords_ary
      ++
      tile (x_aru + 2 * xymax) (y_arv + 2 * xymax) (c_arw - 1)
        (r_arx - 1)
        coords_ary

col, row :: Int -> Int -> Int -> [[Int]] -> [Char]
col x_arz y_arA (norecord@0) coords_arB = ""
col x_arC y_arD (norecord@n_arE) coords_arF
  = place x_arC y_arD coords_arF ++
      col x_arC y'_arG (n_arE - 1) coords_arF
  where y'_arG = y_arD + (2 * xymax)
row (!x_arH) (!y_arI) 0 coords_arJ = ""
row x_arK y_arL (norecord@n_arM) (norecord@coords_arN)
  = place x_arK y_arL coords_arN ++
      row x'_arO y_arL (n_arM - 1) coords_arN
  where x'_arO = x_arK + (2 * xymax)

==================== Renamer ====================
Main.main
  = do { fromMgr_aEp <- getContents;
         let (!toMgr_aEq)
               = setmode 7
                 ++
                   shapewindow [0, 0, 1150, 900]
                   ++
                     setup
                     ++
                       potatotile ([], 1, initalist) (lines fromMgr_aEp)
                       ++
                         shapewindow [0, 0, 500, 500]
                         ++ font 8 ++ textreset ++ clear ++ func 15;
         putStr toMgr_aEq }



==================== Renamer ====================
Drawfuns.gowin :: Int -> [Char]
Drawfuns.gowin n_ap3 = selectwin n_ap3 ++ setmode 7 ++ setmode 8
Drawfuns.rectangle :: [Int] -> [Char]
Drawfuns.rectangle [x1_ap4, (!y1_ap5), x2_ap6, y2_ap7]
  = line [x1_ap4, y1_ap5, x2_ap6, y1_ap5]
    ++
      line [x2_ap6, y1_ap5, x2_ap6, y2_ap7]
      ++
        line [x1_ap4, y1_ap5, x1_ap4, y2_ap7]
        ++ line [x1_ap4, y2_ap7, x2_ap6, y2_ap7]
Drawfuns.fillrect :: [Int] -> [Char]
Drawfuns.fillrect [x0_ap8, y0_ap9, x1_apa, (!y1_apb)]
  = shade_ape (diff x0_ap8 x1_apa)
  where
      m_apc = min x0_ap8 x1_apa
      vline_apd (!n_aCH) = line [n_aCH, y0_ap9, n_aCH, y1_apb]
      shade_ape (!0) = vline_apd m_apc
      shade_ape (!n_aCI)
        = vline_apd (m_apc + n_aCI) ++ shade_ape (n_aCI - 1)
Drawfuns.squ :: Int -> Int -> Int -> [Char]
Drawfuns.squ (!n_aDH) (!x_aDI) (!y_aDJ)
  = Drawfuns.rectangle [x_aDI, y_aDJ, x_aDI + n_aDH, y_aDJ + n_aDH]
Drawfuns.circ :: Int -> Int -> Int -> [Char]
Drawfuns.circ n_aDK (!x_aDL) y_aDM = circle [x_aDL, y_aDM, n_aDK]
Drawfuns.drawdot :: Int -> Int -> [Char]
Drawfuns.drawdot (!x_aDN) (!y_aDO)
  = Drawfuns.fillrect [x_aDN - 1, y_aDO - 1, x_aDN + 1, y_aDO + 1]
Drawfuns.undo :: [Char] -> [Char]
Drawfuns.undo (!f_aDP) = func 0 ++ f_aDP ++ func 15
Drawfuns.undraw :: [Int] -> [Char]
Drawfuns.undraw = Drawfuns.undo . line
Drawfuns.drawlines :: [[Int]] -> [Char]
Drawfuns.drawlines = concat . map line
Drawfuns.allpairs (!_) [] (!_) = []
Drawfuns.allpairs _ _ (![]) = []
Drawfuns.allpairs f_aJX (x_aJY : (!xs_aJZ)) (!ys_aK0)
  = map (f_aJX x_aJY) ys_aK0 ++ Drawfuns.allpairs f_aJX xs_aJZ ys_aK0
Drawfuns.grid ::
  Int
  -> Int
     -> Int -> Int -> Int -> Int -> (Int -> Int -> [a_aoV]) -> [a_aoV]
Drawfuns.grid
  xor_aK1
  yor_aK2
  xgap_aK3
  ygap_aK4
  xlength_aK5
  ylength_aK6
  (!drawf_aK7)
  = concat (Drawfuns.allpairs drawf_aK7 x0list_aK8 y0list_aK9)
  where
      x0list_aK8 = gridlist_aKa xor_aK1 xgap_aK3 xlength_aK5
      y0list_aK9 = gridlist_aKa yor_aK2 ygap_aK4 ylength_aK6
      gridlist_aKa orig_aKb (!gap_aKc) len_aKd
        = take len_aKd (gridlist'_aKe orig_aKb)
        where
            gridlist'_aKe (!n_aKf) = n_aKf : gridlist'_aKe (n_aKf + gap_aKc)


["n_ap3","x1_ap4","y1_ap5","safebang@!y1_ap5","(!y1_ap5)","x2_ap6","y2_ap7","[x1_ap4, (!y1_ap5), x2_ap6, y2_ap7]","x0_ap8","y0_ap9","x1_apa","y1_apb","safebang@!y1_apb","(!y1_apb)","[x0_ap8, y0_ap9, x1_apa, (!y1_apb)]","m_apc","n_aCH","!n_aCH","(!n_aCH)","0","!0","(!0)","n_aCI","!n_aCI","(!n_aCI)","n_aDH","safebang@!n_aDH","(!n_aDH)","x_aDI","safebang@!x_aDI","(!x_aDI)","y_aDJ","safebang@!y_aDJ","(!y_aDJ)","n_aDK","x_aDL","safebang@!x_aDL","(!x_aDL)","y_aDM","x_aDN","safebang@!x_aDN","(!x_aDN)","y_aDO","safebang@!y_aDO","(!y_aDO)","f_aDP","safebang@!f_aDP","(!f_aDP)","undraw","drawlines","_","!_","(!_)","[]","_","!_","(!_)","_","_","[]","![]","(![])","f_aJX","x_aJY","xs_aJZ","!xs_aJZ","(!xs_aJZ)","x_aJY : (!xs_aJZ)","(x_aJY : (!xs_aJZ))","ys_aK0","!ys_aK0","(!ys_aK0)","xor_aK1","yor_aK2","xgap_aK3","ygap_aK4","xlength_aK5","ylength_aK6","drawf_aK7","safebang@!drawf_aK7","(!drawf_aK7)","x0list_aK8","y0list_aK9","orig_aKb","gap_aKc","safebang@!gap_aKc","(!gap_aKc)","len_aKd","n_aKf","safebang@!n_aKf","(!n_aKf)"]
module Drawfuns
       (drawdot, grid, squ, circ, gowin, rectangle, fillrect, undo,
        undraw, drawlines)
       where
import Mgrfuns
import Diff

gowin :: Int -> [Char]
gowin n_ap3 = selectwin n_ap3 ++ setmode 7 ++ setmode 8

rectangle :: [Int] -> [Char]
rectangle [x1_ap4, (!y1_ap5), x2_ap6, y2_ap7]
  = line [x1_ap4, y1_ap5, x2_ap6, y1_ap5] ++
      line [x2_ap6, y1_ap5, x2_ap6, y2_ap7]
      ++ line [x1_ap4, y1_ap5, x1_ap4, y2_ap7]
      ++ line [x1_ap4, y2_ap7, x2_ap6, y2_ap7]

fillrect :: [Int] -> [Char]
fillrect [x0_ap8, y0_ap9, x1_apa, (!y1_apb)]
  = shade_ape (diff x0_ap8 x1_apa)
  where m_apc = min x0_ap8 x1_apa
        vline_apd (norecord@n_aCH) = line [n_aCH, y0_ap9, n_aCH, y1_apb]
        shade_ape (norecord@0) = vline_apd m_apc
        shade_ape (norecord@n_aCI)
          = vline_apd (m_apc + n_aCI) ++ shade_ape (n_aCI - 1)

squ :: Int -> Int -> Int -> [Char]
squ (!n_aDH) (!x_aDI) (!y_aDJ)
  = rectangle [x_aDI, y_aDJ, x_aDI + n_aDH, y_aDJ + n_aDH]

circ :: Int -> Int -> Int -> [Char]
circ n_aDK (!x_aDL) y_aDM = circle [x_aDL, y_aDM, n_aDK]

drawdot :: Int -> Int -> [Char]
drawdot (!x_aDN) (!y_aDO)
  = fillrect [x_aDN - 1, y_aDO - 1, x_aDN + 1, y_aDO + 1]

undo :: [Char] -> [Char]
undo (!f_aDP) = func 0 ++ f_aDP ++ func 15

undraw :: [Int] -> [Char]
undraw = undo . line

drawlines :: [[Int]] -> [Char]
drawlines = concat . map line
allpairs (norecord@_) [] (norecord@_) = []
allpairs _ _ (norecord@[]) = []
allpairs f_aJX (x_aJY : (norecord@xs_aJZ)) (norecord@ys_aK0)
  = map (f_aJX x_aJY) ys_aK0 ++ allpairs f_aJX xs_aJZ ys_aK0

grid ::
     Int ->
       Int ->
         Int -> Int -> Int -> Int -> (Int -> Int -> [a_aoV]) -> [a_aoV]
grid xor_aK1 yor_aK2 xgap_aK3 ygap_aK4 xlength_aK5 ylength_aK6
  (!drawf_aK7) = concat (allpairs drawf_aK7 x0list_aK8 y0list_aK9)
  where x0list_aK8 = gridlist_aKa xor_aK1 xgap_aK3 xlength_aK5
        y0list_aK9 = gridlist_aKa yor_aK2 ygap_aK4 ylength_aK6
        gridlist_aKa orig_aKb (!gap_aKc) len_aKd
          = take len_aKd (gridlist'_aKe orig_aKb)
          where gridlist'_aKe (!n_aKf)
                  = n_aKf : gridlist'_aKe (n_aKf + gap_aKc)

==================== Renamer ====================
Rational.norm :: (Int, Int) -> (Int, Int)
Rational.norm (!(x_an7, y_an8))
  = (u_an9 `div` d_anb, v_ana `div` d_anb)
  where
      u_an9 = if y_an8 > 0 then x_an7 else - x_an7
      v_ana = abs y_an8
      d_anb = gcd_anc (abs u_an9) v_ana
      gcd_anc :: Int -> Int -> Int
      gcd_anc 0 n2_aBD = n2_aBD
      gcd_anc n1_aBE (!0) = n1_aBE
      gcd_anc n1_aBF n2_aBG
        = if n1_aBF < n2_aBG then
              gcd_anc n1_aBF (n2_aBG `mod` n1_aBF)
          else
              gcd_anc (n1_aBF `mod` n2_aBG) n2_aBG
Rational.radd, Rational.rsub, Rational.rmul, Rational.rdiv ::
  (Int, Int) -> (Int, Int) -> (Int, Int)
Rational.radd (!((!x_aKN), (!y_aKO))) (!((!u_aKP), (!v_aKQ)))
  = Rational.norm (x_aKN * v_aKQ + u_aKP * y_aKO, y_aKO * v_aKQ)
Rational.rsub (x_aKR, (!y_aKS)) (!((!u_aKT), (!v_aKU)))
  = Rational.norm (x_aKR * v_aKU - u_aKT * y_aKS, y_aKS * v_aKU)
Rational.rmul (!(x_aKV, y_aKW)) (u_aKX, (!v_aKY))
  = Rational.norm (x_aKV * u_aKX, y_aKW * v_aKY)
Rational.rdiv (x_aKZ, (!y_aL0)) (u_aL1, (!v_aL2))
  = Rational.norm (x_aKZ * v_aL2, y_aL0 * u_aL1)
Rational.rmin (x_aL3, (!y_aL4)) (u_aL5, v_aL6)
  = if a_aL7 > 0 then (u_aL5, v_aL6) else (x_aL3, y_aL4)
  where
      (!(a_aL7, b_aL8)) = Rational.rsub (x_aL3, y_aL4) (u_aL5, v_aL6)
Rational.rabs :: (Int, Int) -> (Int, Int)
Rational.rabs (x_aL9, y_aLa)
  = if x_aL9 < 0 then (- x_aL9, y_aLa) else (x_aL9, y_aLa)
Rational.intval :: (Int, Int) -> Int
Rational.intval (!((!x_aLb), y_aLc)) = x_aLb `div` y_aLc
Rational.show_rat :: (Int, Int) -> [Char]
Rational.show_rat ((!x_aLd), (!y_aLe))
  = show x_aLd ++ "/" ++ show y_aLe
Rational.torat :: Int -> (Int, Int)
Rational.torat n_aTD = (n_aTD, 1)


["x_an7","y_an8","(x_an7, y_an8)","!(x_an7, y_an8)","(!(x_an7, y_an8))","u_an9","v_ana","d_anb","0","n2_aBD","n1_aBE","0","!0","(!0)","n1_aBF","n2_aBG","x_aKN","safebang@!x_aKN","(!x_aKN)","y_aKO","safebang@!y_aKO","(!y_aKO)","((!x_aKN), (!y_aKO))","!((!x_aKN), (!y_aKO))","(!((!x_aKN), (!y_aKO)))","u_aKP","safebang@!u_aKP","(!u_aKP)","v_aKQ","safebang@!v_aKQ","(!v_aKQ)","((!u_aKP), (!v_aKQ))","!((!u_aKP), (!v_aKQ))","(!((!u_aKP), (!v_aKQ)))","x_aKR","y_aKS","safebang@!y_aKS","(!y_aKS)","(x_aKR, (!y_aKS))","u_aKT","safebang@!u_aKT","(!u_aKT)","v_aKU","safebang@!v_aKU","(!v_aKU)","((!u_aKT), (!v_aKU))","!((!u_aKT), (!v_aKU))","(!((!u_aKT), (!v_aKU)))","x_aKV","y_aKW","(x_aKV, y_aKW)","!(x_aKV, y_aKW)","(!(x_aKV, y_aKW))","u_aKX","v_aKY","safebang@!v_aKY","(!v_aKY)","(u_aKX, (!v_aKY))","x_aKZ","y_aL0","safebang@!y_aL0","(!y_aL0)","(x_aKZ, (!y_aL0))","u_aL1","v_aL2","safebang@!v_aL2","(!v_aL2)","(u_aL1, (!v_aL2))","x_aL3","y_aL4","safebang@!y_aL4","(!y_aL4)","(x_aL3, (!y_aL4))","u_aL5","v_aL6","(u_aL5, v_aL6)","a_aL7","b_aL8","(a_aL7, b_aL8)","!(a_aL7, b_aL8)","(!(a_aL7, b_aL8))","x_aL9","y_aLa","(x_aL9, y_aLa)","x_aLb","safebang@!x_aLb","(!x_aLb)","y_aLc","((!x_aLb), y_aLc)","!((!x_aLb), y_aLc)","(!((!x_aLb), y_aLc))","x_aLd","safebang@!x_aLd","(!x_aLd)","y_aLe","safebang@!y_aLe","(!y_aLe)","((!x_aLd), (!y_aLe))","n_aTD"]
module Rational
       (radd, rsub, rmul, rdiv, rmin, rabs, intval, show_rat, torat) where

norm :: (Int, Int) -> (Int, Int)
norm (norecord@(x_an7, y_an8))
  = (u_an9 `div` d_anb, v_ana `div` d_anb)
  where u_an9 = if y_an8 > 0 then x_an7 else -x_an7
        v_ana = abs y_an8
        d_anb = gcd_anc (abs u_an9) v_ana
        
        gcd_anc :: Int -> Int -> Int
        gcd_anc 0 n2_aBD = n2_aBD
        gcd_anc n1_aBE (norecord@0) = n1_aBE
        gcd_anc n1_aBF n2_aBG
          = if n1_aBF < n2_aBG then gcd_anc n1_aBF (n2_aBG `mod` n1_aBF) else
              gcd_anc (n1_aBF `mod` n2_aBG) n2_aBG

radd, rsub, rmul, rdiv :: (Int, Int) -> (Int, Int) -> (Int, Int)
radd (norecord@((!x_aKN), (!y_aKO)))
  (norecord@((!u_aKP), (!v_aKQ)))
  = norm (x_aKN * v_aKQ + u_aKP * y_aKO, y_aKO * v_aKQ)
rsub (x_aKR, (!y_aKS)) (norecord@((!u_aKT), (!v_aKU)))
  = norm (x_aKR * v_aKU - u_aKT * y_aKS, y_aKS * v_aKU)
rmul (norecord@(x_aKV, y_aKW)) (u_aKX, (!v_aKY))
  = norm (x_aKV * u_aKX, y_aKW * v_aKY)
rdiv (x_aKZ, (!y_aL0)) (u_aL1, (!v_aL2))
  = norm (x_aKZ * v_aL2, y_aL0 * u_aL1)
rmin (x_aL3, (!y_aL4)) (u_aL5, v_aL6)
  = if a_aL7 > 0 then (u_aL5, v_aL6) else (x_aL3, y_aL4)
  where (norecord@(a_aL7, b_aL8))
          = rsub (x_aL3, y_aL4) (u_aL5, v_aL6)

rabs :: (Int, Int) -> (Int, Int)
rabs (x_aL9, y_aLa)
  = if x_aL9 < 0 then (-x_aL9, y_aLa) else (x_aL9, y_aLa)

intval :: (Int, Int) -> Int
intval (norecord@((!x_aLb), y_aLc)) = x_aLb `div` y_aLc

show_rat :: (Int, Int) -> [Char]
show_rat ((!x_aLd), (!y_aLe)) = show x_aLd ++ "/" ++ show y_aLe

torat :: Int -> (Int, Int)
torat n_aTD = (n_aTD, 1)

==================== Renamer ====================
Interstate.inter ::
  (a_amR -> [b_amS])
  -> (a_amR -> c_amT -> Bool)
     -> (a_amR -> c_amT -> ([b_amS], a_amR, c_amT))
        -> (a_amR -> c_amT -> [b_amS])
Interstate.inter prompt_an1 endp_an2 (!transact_an3)
  = interprog_an4
  where
      interprog_an4 state_an5 inpt_an6
        = prompt_an1 state_an5
          ++
            if endp_an2 state_an5 inpt_an6 then
                []
            else
                response_an7 ++ interprog_an4 newstate_an8 restofinput_an9
        where
            (response_an7, newstate_an8, restofinput_an9)
              = transact_an3 state_an5 inpt_an6


["prompt_an1","endp_an2","transact_an3","safebang@!transact_an3","(!transact_an3)","state_an5","inpt_an6","response_an7","newstate_an8","restofinput_an9","(response_an7, newstate_an8, restofinput_an9)"]
module Interstate (inter) where

inter ::
      (a_amR -> [b_amS]) ->
        (a_amR -> c_amT -> Bool) ->
          (a_amR -> c_amT -> ([b_amS], a_amR, c_amT)) ->
            (a_amR -> c_amT -> [b_amS])
inter prompt_an1 endp_an2 (!transact_an3) = interprog_an4
  where interprog_an4 state_an5 inpt_an6
          = prompt_an1 state_an5 ++
              if endp_an2 state_an5 inpt_an6 then [] else
                response_an7 ++ interprog_an4 newstate_an8 restofinput_an9
          where (response_an7, newstate_an8, restofinput_an9)
                  = transact_an3 state_an5 inpt_an6

==================== Renamer ====================
Help.helpsetup, Help.helpend :: [Char]
Help.helpdraw, Help.helpdsave, Help.helpdclear, Help.helpdget ::
  [Char]
Help.helptile, Help.helpalter, Help.helptsave, Help.helptclear, Help.helptget, Help.helpt4 ::
  [Char]
Help.helpquit, Help.helpbt, Help.helppic, Help.helpdesign :: [Char]
Help.helpsetup = textregion helptextarea ++ font 8
Help.helpend = cleara helptextarea ++ font 13
Help.helpdraw
  = "This button puts you in drawing mode.\n"
    ++
      "Lines can be drawn in the STAMP DESIGN \n"
      ++
        "area by holding down the middle button,\n"
        ++
          "and deleted by clicking\n"
          ++
            "with the right one.\n"
            ++
              "\n\
              \Little circles will appear if a line\n"
              ++
                "touches the edge of the square.\n"
                ++
                  "These indicate positions on all the sides\n"
                  ++
                    "that would contact that line in each of\n"
                    ++
                      "the possible orientations of the print.\n"
                      ++
                        "Unless special effects are being sought,\n"
                        ++
                          "the recommendation is that all little\n"
                          ++ "circles be attached to a line.\n" ++ Help.endmes
Help.helptile
  = "In this mode, orientations of the print\n"
    ++
      "can be placed in the TILE DESIGN area\n"
      ++
        "to create a 64 X 64 big tile\n"
        ++
          "\n\
          \Use the right button to select a print\n"
          ++
            "and the middle button to place it.\n"
            ++
              "\n\
              \Within the tiling area the right button\n"
              ++
                "may also be used to delete a square\n"
                ++
                  "\n\
                  \To rotate or invert squares within\n"
                  ++
                    "the big tile it may be more convenient\n"
                    ++ "to use the ALTER mode." ++ Help.endmes
Help.helpalter
  = "In ALTER mode, squares within the\n"
    ++
      "big tile can be adjusted.\n"
      ++
        "The middle button causes them to \n"
        ++
          "rotate clockwise.\n"
          ++ "The right button causes them to\n" ++ "invert." ++ Help.endmes
Help.helptsave
  = "Sorry, SAVE is temporarily inoperative." ++ Help.endmes
Help.helptclear
  = "This CLEAR button clears the TILE DESIGN\n"
    ++ "region and draws an empty grid." ++ Help.endmes
Help.helptget
  = "Sorry, GET is temporarily inoperative." ++ Help.endmes
Help.helpt4
  = "The T4 button tiles the whole big tile\n"
    ++
      "with the pattern of the four squares\n"
      ++ "in the top left hand corner\n" ++ Help.endmes
Help.helpquit
  = "\n\
    \\n\
    \\n\
    \Clicking on QUIT allows you\n"
    ++ "to leave the program.\n" ++ Help.endmes
Help.helpbt
  = "\n\
    \\n\
    \\n\
    \Within the TILE DESIGN area,\n"
    ++
      "a big tile, based on orientations of\n"
      ++
        "a print design, can be built.\n"
        ++
          "\n\
          \Using TILE mode the right button\n"
          ++
            "will select from a palette at the bottom\n"
            ++
              "of the screen, and the middle button will\n"
              ++
                "place the selection within the big tile.\n"
                ++
                  "Within the area the right button will\n"
                  ++
                    "delete squares.\n"
                    ++
                      "\n\
                      \Using ALTER mode the right button will\n"
                      ++
                        "invert squares, and the middle button \n"
                        ++ "will rotate them." ++ Help.endmes
Help.helppic
  = "\n\
    \These boxes show the eight possible\n"
    ++
      "orientations of the print that is\n"
      ++
        "to be used in tiling\n"
        ++
          "\n\
          \When in tiling mode, clicking with the\n"
          ++
            "right button over one of these\n"
            ++
              "will make it the \"current selection\".\n"
              ++
                "Clicking with the middle button in\n"
                ++
                  "the TILE DESIGN grid, will put that\n"
                  ++ "orientation of the print at that place" ++ Help.endmes
Help.helpdesign
  = "\n\
    \\n\
    \\n\
    \This is the area in which to design \n\
    \your print.\n"
    ++
      "\n\
      \Draw lines by holding down the\n\
      \ middle button.\n"
      ++
        "Delete lines by clicking with the\n\
        \ right button.\n"
        ++
          "\n\
          \\n\
          \A print that has previously been saved\n"
          ++
            "can be restored by clicking on GET\n"
            ++ "then typing in the filename at the prompt.\n" ++ Help.endmes
Help.helpdsave
  = "Sorry, SAVE is temporarily inoperative." ++ Help.endmes
Help.helpdclear
  = "\n\
    \\n\
    \\n\
    \This clears the PRINT DESIGN grid.\n"
    ++
      "The print currently being worked on\n"
      ++
        "will be lost, unless it has been\n"
        ++ "explicitly SAVEd first\n" ++ Help.endmes
Help.helpdget
  = "Sorry, GET is temporarily inoperative." ++ Help.endmes
Help.inithelp, Help.errmes, Help.endmes :: [Char]
Help.inithelp
  = Help.helpsetup
    ++
      clear
      ++
        "\n\
        \\n\
        \\n\
        \\n\
        \To find out the use of a particular\n"
        ++
          "menu button or region of the screen, \n"
          ++ "click over the item you wish to\n" ++ "investigate.\n"
Help.errmes
  = "\n\
    \\n\
    \\n\
    \You have clicked over an area \n"
    ++ "of no particular interest.\n" ++ Help.endmes
Help.endmes
  = "\n\
    \\n\
    \ PRESS RETURN TO RETURN TO THE PROGRAM\n"
    ++ "OR CLICK SOMEWHERE ELSE TO FIND OUT MORE\n"


["helpsetup","helpend","helpdraw","helptile","helpalter","helptsave","helptclear","helptget","helpt4","helpquit","helpbt","helppic","helpdesign","helpdsave","helpdclear","helpdget","inithelp","errmes","endmes"]
module Help
       (helpend, helpdraw, helptile, helpalter, helptsave, helptclear,
        helptget, helpt4, helpquit, helpbt, helppic, helpdesign, helpdsave,
        helpdclear, helpdget, inithelp, errmes)
       where
import Layout
import Mgrfuns

helpsetup, helpend :: [Char]

helpdraw, helpdsave, helpdclear, helpdget :: [Char]

helptile, helpalter, helptsave, helptclear, helptget, helpt4 ::
          [Char]

helpquit, helpbt, helppic, helpdesign :: [Char]
helpsetup = textregion helptextarea ++ font 8
helpend = cleara helptextarea ++ font 13
helpdraw
  = "This button puts you in drawing mode.\n" ++
      "Lines can be drawn in the STAMP DESIGN \n"
      ++ "area by holding down the middle button,\n"
      ++ "and deleted by clicking\n"
      ++ "with the right one.\n"
      ++ "\nLittle circles will appear if a line\n"
      ++ "touches the edge of the square.\n"
      ++ "These indicate positions on all the sides\n"
      ++ "that would contact that line in each of\n"
      ++ "the possible orientations of the print.\n"
      ++ "Unless special effects are being sought,\n"
      ++ "the recommendation is that all little\n"
      ++ "circles be attached to a line.\n"
      ++ endmes
helptile
  = "In this mode, orientations of the print\n" ++
      "can be placed in the TILE DESIGN area\n"
      ++ "to create a 64 X 64 big tile\n"
      ++ "\nUse the right button to select a print\n"
      ++ "and the middle button to place it.\n"
      ++ "\nWithin the tiling area the right button\n"
      ++ "may also be used to delete a square\n"
      ++ "\nTo rotate or invert squares within\n"
      ++ "the big tile it may be more convenient\n"
      ++ "to use the ALTER mode."
      ++ endmes
helpalter
  = "In ALTER mode, squares within the\n" ++
      "big tile can be adjusted.\n"
      ++ "The middle button causes them to \n"
      ++ "rotate clockwise.\n"
      ++ "The right button causes them to\n"
      ++ "invert."
      ++ endmes
helptsave = "Sorry, SAVE is temporarily inoperative." ++ endmes
helptclear
  = "This CLEAR button clears the TILE DESIGN\n" ++
      "region and draws an empty grid."
      ++ endmes
helptget = "Sorry, GET is temporarily inoperative." ++ endmes
helpt4
  = "The T4 button tiles the whole big tile\n" ++
      "with the pattern of the four squares\n"
      ++ "in the top left hand corner\n"
      ++ endmes
helpquit
  = "\n\n\nClicking on QUIT allows you\n" ++
      "to leave the program.\n"
      ++ endmes
helpbt
  = "\n\n\nWithin the TILE DESIGN area,\n" ++
      "a big tile, based on orientations of\n"
      ++ "a print design, can be built.\n"
      ++ "\nUsing TILE mode the right button\n"
      ++ "will select from a palette at the bottom\n"
      ++ "of the screen, and the middle button will\n"
      ++ "place the selection within the big tile.\n"
      ++ "Within the area the right button will\n"
      ++ "delete squares.\n"
      ++ "\nUsing ALTER mode the right button will\n"
      ++ "invert squares, and the middle button \n"
      ++ "will rotate them."
      ++ endmes
helppic
  = "\nThese boxes show the eight possible\n" ++
      "orientations of the print that is\n"
      ++ "to be used in tiling\n"
      ++ "\nWhen in tiling mode, clicking with the\n"
      ++ "right button over one of these\n"
      ++ "will make it the \"current selection\".\n"
      ++ "Clicking with the middle button in\n"
      ++ "the TILE DESIGN grid, will put that\n"
      ++ "orientation of the print at that place"
      ++ endmes
helpdesign
  = "\n\n\nThis is the area in which to design \nyour print.\n" ++
      "\nDraw lines by holding down the\n middle button.\n"
      ++ "Delete lines by clicking with the\n right button.\n"
      ++ "\n\nA print that has previously been saved\n"
      ++ "can be restored by clicking on GET\n"
      ++ "then typing in the filename at the prompt.\n"
      ++ endmes
helpdsave = "Sorry, SAVE is temporarily inoperative." ++ endmes
helpdclear
  = "\n\n\nThis clears the PRINT DESIGN grid.\n" ++
      "The print currently being worked on\n"
      ++ "will be lost, unless it has been\n"
      ++ "explicitly SAVEd first\n"
      ++ endmes
helpdget = "Sorry, GET is temporarily inoperative." ++ endmes

inithelp, errmes, endmes :: [Char]
inithelp
  = helpsetup ++ clear ++
      "\n\n\n\nTo find out the use of a particular\n"
      ++ "menu button or region of the screen, \n"
      ++ "click over the item you wish to\n"
      ++ "investigate.\n"
errmes
  = "\n\n\nYou have clicked over an area \n" ++
      "of no particular interest.\n"
      ++ endmes
endmes
  = "\n\n PRESS RETURN TO RETURN TO THE PROGRAM\n" ++
      "OR CLICK SOMEWHERE ELSE TO FIND OUT MORE\n"

==================== Renamer ====================
Auxprogfuns.concmap3 ::
  (a_aOS -> b_aOT -> c_aOU -> [d_aOV])
  -> [a_aOS] -> [b_aOT] -> [c_aOU] -> [d_aOV]
Auxprogfuns.concmap3
  f_aOW
  (x_aOX : (!xs_aOY))
  (y_aOZ : ys_aP0)
  (!((!z_aP1) : zs_aP2))
  = f_aOW x_aOX y_aOZ z_aP1
    ++ Auxprogfuns.concmap3 f_aOW xs_aOY ys_aP0 zs_aP2
Auxprogfuns.concmap3 (!f_aP3) (!_) (!_) (!_) = []
Auxprogfuns.display :: [(a_aOR, [[Int]])] -> [Char]
Auxprogfuns.display (!slist_aP4)
  = Auxprogfuns.concmap3
      place
      [624, 624, 624, 624, 724, 724, 724, 724]
      [676, 776, 876, 976, 676, 776, 876, 976]
      (map snd slist_aP4)
Auxprogfuns.orient :: Int -> Int -> [[Int]] -> [[Int]]
Auxprogfuns.orient m_aPb (!n_aPc)
  = case n_aPc of {
      0 -> (\ (!_) -> [[0, 0, 0, 0]])
      (!1) -> (\ (!x_aPd) -> x_aPd)
      2 -> rotatecw m_aPb
      3 -> rotatecw m_aPb . rotatecw m_aPb
      (!4) -> antirotate m_aPb
      5 -> tbinvert m_aPb
      (!6) -> tbinvert m_aPb . rotatecw m_aPb
      7 -> lrinvert m_aPb
      8 -> lrinvert m_aPb . rotatecw m_aPb }
Auxprogfuns.pixdist :: Int
Auxprogfuns.pixdist = 10
Auxprogfuns.between :: Int -> Int -> Int -> Bool
Auxprogfuns.between n1_aPe n2_aPf (!n_aPg)
  = (n1_aPe <= n_aPg && n2_aPf >= n_aPg)
    || (n1_aPe >= n_aPg && n2_aPf <= n_aPg)
Auxprogfuns.online :: [Int] -> Int -> Int -> Bool
Auxprogfuns.online
  [x0_aPh, y0_aPi, (!x1_aPj), y1_aPk]
  xp_aPl
  yp_aPm
  = if y0_aPi == y1_aPk then
        Auxprogfuns.between x0_aPh x1_aPj xp_aPl
        && abs (y0_aPi - yp_aPm) < Auxprogfuns.pixdist
    else
        if x0_aPh == x1_aPj then
            Auxprogfuns.between y0_aPi y1_aPk yp_aPm
            && abs (x0_aPh - xp_aPl) < Auxprogfuns.pixdist
        else
            b2_aPs <= a2_aPr + c2_aPt
            &&
              c2_aPt <= a2_aPr + b2_aPs
              && intval (rmin dx_aPu dy_aPv) < Auxprogfuns.pixdist
  where
      k1_aPn = rdiv (torat (x0_aPh - x1_aPj)) (torat (y0_aPi - y1_aPk))
      k0_aPo = rsub (torat x0_aPh) (rmul k1_aPn (torat y0_aPi))
      (!xp'_aPp) = radd k0_aPo (rmul k1_aPn (torat yp_aPm))
      yp'_aPq = rdiv (rsub (torat xp_aPl) k0_aPo) k1_aPn
      a2_aPr = square (diff x0_aPh x1_aPj) + square (diff y0_aPi y1_aPk)
      b2_aPs = square (diff x1_aPj xp_aPl) + square (diff y1_aPk yp_aPm)
      (!c2_aPt)
        = square (diff x0_aPh xp_aPl) + square (diff y0_aPi yp_aPm)
      dx_aPu = rabs (rsub (torat xp_aPl) xp'_aPp)
      (!dy_aPv) = rabs (rsub (torat yp_aPm) yp'_aPq)
Auxprogfuns.deline ::
  [([Int], [Int])] -> [Int] -> ([Char], [([Int], [Int])])
Auxprogfuns.deline (!ls_aQu) [(!px_aQv), py_aQw]
  = deline'_aQx ls_aQu
  where
      deline'_aQx (![]) = ("", ls_aQu)
      deline'_aQx (!(pl_aQy : pls_aQz))
        = if Auxprogfuns.online thisline_aQA px_aQv py_aQw then
              (undraw thisline_aQA
               ++ (undo . Auxprogfuns.wline) thisline_aQA ++ decircs_aQD, 
               Auxprogfuns.remove1 ls_aQu pl_aQy)
          else
              deline'_aQx pls_aQz
        where
            (!(thisline_aQA, thesecircs_aQB)) = pl_aQy
            (!restcircs_aQC)
              = Auxprogfuns.listremove1 (concat (map snd ls_aQu)) thesecircs_aQB
            decircs_aQD
              = (concat . map Auxprogfuns.decirc)
                  (restcircs_aQC \\ thesecircs_aQB)
Auxprogfuns.remove1 :: (Eq a_aOQ) => [a_aOQ] -> a_aOQ -> [a_aOQ]
Auxprogfuns.remove1 (!(l_aZ4 : ls_aZ5)) (!i_aZ6)
  = if i_aZ6 == l_aZ4 then
        ls_aZ5
    else
        l_aZ4 : Auxprogfuns.remove1 ls_aZ5 i_aZ6
Auxprogfuns.remove1 [] i_aZ7 = []
Auxprogfuns.listremove1 ::
  (Eq a_aBn) => [a_aBn] -> [a_aBn] -> [a_aBn]
Auxprogfuns.listremove1 = foldl Auxprogfuns.remove1
Auxprogfuns.onedge :: Int -> Bool
Auxprogfuns.onedge (!n_aZ8)
  = n_aZ8 == dpxyorig || n_aZ8 == dpxyorig + (dpxynum - 1) * dpxygap
Auxprogfuns.nearest :: Int -> Int
Auxprogfuns.nearest (!n_aZ9)
  = if n_aZ9 - n1_aZa < n2_aZb - n_aZ9 then n1_aZa else n2_aZb
  where
      n1_aZa = dpxyorig + ((n_aZ9 - dpxyorig) `div` dpxygap) * dpxygap
      n2_aZb = n1_aZa + dpxygap
Auxprogfuns.nearx, Auxprogfuns.neary :: Int -> Int
Auxprogfuns.nearx (!x_a18g) = Auxprogfuns.nearest (x_a18g - 4)
Auxprogfuns.neary (!y_a18h) = Auxprogfuns.nearest (y_a18h - 5)
Auxprogfuns.numassoc :: Int -> Int
Auxprogfuns.numassoc (!n_a18i)
  = if n1_a18j <= 9 then n1_a18j else 18 - n1_a18j
  where
      (!n1_a18j) = (n_a18i - dpxyorig) `div` dpxygap
Auxprogfuns.circ6 :: Int -> Int -> [Char]
Auxprogfuns.circ6 x_a18k y_a18l = circle [x_a18k, y_a18l, 6]
Auxprogfuns.circsym :: Int -> Int -> ([Char], [Int])
Auxprogfuns.circsym xn_a18m (!yn_a18n)
  = if Auxprogfuns.onedge xn_a18m then
        (Auxprogfuns.symcircs yn_a18n, [Auxprogfuns.numassoc yn_a18n])
    else
        if Auxprogfuns.onedge yn_a18n then
            (Auxprogfuns.symcircs xn_a18m, [Auxprogfuns.numassoc xn_a18m])
        else
            ("", [])
Auxprogfuns.sympat :: Int -> [Int]
Auxprogfuns.sympat n_a18o
  = [n_a18o, 400 - n_a18o, 380, 380, 400 - n_a18o, n_a18o, 20, 20]
Auxprogfuns.symcircs :: Int -> [Char]
Auxprogfuns.symcircs (!n_a18p)
  = concat
      (zipWith
         Auxprogfuns.circ6
         (Auxprogfuns.sympat n_a18p)
         (reverse (Auxprogfuns.sympat n_a18p)))
Auxprogfuns.cs :: [Int] -> ([Char], [Int])
Auxprogfuns.cs (![x0_a1bC, y0_a1bD, x1_a1bE, y1_a1bF])
  = (line [x0_a1bC, y0_a1bD, x1_a1bE, y1_a1bF]
     ++ circles0_a1bG ++ circles1_a1bI, 
     ids0_a1bH ++ ids1_a1bJ)
  where
      (!((!circles0_a1bG), ids0_a1bH))
        = Auxprogfuns.circsym x0_a1bC y0_a1bD
      ((!circles1_a1bI), ids1_a1bJ) = Auxprogfuns.circsym x1_a1bE y1_a1bF
Auxprogfuns.decirc :: Int -> [Char]
Auxprogfuns.decirc n_a1bK
  = (undo . Auxprogfuns.symcircs) (n_a1bK * dpxygap + dpxyorig)
Auxprogfuns.wscale :: Int -> Int
Auxprogfuns.wscale (!n_a1bL) = (n_a1bL - dpxyorig) `div` 5
Auxprogfuns.wwscale :: Int -> Int
Auxprogfuns.wwscale n_a1bM = (n_a1bM - dpxyorig) `div` 10
Auxprogfuns.wline :: [Int] -> [Char]
Auxprogfuns.wline
  = line
    . mapx (\ (!x_a1bN) -> x_a1bN + picxorig)
      . mapy (\ (!y_a1bO) -> y_a1bO + picyorig) . map Auxprogfuns.wscale
Auxprogfuns.showoris :: [[Int]] -> Int -> [Char]
Auxprogfuns.showoris coords_a1bP n_a1bQ
  = place
      x_a1bR
      y_a1bS
      (((Auxprogfuns.orient xymax) n_a1bQ . map (map Auxprogfuns.wscale))
         coords_a1bP)
  where
      [x_a1bR, y_a1bS, w_a1bT, (!h_a1bU)] = picbox n_a1bQ



==================== Renamer ====================
Diff.square :: Int -> Int
Diff.square n_an0 = n_an0 * n_an0
Diff.diff :: Int -> Int -> Int
Diff.diff a_anZ (!b_ao0)
  = if a_anZ > b_ao0 then a_anZ - b_ao0 else b_ao0 - a_anZ
Diff.bcroot :: Int -> Int
Diff.bcroot n_aBt
  = root'_aBu 0 n_aBt
  where
      root'_aBu a_aBv b_aBw
        = if a_aBv + 1 >= b_aBw then
              b_aBw
          else
              if s_aBy < n_aBt then
                  root'_aBu m_aBx b_aBw
              else
                  if n_aBt < s_aBy then root'_aBu a_aBv m_aBx else m_aBx
        where
            m_aBx = (a_aBv + b_aBw) `div` 2
            s_aBy = m_aBx * m_aBx


["n_an0","a_anZ","b_ao0","safebang@!b_ao0","(!b_ao0)","n_aBt","a_aBv","b_aBw","m_aBx","s_aBy"]
module Diff (diff, bcroot, square) where

square :: Int -> Int
square n_an0 = n_an0 * n_an0

diff :: Int -> Int -> Int
diff a_anZ (!b_ao0)
  = if a_anZ > b_ao0 then a_anZ - b_ao0 else b_ao0 - a_anZ

bcroot :: Int -> Int
bcroot n_aBt = root'_aBu 0 n_aBt
  where root'_aBu a_aBv b_aBw
          = if a_aBv + 1 >= b_aBw then b_aBw else
              if s_aBy < n_aBt then root'_aBu m_aBx b_aBw else
                if n_aBt < s_aBy then root'_aBu a_aBv m_aBx else m_aBx
          where m_aBx = (a_aBv + b_aBw) `div` 2
                s_aBy = m_aBx * m_aBx

==================== Renamer ====================
Progfuns.tileprompt :: a_aTc -> [Char]
Progfuns.tileprompt _ = ""
Progfuns.tilequit :: a_aTb -> [[Char]] -> Bool
Progfuns.tilequit _ (((!'q') : _) : _) = True
Progfuns.tilequit (!_) [] = True
Progfuns.tilequit _ (!_) = False
Progfuns.tiletrans :: Progfuns.Trans
Progfuns.tiletrans
  (!((!dlist_aTd), (!sel_aTe), (!tilist_aTf)))
  ((!((!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) : inpt_aTh)))
  = if intsave x_aTi y_aTj then
        doo_aTk Progfuns.tsave
    else
        if intclear x_aTi y_aTj then
            doo_aTk Progfuns.tclear
        else
            if intget x_aTi y_aTj then
                doo_aTk Progfuns.tget
            else
                if intile4 x_aTi y_aTj then
                    doo_aTk Progfuns.t4'
                else
                    if inquit x_aTi y_aTj then
                        doo_aTk Progfuns.q
                    else
                        if inbigtile x_aTi y_aTj then
                            doo_aTk Progfuns.delsq
                        else
                            if intoalter x_aTi y_aTj then
                                doo_aTk Progfuns.tofiddle'
                            else
                                if intotile x_aTi y_aTj then
                                    doo_aTk Progfuns.totile'
                                else
                                    if intodraw x_aTi y_aTj then
                                        doo_aTk Progfuns.todesign'
                                    else
                                        if inpicarea x_aTi y_aTj then
                                            doo_aTk Progfuns.sel'
                                        else
                                            if inhelp x_aTi y_aTj then
                                                doo_aTk Progfuns.tohelp'
                                            else
                                                Progfuns.tiletrans
                                                  (dlist_aTd, sel_aTe, tilist_aTf) inpt_aTh
  where
      [x_aTi, (!y_aTj)] = Progfuns.stoil rest_aTg
      doo_aTk fun_aTl
        = fun_aTl rest_aTg (dlist_aTd, sel_aTe, tilist_aTf) inpt_aTh
Progfuns.tiletrans
  (!((!dlist_aTm), sel_aTn, tilist_aTo))
  (!(('m' : ('s' : (!('b' : (' ' : rest_aTp))))) : (!inpt_aTq)))
  = if inbigtile x_aTr y_aTs then
        Progfuns.inv' rest_aTp (dlist_aTm, sel_aTn, tilist_aTo) inpt_aTq
    else
        Progfuns.tiletrans
          (dlist_aTm, sel_aTn, tilist_aTo)
          (('m' : 's' : 'a' : ' ' : rest_aTp) : inpt_aTq)
  where
      [(!x_aTr), (!y_aTs)] = Progfuns.stoil rest_aTp
Progfuns.tiletrans
  (dlist_aTt, (!sel_aTu), tilist_aTv)
  ((!(('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) : (!inpt_aTx))))
  = if indesign x_aTy y_aTz then
        doo_aTA Progfuns.rl
    else
        if indsave x_aTy y_aTz then
            doo_aTA Progfuns.dsave
        else
            if indclear x_aTy y_aTz then
                doo_aTA Progfuns.dclear
            else
                if indget x_aTy y_aTz then
                    doo_aTA Progfuns.dget
                else
                    Progfuns.tiletrans
                      (dlist_aTt, sel_aTu, tilist_aTv)
                      (('m' : 's' : 'a' : ' ' : rest_aTw) : inpt_aTx)
  where
      (![x_aTy, y_aTz]) = Progfuns.stoil rest_aTw
      doo_aTA (!fun_aTB)
        = fun_aTB rest_aTw (dlist_aTt, sel_aTu, tilist_aTv) inpt_aTx
Progfuns.tiletrans
  state_aTC
  (((!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))))) : (!inpt_aTE))
  = (inithelp ++ out_aTI, state_aTC, inpt_aTE)
  where
      (![x_aTF, y_aTG]) = Progfuns.stoil rest_aTD
      cf_aTH (!str_aTJ) = clear ++ str_aTJ
      out_aTI
        = if intodraw x_aTF y_aTG then
              cf_aTH helpdraw
          else
              if intotile x_aTF y_aTG then
                  cf_aTH helptile
              else
                  if intoalter x_aTF y_aTG then
                      cf_aTH helpalter
                  else
                      if intsave x_aTF y_aTG then
                          cf_aTH helptsave
                      else
                          if intclear x_aTF y_aTG then
                              cf_aTH helptclear
                          else
                              if intget x_aTF y_aTG then
                                  cf_aTH helptget
                              else
                                  if intile4 x_aTF y_aTG then
                                      cf_aTH helpt4
                                  else
                                      if inquit x_aTF y_aTG then
                                          cf_aTH helpquit
                                      else
                                          if inbigtile x_aTF y_aTG then
                                              cf_aTH helpbt
                                          else
                                              if inpicarea x_aTF y_aTG then
                                                  cf_aTH helppic
                                              else
                                                  if indesign x_aTF y_aTG then
                                                      cf_aTH helpdesign
                                                  else
                                                      if indsave x_aTF y_aTG then
                                                          cf_aTH helpdsave
                                                      else
                                                          if indclear x_aTF y_aTG then
                                                              cf_aTH helpdclear
                                                          else
                                                              if indget x_aTF y_aTG then
                                                                  cf_aTH helpdget
                                                              else
                                                                  if inhelp x_aTF y_aTG then
                                                                      cf_aTH inithelp
                                                                  else
                                                                      cf_aTH errmes
Progfuns.tiletrans
  ((!dlist_aTK), (!sel_aTL), tilist_aTM)
  (('c' : (!((!'s') : (!(' ' : (!rest_aTN)))))) : inpt_aTO)
  = if indgrid nstoilrest_aTQ then
        (linecircs_aTU ++ wnstoilrest_aTR, 
         (newele_aTT : dlist_aTK, sel_aTL, tilist_aTM), inpt_aTO)
    else
        ("", (dlist_aTK, sel_aTL, tilist_aTM), inpt_aTO)
  where
      nearline_aTP (![(!x0_aTV), y0_aTW, (!x1_aTX), y1_aTY])
        = [nearx x0_aTV, neary y0_aTW, nearx x1_aTX, neary y1_aTY]
      (!nstoilrest_aTQ) = nearline_aTP (Progfuns.stoil rest_aTN)
      (!wnstoilrest_aTR) = wline nstoilrest_aTQ
      (!cssr_aTS) = cs nstoilrest_aTQ
      newele_aTT = (nstoilrest_aTQ, snd cssr_aTS)
      (!linecircs_aTU) = fst cssr_aTS
Progfuns.tiletrans
  (!((!dlist_aU5), sel_aU6, (!tilist_aU7)))
  (!((!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9))))
  = if lsrest_aUe == [0, 0] then
        ("", (dlist_aU5, sel_aU6, tilist_aU7), inpt_aU9)
    else
        (undo (put lsrest_aUe (orient xymax oldas_aUc wcoords_aUb))
         ++ put lsrest_aUe (orient xymax (rot oldas_aUc) wcoords_aUb), 
         (dlist_aU5, sel_aU6, newtilist_aUd), inpt_aU9)
  where
      stoilrest_aUa = Progfuns.stoil rest_aU8
      wcoords_aUb = map (map wscale) (map fst dlist_aU5)
      (!oldas_aUc) = Progfuns.assoc (sqid stoilrest_aUa) tilist_aU7
      newtilist_aUd
        = newas (sqid stoilrest_aUa) (rot oldas_aUc) tilist_aU7
      lsrest_aUe = btlocate stoilrest_aUa
Progfuns.tiletrans
  ((!dlist_aUf), (!sel_aUg), (!tilist_aUh))
  ((!(((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) : (!inpt_aUj))))
  = if lsrest_aUm == [0, 0] then
        ("", (dlist_aUf, sel_aUg, tilist_aUh), inpt_aUj)
    else
        (undo (put lsrest_aUm (orient xymax oldas_aUo wcoords_aUp))
         ++ put lsrest_aUm (orient xymax sel_aUg wcoords_aUp), 
         (dlist_aUf, sel_aUg, newtilist_aUl), inpt_aUj)
  where
      stoilrest_aUk = Progfuns.stoil rest_aUi
      newtilist_aUl = newas (sqid stoilrest_aUk) sel_aUg tilist_aUh
      (!lsrest_aUm) = btlocate stoilrest_aUk
      coords_aUn = map fst dlist_aUf
      (!oldas_aUo) = Progfuns.assoc (sqid stoilrest_aUk) tilist_aUh
      wcoords_aUp = map (map wscale) coords_aUn
Progfuns.tiletrans state_aUq (!((!("" : inpt_aUr))))
  = (helpend ++ todesign, state_aUq, inpt_aUr)
Progfuns.tiletrans (!state_aUs) (_ : inpt_aUt)
  = ("", state_aUs, inpt_aUt)
Progfuns.todesign', Progfuns.totile', Progfuns.tofiddle', Progfuns.tohelp' ::
  [Char] -> Progfuns.Trans
Progfuns.todesign'
  (!_)
  (!(dlist_aUu, sel_aUv, (!tilist_aUw)))
  inpt_aUx
  = (cleara picarea
     ++
       picgrid
       ++
         cleara tilearea
         ++ tpgrid ++ showoris (map fst dlist_aUu) 1 ++ todesign, 
     (dlist_aUu, sel_aUv, tilist_aUw), inpt_aUx)
Progfuns.totile'
  _
  ((!dlist_aUy), sel_aUz, (!tilist_aUA))
  (!inpt_aUB)
  = (concat (map (showoris coords_aUC) [1 .. 8]) ++ totile, 
     (dlist_aUy, sel_aUz, tilist_aUA), inpt_aUB)
  where
      coords_aUC = map fst dlist_aUy
Progfuns.tofiddle'
  (!_)
  ((!dlist_a10K), sel_a10L, (!tilist_a10M))
  (!inpt_a10N)
  = (tofiddle, (dlist_a10K, sel_a10L, tilist_a10M), inpt_a10N)
Progfuns.tohelp'
  (!_)
  (!((!dlist_a10O), sel_a10P, (!tilist_a10Q)))
  (!inpt_a10R)
  = (tohelp, (dlist_a10O, sel_a10P, tilist_a10Q), inpt_a10R)
Progfuns.rl, Progfuns.dsave, Progfuns.dclear, Progfuns.dget ::
  [Char] -> Progfuns.Trans
Progfuns.rl
  rest_a10S
  (!(dlist_a10T, (!sel_a10U), (!tilist_a10V)))
  (!inpt_a10W)
  = (out_a10X, (newdlist_a10Y, sel_a10U, tilist_a10V), inpt_a10W)
  where
      (!(out_a10X, (!newdlist_a10Y)))
        = deline dlist_a10T (Progfuns.stoil rest_a10S)
Progfuns.dsave (!_) state_a10Z (!inpt_a110)
  = ("", state_a10Z, inpt_a110)
Progfuns.dclear
  rest_a111
  (dlist_a112, sel_a113, (!tilist_a114))
  (!inpt_a115)
  = (menumark "dclear"
     ++ Progfuns.newdraw ++ unmark sel_a113 ++ unmenumark "dclear", 
     ([], 1, initalist), inpt_a115)
Progfuns.dget (!_) (!state_a116) inpt_a117
  = ("", state_a116, inpt_a117)
Progfuns.sel', Progfuns.delsq, Progfuns.inv' ::
  [Char] -> Progfuns.Trans
Progfuns.sel'
  (!rest_a118)
  (!((!dlist_a119), sel_a11a, slist_a11b))
  (!inpt_a11c)
  = (unmark sel_a11a ++ mark newsel_a11e, 
     (dlist_a119, newsel_a11e, slist_a11b), inpt_a11c)
  where
      new_a11d = inbox (Progfuns.stoil rest_a118)
      (!newsel_a11e) = if new_a11d == 0 then sel_a11a else new_a11d
Progfuns.delsq
  rest_a11f
  (!((!dlist_a11g), sel_a11h, tilist_a11i))
  inpt_a11j
  = (undo (put lsrest_a11n (orient xymax oldas_a11m wcoords_a11k)), 
     (dlist_a11g, sel_a11h, newtilist_a11o), inpt_a11j)
  where
      (!wcoords_a11k) = map (map wscale) (map fst dlist_a11g)
      stoilrest_a11l = Progfuns.stoil rest_a11f
      oldas_a11m = Progfuns.assoc (sqid stoilrest_a11l) tilist_a11i
      lsrest_a11n = btlocate stoilrest_a11l
      (!newtilist_a11o) = newas (sqid stoilrest_a11l) 0 tilist_a11i
Progfuns.inv'
  rest_a11p
  (!(dlist_a11q, sel_a11r, (!tilist_a11s)))
  (!inpt_a11t)
  = if lsrest_a11y == [0, 0] then
        ("", (dlist_a11q, sel_a11r, tilist_a11s), inpt_a11t)
    else
        (undo (put lsrest_a11y (orient xymax oldas_a11w wcoords_a11v))
         ++ put lsrest_a11y (orient xymax (inv oldas_a11w) wcoords_a11v), 
         (dlist_a11q, sel_a11r, newtilist_a11x), inpt_a11t)
  where
      (!stoilrest_a11u) = Progfuns.stoil rest_a11p
      (!wcoords_a11v) = map (map wscale) (map fst dlist_a11q)
      oldas_a11w = Progfuns.assoc (sqid stoilrest_a11u) tilist_a11s
      newtilist_a11x
        = newas (sqid stoilrest_a11u) (inv oldas_a11w) tilist_a11s
      lsrest_a11y = btlocate stoilrest_a11u
Progfuns.tclear, Progfuns.tsave, Progfuns.tget, Progfuns.t4' ::
  [Char] -> Progfuns.Trans
Progfuns.tclear
  (!_)
  (dlist_a11z, sel_a11A, (!tilist_a11B))
  inpt_a11C
  = (menumark "tclear"
     ++ cleara tilearea ++ tpgrid ++ totile ++ unmenumark "tclear", 
     (dlist_a11z, sel_a11A, initalist), inpt_a11C)
Progfuns.tsave _ (!state_a11D) (!inpt_a11E)
  = ("", state_a11D, inpt_a11E)
Progfuns.tget _ state_a11F (!inpt_a11G)
  = ("", state_a11F, inpt_a11G)
Progfuns.t4'
  (!_)
  (!((!dlist_a11H), sel_a11I, (!tilist_a11J)))
  (!inpt_a11K)
  = (out_a11P, (dlist_a11H, sel_a11I, newtilist_a11O), inpt_a11K)
  where
      (!orilist_a11L)
        = pam Progfuns.assoc [(0, 0), (0, 1), (1, 0), (1, 1)] tilist_a11J
      (!wcoords_a11M) = map (map wscale) (map fst dlist_a11H)
      pic_a11N = t4 (pam (orient xymax) orilist_a11L wcoords_a11M)
      newtilist_a11O
        = zip alistind (concrep 4 (cr12_a11Q ++ cr34_a11R))
        where
            cr12_a11Q = concrep 4 [n1_a11S, n2_a11T]
            cr34_a11R = concrep 4 [n3_a11U, n4_a11V]
            (![n1_a11S, (!n2_a11T), n3_a11U, n4_a11V]) = orilist_a11L
      (!out_a11P)
        = menumark "t4"
          ++
            cleara tilearea
            ++ tile tpxorig tpyorig 4 4 pic_a11N ++ unmenumark "t4"
Progfuns.assoc :: (Eq a_aFH) => a_aFH -> [(a_aFH, b_aFI)] -> b_aFI
Progfuns.assoc (!i_a15j) (!((!(j_a15k, v_a15l)) : (!ivs_a15m)))
  = if i_a15j == j_a15k then
        v_a15l
    else
        Progfuns.assoc i_a15j ivs_a15m
Progfuns.q :: [Char] -> Progfuns.Trans
Progfuns.q (!_) state_a15n (!_) = ("", state_a15n, [])
Progfuns.newdraw :: [Char]
Progfuns.newdraw
  = cleara designarea
    ++
      dpgrid
      ++
        cleara picarea
        ++
          picgrid ++ cleara tilearea ++ tpgrid ++ invisibletext ++ todesign
Progfuns.potatotile :: Progfuns.State -> [[Char]] -> [Char]
Progfuns.potatotile
  = inter Progfuns.tileprompt Progfuns.tilequit Progfuns.tiletrans
Progfuns.stoil :: [Char] -> [Int]
Progfuns.stoil = map read . words

type Progfuns.State = ([([Int], [Int])], Int, [((Int, Int), Int)])
type Progfuns.Trans =
    Progfuns.State -> [[Char]] -> ([Char], Progfuns.State, [[Char]])


["_","_","'q'","!'q'","(!'q')","_","(!'q') : _","((!'q') : _)","_","((!'q') : _) : _","(((!'q') : _) : _)","_","!_","(!_)","[]","_","_","!_","(!_)","dlist_aTd","safebang@!dlist_aTd","(!dlist_aTd)","sel_aTe","safebang@!sel_aTe","(!sel_aTe)","tilist_aTf","safebang@!tilist_aTf","(!tilist_aTf)","((!dlist_aTd), (!sel_aTe), (!tilist_aTf))","!((!dlist_aTd), (!sel_aTe), (!tilist_aTf))","(!((!dlist_aTd), (!sel_aTe), (!tilist_aTf)))","'m'","!'m'","(!'m')","'s'","'a'","!'a'","(!'a')","' '","rest_aTg","lazydmd@!rest_aTg","(!rest_aTg)","' ' : (!rest_aTg)","(' ' : (!rest_aTg))","!(' ' : (!rest_aTg))","(!(' ' : (!rest_aTg)))","(!'a') : (!(' ' : (!rest_aTg)))","((!'a') : (!(' ' : (!rest_aTg))))","!((!'a') : (!(' ' : (!rest_aTg))))","(!((!'a') : (!(' ' : (!rest_aTg)))))","'s' : (!((!'a') : (!(' ' : (!rest_aTg)))))","('s' : (!((!'a') : (!(' ' : (!rest_aTg))))))","(!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg))))))","((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))","!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))","(!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg))))))))","inpt_aTh","(!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n  inpt_aTh","((!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n   inpt_aTh)","!((!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n    inpt_aTh)","(!((!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n     inpt_aTh))","((!((!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n      inpt_aTh)))","x_aTi","y_aTj","!y_aTj","(!y_aTj)","[x_aTi, (!y_aTj)]","fun_aTl","dlist_aTm","!dlist_aTm","(!dlist_aTm)","sel_aTn","tilist_aTo","((!dlist_aTm), sel_aTn, tilist_aTo)","!((!dlist_aTm), sel_aTn, tilist_aTo)","(!((!dlist_aTm), sel_aTn, tilist_aTo))","'m'","'s'","'b'","' '","rest_aTp","' ' : rest_aTp","(' ' : rest_aTp)","'b' : (' ' : rest_aTp)","('b' : (' ' : rest_aTp))","!('b' : (' ' : rest_aTp))","(!('b' : (' ' : rest_aTp)))","'s' : (!('b' : (' ' : rest_aTp)))","('s' : (!('b' : (' ' : rest_aTp))))","'m' : ('s' : (!('b' : (' ' : rest_aTp))))","('m' : ('s' : (!('b' : (' ' : rest_aTp)))))","inpt_aTq","lazydmd@!inpt_aTq","(!inpt_aTq)","('m' : ('s' : (!('b' : (' ' : rest_aTp))))) : (!inpt_aTq)","(('m' : ('s' : (!('b' : (' ' : rest_aTp))))) : (!inpt_aTq))","!(('m' : ('s' : (!('b' : (' ' : rest_aTp))))) : (!inpt_aTq))","(!(('m' : ('s' : (!('b' : (' ' : rest_aTp))))) : (!inpt_aTq)))","x_aTr","!x_aTr","(!x_aTr)","y_aTs","!y_aTs","(!y_aTs)","[(!x_aTr), (!y_aTs)]","dlist_aTt","sel_aTu","!sel_aTu","(!sel_aTu)","tilist_aTv","(dlist_aTt, (!sel_aTu), tilist_aTv)","'m'","'s'","!'s'","(!'s')","'c'","' '","rest_aTw","lazydmd@!rest_aTw","(!rest_aTw)","' ' : (!rest_aTw)","(' ' : (!rest_aTw))","!(' ' : (!rest_aTw))","(!(' ' : (!rest_aTw)))","'c' : (!(' ' : (!rest_aTw)))","('c' : (!(' ' : (!rest_aTw))))","(!'s') : ('c' : (!(' ' : (!rest_aTw))))","((!'s') : ('c' : (!(' ' : (!rest_aTw)))))","'m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))","('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw))))))","inpt_aTx","lazydmd@!inpt_aTx","(!inpt_aTx)","('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) : (!inpt_aTx)","(('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) : (!inpt_aTx))","!(('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) : (!inpt_aTx))","(!(('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) :\n     (!inpt_aTx)))","((!(('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) :\n      (!inpt_aTx))))","x_aTy","y_aTz","[x_aTy, y_aTz]","![x_aTy, y_aTz]","(![x_aTy, y_aTz])","fun_aTB","!fun_aTB","(!fun_aTB)","state_aTC","'m'","'s'","!'s'","(!'s')","'d'","!'d'","(!'d')","' '","!' '","(!' ')","rest_aTD","lazydmd@!rest_aTD","(!rest_aTD)","(!' ') : (!rest_aTD)","((!' ') : (!rest_aTD))","(!'d') : ((!' ') : (!rest_aTD))","((!'d') : ((!' ') : (!rest_aTD)))","(!'s') : ((!'d') : ((!' ') : (!rest_aTD)))","((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))","'m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))","('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD)))))","!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD)))))","(!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))))","((!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD)))))))","inpt_aTE","lazydmd@!inpt_aTE","(!inpt_aTE)","((!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))))) :\n  (!inpt_aTE)","(((!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))))) :\n   (!inpt_aTE))","x_aTF","y_aTG","[x_aTF, y_aTG]","![x_aTF, y_aTG]","(![x_aTF, y_aTG])","str_aTJ","!str_aTJ","(!str_aTJ)","out_aTI","dlist_aTK","!dlist_aTK","(!dlist_aTK)","sel_aTL","!sel_aTL","(!sel_aTL)","tilist_aTM","((!dlist_aTK), (!sel_aTL), tilist_aTM)","'c'","'s'","!'s'","(!'s')","' '","rest_aTN","lazydmd@!rest_aTN","(!rest_aTN)","' ' : (!rest_aTN)","(' ' : (!rest_aTN))","!(' ' : (!rest_aTN))","(!(' ' : (!rest_aTN)))","(!'s') : (!(' ' : (!rest_aTN)))","((!'s') : (!(' ' : (!rest_aTN))))","!((!'s') : (!(' ' : (!rest_aTN))))","(!((!'s') : (!(' ' : (!rest_aTN)))))","'c' : (!((!'s') : (!(' ' : (!rest_aTN)))))","('c' : (!((!'s') : (!(' ' : (!rest_aTN))))))","inpt_aTO","('c' : (!((!'s') : (!(' ' : (!rest_aTN)))))) : inpt_aTO","(('c' : (!((!'s') : (!(' ' : (!rest_aTN)))))) : inpt_aTO)","x0_aTV","safebang@!x0_aTV","(!x0_aTV)","y0_aTW","x1_aTX","safebang@!x1_aTX","(!x1_aTX)","y1_aTY","[(!x0_aTV), y0_aTW, (!x1_aTX), y1_aTY]","![(!x0_aTV), y0_aTW, (!x1_aTX), y1_aTY]","(![(!x0_aTV), y0_aTW, (!x1_aTX), y1_aTY])","nstoilrest_aTQ","safebang@!nstoilrest_aTQ","(!nstoilrest_aTQ)","wnstoilrest_aTR","!wnstoilrest_aTR","(!wnstoilrest_aTR)","cssr_aTS","!cssr_aTS","(!cssr_aTS)","newele_aTT","linecircs_aTU","lazydmd@!linecircs_aTU","(!linecircs_aTU)","dlist_aU5","!dlist_aU5","(!dlist_aU5)","sel_aU6","tilist_aU7","!tilist_aU7","(!tilist_aU7)","((!dlist_aU5), sel_aU6, (!tilist_aU7))","!((!dlist_aU5), sel_aU6, (!tilist_aU7))","(!((!dlist_aU5), sel_aU6, (!tilist_aU7)))","'r'","'o'","'t'","' '","rest_aU8","' ' : rest_aU8","(' ' : rest_aU8)","'t' : (' ' : rest_aU8)","('t' : (' ' : rest_aU8))","'o' : ('t' : (' ' : rest_aU8))","('o' : ('t' : (' ' : rest_aU8)))","'r' : ('o' : ('t' : (' ' : rest_aU8)))","('r' : ('o' : ('t' : (' ' : rest_aU8))))","!('r' : ('o' : ('t' : (' ' : rest_aU8))))","(!('r' : ('o' : ('t' : (' ' : rest_aU8)))))","((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))","!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))","(!((!('r' : ('o' : ('t' : (' ' : rest_aU8)))))))","inpt_aU9","(!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9","((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9)","!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9)","(!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9))","((!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9)))","!((!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9)))","(!((!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) :\n        inpt_aU9))))","stoilrest_aUa","wcoords_aUb","oldas_aUc","!oldas_aUc","(!oldas_aUc)","newtilist_aUd","lsrest_aUe","dlist_aUf","!dlist_aUf","(!dlist_aUf)","sel_aUg","!sel_aUg","(!sel_aUg)","tilist_aUh","!tilist_aUh","(!tilist_aUh)","((!dlist_aUf), (!sel_aUg), (!tilist_aUh))","'p'","!'p'","(!'p')","'u'","!'u'","(!'u')","'t'","!'t'","(!'t')","' '","!' '","(!' ')","rest_aUi","(!' ') : rest_aUi","((!' ') : rest_aUi)","(!'t') : ((!' ') : rest_aUi)","((!'t') : ((!' ') : rest_aUi))","(!'u') : ((!'t') : ((!' ') : rest_aUi))","((!'u') : ((!'t') : ((!' ') : rest_aUi)))","!((!'u') : ((!'t') : ((!' ') : rest_aUi)))","(!((!'u') : ((!'t') : ((!' ') : rest_aUi))))","(!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))","((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi)))))","!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi)))))","(!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))","((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi)))))))","inpt_aUj","!inpt_aUj","(!inpt_aUj)","((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n  (!inpt_aUj)","(((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n   (!inpt_aUj))","!(((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n    (!inpt_aUj))","(!(((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n     (!inpt_aUj)))","((!(((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n      (!inpt_aUj))))","stoilrest_aUk","newtilist_aUl","lsrest_aUm","safebang@!lsrest_aUm","(!lsrest_aUm)","coords_aUn","oldas_aUo","!oldas_aUo","(!oldas_aUo)","wcoords_aUp","state_aUq","\"\"","inpt_aUr","\"\" : inpt_aUr","(\"\" : inpt_aUr)","!(\"\" : inpt_aUr)","(!(\"\" : inpt_aUr))","((!(\"\" : inpt_aUr)))","!((!(\"\" : inpt_aUr)))","(!((!(\"\" : inpt_aUr))))","state_aUs","!state_aUs","(!state_aUs)","_","inpt_aUt","_ : inpt_aUt","(_ : inpt_aUt)","_","!_","(!_)","dlist_aUu","sel_aUv","tilist_aUw","!tilist_aUw","(!tilist_aUw)","(dlist_aUu, sel_aUv, (!tilist_aUw))","!(dlist_aUu, sel_aUv, (!tilist_aUw))","(!(dlist_aUu, sel_aUv, (!tilist_aUw)))","inpt_aUx","_","dlist_aUy","!dlist_aUy","(!dlist_aUy)","sel_aUz","tilist_aUA","!tilist_aUA","(!tilist_aUA)","((!dlist_aUy), sel_aUz, (!tilist_aUA))","inpt_aUB","!inpt_aUB","(!inpt_aUB)","coords_aUC","_","!_","(!_)","dlist_a10K","!dlist_a10K","(!dlist_a10K)","sel_a10L","tilist_a10M","!tilist_a10M","(!tilist_a10M)","((!dlist_a10K), sel_a10L, (!tilist_a10M))","inpt_a10N","!inpt_a10N","(!inpt_a10N)","_","!_","(!_)","dlist_a10O","!dlist_a10O","(!dlist_a10O)","sel_a10P","tilist_a10Q","!tilist_a10Q","(!tilist_a10Q)","((!dlist_a10O), sel_a10P, (!tilist_a10Q))","!((!dlist_a10O), sel_a10P, (!tilist_a10Q))","(!((!dlist_a10O), sel_a10P, (!tilist_a10Q)))","inpt_a10R","!inpt_a10R","(!inpt_a10R)","rest_a10S","dlist_a10T","sel_a10U","!sel_a10U","(!sel_a10U)","tilist_a10V","!tilist_a10V","(!tilist_a10V)","(dlist_a10T, (!sel_a10U), (!tilist_a10V))","!(dlist_a10T, (!sel_a10U), (!tilist_a10V))","(!(dlist_a10T, (!sel_a10U), (!tilist_a10V)))","inpt_a10W","!inpt_a10W","(!inpt_a10W)","out_a10X","newdlist_a10Y","!newdlist_a10Y","(!newdlist_a10Y)","(out_a10X, (!newdlist_a10Y))","!(out_a10X, (!newdlist_a10Y))","(!(out_a10X, (!newdlist_a10Y)))","_","!_","(!_)","state_a10Z","inpt_a110","!inpt_a110","(!inpt_a110)","rest_a111","dlist_a112","sel_a113","tilist_a114","!tilist_a114","(!tilist_a114)","(dlist_a112, sel_a113, (!tilist_a114))","inpt_a115","!inpt_a115","(!inpt_a115)","_","!_","(!_)","state_a116","!state_a116","(!state_a116)","inpt_a117","rest_a118","!rest_a118","(!rest_a118)","dlist_a119","!dlist_a119","(!dlist_a119)","sel_a11a","slist_a11b","((!dlist_a119), sel_a11a, slist_a11b)","!((!dlist_a119), sel_a11a, slist_a11b)","(!((!dlist_a119), sel_a11a, slist_a11b))","inpt_a11c","!inpt_a11c","(!inpt_a11c)","new_a11d","newsel_a11e","!newsel_a11e","(!newsel_a11e)","rest_a11f","dlist_a11g","!dlist_a11g","(!dlist_a11g)","sel_a11h","tilist_a11i","((!dlist_a11g), sel_a11h, tilist_a11i)","!((!dlist_a11g), sel_a11h, tilist_a11i)","(!((!dlist_a11g), sel_a11h, tilist_a11i))","inpt_a11j","wcoords_a11k","lazydmd@!wcoords_a11k","(!wcoords_a11k)","stoilrest_a11l","oldas_a11m","lsrest_a11n","newtilist_a11o","!newtilist_a11o","(!newtilist_a11o)","rest_a11p","dlist_a11q","sel_a11r","tilist_a11s","!tilist_a11s","(!tilist_a11s)","(dlist_a11q, sel_a11r, (!tilist_a11s))","!(dlist_a11q, sel_a11r, (!tilist_a11s))","(!(dlist_a11q, sel_a11r, (!tilist_a11s)))","inpt_a11t","!inpt_a11t","(!inpt_a11t)","stoilrest_a11u","safebang@!stoilrest_a11u","(!stoilrest_a11u)","wcoords_a11v","!wcoords_a11v","(!wcoords_a11v)","oldas_a11w","newtilist_a11x","lsrest_a11y","_","!_","(!_)","dlist_a11z","sel_a11A","tilist_a11B","!tilist_a11B","(!tilist_a11B)","(dlist_a11z, sel_a11A, (!tilist_a11B))","inpt_a11C","_","state_a11D","!state_a11D","(!state_a11D)","inpt_a11E","!inpt_a11E","(!inpt_a11E)","_","state_a11F","inpt_a11G","!inpt_a11G","(!inpt_a11G)","_","!_","(!_)","dlist_a11H","!dlist_a11H","(!dlist_a11H)","sel_a11I","tilist_a11J","!tilist_a11J","(!tilist_a11J)","((!dlist_a11H), sel_a11I, (!tilist_a11J))","!((!dlist_a11H), sel_a11I, (!tilist_a11J))","(!((!dlist_a11H), sel_a11I, (!tilist_a11J)))","inpt_a11K","!inpt_a11K","(!inpt_a11K)","orilist_a11L","!orilist_a11L","(!orilist_a11L)","wcoords_a11M","!wcoords_a11M","(!wcoords_a11M)","pic_a11N","newtilist_a11O","cr12_a11Q","cr34_a11R","n1_a11S","n2_a11T","safebang@!n2_a11T","(!n2_a11T)","n3_a11U","n4_a11V","[n1_a11S, (!n2_a11T), n3_a11U, n4_a11V]","![n1_a11S, (!n2_a11T), n3_a11U, n4_a11V]","(![n1_a11S, (!n2_a11T), n3_a11U, n4_a11V])","out_a11P","!out_a11P","(!out_a11P)","i_a15j","!i_a15j","(!i_a15j)","j_a15k","v_a15l","(j_a15k, v_a15l)","!(j_a15k, v_a15l)","(!(j_a15k, v_a15l))","ivs_a15m","safebang@!ivs_a15m","(!ivs_a15m)","(!(j_a15k, v_a15l)) : (!ivs_a15m)","((!(j_a15k, v_a15l)) : (!ivs_a15m))","!((!(j_a15k, v_a15l)) : (!ivs_a15m))","(!((!(j_a15k, v_a15l)) : (!ivs_a15m)))","_","!_","(!_)","state_a15n","_","!_","(!_)","newdraw","potatotile","stoil"]
module Progfuns
       (tileprompt, tilequit, tiletrans, potatotile, State) where
import Mgrfuns
import Drawfuns
import Geomfuns
import Psfuns
import Interstate
import Auxprogfuns
import Layout
import Tilefuns
import Help

tileprompt :: a_aTc -> [Char]
tileprompt _ = ""

tilequit :: a_aTb -> [[Char]] -> Bool
tilequit _ (((norecord@'q') : _) : _) = True
tilequit (norecord@_) [] = True
tilequit _ (norecord@_) = False

tiletrans :: Trans
tiletrans (norecord@((!dlist_aTd), (!sel_aTe), (!tilist_aTf)))
  ((norecord@((norecord@((norecord@'m') :
                           ('s' :
                              (norecord@((norecord@'a') :
                                           (norecord@(' ' : (lazydmd@rest_aTg))))))))
                : inpt_aTh)))
  = if intsave x_aTi y_aTj then doo_aTk tsave else
      if intclear x_aTi y_aTj then doo_aTk tclear else
        if intget x_aTi y_aTj then doo_aTk tget else
          if intile4 x_aTi y_aTj then doo_aTk t4' else
            if inquit x_aTi y_aTj then doo_aTk q else
              if inbigtile x_aTi y_aTj then doo_aTk delsq else
                if intoalter x_aTi y_aTj then doo_aTk tofiddle' else
                  if intotile x_aTi y_aTj then doo_aTk totile' else
                    if intodraw x_aTi y_aTj then doo_aTk todesign' else
                      if inpicarea x_aTi y_aTj then doo_aTk sel' else
                        if inhelp x_aTi y_aTj then doo_aTk tohelp' else
                          tiletrans (dlist_aTd, sel_aTe, tilist_aTf) inpt_aTh
  where [x_aTi, (norecord@y_aTj)] = stoil rest_aTg
        doo_aTk fun_aTl
          = fun_aTl rest_aTg (dlist_aTd, sel_aTe, tilist_aTf) inpt_aTh
tiletrans (norecord@((norecord@dlist_aTm), sel_aTn, tilist_aTo))
  (norecord@(('m' : ('s' : (norecord@('b' : (' ' : rest_aTp))))) :
               (lazydmd@inpt_aTq)))
  = if inbigtile x_aTr y_aTs then
      inv' rest_aTp (dlist_aTm, sel_aTn, tilist_aTo) inpt_aTq else
      tiletrans (dlist_aTm, sel_aTn, tilist_aTo)
        (('m' : 's' : 'a' : ' ' : rest_aTp) : inpt_aTq)
  where [(norecord@x_aTr), (norecord@y_aTs)] = stoil rest_aTp
tiletrans (dlist_aTt, (norecord@sel_aTu), tilist_aTv)
  ((norecord@(('m' :
                 ((norecord@'s') : ('c' : (norecord@(' ' : (lazydmd@rest_aTw))))))
                : (lazydmd@inpt_aTx))))
  = if indesign x_aTy y_aTz then doo_aTA rl else
      if indsave x_aTy y_aTz then doo_aTA dsave else
        if indclear x_aTy y_aTz then doo_aTA dclear else
          if indget x_aTy y_aTz then doo_aTA dget else
            tiletrans (dlist_aTt, sel_aTu, tilist_aTv)
              (('m' : 's' : 'a' : ' ' : rest_aTw) : inpt_aTx)
  where (norecord@[x_aTy, y_aTz]) = stoil rest_aTw
        doo_aTA (norecord@fun_aTB)
          = fun_aTB rest_aTw (dlist_aTt, sel_aTu, tilist_aTv) inpt_aTx
tiletrans state_aTC
  (((norecord@('m' :
                 ((norecord@'s') :
                    ((norecord@'d') : ((norecord@' ') : (lazydmd@rest_aTD)))))))
     : (lazydmd@inpt_aTE))
  = (inithelp ++ out_aTI, state_aTC, inpt_aTE)
  where (norecord@[x_aTF, y_aTG]) = stoil rest_aTD
        cf_aTH (norecord@str_aTJ) = clear ++ str_aTJ
        out_aTI
          = if intodraw x_aTF y_aTG then cf_aTH helpdraw else
              if intotile x_aTF y_aTG then cf_aTH helptile else
                if intoalter x_aTF y_aTG then cf_aTH helpalter else
                  if intsave x_aTF y_aTG then cf_aTH helptsave else
                    if intclear x_aTF y_aTG then cf_aTH helptclear else
                      if intget x_aTF y_aTG then cf_aTH helptget else
                        if intile4 x_aTF y_aTG then cf_aTH helpt4 else
                          if inquit x_aTF y_aTG then cf_aTH helpquit else
                            if inbigtile x_aTF y_aTG then cf_aTH helpbt else
                              if inpicarea x_aTF y_aTG then cf_aTH helppic else
                                if indesign x_aTF y_aTG then cf_aTH helpdesign else
                                  if indsave x_aTF y_aTG then cf_aTH helpdsave else
                                    if indclear x_aTF y_aTG then cf_aTH helpdclear else
                                      if indget x_aTF y_aTG then cf_aTH helpdget else
                                        if inhelp x_aTF y_aTG then cf_aTH inithelp else
                                          cf_aTH errmes
tiletrans ((norecord@dlist_aTK), (norecord@sel_aTL), tilist_aTM)
  (('c' :
      (norecord@((norecord@'s') :
                   (norecord@(' ' : (lazydmd@rest_aTN))))))
     : inpt_aTO)
  = if indgrid nstoilrest_aTQ then
      (linecircs_aTU ++ wnstoilrest_aTR,
       (newele_aTT : dlist_aTK, sel_aTL, tilist_aTM), inpt_aTO)
      else ("", (dlist_aTK, sel_aTL, tilist_aTM), inpt_aTO)
  where nearline_aTP
          (norecord@[(!x0_aTV), y0_aTW, (!x1_aTX), y1_aTY])
          = [nearx x0_aTV, neary y0_aTW, nearx x1_aTX, neary y1_aTY]
        (!nstoilrest_aTQ) = nearline_aTP (stoil rest_aTN)
        (norecord@wnstoilrest_aTR) = wline nstoilrest_aTQ
        (norecord@cssr_aTS) = cs nstoilrest_aTQ
        newele_aTT = (nstoilrest_aTQ, snd cssr_aTS)
        (lazydmd@linecircs_aTU) = fst cssr_aTS
tiletrans
  (norecord@((norecord@dlist_aU5), sel_aU6, (norecord@tilist_aU7)))
  (norecord@((norecord@((norecord@((norecord@('r' :
                                                ('o' : ('t' : (' ' : rest_aU8)))))))
                          : inpt_aU9))))
  = if lsrest_aUe == [0, 0] then
      ("", (dlist_aU5, sel_aU6, tilist_aU7), inpt_aU9) else
      (undo (put lsrest_aUe (orient xymax oldas_aUc wcoords_aUb)) ++
         put lsrest_aUe (orient xymax (rot oldas_aUc) wcoords_aUb),
       (dlist_aU5, sel_aU6, newtilist_aUd), inpt_aU9)
  where stoilrest_aUa = stoil rest_aU8
        wcoords_aUb = map (map wscale) (map fst dlist_aU5)
        (norecord@oldas_aUc) = assoc (sqid stoilrest_aUa) tilist_aU7
        newtilist_aUd
          = newas (sqid stoilrest_aUa) (rot oldas_aUc) tilist_aU7
        lsrest_aUe = btlocate stoilrest_aUa
tiletrans
  ((norecord@dlist_aUf), (norecord@sel_aUg), (norecord@tilist_aUh))
  ((norecord@(((norecord@((norecord@'p') :
                            (norecord@((norecord@'u') :
                                         ((norecord@'t') : ((norecord@' ') : rest_aUi)))))))
                : (norecord@inpt_aUj))))
  = if lsrest_aUm == [0, 0] then
      ("", (dlist_aUf, sel_aUg, tilist_aUh), inpt_aUj) else
      (undo (put lsrest_aUm (orient xymax oldas_aUo wcoords_aUp)) ++
         put lsrest_aUm (orient xymax sel_aUg wcoords_aUp),
       (dlist_aUf, sel_aUg, newtilist_aUl), inpt_aUj)
  where stoilrest_aUk = stoil rest_aUi
        newtilist_aUl = newas (sqid stoilrest_aUk) sel_aUg tilist_aUh
        (!lsrest_aUm) = btlocate stoilrest_aUk
        coords_aUn = map fst dlist_aUf
        (norecord@oldas_aUo) = assoc (sqid stoilrest_aUk) tilist_aUh
        wcoords_aUp = map (map wscale) coords_aUn
tiletrans state_aUq (norecord@((norecord@("" : inpt_aUr))))
  = (helpend ++ todesign, state_aUq, inpt_aUr)
tiletrans (norecord@state_aUs) (_ : inpt_aUt)
  = ("", state_aUs, inpt_aUt)

todesign', totile', tofiddle', tohelp' :: [Char] -> Trans
todesign' (norecord@_)
  (norecord@(dlist_aUu, sel_aUv, (norecord@tilist_aUw))) inpt_aUx
  = (cleara picarea ++ picgrid ++ cleara tilearea ++ tpgrid ++
       showoris (map fst dlist_aUu) 1
       ++ todesign,
     (dlist_aUu, sel_aUv, tilist_aUw), inpt_aUx)
totile' _ ((norecord@dlist_aUy), sel_aUz, (norecord@tilist_aUA))
  (norecord@inpt_aUB)
  = (concat (map (showoris coords_aUC) [1 .. 8]) ++ totile,
     (dlist_aUy, sel_aUz, tilist_aUA), inpt_aUB)
  where coords_aUC = map fst dlist_aUy
tofiddle' (norecord@_)
  ((norecord@dlist_a10K), sel_a10L, (norecord@tilist_a10M))
  (norecord@inpt_a10N)
  = (tofiddle, (dlist_a10K, sel_a10L, tilist_a10M), inpt_a10N)
tohelp' (norecord@_)
  (norecord@((norecord@dlist_a10O), sel_a10P,
             (norecord@tilist_a10Q)))
  (norecord@inpt_a10R)
  = (tohelp, (dlist_a10O, sel_a10P, tilist_a10Q), inpt_a10R)

rl, dsave, dclear, dget :: [Char] -> Trans
rl rest_a10S
  (norecord@(dlist_a10T, (norecord@sel_a10U),
             (norecord@tilist_a10V)))
  (norecord@inpt_a10W)
  = (out_a10X, (newdlist_a10Y, sel_a10U, tilist_a10V), inpt_a10W)
  where (norecord@(out_a10X, (norecord@newdlist_a10Y)))
          = deline dlist_a10T (stoil rest_a10S)
dsave (norecord@_) state_a10Z (norecord@inpt_a110)
  = ("", state_a10Z, inpt_a110)
dclear rest_a111 (dlist_a112, sel_a113, (norecord@tilist_a114))
  (norecord@inpt_a115)
  = (menumark "dclear" ++ newdraw ++ unmark sel_a113 ++
       unmenumark "dclear",
     ([], 1, initalist), inpt_a115)
dget (norecord@_) (norecord@state_a116) inpt_a117
  = ("", state_a116, inpt_a117)

sel', delsq, inv' :: [Char] -> Trans
sel' (norecord@rest_a118)
  (norecord@((norecord@dlist_a119), sel_a11a, slist_a11b))
  (norecord@inpt_a11c)
  = (unmark sel_a11a ++ mark newsel_a11e,
     (dlist_a119, newsel_a11e, slist_a11b), inpt_a11c)
  where new_a11d = inbox (stoil rest_a118)
        (norecord@newsel_a11e)
          = if new_a11d == 0 then sel_a11a else new_a11d
delsq rest_a11f
  (norecord@((norecord@dlist_a11g), sel_a11h, tilist_a11i)) inpt_a11j
  = (undo (put lsrest_a11n (orient xymax oldas_a11m wcoords_a11k)),
     (dlist_a11g, sel_a11h, newtilist_a11o), inpt_a11j)
  where (lazydmd@wcoords_a11k)
          = map (map wscale) (map fst dlist_a11g)
        stoilrest_a11l = stoil rest_a11f
        oldas_a11m = assoc (sqid stoilrest_a11l) tilist_a11i
        lsrest_a11n = btlocate stoilrest_a11l
        (norecord@newtilist_a11o)
          = newas (sqid stoilrest_a11l) 0 tilist_a11i
inv' rest_a11p
  (norecord@(dlist_a11q, sel_a11r, (norecord@tilist_a11s)))
  (norecord@inpt_a11t)
  = if lsrest_a11y == [0, 0] then
      ("", (dlist_a11q, sel_a11r, tilist_a11s), inpt_a11t) else
      (undo (put lsrest_a11y (orient xymax oldas_a11w wcoords_a11v)) ++
         put lsrest_a11y (orient xymax (inv oldas_a11w) wcoords_a11v),
       (dlist_a11q, sel_a11r, newtilist_a11x), inpt_a11t)
  where (!stoilrest_a11u) = stoil rest_a11p
        (norecord@wcoords_a11v) = map (map wscale) (map fst dlist_a11q)
        oldas_a11w = assoc (sqid stoilrest_a11u) tilist_a11s
        newtilist_a11x
          = newas (sqid stoilrest_a11u) (inv oldas_a11w) tilist_a11s
        lsrest_a11y = btlocate stoilrest_a11u

tclear, tsave, tget, t4' :: [Char] -> Trans
tclear (norecord@_) (dlist_a11z, sel_a11A, (norecord@tilist_a11B))
  inpt_a11C
  = (menumark "tclear" ++ cleara tilearea ++ tpgrid ++ totile ++
       unmenumark "tclear",
     (dlist_a11z, sel_a11A, initalist), inpt_a11C)
tsave _ (norecord@state_a11D) (norecord@inpt_a11E)
  = ("", state_a11D, inpt_a11E)
tget _ state_a11F (norecord@inpt_a11G)
  = ("", state_a11F, inpt_a11G)
t4' (norecord@_)
  (norecord@((norecord@dlist_a11H), sel_a11I,
             (norecord@tilist_a11J)))
  (norecord@inpt_a11K)
  = (out_a11P, (dlist_a11H, sel_a11I, newtilist_a11O), inpt_a11K)
  where (norecord@orilist_a11L)
          = pam assoc [(0, 0), (0, 1), (1, 0), (1, 1)] tilist_a11J
        (norecord@wcoords_a11M) = map (map wscale) (map fst dlist_a11H)
        pic_a11N = t4 (pam (orient xymax) orilist_a11L wcoords_a11M)
        newtilist_a11O = zip alistind (concrep 4 (cr12_a11Q ++ cr34_a11R))
          where cr12_a11Q = concrep 4 [n1_a11S, n2_a11T]
                cr34_a11R = concrep 4 [n3_a11U, n4_a11V]
                (norecord@[n1_a11S, (!n2_a11T), n3_a11U, n4_a11V]) = orilist_a11L
        (norecord@out_a11P)
          = menumark "t4" ++ cleara tilearea ++
              tile tpxorig tpyorig 4 4 pic_a11N
              ++ unmenumark "t4"

assoc :: (Eq a_aFH) => a_aFH -> [(a_aFH, b_aFI)] -> b_aFI
assoc (norecord@i_a15j)
  (norecord@((norecord@(j_a15k, v_a15l)) : (!ivs_a15m)))
  = if i_a15j == j_a15k then v_a15l else assoc i_a15j ivs_a15m

q :: [Char] -> Trans
q (norecord@_) state_a15n (norecord@_) = ("", state_a15n, [])

newdraw :: [Char]
newdraw
  = cleara designarea ++ dpgrid ++ cleara picarea ++ picgrid ++
      cleara tilearea
      ++ tpgrid
      ++ invisibletext
      ++ todesign

potatotile :: State -> [[Char]] -> [Char]
potatotile = inter tileprompt tilequit tiletrans

stoil :: [Char] -> [Int]
stoil = map read . words

type State = ([([Int], [Int])], Int, [((Int, Int), Int)])

type Trans = State -> [[Char]] -> ([Char], State, [[Char]])

==================== Renamer ====================
Mgrfuns.escom :: [Char] -> [Int] -> [Char]
Mgrfuns.escom str_anx ns_any
  = '\ESC' : foldr f_anz "" ns_any
  where
      f_anz (!n_anA) "" = show n_anA ++ str_anx
      f_anz n_aw1 s_aw2 = show n_aw1 ++ "," ++ s_aw2
Mgrfuns.aligntext = '\ESC' : "l"
Mgrfuns.bitcopy = Mgrfuns.escom "b"
Mgrfuns.circle = Mgrfuns.escom "o"
Mgrfuns.clear = "\f"
Mgrfuns.clearevent event_aCa
  = Mgrfuns.escom "e" [Mgrfuns.mapevent event_aCa]
Mgrfuns.clearmode mode_aCb = Mgrfuns.escom "s" [mode_aCb]
Mgrfuns.destroywin (!n_aCc) = Mgrfuns.escom ",OZ" [n_aCc]
Mgrfuns.dragcircle (![(!x1_aCd), (!y1_aCe), (!x2_aCf), (!y2_aCg)])
  = Mgrfuns.circle [x1_aCd, y1_aCe, r_aCh]
  where
      r_aCh
        = bcroot
            (square (diff x1_aCd x2_aCf) + square (diff y1_aCe y2_aCg))
Mgrfuns.dragline = "%l\n"
Mgrfuns.dragrect = "%r\n"
Mgrfuns.font (!x_aDg) = Mgrfuns.escom "F" [x_aDg]
Mgrfuns.func (!mode_aDh) = Mgrfuns.escom "b" [mode_aDh]
Mgrfuns.go = Mgrfuns.escom "g"
Mgrfuns.highlight = Mgrfuns.escom "H"
Mgrfuns.line = Mgrfuns.escom "l"
Mgrfuns.mapevent (!event_aDi)
  = if event_aDi == 3 || event_aDi == 4 then
        2 - event_aDi
    else
        event_aDi
Mgrfuns.newwin = Mgrfuns.escom "Z"
Mgrfuns.rcircle (!r_aQL) = Mgrfuns.escom "o" [r_aQL]
Mgrfuns.selectwin n_aQM = Mgrfuns.escom "Z" [n_aQM]
Mgrfuns.setevent event_aQN (!str_aQO)
  = Mgrfuns.escom
      ("e" ++ str_aQO) [Mgrfuns.mapevent event_aQN, length str_aQO]
Mgrfuns.setmode mode_aQP = Mgrfuns.escom "S" [mode_aQP]
Mgrfuns.shapewindow = Mgrfuns.escom "W"
Mgrfuns.standend = '\ESC' : ",n"
Mgrfuns.standout = '\ESC' : "i"
Mgrfuns.stringto win_aQQ (!x_aQR) y_aQS str_aQT
  = Mgrfuns.escom
      ("." ++ str_aQT) [win_aQQ, x_aQR, y_aQS, length str_aQT]
Mgrfuns.textregion = Mgrfuns.escom "t"
Mgrfuns.textreset = '\ESC' : "t"


["str_anx","ns_any","n_anA","!n_anA","(!n_anA)","\"\"","n_aw1","s_aw2","aligntext","bitcopy","circle","clear","event_aCa","mode_aCb","n_aCc","safebang@!n_aCc","(!n_aCc)","x1_aCd","safebang@!x1_aCd","(!x1_aCd)","y1_aCe","safebang@!y1_aCe","(!y1_aCe)","x2_aCf","safebang@!x2_aCf","(!x2_aCf)","y2_aCg","safebang@!y2_aCg","(!y2_aCg)","[(!x1_aCd), (!y1_aCe), (!x2_aCf), (!y2_aCg)]","![(!x1_aCd), (!y1_aCe), (!x2_aCf), (!y2_aCg)]","(![(!x1_aCd), (!y1_aCe), (!x2_aCf), (!y2_aCg)])","r_aCh","dragline","dragrect","x_aDg","safebang@!x_aDg","(!x_aDg)","mode_aDh","safebang@!mode_aDh","(!mode_aDh)","go","highlight","line","event_aDi","safebang@!event_aDi","(!event_aDi)","newwin","r_aQL","safebang@!r_aQL","(!r_aQL)","n_aQM","event_aQN","str_aQO","safebang@!str_aQO","(!str_aQO)","mode_aQP","shapewindow","standend","standout","win_aQQ","x_aQR","safebang@!x_aQR","(!x_aQR)","y_aQS","str_aQT","textregion","textreset"]
module Mgrfuns
       (aligntext, bitcopy, circle, clear, clearevent, clearmode,
        destroywin, dragcircle, dragline, dragrect, font, func, go,
        highlight, line, mapevent, newwin, rcircle, selectwin, setevent,
        setmode, shapewindow, standend, stringto, standout, textregion,
        textreset)
       where
import Diff

escom :: [Char] -> [Int] -> [Char]
escom str_anx ns_any = '\ESC' : foldr f_anz "" ns_any
  where f_anz (norecord@n_anA) "" = show n_anA ++ str_anx
        f_anz n_aw1 s_aw2 = show n_aw1 ++ "," ++ s_aw2
aligntext = '\ESC' : "l"
bitcopy = escom "b"
circle = escom "o"
clear = "\f"
clearevent event_aCa = escom "e" [mapevent event_aCa]
clearmode mode_aCb = escom "s" [mode_aCb]
destroywin (!n_aCc) = escom ",OZ" [n_aCc]
dragcircle (norecord@[(!x1_aCd), (!y1_aCe), (!x2_aCf), (!y2_aCg)])
  = circle [x1_aCd, y1_aCe, r_aCh]
  where r_aCh
          = bcroot
              (square (diff x1_aCd x2_aCf) + square (diff y1_aCe y2_aCg))
dragline = "%l\n"
dragrect = "%r\n"
font (!x_aDg) = escom "F" [x_aDg]
func (!mode_aDh) = escom "b" [mode_aDh]
go = escom "g"
highlight = escom "H"
line = escom "l"
mapevent (!event_aDi)
  = if event_aDi == 3 || event_aDi == 4 then 2 - event_aDi else
      event_aDi
newwin = escom "Z"
rcircle (!r_aQL) = escom "o" [r_aQL]
selectwin n_aQM = escom "Z" [n_aQM]
setevent event_aQN (!str_aQO)
  = escom ("e" ++ str_aQO) [mapevent event_aQN, length str_aQO]
setmode mode_aQP = escom "S" [mode_aQP]
shapewindow = escom "W"
standend = '\ESC' : ",n"
standout = '\ESC' : "i"
stringto win_aQQ (!x_aQR) y_aQS str_aQT
  = escom ("." ++ str_aQT) [win_aQQ, x_aQR, y_aQS, length str_aQT]
textregion = escom "t"
textreset = '\ESC' : "t"

==================== Renamer ====================
Psfuns.concrep :: Int -> [a_app] -> [a_app]
Psfuns.concrep x_apq y_apr = concat (take x_apq (repeat y_apr))
Psfuns.pos8head :: [[Int]] -> [Char]
Psfuns.pos8head (!coords_ayY)
  = header_ayZ ++ pamcat_az1 (map newf_az3 [1 .. 8]) coords_ayY
  where
      header_ayZ
        = "%!PS-Adobe-1.0\n\
          \0.75 setlinewidth\n"
          ++
            "/print0\n\
            \{\n\
            \} def\n"
      topos_az0 [x1_az4, y1_az5, x2_az6, y2_az7]
        = show x1_az4
          ++
            " "
            ++
              show y1_az5
              ++ " moveto\n" ++ show x2_az6 ++ " " ++ show y2_az7 ++ " lineto\n"
      pamcat_az1 (!((!f_aHx) : fs_aHy)) (!a_aHz)
        = f_aHx a_aHz ++ pamcat_az1 fs_aHy a_aHz
      pamcat_az1 (![]) (!a_aHA) = []
      fpat_az2 (!h_aHB) (!f_aHC) coords_aHD
        = h_aHB
          ++ (concat . map topos_az0 . f_aHC) coords_aHD ++ "stroke} def\n"
      newf_az3 (!n_aHE)
        = fpat_az2
            ("/print"
             ++
               show n_aHE
               ++
                 "\n\
                 \{")
            (orient Psfuns.psmax n_aHE)
Psfuns.introline, Psfuns.rowline, Psfuns.ss :: [Char]
Psfuns.introline = "400 400 translate"
Psfuns.rowline
  = "\n\
    \-288 36 translate"
Psfuns.ss
  = "\n\
    \36 0 translate\n\
    \print"
Psfuns.sq :: Int -> [Char]
Psfuns.sq (!num_aHF) = Psfuns.ss ++ show num_aHF
Psfuns.lf :: [Int] -> [Char]
Psfuns.lf list_aHG
  = Psfuns.rowline ++ concat (map Psfuns.sq list_aHG)
Psfuns.tile4 :: [Int] -> [Char]
Psfuns.tile4 [n1_aHH, (!n2_aHI), n3_aHJ, (!n4_aHK)]
  = Psfuns.introline
    ++
      Psfuns.concrep
        4 (posrow_aHL n1_aHH n2_aHI ++ posrow_aHL n3_aHJ n4_aHK)
      ++
        "\n\
        \showpage\n"
  where
      posrow_aHL i_aHM (!j_aHN)
        = Psfuns.rowline
          ++ Psfuns.concrep 4 (Psfuns.sq i_aHM ++ Psfuns.sq j_aHN)
Psfuns.psmax :: Int
Psfuns.psmax = 36


["x_apq","y_apr","coords_ayY","safebang@!coords_ayY","(!coords_ayY)","header_ayZ","x1_az4","y1_az5","x2_az6","y2_az7","[x1_az4, y1_az5, x2_az6, y2_az7]","f_aHx","safebang@!f_aHx","(!f_aHx)","fs_aHy","(!f_aHx) : fs_aHy","((!f_aHx) : fs_aHy)","!((!f_aHx) : fs_aHy)","(!((!f_aHx) : fs_aHy))","a_aHz","safebang@!a_aHz","(!a_aHz)","[]","![]","(![])","a_aHA","!a_aHA","(!a_aHA)","h_aHB","!h_aHB","(!h_aHB)","f_aHC","!f_aHC","(!f_aHC)","coords_aHD","n_aHE","!n_aHE","(!n_aHE)","introline","rowline","ss","num_aHF","!num_aHF","(!num_aHF)","list_aHG","n1_aHH","n2_aHI","safebang@!n2_aHI","(!n2_aHI)","n3_aHJ","n4_aHK","safebang@!n4_aHK","(!n4_aHK)","[n1_aHH, (!n2_aHI), n3_aHJ, (!n4_aHK)]","i_aHM","j_aHN","safebang@!j_aHN","(!j_aHN)","psmax"]
module Psfuns (pos8head, introline, lf, tile4, concrep) where
import Geomfuns
import Auxprogfuns

concrep :: Int -> [a_app] -> [a_app]
concrep x_apq y_apr = concat (take x_apq (repeat y_apr))

pos8head :: [[Int]] -> [Char]
pos8head (!coords_ayY)
  = header_ayZ ++ pamcat_az1 (map newf_az3 [1 .. 8]) coords_ayY
  where header_ayZ
          = "%!PS-Adobe-1.0\n0.75 setlinewidth\n" ++ "/print0\n{\n} def\n"
        topos_az0 [x1_az4, y1_az5, x2_az6, y2_az7]
          = show x1_az4 ++ " " ++ show y1_az5 ++ " moveto\n" ++ show x2_az6
              ++ " "
              ++ show y2_az7
              ++ " lineto\n"
        pamcat_az1 (norecord@((!f_aHx) : fs_aHy)) (!a_aHz)
          = f_aHx a_aHz ++ pamcat_az1 fs_aHy a_aHz
        pamcat_az1 (norecord@[]) (norecord@a_aHA) = []
        fpat_az2 (norecord@h_aHB) (norecord@f_aHC) coords_aHD
          = h_aHB ++ (concat . map topos_az0 . f_aHC) coords_aHD ++
              "stroke} def\n"
        newf_az3 (norecord@n_aHE)
          = fpat_az2 ("/print" ++ show n_aHE ++ "\n{") (orient psmax n_aHE)

introline, rowline, ss :: [Char]
introline = "400 400 translate"
rowline = "\n-288 36 translate"
ss = "\n36 0 translate\nprint"

sq :: Int -> [Char]
sq (norecord@num_aHF) = ss ++ show num_aHF

lf :: [Int] -> [Char]
lf list_aHG = rowline ++ concat (map sq list_aHG)

tile4 :: [Int] -> [Char]
tile4 [n1_aHH, (!n2_aHI), n3_aHJ, (!n4_aHK)]
  = introline ++
      concrep 4 (posrow_aHL n1_aHH n2_aHI ++ posrow_aHL n3_aHJ n4_aHK)
      ++ "\nshowpage\n"
  where posrow_aHL i_aHM (!j_aHN)
          = rowline ++ concrep 4 (sq i_aHM ++ sq j_aHN)

psmax :: Int
psmax = 36

==================== Renamer ====================
Tilefuns.nextoct :: Int -> Int
Tilefuns.nextoct n_aLH = (n_aLH + 1) `mod` 8
Tilefuns.nop :: (Int, Int) -> (Int, Int)
Tilefuns.nop (n1_aVM, (!n2_aVN))
  = if n2_aVN == 7 then
        (Tilefuns.nextoct n1_aVM, 0)
    else
        (n1_aVM, Tilefuns.nextoct n2_aVN)
Tilefuns.indlist :: (Int, Int) -> [(Int, Int)]
Tilefuns.indlist n1n2_aVO
  = n1n2_aVO : (Tilefuns.indlist . Tilefuns.nop) n1n2_aVO
Tilefuns.alistind :: [(Int, Int)]
Tilefuns.alistind = take 64 (Tilefuns.indlist (0, 0))
Tilefuns.initalist :: [((Int, Int), Int)]
Tilefuns.initalist = map (\ x_aZp -> (x_aZp, 0)) Tilefuns.alistind
Tilefuns.unmark :: Int -> [Char]
Tilefuns.unmark = undo . Tilefuns.mark
Tilefuns.mark :: Int -> [Char]
Tilefuns.mark (!0) = ""
Tilefuns.mark n_aZq
  = rectangle
      [x_aZr - 3, y_aZs - 3, x_aZr + w_aZt + 3, y_aZs + h_aZu + 3]
  where
      (![x_aZr, (!y_aZs), (!w_aZt), (!h_aZu)]) = picbox n_aZq
Tilefuns.tlx, Tilefuns.tly :: Int -> Int
Tilefuns.tlx
  = \ (!x_aZv)
      -> tpxorig + (((x_aZv - tpxorig) `div` tpxygap) * tpxygap)
Tilefuns.tly
  = \ (!y_aZw)
      -> tpyorig + (((y_aZw - tpyorig) `div` tpxygap) * tpxygap)
Tilefuns.tlidx, Tilefuns.tlidy :: Int -> Int
Tilefuns.tlidx = \ (!x_aZx) -> ((x_aZx - tpxorig) `div` tpxygap)
Tilefuns.tlidy = \ (!y_aZy) -> ((y_aZy - tpyorig) `div` tpxygap)
Tilefuns.sqas :: Int -> Int -> [Int]
Tilefuns.sqas x_aZz y_aZA
  = [Tilefuns.tlx x_aZz, Tilefuns.tly y_aZA]
Tilefuns.sqid :: [Int] -> (Int, Int)
Tilefuns.sqid (![(!x_aZB), y_aZC])
  = (Tilefuns.tlidy y_aZC, Tilefuns.tlidx x_aZB)
Tilefuns.squas :: (Int, Int) -> [Int]
Tilefuns.squas (!(ln1_aZD, ln2_aZE))
  = [tpxorig + ln2_aZE * tpxygap, tpyorig + ln1_aZD * tpxygap]
Tilefuns.btlocate :: [Int] -> [Int]
Tilefuns.btlocate (![x_aZF, y_aZG])
  = if inbigtile x_aZF y_aZG then
        Tilefuns.sqas x_aZF y_aZG
    else
        [0, 0]
Tilefuns.put :: [Int] -> [[Int]] -> [Char]
Tilefuns.put (![x_aZH, y_aZI]) = place x_aZH y_aZI
Tilefuns.ineights :: [a_aLG] -> [[a_aLG]]
Tilefuns.ineights [] = []
Tilefuns.ineights ns_aZJ
  = take 8 ns_aZJ : Tilefuns.ineights (drop 8 ns_aZJ)
Tilefuns.rot :: Int -> Int
Tilefuns.rot n_aZK
  = case n_aZK of {
      0 -> 0
      4 -> 1
      8 -> 7
      (!7) -> 6
      6 -> 5
      5 -> 8
      n_aZL -> n_aZL + 1 }
Tilefuns.turn :: Int -> Int
Tilefuns.turn (!n_aZM)
  = if n_aZM == 0 then
        0
    else
        (if n_aZM == 4 then 8 else (n_aZM + 4) `mod` 8)
Tilefuns.inv :: Int -> Int
Tilefuns.inv = Tilefuns.turn
Tilefuns.inbox :: [Int] -> Int
Tilefuns.inbox (![(!xp_aZN), (!yp_aZO)])
  = inbox'_aZP 1
  where
      inbox'_aZP n_aZQ
        = if n_aZQ > 8 then
              0
          else
              if inrect x_aZR y_aZS w_aZT h_aZU xp_aZN yp_aZO then
                  n_aZQ
              else
                  inbox'_aZP (n_aZQ + 1)
        where
            [x_aZR, (!y_aZS), w_aZT, h_aZU] = picbox n_aZQ
Tilefuns.tpatformat :: [[Int]] -> [Char]
Tilefuns.tpatformat (![]) = ""
Tilefuns.tpatformat (!((!(ln_aZV : lns_aZW))))
  = formline_aZX ln_aZV ++ "\n" ++ Tilefuns.tpatformat lns_aZW
  where
      formline_aZX (n_aZY : ns_aZZ)
        = if (ns_aZZ /= []) then
              show n_aZY ++ " " ++ formline_aZX ns_aZZ
          else
              show n_aZY
Tilefuns.pam ::
  (a_aLw -> b_aLx -> c_aLy) -> [a_aLw] -> b_aLx -> [c_aLy]
Tilefuns.pam (!f_a18n) (!xs_a18o) y_a18p
  = map (\ x_a18q -> f_a18n x_a18q y_a18p) xs_a18o
Tilefuns.newas ::
  (Eq a_ay2) =>
  a_ay2 -> b_ay3 -> [(a_ay2, b_ay3)] -> [(a_ay2, b_ay3)]
Tilefuns.newas i_a18r (!e_a18s) (![]) = [(i_a18r, e_a18s)]
Tilefuns.newas
  i_a18t
  e_a18u
  ((!((!g1_a18v), (!g2_a18w))) : (!gs_a18x))
  = if g1_a18v == i_a18t then
        (i_a18t, e_a18u) : gs_a18x
    else
        (g1_a18v, g2_a18w) : Tilefuns.newas i_a18t e_a18u gs_a18x



==================== Renamer ====================
Main.main = getContents >>= \ s_arV -> Main.process s_arV
Main.process :: [Char] -> IO ()
Main.process s_arW
  = putStr a_arX
  where
      (!a_arX)
        = source_data db_arY
          ++ uvwresult db_arY uvwres_arZ ++ forceresult db_arY frc_as0
      (!db_arY) = (idatabase s_arW, rdatabase s_arW)
      (!uvwres_arZ) = uvw db_arY
      frc_as0 = forces db_arY uvwres_arZ


["main","s_arV","s_arW","a_arX","lazydmd@!a_arX","(!a_arX)","db_arY","!db_arY","(!db_arY)","uvwres_arZ","lazydmd@!uvwres_arZ","(!uvwres_arZ)","frc_as0"]
module Main (main) where
import Database
import Vector
import Displacement
import Elemforce
import PrintSource
import Printuvwforce
main = getContents >>= \ s_arV -> process s_arV

process :: [Char] -> IO ()
process s_arW = putStr a_arX
  where (lazydmd@a_arX)
          = source_data db_arY ++ uvwresult db_arY uvwres_arZ ++
              forceresult db_arY frc_as0
        (norecord@db_arY) = (idatabase s_arW, rdatabase s_arW)
        (lazydmd@uvwres_arZ) = uvw db_arY
        frc_as0 = forces db_arY uvwres_arZ

==================== Renamer ====================
VBmatrix.defvbmat ::
  Int -> Vec Int -> Vec a_apA -> VBmatrix.Vbm a_apA
VBmatrix.makevbmat ::
  Int -> Vec Int -> ((Int, Int) -> a_apz) -> VBmatrix.Vbm a_apz
VBmatrix.updvbmat ::
  VBmatrix.Vbm a_apy -> [((Int, Int), a_apy)] -> VBmatrix.Vbm a_apy
VBmatrix.incrvbmat ::
  (Num a_aoz) =>
  VBmatrix.Vbm a_aoz -> [((Int, Int), a_aoz)] -> VBmatrix.Vbm a_aoz
VBmatrix.vbmatsub :: VBmatrix.Vbm a_aoy -> (Int, Int) -> a_aoy
VBmatrix.boundvbmat :: VBmatrix.Vbm a_aox -> Int
VBmatrix.addrvbmat :: VBmatrix.Vbm a_aow -> (Int, Int) -> Int
VBmatrix.lengrvbmat :: VBmatrix.Vbm a_aov -> Int -> Int
VBmatrix.fstclvbmat :: VBmatrix.Vbm a_aou -> Int -> Int
VBmatrix.diagadrvbm :: VBmatrix.Vbm a_aot -> Vec Int
VBmatrix.displayvbmati :: VBmatrix.Vbm Int -> [Char]
VBmatrix.displayvbmatr :: VBmatrix.Vbm Float -> [Char]
VBmatrix.lengrvbmat
  (!((!(VBmatrix.VBMAT (!n_apB) addiag_apC elems_apD))))
  (!i_apE)
  = if (i_apE == 1) then
        1
    else
        (vecsub addiag_apC i_apE) - (vecsub addiag_apC (i_apE - 1))
VBmatrix.fstclvbmat
  (!((!(VBmatrix.VBMAT n_aD7 addiag_aD8 elems_aD9))))
  i_aDa
  = if (i_aDa == 1) then
        1
    else
        i_aDa
        - (VBmatrix.lengrvbmat
             (VBmatrix.VBMAT n_aD7 addiag_aD8 elems_aD9) i_aDa)
        + 1
VBmatrix.addrvbmat vbm_aDb (i_aDc, j_aDd)
  = vecsub addiag_aDf i_aDc + j_aDd - i_aDc
  where
      ((!(VBmatrix.VBMAT n_aDe (!addiag_aDf) elementlist_aDg))) = vbm_aDb
VBmatrix.boundvbmat
  ((!(VBmatrix.VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj))))
  = bounds_aDh
VBmatrix.diagadrvbm
  ((!(VBmatrix.VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm))))
  = addiag_aDl
VBmatrix.defvbmat bounds_aDn addiag_aDo (!elementlist_aDp)
  = VBmatrix.VBMAT bounds_aDn addiag_aDo elementlist_aDp
VBmatrix.makevbmat n_aDq (!addiag_aDr) generator_aDs
  = VBmatrix.VBMAT
      n_aDq addiag_aDr (makevec (vecsub addiag_aDr n_aDq) f_aDt)
  where
      f_aDt i_aDx = elemts_aDu !! (i_aDx - 1)
      (!elemts_aDu) = foldl irow_aDv [] [1 .. n_aDq]
      irow_aDv ls_aN3 i_aN4
        = ls_aN3
          ++
            [generator_aDs (i_aN4, j_aN5) |
               (!j_aN5) <- [(fstcl_aDw i_aN4) .. i_aN4]]
      fstcl_aDw i_aN6
        = if (i_aN6 == 1) then
              1
          else
              i_aN6 - vecsub addiag_aDr i_aN6 + vecsub addiag_aDr (i_aN6 - 1) + 1
VBmatrix.incrvbmat vbm_aN7 (!updates_aN8)
  = VBmatrix.VBMAT n_aN9 addiag_aNa new_elements_aNc
  where
      ((!(VBmatrix.VBMAT n_aN9 addiag_aNa elements_aNb))) = vbm_aN7
      (!new_elements_aNc) = incrvec elements_aNb new_s_aNd
      (!new_s_aNd)
        = map
            (\ (!((!(i_aNe, (!j_aNf))), (!x_aNg)))
               -> (VBmatrix.addrvbmat vbm_aN7 (i_aNe, j_aNf), x_aNg))
            updates_aN8
VBmatrix.updvbmat (!vbm_aNh) updates_aNi
  = VBmatrix.VBMAT n_aNj addiag_aNk new_elements_aNm
  where
      VBmatrix.VBMAT n_aNj (!addiag_aNk) (!elements_aNl) = vbm_aNh
      new_elements_aNm = updvec elements_aNl new_s_aNn
      new_s_aNn
        = map
            (\ (!((!((!i_aNo), j_aNp)), x_aNq))
               -> (VBmatrix.addrvbmat vbm_aNh (i_aNo, j_aNp), x_aNq))
            updates_aNi
VBmatrix.vbmatsub (!vbm_aNr) (!(i_aNs, j_aNt))
  = vecsub elements_aNw (VBmatrix.addrvbmat vbm_aNr (i_aNs, j_aNt))
  where
      VBmatrix.VBMAT n_aNu addiag_aNv elements_aNw = vbm_aNr
VBmatrix.displayvbmati (!vbm_aNx)
  = "<  \n" ++ concat (map displayvec rows_aNy) ++ "> \n"
  where
      (!rows_aNy)
        = [VBmatrix.rowi vbm_aNx i_aNA | (!i_aNA) <- [1 .. n_aNz]]
      (!n_aNz) = VBmatrix.boundvbmat vbm_aNx
VBmatrix.displayvbmatr (!vbm_aNB)
  = "<  \n" ++ concat (map displayvec rows_aNC) ++ "> \n"
  where
      rows_aNC = [VBmatrix.rowr vbm_aNB i_aNE | (!i_aNE) <- [1 .. n_aND]]
      (!n_aND) = VBmatrix.boundvbmat vbm_aNB
VBmatrix.rowi (!vbm_aNF) (!i_aNG)
  = makevec n_aNH f_aNI
  where
      (!n_aNH) = VBmatrix.boundvbmat vbm_aNF
      f_aNI (!j_aNJ)
        = if ((j_aNJ >= (VBmatrix.fstclvbmat vbm_aNF i_aNG))
              && (j_aNJ <= i_aNG)) then
              VBmatrix.vbmatsub vbm_aNF (i_aNG, j_aNJ)
          else
              0
VBmatrix.rowr (!vbm_aNK) (!i_aNL)
  = makevec n_aNM f_aNN
  where
      (!n_aNM) = VBmatrix.boundvbmat vbm_aNK
      f_aNN (!j_aNO)
        = if ((j_aNO >= (VBmatrix.fstclvbmat vbm_aNK i_aNL))
              && (j_aNO <= i_aNL)) then
              VBmatrix.vbmatsub vbm_aNK (i_aNL, j_aNO)
          else
              0.0

data VBmatrix.Vbm a_aol = VBmatrix.VBMAT Int (Vec Int) (Vec a_aol)


["n_apB","!n_apB","(!n_apB)","addiag_apC","elems_apD","VBMAT (!n_apB) addiag_apC elems_apD","(VBMAT (!n_apB) addiag_apC elems_apD)","!(VBMAT (!n_apB) addiag_apC elems_apD)","(!(VBMAT (!n_apB) addiag_apC elems_apD))","((!(VBMAT (!n_apB) addiag_apC elems_apD)))","!((!(VBMAT (!n_apB) addiag_apC elems_apD)))","(!((!(VBMAT (!n_apB) addiag_apC elems_apD))))","i_apE","!i_apE","(!i_apE)","n_aD7","addiag_aD8","elems_aD9","VBMAT n_aD7 addiag_aD8 elems_aD9","(VBMAT n_aD7 addiag_aD8 elems_aD9)","!(VBMAT n_aD7 addiag_aD8 elems_aD9)","(!(VBMAT n_aD7 addiag_aD8 elems_aD9))","((!(VBMAT n_aD7 addiag_aD8 elems_aD9)))","!((!(VBMAT n_aD7 addiag_aD8 elems_aD9)))","(!((!(VBMAT n_aD7 addiag_aD8 elems_aD9))))","i_aDa","vbm_aDb","i_aDc","j_aDd","(i_aDc, j_aDd)","n_aDe","addiag_aDf","!addiag_aDf","(!addiag_aDf)","elementlist_aDg","VBMAT n_aDe (!addiag_aDf) elementlist_aDg","(VBMAT n_aDe (!addiag_aDf) elementlist_aDg)","!(VBMAT n_aDe (!addiag_aDf) elementlist_aDg)","(!(VBMAT n_aDe (!addiag_aDf) elementlist_aDg))","((!(VBMAT n_aDe (!addiag_aDf) elementlist_aDg)))","bounds_aDh","safebang@!bounds_aDh","(!bounds_aDh)","addiag_aDi","elementlist_aDj","safebang@!elementlist_aDj","(!elementlist_aDj)","VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj)","(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj))","!(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj))","(!(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj)))","((!(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj))))","bounds_aDk","safebang@!bounds_aDk","(!bounds_aDk)","addiag_aDl","elementlist_aDm","safebang@!elementlist_aDm","(!elementlist_aDm)","VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm)","(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm))","!(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm))","(!(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm)))","((!(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm))))","bounds_aDn","addiag_aDo","elementlist_aDp","safebang@!elementlist_aDp","(!elementlist_aDp)","n_aDq","addiag_aDr","safebang@!addiag_aDr","(!addiag_aDr)","generator_aDs","i_aDx","elemts_aDu","!elemts_aDu","(!elemts_aDu)","ls_aN3","i_aN4","j_aN5","!j_aN5","(!j_aN5)","i_aN6","vbm_aN7","updates_aN8","safebang@!updates_aN8","(!updates_aN8)","n_aN9","addiag_aNa","elements_aNb","VBMAT n_aN9 addiag_aNa elements_aNb","(VBMAT n_aN9 addiag_aNa elements_aNb)","!(VBMAT n_aN9 addiag_aNa elements_aNb)","(!(VBMAT n_aN9 addiag_aNa elements_aNb))","((!(VBMAT n_aN9 addiag_aNa elements_aNb)))","new_elements_aNc","!new_elements_aNc","(!new_elements_aNc)","new_s_aNd","safebang@!new_s_aNd","(!new_s_aNd)","i_aNe","j_aNf","safebang@!j_aNf","(!j_aNf)","(i_aNe, (!j_aNf))","!(i_aNe, (!j_aNf))","(!(i_aNe, (!j_aNf)))","x_aNg","safebang@!x_aNg","(!x_aNg)","((!(i_aNe, (!j_aNf))), (!x_aNg))","!((!(i_aNe, (!j_aNf))), (!x_aNg))","(!((!(i_aNe, (!j_aNf))), (!x_aNg)))","vbm_aNh","safebang@!vbm_aNh","(!vbm_aNh)","updates_aNi","n_aNj","addiag_aNk","!addiag_aNk","(!addiag_aNk)","elements_aNl","!elements_aNl","(!elements_aNl)","VBMAT n_aNj (!addiag_aNk) (!elements_aNl)","new_elements_aNm","new_s_aNn","i_aNo","safebang@!i_aNo","(!i_aNo)","j_aNp","((!i_aNo), j_aNp)","!((!i_aNo), j_aNp)","(!((!i_aNo), j_aNp))","x_aNq","((!((!i_aNo), j_aNp)), x_aNq)","!((!((!i_aNo), j_aNp)), x_aNq)","(!((!((!i_aNo), j_aNp)), x_aNq))","vbm_aNr","!vbm_aNr","(!vbm_aNr)","i_aNs","j_aNt","(i_aNs, j_aNt)","!(i_aNs, j_aNt)","(!(i_aNs, j_aNt))","n_aNu","addiag_aNv","elements_aNw","VBMAT n_aNu addiag_aNv elements_aNw","vbm_aNx","!vbm_aNx","(!vbm_aNx)","rows_aNy","lazydmd@!rows_aNy","(!rows_aNy)","i_aNA","!i_aNA","(!i_aNA)","n_aNz","!n_aNz","(!n_aNz)","vbm_aNB","!vbm_aNB","(!vbm_aNB)","rows_aNC","i_aNE","!i_aNE","(!i_aNE)","n_aND","!n_aND","(!n_aND)","vbm_aNF","!vbm_aNF","(!vbm_aNF)","i_aNG","!i_aNG","(!i_aNG)","n_aNH","!n_aNH","(!n_aNH)","j_aNJ","safebang@!j_aNJ","(!j_aNJ)","vbm_aNK","!vbm_aNK","(!vbm_aNK)","i_aNL","!i_aNL","(!i_aNL)","n_aNM","!n_aNM","(!n_aNM)","j_aNO","safebang@!j_aNO","(!j_aNO)"]
module VBmatrix
       (Vbm, defvbmat, makevbmat, incrvbmat, updvbmat, vbmatsub,
        boundvbmat, addrvbmat, lengrvbmat, fstclvbmat, diagadrvbm,
        displayvbmati, displayvbmatr)
       where
import Basics
import Vector

defvbmat :: Int -> Vec Int -> Vec a_apA -> Vbm a_apA

makevbmat :: Int -> Vec Int -> ((Int, Int) -> a_apz) -> Vbm a_apz

updvbmat :: Vbm a_apy -> [((Int, Int), a_apy)] -> Vbm a_apy

incrvbmat ::
            (Num a_aoz) => Vbm a_aoz -> [((Int, Int), a_aoz)] -> Vbm a_aoz

vbmatsub :: Vbm a_aoy -> (Int, Int) -> a_aoy

boundvbmat :: Vbm a_aox -> Int

addrvbmat :: Vbm a_aow -> (Int, Int) -> Int

lengrvbmat :: Vbm a_aov -> Int -> Int

fstclvbmat :: Vbm a_aou -> Int -> Int

diagadrvbm :: Vbm a_aot -> Vec Int

displayvbmati :: Vbm Int -> [Char]

displayvbmatr :: Vbm Float -> [Char]
lengrvbmat
  (norecord@((norecord@(VBMAT (norecord@n_apB) addiag_apC
                          elems_apD))))
  (norecord@i_apE)
  = if (i_apE == 1) then 1 else
      (vecsub addiag_apC i_apE) - (vecsub addiag_apC (i_apE - 1))
fstclvbmat
  (norecord@((norecord@(VBMAT n_aD7 addiag_aD8 elems_aD9)))) i_aDa
  = if (i_aDa == 1) then 1 else
      i_aDa - (lengrvbmat (VBMAT n_aD7 addiag_aD8 elems_aD9) i_aDa) + 1
addrvbmat vbm_aDb (i_aDc, j_aDd)
  = vecsub addiag_aDf i_aDc + j_aDd - i_aDc
  where ((norecord@(VBMAT n_aDe (norecord@addiag_aDf)
                      elementlist_aDg)))
          = vbm_aDb
boundvbmat
  ((norecord@(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj))))
  = bounds_aDh
diagadrvbm
  ((norecord@(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm))))
  = addiag_aDl
defvbmat bounds_aDn addiag_aDo (!elementlist_aDp)
  = VBMAT bounds_aDn addiag_aDo elementlist_aDp
makevbmat n_aDq (!addiag_aDr) generator_aDs
  = VBMAT n_aDq addiag_aDr (makevec (vecsub addiag_aDr n_aDq) f_aDt)
  where f_aDt i_aDx = elemts_aDu !! (i_aDx - 1)
        (norecord@elemts_aDu) = foldl irow_aDv [] [1 .. n_aDq]
        irow_aDv ls_aN3 i_aN4
          = ls_aN3 ++
              [generator_aDs (i_aN4, j_aN5) |
               (norecord@j_aN5) <- [(fstcl_aDw i_aN4) .. i_aN4]]
        fstcl_aDw i_aN6
          = if (i_aN6 == 1) then 1 else
              i_aN6 - vecsub addiag_aDr i_aN6 + vecsub addiag_aDr (i_aN6 - 1) + 1
incrvbmat vbm_aN7 (!updates_aN8)
  = VBMAT n_aN9 addiag_aNa new_elements_aNc
  where ((norecord@(VBMAT n_aN9 addiag_aNa elements_aNb))) = vbm_aN7
        (norecord@new_elements_aNc) = incrvec elements_aNb new_s_aNd
        (!new_s_aNd)
          = map
              (\ (norecord@((norecord@(i_aNe, (!j_aNf))), (!x_aNg))) ->
                 (addrvbmat vbm_aN7 (i_aNe, j_aNf), x_aNg))
              updates_aN8
updvbmat (!vbm_aNh) updates_aNi
  = VBMAT n_aNj addiag_aNk new_elements_aNm
  where VBMAT n_aNj (norecord@addiag_aNk) (norecord@elements_aNl)
          = vbm_aNh
        new_elements_aNm = updvec elements_aNl new_s_aNn
        new_s_aNn
          = map
              (\ (norecord@((norecord@((!i_aNo), j_aNp)), x_aNq)) ->
                 (addrvbmat vbm_aNh (i_aNo, j_aNp), x_aNq))
              updates_aNi
vbmatsub (norecord@vbm_aNr) (norecord@(i_aNs, j_aNt))
  = vecsub elements_aNw (addrvbmat vbm_aNr (i_aNs, j_aNt))
  where VBMAT n_aNu addiag_aNv elements_aNw = vbm_aNr
displayvbmati (norecord@vbm_aNx)
  = "<  \n" ++ concat (map displayvec rows_aNy) ++ "> \n"
  where (lazydmd@rows_aNy)
          = [rowi vbm_aNx i_aNA | (norecord@i_aNA) <- [1 .. n_aNz]]
        (norecord@n_aNz) = boundvbmat vbm_aNx
displayvbmatr (norecord@vbm_aNB)
  = "<  \n" ++ concat (map displayvec rows_aNC) ++ "> \n"
  where rows_aNC
          = [rowr vbm_aNB i_aNE | (norecord@i_aNE) <- [1 .. n_aND]]
        (norecord@n_aND) = boundvbmat vbm_aNB
rowi (norecord@vbm_aNF) (norecord@i_aNG) = makevec n_aNH f_aNI
  where (norecord@n_aNH) = boundvbmat vbm_aNF
        f_aNI (!j_aNJ)
          = if ((j_aNJ >= (fstclvbmat vbm_aNF i_aNG)) && (j_aNJ <= i_aNG))
              then vbmatsub vbm_aNF (i_aNG, j_aNJ) else 0
rowr (norecord@vbm_aNK) (norecord@i_aNL) = makevec n_aNM f_aNN
  where (norecord@n_aNM) = boundvbmat vbm_aNK
        f_aNN (!j_aNO)
          = if ((j_aNO >= (fstclvbmat vbm_aNK i_aNL)) && (j_aNO <= i_aNL))
              then vbmatsub vbm_aNK (i_aNL, j_aNO) else 0.0

data Vbm a_aol = VBMAT Int (Vec Int) (Vec a_aol)

==================== Renamer ====================
VBlldecomp.vblldecomp :: Vbm Float -> Vbm Float
VBlldecomp.vbllsolution :: Vbm Float -> Vec Float -> Vec Float
VBlldecomp.vbllsolution' :: Vbm Float -> Vec Float -> Vec Float
VBlldecomp.vblldecomp (!mA_ap7)
  = m_ap8
  where
      m_ap8 = makevbmat (boundvbmat mA_ap7) (diagadrvbm mA_ap7) f_ap9
      f_ap9 (!(i_apb, (!j_apc)))
        = if (i_apb == j_apc) then
              sqrt
                (vbmatsub mA_ap7 (i_apb, i_apb)
                 - sum
                     (map
                        (\ (!k_aIL)
                           -> vbmatsub m_ap8 (i_apb, k_aIL) * vbmatsub m_ap8 (i_apb, k_aIL))
                        [(fstclvbmat mA_ap7 i_apb) .. (i_apb - 1)]))
          else
              (vbmatsub mA_ap7 (i_apb, j_apc)
               - sum
                   (map
                      (\ k_aJK
                         -> (vbmatsub m_ap8 (i_apb, k_aJK) * vbmatsub m_ap8 (j_apc, k_aJK)))
                      [(k0_apa i_apb j_apc) .. (j_apc - 1)]))
              / (vbmatsub m_ap8 (j_apc, j_apc))
      k0_apa i_aSR j_aSS
        = if ((fstclvbmat mA_ap7 i_aSR) >= (fstclvbmat mA_ap7 j_aSS)) then
              (fstclvbmat mA_ap7 i_aSR)
          else
              (fstclvbmat mA_ap7 j_aSS)
VBlldecomp.vbllsolution (!a_aST) (!b_aSU)
  = fst
      (VBlldecomp.backwarding
         (VBlldecomp.forwarding (b_aSU, VBlldecomp.vblldecomp a_aST)))
VBlldecomp.vbllsolution' a'_aT1 b_aT2
  = fst
      (VBlldecomp.backwarding (VBlldecomp.forwarding (b_aT2, a'_aT1)))
VBlldecomp.forwarding (b_aT3, mVB_aT4)
  = (b'_aT5, mVB_aT4)
  where
      b'_aT5 = makevec n_aT6 f_aT7
      (!n_aT6) = boundvec b_aT3
      f_aT7 i_aT9
        = (vecsub b_aT3 i_aT9
           - sum
               [(vbmatsub mVB_aT4 (i_aT9, j_aTa)) * (vecsub b'_aT5 j_aTa) |
                  (!j_aTa) <- [l_aT8 i_aT9 .. i_aT9 - 1]])
          / (vbmatsub mVB_aT4 (i_aT9, i_aT9))
      l_aT8 i_aTb = fstclvbmat mVB_aT4 i_aTb
VBlldecomp.backwarding (!((!b_aTc), mVB_aTd))
  = (b'_aTf, mVB_aTd)
  where
      (!n_aTe) = boundvec b_aTc
      b'_aTf = makevec n_aTe f_aTg
      f_aTg (!i_aTi)
        = (vecsub b_aTc i_aTi
           - sum
               [(vbmatsub mVB_aTd (j_aTj, i_aTi)) * (vecsub b'_aTf j_aTj) |
                  j_aTj <- (validj_aTh i_aTi [i_aTi + 1 .. n_aTe])])
          / (vbmatsub mVB_aTd (i_aTi, i_aTi))
      validj_aTh (!i_aTk) ((!j_aTl) : js_aTm)
        = if (i_aTk >= fstclvbmat mVB_aTd j_aTl) then
              j_aTl : (validj_aTh i_aTk js_aTm)
          else
              validj_aTh i_aTk js_aTm
      validj_aTh (!i_aTn) [] = []


["mA_ap7","!mA_ap7","(!mA_ap7)","m_ap8","i_apb","j_apc","safebang@!j_apc","(!j_apc)","(i_apb, (!j_apc))","!(i_apb, (!j_apc))","(!(i_apb, (!j_apc)))","k_aIL","!k_aIL","(!k_aIL)","k_aJK","i_aSR","j_aSS","a_aST","safebang@!a_aST","(!a_aST)","b_aSU","!b_aSU","(!b_aSU)","a'_aT1","b_aT2","b_aT3","mVB_aT4","(b_aT3, mVB_aT4)","b'_aT5","n_aT6","!n_aT6","(!n_aT6)","i_aT9","j_aTa","!j_aTa","(!j_aTa)","i_aTb","b_aTc","!b_aTc","(!b_aTc)","mVB_aTd","((!b_aTc), mVB_aTd)","!((!b_aTc), mVB_aTd)","(!((!b_aTc), mVB_aTd))","n_aTe","!n_aTe","(!n_aTe)","b'_aTf","i_aTi","safebang@!i_aTi","(!i_aTi)","j_aTj","i_aTk","safebang@!i_aTk","(!i_aTk)","j_aTl","!j_aTl","(!j_aTl)","js_aTm","(!j_aTl) : js_aTm","((!j_aTl) : js_aTm)","i_aTn","!i_aTn","(!i_aTn)","[]"]
module VBlldecomp (vblldecomp, vbllsolution, vbllsolution') where
import Basics
import Vector
import VBmatrix

vblldecomp :: Vbm Float -> Vbm Float

vbllsolution :: Vbm Float -> Vec Float -> Vec Float

vbllsolution' :: Vbm Float -> Vec Float -> Vec Float
vblldecomp (norecord@mA_ap7) = m_ap8
  where m_ap8
          = makevbmat (boundvbmat mA_ap7) (diagadrvbm mA_ap7) f_ap9
        f_ap9 (norecord@(i_apb, (!j_apc)))
          = if (i_apb == j_apc) then
              sqrt
                (vbmatsub mA_ap7 (i_apb, i_apb) -
                   sum
                     (map
                        (\ (norecord@k_aIL) ->
                           vbmatsub m_ap8 (i_apb, k_aIL) * vbmatsub m_ap8 (i_apb, k_aIL))
                        [(fstclvbmat mA_ap7 i_apb) .. (i_apb - 1)]))
              else
              (vbmatsub mA_ap7 (i_apb, j_apc) -
                 sum
                   (map
                      (\ k_aJK ->
                         (vbmatsub m_ap8 (i_apb, k_aJK) * vbmatsub m_ap8 (j_apc, k_aJK)))
                      [(k0_apa i_apb j_apc) .. (j_apc - 1)]))
                / (vbmatsub m_ap8 (j_apc, j_apc))
        k0_apa i_aSR j_aSS
          = if ((fstclvbmat mA_ap7 i_aSR) >= (fstclvbmat mA_ap7 j_aSS)) then
              (fstclvbmat mA_ap7 i_aSR) else (fstclvbmat mA_ap7 j_aSS)
vbllsolution (!a_aST) (norecord@b_aSU)
  = fst (backwarding (forwarding (b_aSU, vblldecomp a_aST)))
vbllsolution' a'_aT1 b_aT2
  = fst (backwarding (forwarding (b_aT2, a'_aT1)))
forwarding (b_aT3, mVB_aT4) = (b'_aT5, mVB_aT4)
  where b'_aT5 = makevec n_aT6 f_aT7
        (norecord@n_aT6) = boundvec b_aT3
        f_aT7 i_aT9
          = (vecsub b_aT3 i_aT9 -
               sum
                 [(vbmatsub mVB_aT4 (i_aT9, j_aTa)) * (vecsub b'_aT5 j_aTa) |
                  (norecord@j_aTa) <- [l_aT8 i_aT9 .. i_aT9 - 1]])
              / (vbmatsub mVB_aT4 (i_aT9, i_aT9))
        l_aT8 i_aTb = fstclvbmat mVB_aT4 i_aTb
backwarding (norecord@((norecord@b_aTc), mVB_aTd))
  = (b'_aTf, mVB_aTd)
  where (norecord@n_aTe) = boundvec b_aTc
        b'_aTf = makevec n_aTe f_aTg
        f_aTg (!i_aTi)
          = (vecsub b_aTc i_aTi -
               sum
                 [(vbmatsub mVB_aTd (j_aTj, i_aTi)) * (vecsub b'_aTf j_aTj) |
                  j_aTj <- (validj_aTh i_aTi [i_aTi + 1 .. n_aTe])])
              / (vbmatsub mVB_aTd (i_aTi, i_aTi))
        validj_aTh (!i_aTk) ((norecord@j_aTl) : js_aTm)
          = if (i_aTk >= fstclvbmat mVB_aTd j_aTl) then
              j_aTl : (validj_aTh i_aTk js_aTm) else validj_aTh i_aTk js_aTm
        validj_aTh (norecord@i_aTn) [] = []

==================== Renamer ====================
Matrix.makemat ::
  (Int, Int) -> ((Int, Int) -> a_ay2) -> Matrix.Mat a_ay2
Matrix.boundmat :: Matrix.Mat a_ay1 -> (Int, Int)
Matrix.incrmat ::
  (Num a_ay0) =>
  Matrix.Mat a_ay0 -> [((Int, Int), a_ay0)] -> Matrix.Mat a_ay0
Matrix.updmat ::
  Matrix.Mat a_axZ -> [((Int, Int), a_axZ)] -> Matrix.Mat a_axZ
Matrix.matsub :: Matrix.Mat a_axY -> (Int, Int) -> a_axY
Matrix.mmatvec ::
  (Num a_axX) => Matrix.Mat a_axX -> Vec a_axX -> Vec a_axX
Matrix.mmatmat ::
  (Num a_awY) =>
  Matrix.Mat a_awY -> Matrix.Mat a_awY -> Matrix.Mat a_awY
Matrix.row :: Matrix.Mat a_awX -> Int -> Vec a_awX
Matrix.col :: Matrix.Mat a_awW -> Int -> Vec a_awW
Matrix.intchrow ::
  Int -> Int -> Matrix.Mat a_awV -> Matrix.Mat a_awV
Matrix.intchcol ::
  Int -> Int -> Matrix.Mat a_awU -> Matrix.Mat a_awU
Matrix.interchmat ::
  (Int, Int) -> (Int, Int) -> Matrix.Mat a_awT -> Matrix.Mat a_awT
Matrix.displaymat :: (Show a_aos) => Matrix.Mat a_aos -> [Char]
Matrix.makemat ((!nr_ay3), nc_ay4) (!g_ay5)
  = Matrix.MAT
      (nr_ay3, nc_ay4)
      (makevec
         (nr_ay3 * nc_ay4)
         (\ (!i_ay6)
            -> (map g_ay5 (range ((1, 1), (nr_ay3, nc_ay4)))) !! (i_ay6 - 1)))
Matrix.boundmat
  (!((!(Matrix.MAT ((!nr_aK8), nc_aK9) elements_aKa))))
  = (nr_aK8, nc_aK9)
Matrix.updmat m_aKb s_aKc
  = Matrix.MAT (nr_aKd, nc_aKe) new_elements_aKg
  where
      (!(Matrix.MAT (nr_aKd, nc_aKe) elements_aKf)) = m_aKb
      new_elements_aKg = updvec elements_aKf new_s_aKh
      (!new_s_aKh)
        = map
            (\ ((!((i_aKi, (!j_aKj)), (!x_aKk))))
               -> (((i_aKi - 1) * nc_aKe + j_aKj, x_aKk)))
            s_aKc
Matrix.incrmat (!m_aKl) s_aKm
  = Matrix.MAT (nr_aKn, nc_aKo) new_elements_aKq
  where
      Matrix.MAT ((!nr_aKn), (!nc_aKo)) elements_aKp = m_aKl
      (!new_elements_aKq) = incrvec elements_aKp new_s_aKr
      new_s_aKr
        = map
            (\ ((((!i_aKs), j_aKt), (!x_aKu)))
               -> (((i_aKs - 1) * nc_aKo + j_aKt, x_aKu)))
            s_aKm
Matrix.matsub (!m_aKv) (!(i_aKw, j_aKx))
  = vecsub elements_aKA ((i_aKw - 1) * nc_aKz + j_aKx)
  where
      Matrix.MAT (nr_aKy, nc_aKz) (!elements_aKA) = m_aKv
Matrix.mmatvec (!m_aKB) (!v_aKC)
  = makevec
      nr_aKD
      (\ i_aKF
         -> sum
              [(Matrix.matsub m_aKB (i_aKF, j_aQu)) * (vecsub v_aKC j_aQu) |
                 (!j_aQu) <- [1 .. nc_aKE]])
  where
      (!((!nr_aKD), (!nc_aKE))) = Matrix.boundmat m_aKB
Matrix.mmatmat (!m1_aQv) m2_aQw
  = if (t1_aQy == t2_aQz) then
        Matrix.makemat
          (l_aQx, n_aQA)
          (\ (!(i_a13w, (!j_a13x)))
             -> sum
                  [(Matrix.matsub m1_aQv (i_a13w, k_a13y))
                   * (Matrix.matsub m2_aQw (k_a13y, j_a13x)) |
                     k_a13y <- [1 .. t1_aQy]])
    else
        error "Dimension error"
  where
      (!(l_aQx, t1_aQy)) = Matrix.boundmat m1_aQv
      (t2_aQz, (!n_aQA)) = Matrix.boundmat m2_aQw
Matrix.row (!m_a13A) (!i_a13B)
  = makevec
      n_a13C (\ j_a13D -> Matrix.matsub m_a13A (i_a13B, j_a13D))
  where
      (_, (!n_a13C)) = Matrix.boundmat m_a13A
Matrix.col m_a13E j_a13F
  = makevec
      n_a13G (\ i_a13H -> Matrix.matsub m_a13E (i_a13H, j_a13F))
  where
      (!((!n_a13G), (!_))) = Matrix.boundmat m_a13E
Matrix.intchrow (!i_a13I) (!j_a13J) m_a13K
  = Matrix.makemat
      (Matrix.boundmat m_a13K)
      (\ (!((!r_a13L), (!c_a13M)))
         -> if (r_a13L == i_a13I) then
                Matrix.matsub m_a13K (j_a13J, c_a13M)
            else
                if (r_a13L == j_a13J) then
                    Matrix.matsub m_a13K (i_a13I, c_a13M)
                else
                    Matrix.matsub m_a13K (r_a13L, c_a13M))
Matrix.intchcol (!i_a13N) (!j_a13O) (!m_a13P)
  = Matrix.makemat
      (Matrix.boundmat m_a13P)
      (\ (!((!r_a13Q), (!c_a13R)))
         -> if (c_a13R == i_a13N) then
                Matrix.matsub m_a13P (r_a13Q, j_a13O)
            else
                if (c_a13R == j_a13O) then
                    Matrix.matsub m_a13P (r_a13Q, i_a13N)
                else
                    Matrix.matsub m_a13P (r_a13Q, c_a13R))
Matrix.interchmat
  ((!i1_a13S), j1_a13T)
  (i2_a13U, (!j2_a13V))
  m_a13W
  = Matrix.makemat
      (Matrix.boundmat m_a13W)
      (\ (!((!i_a13X), j_a13Y))
         -> if (i_a13X, j_a13Y) == (i1_a13S, j1_a13T) then
                Matrix.matsub m_a13W (i2_a13U, j2_a13V)
            else
                if (i_a13X, j_a13Y) == (i2_a13U, j2_a13V) then
                    Matrix.matsub m_a13W (i1_a13S, j1_a13T)
                else
                    Matrix.matsub m_a13W (i_a13X, j_a13Y))
Matrix.displaymat m_a13Z
  = "<\n"
    ++
      concat
        [displayvec (Matrix.row m_a13Z i_a141) | i_a141 <- [1 .. nr_a140]]
      ++ ">\n"
  where
      (nr_a140, (!_)) = Matrix.boundmat m_a13Z

data Matrix.Mat a_aok = Matrix.MAT (Int, Int) (Vec a_aok)


["nr_ay3","safebang@!nr_ay3","(!nr_ay3)","nc_ay4","((!nr_ay3), nc_ay4)","g_ay5","safebang@!g_ay5","(!g_ay5)","i_ay6","safebang@!i_ay6","(!i_ay6)","nr_aK8","safebang@!nr_aK8","(!nr_aK8)","nc_aK9","((!nr_aK8), nc_aK9)","elements_aKa","MAT ((!nr_aK8), nc_aK9) elements_aKa","(MAT ((!nr_aK8), nc_aK9) elements_aKa)","!(MAT ((!nr_aK8), nc_aK9) elements_aKa)","(!(MAT ((!nr_aK8), nc_aK9) elements_aKa))","((!(MAT ((!nr_aK8), nc_aK9) elements_aKa)))","!((!(MAT ((!nr_aK8), nc_aK9) elements_aKa)))","(!((!(MAT ((!nr_aK8), nc_aK9) elements_aKa))))","m_aKb","s_aKc","nr_aKd","nc_aKe","(nr_aKd, nc_aKe)","elements_aKf","MAT (nr_aKd, nc_aKe) elements_aKf","(MAT (nr_aKd, nc_aKe) elements_aKf)","!(MAT (nr_aKd, nc_aKe) elements_aKf)","(!(MAT (nr_aKd, nc_aKe) elements_aKf))","new_elements_aKg","new_s_aKh","lazydmd@!new_s_aKh","(!new_s_aKh)","i_aKi","j_aKj","safebang@!j_aKj","(!j_aKj)","(i_aKi, (!j_aKj))","x_aKk","safebang@!x_aKk","(!x_aKk)","((i_aKi, (!j_aKj)), (!x_aKk))","!((i_aKi, (!j_aKj)), (!x_aKk))","(!((i_aKi, (!j_aKj)), (!x_aKk)))","((!((i_aKi, (!j_aKj)), (!x_aKk))))","m_aKl","!m_aKl","(!m_aKl)","s_aKm","nr_aKn","!nr_aKn","(!nr_aKn)","nc_aKo","!nc_aKo","(!nc_aKo)","((!nr_aKn), (!nc_aKo))","elements_aKp","MAT ((!nr_aKn), (!nc_aKo)) elements_aKp","new_elements_aKq","!new_elements_aKq","(!new_elements_aKq)","new_s_aKr","i_aKs","safebang@!i_aKs","(!i_aKs)","j_aKt","((!i_aKs), j_aKt)","x_aKu","safebang@!x_aKu","(!x_aKu)","(((!i_aKs), j_aKt), (!x_aKu))","((((!i_aKs), j_aKt), (!x_aKu)))","m_aKv","!m_aKv","(!m_aKv)","i_aKw","j_aKx","(i_aKw, j_aKx)","!(i_aKw, j_aKx)","(!(i_aKw, j_aKx))","nr_aKy","nc_aKz","(nr_aKy, nc_aKz)","elements_aKA","!elements_aKA","(!elements_aKA)","MAT (nr_aKy, nc_aKz) (!elements_aKA)","m_aKB","!m_aKB","(!m_aKB)","v_aKC","safebang@!v_aKC","(!v_aKC)","i_aKF","j_aQu","!j_aQu","(!j_aQu)","nr_aKD","!nr_aKD","(!nr_aKD)","nc_aKE","!nc_aKE","(!nc_aKE)","((!nr_aKD), (!nc_aKE))","!((!nr_aKD), (!nc_aKE))","(!((!nr_aKD), (!nc_aKE)))","m1_aQv","!m1_aQv","(!m1_aQv)","m2_aQw","i_a13w","j_a13x","safebang@!j_a13x","(!j_a13x)","(i_a13w, (!j_a13x))","!(i_a13w, (!j_a13x))","(!(i_a13w, (!j_a13x)))","k_a13y","l_aQx","t1_aQy","(l_aQx, t1_aQy)","!(l_aQx, t1_aQy)","(!(l_aQx, t1_aQy))","t2_aQz","n_aQA","!n_aQA","(!n_aQA)","(t2_aQz, (!n_aQA))","m_a13A","!m_a13A","(!m_a13A)","i_a13B","safebang@!i_a13B","(!i_a13B)","j_a13D","_","n_a13C","!n_a13C","(!n_a13C)","(_, (!n_a13C))","m_a13E","j_a13F","i_a13H","n_a13G","!n_a13G","(!n_a13G)","_","!_","(!_)","((!n_a13G), (!_))","!((!n_a13G), (!_))","(!((!n_a13G), (!_)))","i_a13I","safebang@!i_a13I","(!i_a13I)","j_a13J","safebang@!j_a13J","(!j_a13J)","m_a13K","r_a13L","safebang@!r_a13L","(!r_a13L)","c_a13M","safebang@!c_a13M","(!c_a13M)","((!r_a13L), (!c_a13M))","!((!r_a13L), (!c_a13M))","(!((!r_a13L), (!c_a13M)))","i_a13N","safebang@!i_a13N","(!i_a13N)","j_a13O","safebang@!j_a13O","(!j_a13O)","m_a13P","!m_a13P","(!m_a13P)","r_a13Q","safebang@!r_a13Q","(!r_a13Q)","c_a13R","safebang@!c_a13R","(!c_a13R)","((!r_a13Q), (!c_a13R))","!((!r_a13Q), (!c_a13R))","(!((!r_a13Q), (!c_a13R)))","i1_a13S","safebang@!i1_a13S","(!i1_a13S)","j1_a13T","((!i1_a13S), j1_a13T)","i2_a13U","j2_a13V","safebang@!j2_a13V","(!j2_a13V)","(i2_a13U, (!j2_a13V))","m_a13W","i_a13X","safebang@!i_a13X","(!i_a13X)","j_a13Y","((!i_a13X), j_a13Y)","!((!i_a13X), j_a13Y)","(!((!i_a13X), j_a13Y))","m_a13Z","i_a141","nr_a140","_","!_","(!_)","(nr_a140, (!_))"]
module Matrix
       (Mat, makemat, boundmat, matsub, incrmat, updmat, mmatvec, mmatmat,
        row, col, intchrow, intchcol, interchmat, displaymat)
       where
import Data.Ix
import Basics
import Vector

makemat :: (Int, Int) -> ((Int, Int) -> a_ay2) -> Mat a_ay2

boundmat :: Mat a_ay1 -> (Int, Int)

incrmat ::
          (Num a_ay0) => Mat a_ay0 -> [((Int, Int), a_ay0)] -> Mat a_ay0

updmat :: Mat a_axZ -> [((Int, Int), a_axZ)] -> Mat a_axZ

matsub :: Mat a_axY -> (Int, Int) -> a_axY

mmatvec :: (Num a_axX) => Mat a_axX -> Vec a_axX -> Vec a_axX

mmatmat :: (Num a_awY) => Mat a_awY -> Mat a_awY -> Mat a_awY

row :: Mat a_awX -> Int -> Vec a_awX

col :: Mat a_awW -> Int -> Vec a_awW

intchrow :: Int -> Int -> Mat a_awV -> Mat a_awV

intchcol :: Int -> Int -> Mat a_awU -> Mat a_awU

interchmat :: (Int, Int) -> (Int, Int) -> Mat a_awT -> Mat a_awT

displaymat :: (Show a_aos) => Mat a_aos -> [Char]
makemat ((!nr_ay3), nc_ay4) (!g_ay5)
  = MAT (nr_ay3, nc_ay4)
      (makevec (nr_ay3 * nc_ay4)
         (\ (!i_ay6) ->
            (map g_ay5 (range ((1, 1), (nr_ay3, nc_ay4)))) !! (i_ay6 - 1)))
boundmat
  (norecord@((norecord@(MAT ((!nr_aK8), nc_aK9) elements_aKa))))
  = (nr_aK8, nc_aK9)
updmat m_aKb s_aKc = MAT (nr_aKd, nc_aKe) new_elements_aKg
  where (norecord@(MAT (nr_aKd, nc_aKe) elements_aKf)) = m_aKb
        new_elements_aKg = updvec elements_aKf new_s_aKh
        (lazydmd@new_s_aKh)
          = map
              (\ ((norecord@((i_aKi, (!j_aKj)), (!x_aKk)))) ->
                 (((i_aKi - 1) * nc_aKe + j_aKj, x_aKk)))
              s_aKc
incrmat (norecord@m_aKl) s_aKm
  = MAT (nr_aKn, nc_aKo) new_elements_aKq
  where MAT ((norecord@nr_aKn), (norecord@nc_aKo)) elements_aKp
          = m_aKl
        (norecord@new_elements_aKq) = incrvec elements_aKp new_s_aKr
        new_s_aKr
          = map
              (\ ((((!i_aKs), j_aKt), (!x_aKu))) ->
                 (((i_aKs - 1) * nc_aKo + j_aKt, x_aKu)))
              s_aKm
matsub (norecord@m_aKv) (norecord@(i_aKw, j_aKx))
  = vecsub elements_aKA ((i_aKw - 1) * nc_aKz + j_aKx)
  where MAT (nr_aKy, nc_aKz) (norecord@elements_aKA) = m_aKv
mmatvec (norecord@m_aKB) (!v_aKC)
  = makevec nr_aKD
      (\ i_aKF ->
         sum
           [(matsub m_aKB (i_aKF, j_aQu)) * (vecsub v_aKC j_aQu) |
            (norecord@j_aQu) <- [1 .. nc_aKE]])
  where (norecord@((norecord@nr_aKD), (norecord@nc_aKE)))
          = boundmat m_aKB
mmatmat (norecord@m1_aQv) m2_aQw
  = if (t1_aQy == t2_aQz) then
      makemat (l_aQx, n_aQA)
        (\ (norecord@(i_a13w, (!j_a13x))) ->
           sum
             [(matsub m1_aQv (i_a13w, k_a13y)) *
                (matsub m2_aQw (k_a13y, j_a13x))
              | k_a13y <- [1 .. t1_aQy]])
      else error "Dimension error"
  where (norecord@(l_aQx, t1_aQy)) = boundmat m1_aQv
        (t2_aQz, (norecord@n_aQA)) = boundmat m2_aQw
row (norecord@m_a13A) (!i_a13B)
  = makevec n_a13C (\ j_a13D -> matsub m_a13A (i_a13B, j_a13D))
  where (_, (norecord@n_a13C)) = boundmat m_a13A
col m_a13E j_a13F
  = makevec n_a13G (\ i_a13H -> matsub m_a13E (i_a13H, j_a13F))
  where (norecord@((norecord@n_a13G), (norecord@_)))
          = boundmat m_a13E
intchrow (!i_a13I) (!j_a13J) m_a13K
  = makemat (boundmat m_a13K)
      (\ (norecord@((!r_a13L), (!c_a13M))) ->
         if (r_a13L == i_a13I) then matsub m_a13K (j_a13J, c_a13M) else
           if (r_a13L == j_a13J) then matsub m_a13K (i_a13I, c_a13M) else
             matsub m_a13K (r_a13L, c_a13M))
intchcol (!i_a13N) (!j_a13O) (norecord@m_a13P)
  = makemat (boundmat m_a13P)
      (\ (norecord@((!r_a13Q), (!c_a13R))) ->
         if (c_a13R == i_a13N) then matsub m_a13P (r_a13Q, j_a13O) else
           if (c_a13R == j_a13O) then matsub m_a13P (r_a13Q, i_a13N) else
             matsub m_a13P (r_a13Q, c_a13R))
interchmat ((!i1_a13S), j1_a13T) (i2_a13U, (!j2_a13V)) m_a13W
  = makemat (boundmat m_a13W)
      (\ (norecord@((!i_a13X), j_a13Y)) ->
         if (i_a13X, j_a13Y) == (i1_a13S, j1_a13T) then
           matsub m_a13W (i2_a13U, j2_a13V) else
           if (i_a13X, j_a13Y) == (i2_a13U, j2_a13V) then
             matsub m_a13W (i1_a13S, j1_a13T) else
             matsub m_a13W (i_a13X, j_a13Y))
displaymat m_a13Z
  = "<\n" ++
      concat [displayvec (row m_a13Z i_a141) | i_a141 <- [1 .. nr_a140]]
      ++ ">\n"
  where (nr_a140, (norecord@_)) = boundmat m_a13Z

data Mat a_aok = MAT (Int, Int) (Vec a_aok)

==================== Renamer ====================
DB_interface.nnode, DB_interface.nelem, DB_interface.nmats, DB_interface.nplds ::
  (Array Int Int, Array Int Float) -> Int
DB_interface.nnode ((!idb_aw4), rdb_aw5) = idb_aw4 ! 0
DB_interface.nelem (!((!idb_aw6), (!rdb_aw7))) = idb_aw6 ! 1
DB_interface.nmats (idb_aw8, rdb_aw9) = idb_aw8 ! 2
DB_interface.nplds ((!idb_awa), (!rdb_awb)) = idb_awa ! 3
DB_interface.getnxy ::
  (Array Int Int, Array Int Float) -> Int -> (Float, Float)
DB_interface.getnxy (idb_awc, rdb_awd) node_awe
  = (x_awf, y_awg)
  where
      x_awf = rdb_awd ! index_awh
      (!y_awg) = rdb_awd ! (index_awh + 1)
      index_awh = (node_awe - 1) * 2
DB_interface.getnbc ::
  (Array Int Int, Array Int Float) -> Int -> Int
DB_interface.getnbc (!((!idb_axf), rdb_axg)) node_axh
  = idb_axf ! (3 + node_axh)
DB_interface.getmpro ::
  (Array Int Int, Array Int Float) -> Int -> (Float, Float)
DB_interface.getmpro ((!idb_axi), (!rdb_axj)) (!material_axk)
  = (ea_axl, ei_axm)
  where
      ea_axl = rdb_axj ! index_axn
      (!ei_axm) = rdb_axj ! (index_axn + 1)
      (!index_axn)
        = (DB_interface.nnode (idb_axi, rdb_axj)) * 2
          + (material_axk - 1) * 2
DB_interface.getenlr ::
  (Array Int Int, Array Int Float) -> Int -> (Int, Int)
DB_interface.getenlr (idb_axo, rdb_axp) (!element_axq)
  = (nodel_axr, noder_axs)
  where
      nodel_axr = idb_axo ! index_axt
      (!noder_axs) = idb_axo ! (index_axt + 1)
      index_axt
        = 4 + (DB_interface.nnode (idb_axo, rdb_axp))
          + (element_axq - 1) * 3
DB_interface.getemat ::
  (Array Int Int, Array Int Float) -> Int -> Int
DB_interface.getemat (idb_axu, (!rdb_axv)) element_axw
  = idb_axu
    ! (3 + (DB_interface.nnode (idb_axu, rdb_axv)) + element_axw * 3)
DB_interface.getpld ::
  (Array Int Int, Array Int Float)
  -> Int -> (Int, Float, Float, Float)
DB_interface.getpld ((!idb_axx), rdb_axy) (!j_axz)
  = (to_node_axA, px_axB, py_axC, m_axD)
  where
      to_node_axA = idb_axx ! indexi_axE
      px_axB = rdb_axy ! (indexr_axF)
      py_axC = rdb_axy ! (indexr_axF + 1)
      (!m_axD) = rdb_axy ! (indexr_axF + 2)
      indexi_axE = 4 + nnodes_axG + nelems_axH * 3 + (j_axz - 1)
      (!indexr_axF) = nnodes_axG * 2 + nmatss_axI * 2 + (j_axz - 1) * 3
      (!nnodes_axG) = DB_interface.nnode (idb_axx, rdb_axy)
      nelems_axH = DB_interface.nelem (idb_axx, rdb_axy)
      (!nmatss_axI) = DB_interface.nmats (idb_axx, rdb_axy)


["idb_aw4","!idb_aw4","(!idb_aw4)","rdb_aw5","((!idb_aw4), rdb_aw5)","idb_aw6","!idb_aw6","(!idb_aw6)","rdb_aw7","!rdb_aw7","(!rdb_aw7)","((!idb_aw6), (!rdb_aw7))","!((!idb_aw6), (!rdb_aw7))","(!((!idb_aw6), (!rdb_aw7)))","idb_aw8","rdb_aw9","(idb_aw8, rdb_aw9)","idb_awa","!idb_awa","(!idb_awa)","rdb_awb","!rdb_awb","(!rdb_awb)","((!idb_awa), (!rdb_awb))","idb_awc","rdb_awd","(idb_awc, rdb_awd)","node_awe","x_awf","y_awg","!y_awg","(!y_awg)","index_awh","idb_axf","!idb_axf","(!idb_axf)","rdb_axg","((!idb_axf), rdb_axg)","!((!idb_axf), rdb_axg)","(!((!idb_axf), rdb_axg))","node_axh","idb_axi","!idb_axi","(!idb_axi)","rdb_axj","!rdb_axj","(!rdb_axj)","((!idb_axi), (!rdb_axj))","material_axk","safebang@!material_axk","(!material_axk)","ea_axl","ei_axm","!ei_axm","(!ei_axm)","index_axn","!index_axn","(!index_axn)","idb_axo","rdb_axp","(idb_axo, rdb_axp)","element_axq","safebang@!element_axq","(!element_axq)","nodel_axr","noder_axs","!noder_axs","(!noder_axs)","index_axt","idb_axu","rdb_axv","!rdb_axv","(!rdb_axv)","(idb_axu, (!rdb_axv))","element_axw","idb_axx","!idb_axx","(!idb_axx)","rdb_axy","((!idb_axx), rdb_axy)","j_axz","safebang@!j_axz","(!j_axz)","to_node_axA","px_axB","py_axC","m_axD","!m_axD","(!m_axD)","indexi_axE","indexr_axF","!indexr_axF","(!indexr_axF)","nnodes_axG","!nnodes_axG","(!nnodes_axG)","nelems_axH","nmatss_axI","!nmatss_axI","(!nmatss_axI)"]
module DB_interface
       (nnode, nmats, getnxy, getnbc, getmpro, nelem, nplds, getenlr,
        getemat, getpld)
       where
import Data.Array
import Database

nnode, nelem, nmats, nplds ::
       (Array Int Int, Array Int Float) -> Int
nnode ((norecord@idb_aw4), rdb_aw5) = idb_aw4 ! 0
nelem (norecord@((norecord@idb_aw6), (norecord@rdb_aw7)))
  = idb_aw6 ! 1
nmats (idb_aw8, rdb_aw9) = idb_aw8 ! 2
nplds ((norecord@idb_awa), (norecord@rdb_awb)) = idb_awa ! 3

getnxy :: (Array Int Int, Array Int Float) -> Int -> (Float, Float)
getnxy (idb_awc, rdb_awd) node_awe = (x_awf, y_awg)
  where x_awf = rdb_awd ! index_awh
        (norecord@y_awg) = rdb_awd ! (index_awh + 1)
        index_awh = (node_awe - 1) * 2

getnbc :: (Array Int Int, Array Int Float) -> Int -> Int
getnbc (norecord@((norecord@idb_axf), rdb_axg)) node_axh
  = idb_axf ! (3 + node_axh)

getmpro ::
        (Array Int Int, Array Int Float) -> Int -> (Float, Float)
getmpro ((norecord@idb_axi), (norecord@rdb_axj)) (!material_axk)
  = (ea_axl, ei_axm)
  where ea_axl = rdb_axj ! index_axn
        (norecord@ei_axm) = rdb_axj ! (index_axn + 1)
        (norecord@index_axn)
          = (nnode (idb_axi, rdb_axj)) * 2 + (material_axk - 1) * 2

getenlr :: (Array Int Int, Array Int Float) -> Int -> (Int, Int)
getenlr (idb_axo, rdb_axp) (!element_axq) = (nodel_axr, noder_axs)
  where nodel_axr = idb_axo ! index_axt
        (norecord@noder_axs) = idb_axo ! (index_axt + 1)
        index_axt = 4 + (nnode (idb_axo, rdb_axp)) + (element_axq - 1) * 3

getemat :: (Array Int Int, Array Int Float) -> Int -> Int
getemat (idb_axu, (norecord@rdb_axv)) element_axw
  = idb_axu ! (3 + (nnode (idb_axu, rdb_axv)) + element_axw * 3)

getpld ::
       (Array Int Int, Array Int Float) ->
         Int -> (Int, Float, Float, Float)
getpld ((norecord@idb_axx), rdb_axy) (!j_axz)
  = (to_node_axA, px_axB, py_axC, m_axD)
  where to_node_axA = idb_axx ! indexi_axE
        px_axB = rdb_axy ! (indexr_axF)
        py_axC = rdb_axy ! (indexr_axF + 1)
        (norecord@m_axD) = rdb_axy ! (indexr_axF + 2)
        indexi_axE = 4 + nnodes_axG + nelems_axH * 3 + (j_axz - 1)
        (norecord@indexr_axF)
          = nnodes_axG * 2 + nmatss_axI * 2 + (j_axz - 1) * 3
        (norecord@nnodes_axG) = nnode (idb_axx, rdb_axy)
        nelems_axH = nelem (idb_axx, rdb_axy)
        (norecord@nmatss_axI) = nmats (idb_axx, rdb_axy)

==================== Renamer ====================
Assemble_stiffness.kdd ::
  (Array Int Int, Array Int Float) -> Vbm Float
Assemble_stiffness.kdd (!s_azG)
  = incrvbmat initial_value_azH index_value_assoc_s_azI
  where
      initial_value_azH
        = makevbmat (ndgrs s_azG) (diagadr s_azG) (\ i_azJ -> 0.0)
      (!index_value_assoc_s_azI)
        = Assemble_stiffness.index_value_assoc s_azG
Assemble_stiffness.index_value_assoc (!s_azK)
  = foldl assemble_s_azL [] [1 .. (nelem s_azK)]
  where
      (!assemble_s_azL) = Assemble_stiffness.assemble s_azK
Assemble_stiffness.assemble s_aFL till_now_dd_aFM element_aFN
  = (till_now_dd_aFM ++ dd_this'_aFO)
  where
      (!dd_this'_aFO)
        = [((f_aFY i_aGW, f_aFY j_aGX), x_aFX i_aGW j_aGX) |
             (!i_aGW) <- [0 .. n_aFW - 1],
             j_aGX <- [0 .. i_aGW],
             f_aFY i_aGW > 0,
             f_aFY j_aGX > 0]
      dgrs_list_aFP
        = (dgrs_list_node_aFS nodel_aFQ) ++ (dgrs_list_node_aFS noder_aFR)
      (nodel_aFQ, noder_aFR) = getenlr s_aFL element_aFN
      dgrs_list_node_aFS node_aTT = getndgr s_aFL node_aTT
      (!eindex_dgrs_list_aFT) = zip [1 .. 6] dgrs_list_aFP
      aindex_dgrs_list_aFU = filter valid_index_aFV eindex_dgrs_list_aFT
      valid_index_aFV (!((!i_aXi), dgr_aXj)) = (dgr_aXj /= 0)
      n_aFW = length aindex_dgrs_list_aFU
      x_aFX (!i_aXk) (!j_aXl)
        = matsub
            (beam2d s_aFL element_aFN)
            (fst (aindex_dgrs_list_aFU !! i_aXk), 
             fst (aindex_dgrs_list_aFU !! j_aXl))
      f_aFY i_aXs = (snd (aindex_dgrs_list_aFU !! i_aXs))


["s_azG","!s_azG","(!s_azG)","initial_value_azH","i_azJ","index_value_assoc_s_azI","safebang@!index_value_assoc_s_azI","(!index_value_assoc_s_azI)","s_azK","!s_azK","(!s_azK)","assemble_s_azL","!assemble_s_azL","(!assemble_s_azL)","s_aFL","till_now_dd_aFM","element_aFN","dd_this'_aFO","lazydmd@!dd_this'_aFO","(!dd_this'_aFO)","i_aGW","!i_aGW","(!i_aGW)","j_aGX","dgrs_list_aFP","nodel_aFQ","noder_aFR","(nodel_aFQ, noder_aFR)","node_aTT","eindex_dgrs_list_aFT","safebang@!eindex_dgrs_list_aFT","(!eindex_dgrs_list_aFT)","aindex_dgrs_list_aFU","i_aXi","safebang@!i_aXi","(!i_aXi)","dgr_aXj","((!i_aXi), dgr_aXj)","!((!i_aXi), dgr_aXj)","(!((!i_aXi), dgr_aXj))","n_aFW","i_aXk","!i_aXk","(!i_aXk)","j_aXl","!j_aXl","(!j_aXl)","i_aXs"]
module Assemble_stiffness (kdd) where
import Basics
import Vector
import Matrix
import VBmatrix
import DB_interface
import Degrees
import Pre_assemble
import Elemstif

kdd :: (Array Int Int, Array Int Float) -> Vbm Float
kdd (norecord@s_azG)
  = incrvbmat initial_value_azH index_value_assoc_s_azI
  where initial_value_azH
          = makevbmat (ndgrs s_azG) (diagadr s_azG) (\ i_azJ -> 0.0)
        (!index_value_assoc_s_azI) = index_value_assoc s_azG
index_value_assoc (norecord@s_azK)
  = foldl assemble_s_azL [] [1 .. (nelem s_azK)]
  where (norecord@assemble_s_azL) = assemble s_azK
assemble s_aFL till_now_dd_aFM element_aFN
  = (till_now_dd_aFM ++ dd_this'_aFO)
  where (lazydmd@dd_this'_aFO)
          = [((f_aFY i_aGW, f_aFY j_aGX), x_aFX i_aGW j_aGX) |
             (norecord@i_aGW) <- [0 .. n_aFW - 1], j_aGX <- [0 .. i_aGW],
             f_aFY i_aGW > 0, f_aFY j_aGX > 0]
        dgrs_list_aFP
          = (dgrs_list_node_aFS nodel_aFQ) ++ (dgrs_list_node_aFS noder_aFR)
        (nodel_aFQ, noder_aFR) = getenlr s_aFL element_aFN
        dgrs_list_node_aFS node_aTT = getndgr s_aFL node_aTT
        (!eindex_dgrs_list_aFT) = zip [1 .. 6] dgrs_list_aFP
        aindex_dgrs_list_aFU = filter valid_index_aFV eindex_dgrs_list_aFT
        valid_index_aFV (norecord@((!i_aXi), dgr_aXj)) = (dgr_aXj /= 0)
        n_aFW = length aindex_dgrs_list_aFU
        x_aFX (norecord@i_aXk) (norecord@j_aXl)
          = matsub (beam2d s_aFL element_aFN)
              (fst (aindex_dgrs_list_aFU !! i_aXk),
               fst (aindex_dgrs_list_aFU !! j_aXl))
        f_aFY i_aXs = (snd (aindex_dgrs_list_aFU !! i_aXs))

==================== Renamer ====================
PrintSource.source_data ::
  (Array Int Int, Array Int Float) -> [Char]
PrintSource.source_data (!db_ax4)
  = PrintSource.control_data db_ax4
    ++
      PrintSource.node_data db_ax4
      ++
        PrintSource.material_data db_ax4
        ++ PrintSource.elements db_ax4 ++ PrintSource.plds db_ax4
PrintSource.control_data db_ax5
  = "\n\
    \\n\
    \\n\
    \CONTROL DATA :\n\
    \\n"
    ++
      "   Total number of nodes = "
      ++
        (showlj 3 (nnode db_ax5))
        ++
          "\n"
          ++
            "   Number of elements    = "
            ++
              (showlj 3 (nelem db_ax5))
              ++
                "\n"
                ++
                  "   Number of point loads = "
                  ++
                    (showlj 3 (nplds db_ax5))
                    ++
                      "\n"
                      ++
                        "   Total number of materials = "
                        ++
                          (showlj 3 (nmats db_ax5))
                          ++
                            "\n\
                            \\n\
                            \\n"
PrintSource.node_data db_ax6
  = "NODE INFORMATION  :\n\
    \\n"
    ++
      (concat (map a_node_s_ax7 [1 .. (nnode db_ax6)]))
      ++
        "\n\
        \\n"
  where
      (!a_node_s_ax7) = PrintSource.a_node db_ax6
PrintSource.a_node (!db_aD7) (!node_aD8)
  = "  Node.no = "
    ++
      (showlj 3 node_aD8)
      ++
        "   x = "
        ++
          (showlj 8 x_aD9)
          ++
            "   y = "
            ++ (showlj 8 y_aDa) ++ "   bc = " ++ (showlj 3 bc_aDb) ++ "\n"
  where
      (x_aD9, y_aDa) = getnxy db_aD7 node_aD8
      (!bc_aDb) = getnbc db_aD7 node_aD8
PrintSource.material_data (!db_aDc)
  = "MATERIAL INFORMATION :\n\
    \\n"
    ++ (concat (map a_material_s_aDd [1 .. (nmats db_aDc)]))
  where
      a_material_s_aDd = PrintSource.a_material db_aDc
PrintSource.a_material db_aDe material_aDf
  = "  Material No.="
    ++
      (showlj 3 material_aDf)
      ++
        "   EA = "
        ++ (showlj 8 ea_aDg) ++ "   EI = " ++ (showlj 8 ei_aDh) ++ "\n"
  where
      (ea_aDg, ei_aDh) = getmpro db_aDe material_aDf
PrintSource.elements (!db_aDi)
  = "\n\
    \ELEMENT DATA:\n\
    \\n"
    ++
      (concat (map (a_element_s_aDj) [1 .. (nelem db_aDi)]))
      ++
        "\n\
        \\n"
  where
      a_element_s_aDj = PrintSource.a_element db_aDi
PrintSource.a_element (!db_aDk) element_aDl
  = "  Element No.="
    ++
      (showlj 3 element_aDl)
      ++
        "   Node.L ="
        ++
          (showlj 3 nodel_aDm)
          ++
            "   Node.R ="
            ++
              (showlj 3 noder_aDn)
              ++ "   Material No. =" ++ (showlj 3 material_aDo) ++ "\n"
  where
      (!((!nodel_aDm), noder_aDn)) = getenlr db_aDk element_aDl
      (!material_aDo) = getemat db_aDk element_aDl
PrintSource.plds db_aDp
  = "\n\
    \POINT LOADS DATA:\n\
    \\n"
    ++
      (concat (map (a_load_s_aDq) [1 .. (nplds db_aDp)]))
      ++
        "\n\
        \\n"
  where
      (!a_load_s_aDq) = PrintSource.a_load db_aDp
PrintSource.a_load db_aDr (!n_aDs)
  = "  To_point No."
    ++
      (showlj 3 to_point_aDt)
      ++
        "  Px = "
        ++
          (showlj 9 px_aDu)
          ++
            "  Py = "
            ++ (showlj 9 py_aDv) ++ "  M = " ++ (showlj 9 m_aDw) ++ "\n"
  where
      (!((!to_point_aDt), px_aDu, py_aDv, m_aDw)) = getpld db_aDr n_aDs


["db_ax4","safebang@!db_ax4","(!db_ax4)","db_ax5","db_ax6","a_node_s_ax7","!a_node_s_ax7","(!a_node_s_ax7)","db_aD7","!db_aD7","(!db_aD7)","node_aD8","!node_aD8","(!node_aD8)","x_aD9","y_aDa","(x_aD9, y_aDa)","bc_aDb","!bc_aDb","(!bc_aDb)","db_aDc","!db_aDc","(!db_aDc)","a_material_s_aDd","db_aDe","material_aDf","ea_aDg","ei_aDh","(ea_aDg, ei_aDh)","db_aDi","!db_aDi","(!db_aDi)","a_element_s_aDj","db_aDk","!db_aDk","(!db_aDk)","element_aDl","nodel_aDm","!nodel_aDm","(!nodel_aDm)","noder_aDn","((!nodel_aDm), noder_aDn)","!((!nodel_aDm), noder_aDn)","(!((!nodel_aDm), noder_aDn))","material_aDo","!material_aDo","(!material_aDo)","db_aDp","a_load_s_aDq","!a_load_s_aDq","(!a_load_s_aDq)","db_aDr","n_aDs","!n_aDs","(!n_aDs)","to_point_aDt","!to_point_aDt","(!to_point_aDt)","px_aDu","py_aDv","m_aDw","((!to_point_aDt), px_aDu, py_aDv, m_aDw)","!((!to_point_aDt), px_aDu, py_aDv, m_aDw)","(!((!to_point_aDt), px_aDu, py_aDv, m_aDw))"]
module PrintSource (source_data) where
import Database
import DB_interface
import Basics

source_data :: (Array Int Int, Array Int Float) -> [Char]
source_data (!db_ax4)
  = control_data db_ax4 ++ node_data db_ax4 ++ material_data db_ax4
      ++ elements db_ax4
      ++ plds db_ax4
control_data db_ax5
  = "\n\n\nCONTROL DATA :\n\n" ++ "   Total number of nodes = " ++
      (showlj 3 (nnode db_ax5))
      ++ "\n"
      ++ "   Number of elements    = "
      ++ (showlj 3 (nelem db_ax5))
      ++ "\n"
      ++ "   Number of point loads = "
      ++ (showlj 3 (nplds db_ax5))
      ++ "\n"
      ++ "   Total number of materials = "
      ++ (showlj 3 (nmats db_ax5))
      ++ "\n\n\n"
node_data db_ax6
  = "NODE INFORMATION  :\n\n" ++
      (concat (map a_node_s_ax7 [1 .. (nnode db_ax6)]))
      ++ "\n\n"
  where (norecord@a_node_s_ax7) = a_node db_ax6
a_node (norecord@db_aD7) (norecord@node_aD8)
  = "  Node.no = " ++ (showlj 3 node_aD8) ++ "   x = " ++
      (showlj 8 x_aD9)
      ++ "   y = "
      ++ (showlj 8 y_aDa)
      ++ "   bc = "
      ++ (showlj 3 bc_aDb)
      ++ "\n"
  where (x_aD9, y_aDa) = getnxy db_aD7 node_aD8
        (norecord@bc_aDb) = getnbc db_aD7 node_aD8
material_data (norecord@db_aDc)
  = "MATERIAL INFORMATION :\n\n" ++
      (concat (map a_material_s_aDd [1 .. (nmats db_aDc)]))
  where a_material_s_aDd = a_material db_aDc
a_material db_aDe material_aDf
  = "  Material No.=" ++ (showlj 3 material_aDf) ++ "   EA = " ++
      (showlj 8 ea_aDg)
      ++ "   EI = "
      ++ (showlj 8 ei_aDh)
      ++ "\n"
  where (ea_aDg, ei_aDh) = getmpro db_aDe material_aDf
elements (norecord@db_aDi)
  = "\nELEMENT DATA:\n\n" ++
      (concat (map (a_element_s_aDj) [1 .. (nelem db_aDi)]))
      ++ "\n\n"
  where a_element_s_aDj = a_element db_aDi
a_element (norecord@db_aDk) element_aDl
  = "  Element No.=" ++ (showlj 3 element_aDl) ++ "   Node.L =" ++
      (showlj 3 nodel_aDm)
      ++ "   Node.R ="
      ++ (showlj 3 noder_aDn)
      ++ "   Material No. ="
      ++ (showlj 3 material_aDo)
      ++ "\n"
  where (norecord@((norecord@nodel_aDm), noder_aDn))
          = getenlr db_aDk element_aDl
        (norecord@material_aDo) = getemat db_aDk element_aDl
plds db_aDp
  = "\nPOINT LOADS DATA:\n\n" ++
      (concat (map (a_load_s_aDq) [1 .. (nplds db_aDp)]))
      ++ "\n\n"
  where (norecord@a_load_s_aDq) = a_load db_aDp
a_load db_aDr (norecord@n_aDs)
  = "  To_point No." ++ (showlj 3 to_point_aDt) ++ "  Px = " ++
      (showlj 9 px_aDu)
      ++ "  Py = "
      ++ (showlj 9 py_aDv)
      ++ "  M = "
      ++ (showlj 9 m_aDw)
      ++ "\n"
  where (norecord@((norecord@to_point_aDt), px_aDu, py_aDv, m_aDw))
          = getpld db_aDr n_aDs

==================== Renamer ====================
Pre_assemble.diagadr :: (Array Int Int, Array Int Float) -> Vec Int
Pre_assemble.diagadr (!s_axM)
  = v_axN
  where
      v_axN = makevec bound_axO f_axP
      bound_axO = boundvec (bandvec_s_axQ)
      f_axP (!i_axR)
        = if (i_axR == 1) then
              1
          else
              vecsub v_axN (i_axR - 1) + vecsub bandvec_s_axQ i_axR
      (!bandvec_s_axQ) = Pre_assemble.bandvec s_axM
Pre_assemble.bandvec (!s_aLK)
  = maxupdvec
      initial_value_aLL
      (concat (map pre_assemble_s_aLM [1 .. (nelem s_aLK)]))
  where
      initial_value_aLL = makevec (ndgrs s_aLK) (\ i_aLN -> 0)
      pre_assemble_s_aLM = Pre_assemble.pre_assemble s_aLK
Pre_assemble.pre_assemble (!s_aRN) (!element_aRO)
  = azip dgrs_list_aRQ (map f_aRP dgrs_list_aRQ)
  where
      f_aRP x_aRU = x_aRU - (head dgrs_list_aRQ) + 1
      dgrs_list_aRQ
        = (dgrs_list_node_aRT nodel_aRR) ++ (dgrs_list_node_aRT noder_aRS)
      (nodel_aRR, noder_aRS) = getenlr s_aRN element_aRO
      dgrs_list_node_aRT node_aVk
        = filter (\ (!x_aVl) -> x_aVl /= 0) (getndgr s_aRN node_aVk)
Pre_assemble.diagadrrlt ::
  (Array Int Int, Array Int Float) -> [Char]
Pre_assemble.diagadrrlt s_aVm
  = "DIAGONAL ADDRESS VECTOR=\n"
    ++ displayvec (Pre_assemble.diagadr s_aVm)


["s_axM","!s_axM","(!s_axM)","v_axN","bound_axO","i_axR","!i_axR","(!i_axR)","bandvec_s_axQ","!bandvec_s_axQ","(!bandvec_s_axQ)","s_aLK","!s_aLK","(!s_aLK)","initial_value_aLL","i_aLN","pre_assemble_s_aLM","s_aRN","!s_aRN","(!s_aRN)","element_aRO","!element_aRO","(!element_aRO)","x_aRU","dgrs_list_aRQ","nodel_aRR","noder_aRS","(nodel_aRR, noder_aRS)","node_aVk","x_aVl","!x_aVl","(!x_aVl)","s_aVm"]
module Pre_assemble (diagadr, diagadrrlt) where
import Basics
import Vector
import DB_interface
import Degrees

diagadr :: (Array Int Int, Array Int Float) -> Vec Int
diagadr (norecord@s_axM) = v_axN
  where v_axN = makevec bound_axO f_axP
        bound_axO = boundvec (bandvec_s_axQ)
        f_axP (norecord@i_axR)
          = if (i_axR == 1) then 1 else
              vecsub v_axN (i_axR - 1) + vecsub bandvec_s_axQ i_axR
        (norecord@bandvec_s_axQ) = bandvec s_axM
bandvec (norecord@s_aLK)
  = maxupdvec initial_value_aLL
      (concat (map pre_assemble_s_aLM [1 .. (nelem s_aLK)]))
  where initial_value_aLL = makevec (ndgrs s_aLK) (\ i_aLN -> 0)
        pre_assemble_s_aLM = pre_assemble s_aLK
pre_assemble (norecord@s_aRN) (norecord@element_aRO)
  = azip dgrs_list_aRQ (map f_aRP dgrs_list_aRQ)
  where f_aRP x_aRU = x_aRU - (head dgrs_list_aRQ) + 1
        dgrs_list_aRQ
          = (dgrs_list_node_aRT nodel_aRR) ++ (dgrs_list_node_aRT noder_aRS)
        (nodel_aRR, noder_aRS) = getenlr s_aRN element_aRO
        dgrs_list_node_aRT node_aVk
          = filter (\ (norecord@x_aVl) -> x_aVl /= 0)
              (getndgr s_aRN node_aVk)

diagadrrlt :: (Array Int Int, Array Int Float) -> [Char]
diagadrrlt s_aVm
  = "DIAGONAL ADDRESS VECTOR=\n" ++ displayvec (diagadr s_aVm)

==================== Renamer ====================
Database.idatabase :: [Char] -> Array Int Int
Database.idatabase (!s_aDH)
  = listArray (0, n_aDJ - 1) il_aDI
  where
      il_aDI = Database.isource s_aDH
      n_aDJ = length il_aDI
Database.rdatabase :: [Char] -> Array Int Float
Database.rdatabase (!s_aKG)
  = listArray (0, n_aKI - 1) rl_aKH
  where
      (!rl_aKH) = Database.rsource s_aKG
      (!n_aKI) = length rl_aKH
Database.isource :: [Char] -> [Int]
Database.isource s_aKJ = fst (Database.irsource s_aKJ)
Database.rsource :: [Char] -> [Float]
Database.rsource s_aKQ = snd (Database.irsource s_aKQ)
Database.irsource s_aKR = Database.intreal (words s_aKR)
Database.intreal (![]) = ([], [])
Database.intreal ((!x_aO9) : ls_aOa)
  = if (elem '.' x_aO9) then
        (idb_aOb, (Database.realreal x_aO9) : rdb_aOc)
    else
        ((Database.intint x_aO9) : idb_aOb, rdb_aOc)
  where
      (idb_aOb, rdb_aOc) = Database.intreal ls_aOa
Database.intint :: [Char] -> Int
Database.intint ((!((!c_aOd) : x_aOe)))
  = if (c_aOd == '-') then
        (- 1) * (Database.stoi x_aOe)
    else
        if (c_aOd == '+') then
            Database.stoi x_aOe
        else
            Database.stoi (c_aOd : x_aOe)
Database.stoi :: [Char] -> Int
Database.stoi (!s_a119) = Database.stoi' (reverse s_a119)
Database.stoi' [] = 0
Database.stoi' (!((!c_a14o) : (!ls_a14p)))
  = (Database.stoi' ls_a14p) * 10 + Database.ctoi c_a14o
Database.ctoi c_a14q
  = if (c_a14q == '0') then
        0
    else
        if (c_a14q == '1') then
            1
        else
            if (c_a14q == '2') then
                2
            else
                if (c_a14q == '3') then
                    3
                else
                    if (c_a14q == '4') then
                        4
                    else
                        if (c_a14q == '5') then
                            5
                        else
                            if (c_a14q == '6') then
                                6
                            else
                                if (c_a14q == '7') then 7 else if (c_a14q == '8') then 8 else 9
Database.realreal :: [Char] -> Float
Database.realreal ((!c_a14r) : (!x_a14s))
  = if (c_a14r == '-') then
        (- 1.0) * (Database.stor x_a14s)
    else
        if (c_a14r == '+') then
            Database.stor x_a14s
        else
            Database.stor (c_a14r : x_a14s)
Database.stor :: [Char] -> Float
Database.stor s_a14t
  = (Database.intpart s_a14t) + (Database.floatpart s_a14t)
Database.intpart :: [Char] -> Float
Database.intpart (!x_a14u)
  = Database.intpart' (takeWhile isDigit x_a14u)
Database.intpart' :: [Char] -> Float
Database.intpart' s_a14R = Database.intparts (reverse s_a14R)
Database.intparts (![]) = 0.0
Database.intparts ((!(c_a14S : s_a14T)))
  = (Database.intparts s_a14T) * 10.0 + Database.intpartss c_a14S
Database.intpartss c_a14U
  = if (c_a14U == '0') then
        0.0
    else
        if (c_a14U == '1') then
            1.0
        else
            if (c_a14U == '2') then
                2.0
            else
                if (c_a14U == '3') then
                    3.0
                else
                    if (c_a14U == '4') then
                        4.0
                    else
                        if (c_a14U == '5') then
                            5.0
                        else
                            if (c_a14U == '6') then
                                6.0
                            else
                                if (c_a14U == '7') then
                                    7.0
                                else
                                    if (c_a14U == '8') then 8.0 else 9.0
Database.floatpart :: [Char] -> Float
Database.floatpart (!x_a14V)
  = Database.floatpart' (drop 1 (dropWhile isDigit x_a14V))
Database.floatpart' :: [Char] -> Float
Database.floatpart' s_a14W
  = (Database.intpart' s_a14W) / (Database.e10 (length s_a14W))
Database.e10 0 = 1.0
Database.e10 (!i_a1e2) = 10.0 * (Database.e10 (i_a1e2 - 1))


["s_aDH","safebang@!s_aDH","(!s_aDH)","il_aDI","n_aDJ","s_aKG","safebang@!s_aKG","(!s_aKG)","rl_aKH","safebang@!rl_aKH","(!rl_aKH)","n_aKI","!n_aKI","(!n_aKI)","s_aKJ","s_aKQ","s_aKR","[]","![]","(![])","x_aO9","safebang@!x_aO9","(!x_aO9)","ls_aOa","(!x_aO9) : ls_aOa","((!x_aO9) : ls_aOa)","idb_aOb","rdb_aOc","(idb_aOb, rdb_aOc)","c_aOd","!c_aOd","(!c_aOd)","x_aOe","(!c_aOd) : x_aOe","((!c_aOd) : x_aOe)","!((!c_aOd) : x_aOe)","(!((!c_aOd) : x_aOe))","((!((!c_aOd) : x_aOe)))","s_a119","!s_a119","(!s_a119)","[]","c_a14o","!c_a14o","(!c_a14o)","ls_a14p","safebang@!ls_a14p","(!ls_a14p)","(!c_a14o) : (!ls_a14p)","((!c_a14o) : (!ls_a14p))","!((!c_a14o) : (!ls_a14p))","(!((!c_a14o) : (!ls_a14p)))","c_a14q","c_a14r","!c_a14r","(!c_a14r)","x_a14s","safebang@!x_a14s","(!x_a14s)","(!c_a14r) : (!x_a14s)","((!c_a14r) : (!x_a14s))","s_a14t","x_a14u","!x_a14u","(!x_a14u)","s_a14R","[]","![]","(![])","c_a14S","s_a14T","c_a14S : s_a14T","(c_a14S : s_a14T)","!(c_a14S : s_a14T)","(!(c_a14S : s_a14T))","((!(c_a14S : s_a14T)))","c_a14U","x_a14V","!x_a14V","(!x_a14V)","s_a14W","0","i_a1e2","!i_a1e2","(!i_a1e2)"]
module Database (idatabase, rdatabase) where
import Data.Array
import Data.Char (isDigit)

idatabase :: [Char] -> Array Int Int
idatabase (!s_aDH) = listArray (0, n_aDJ - 1) il_aDI
  where il_aDI = isource s_aDH
        n_aDJ = length il_aDI

rdatabase :: [Char] -> Array Int Float
rdatabase (!s_aKG) = listArray (0, n_aKI - 1) rl_aKH
  where (!rl_aKH) = rsource s_aKG
        (norecord@n_aKI) = length rl_aKH

isource :: [Char] -> [Int]
isource s_aKJ = fst (irsource s_aKJ)

rsource :: [Char] -> [Float]
rsource s_aKQ = snd (irsource s_aKQ)
irsource s_aKR = intreal (words s_aKR)
intreal (norecord@[]) = ([], [])
intreal ((!x_aO9) : ls_aOa)
  = if (elem '.' x_aO9) then (idb_aOb, (realreal x_aO9) : rdb_aOc)
      else ((intint x_aO9) : idb_aOb, rdb_aOc)
  where (idb_aOb, rdb_aOc) = intreal ls_aOa

intint :: [Char] -> Int
intint ((norecord@((norecord@c_aOd) : x_aOe)))
  = if (c_aOd == '-') then (-1) * (stoi x_aOe) else
      if (c_aOd == '+') then stoi x_aOe else stoi (c_aOd : x_aOe)

stoi :: [Char] -> Int
stoi (norecord@s_a119) = stoi' (reverse s_a119)
stoi' [] = 0
stoi' (norecord@((norecord@c_a14o) : (!ls_a14p)))
  = (stoi' ls_a14p) * 10 + ctoi c_a14o
ctoi c_a14q
  = if (c_a14q == '0') then 0 else
      if (c_a14q == '1') then 1 else
        if (c_a14q == '2') then 2 else
          if (c_a14q == '3') then 3 else
            if (c_a14q == '4') then 4 else
              if (c_a14q == '5') then 5 else
                if (c_a14q == '6') then 6 else
                  if (c_a14q == '7') then 7 else if (c_a14q == '8') then 8 else 9

realreal :: [Char] -> Float
realreal ((norecord@c_a14r) : (!x_a14s))
  = if (c_a14r == '-') then (-1.0) * (stor x_a14s) else
      if (c_a14r == '+') then stor x_a14s else stor (c_a14r : x_a14s)

stor :: [Char] -> Float
stor s_a14t = (intpart s_a14t) + (floatpart s_a14t)

intpart :: [Char] -> Float
intpart (norecord@x_a14u) = intpart' (takeWhile isDigit x_a14u)

intpart' :: [Char] -> Float
intpart' s_a14R = intparts (reverse s_a14R)
intparts (norecord@[]) = 0.0
intparts ((norecord@(c_a14S : s_a14T)))
  = (intparts s_a14T) * 10.0 + intpartss c_a14S
intpartss c_a14U
  = if (c_a14U == '0') then 0.0 else
      if (c_a14U == '1') then 1.0 else
        if (c_a14U == '2') then 2.0 else
          if (c_a14U == '3') then 3.0 else
            if (c_a14U == '4') then 4.0 else
              if (c_a14U == '5') then 5.0 else
                if (c_a14U == '6') then 6.0 else
                  if (c_a14U == '7') then 7.0 else
                    if (c_a14U == '8') then 8.0 else 9.0

floatpart :: [Char] -> Float
floatpart (norecord@x_a14V)
  = floatpart' (drop 1 (dropWhile isDigit x_a14V))

floatpart' :: [Char] -> Float
floatpart' s_a14W = (intpart' s_a14W) / (e10 (length s_a14W))
e10 0 = 1.0
e10 (norecord@i_a1e2) = 10.0 * (e10 (i_a1e2 - 1))

==================== Renamer ====================
Elemforce.forces ::
  (Array Int Int, Array Int Float) -> Vec Float -> Vec Float
Elemforce.getefrc ::
  (Array Int Int, Array Int Float) -> Int -> Vec Float -> Float
Elemforce.forces (!db_axF) uvw_axG
  = makevec (nelem db_axF) force_2d_bar_s_axH
  where
      force_2d_bar_s_axH = Elemforce.force_2d_bar db_axF uvw_axG
Elemforce.getefrc (!db_axI) (!element_axJ) (!frc_axK)
  = vecsub frc_axK element_axJ
Elemforce.force_2d_bar db_axL uvw_axM element_axN
  = (ea_axQ / length_ay0)
    * ((ur_ay4 - ul_ay1) * c_axW + (vr_ay5 - vl_ay2) * s_axX)
  where
      ((!nodel_axO), (!noder_axP)) = getenlr db_axL element_axN
      (ea_axQ, ei_axR) = getmpro db_axL (getemat db_axL element_axN)
      (!(xl_axS, yl_axT)) = getnxy db_axL nodel_axO
      (xr_axU, (!yr_axV)) = getnxy db_axL noder_axP
      (!c_axW) = det_x_axY / length_ay0
      s_axX = det_y_axZ / length_ay0
      (!det_x_axY) = xr_axU - xl_axS
      (!det_y_axZ) = yr_axV - yl_axT
      length_ay0 = sqrt (det_x_axY * det_x_axY + det_y_axZ * det_y_axZ)
      (!((!ul_ay1), vl_ay2, (!thetal_ay3)))
        = getnuvw db_axL nodel_axO uvw_axM
      (!(ur_ay4, vr_ay5, thetar_ay6)) = getnuvw db_axL noder_axP uvw_axM


["db_axF","!db_axF","(!db_axF)","uvw_axG","force_2d_bar_s_axH","db_axI","safebang@!db_axI","(!db_axI)","element_axJ","safebang@!element_axJ","(!element_axJ)","frc_axK","!frc_axK","(!frc_axK)","db_axL","uvw_axM","element_axN","nodel_axO","!nodel_axO","(!nodel_axO)","noder_axP","!noder_axP","(!noder_axP)","((!nodel_axO), (!noder_axP))","ea_axQ","ei_axR","(ea_axQ, ei_axR)","xl_axS","yl_axT","(xl_axS, yl_axT)","!(xl_axS, yl_axT)","(!(xl_axS, yl_axT))","xr_axU","yr_axV","!yr_axV","(!yr_axV)","(xr_axU, (!yr_axV))","c_axW","!c_axW","(!c_axW)","s_axX","det_x_axY","!det_x_axY","(!det_x_axY)","det_y_axZ","!det_y_axZ","(!det_y_axZ)","length_ay0","ul_ay1","!ul_ay1","(!ul_ay1)","vl_ay2","thetal_ay3","!thetal_ay3","(!thetal_ay3)","((!ul_ay1), vl_ay2, (!thetal_ay3))","!((!ul_ay1), vl_ay2, (!thetal_ay3))","(!((!ul_ay1), vl_ay2, (!thetal_ay3)))","ur_ay4","vr_ay5","thetar_ay6","(ur_ay4, vr_ay5, thetar_ay6)","!(ur_ay4, vr_ay5, thetar_ay6)","(!(ur_ay4, vr_ay5, thetar_ay6))"]
module Elemforce (forces, getefrc) where
import Basics
import Vector
import DB_interface
import Displacement

forces ::
       (Array Int Int, Array Int Float) -> Vec Float -> Vec Float

getefrc ::
        (Array Int Int, Array Int Float) -> Int -> Vec Float -> Float
forces (norecord@db_axF) uvw_axG
  = makevec (nelem db_axF) force_2d_bar_s_axH
  where force_2d_bar_s_axH = force_2d_bar db_axF uvw_axG
getefrc (!db_axI) (!element_axJ) (norecord@frc_axK)
  = vecsub frc_axK element_axJ
force_2d_bar db_axL uvw_axM element_axN
  = (ea_axQ / length_ay0) *
      ((ur_ay4 - ul_ay1) * c_axW + (vr_ay5 - vl_ay2) * s_axX)
  where ((norecord@nodel_axO), (norecord@noder_axP))
          = getenlr db_axL element_axN
        (ea_axQ, ei_axR) = getmpro db_axL (getemat db_axL element_axN)
        (norecord@(xl_axS, yl_axT)) = getnxy db_axL nodel_axO
        (xr_axU, (norecord@yr_axV)) = getnxy db_axL noder_axP
        (norecord@c_axW) = det_x_axY / length_ay0
        s_axX = det_y_axZ / length_ay0
        (norecord@det_x_axY) = xr_axU - xl_axS
        (norecord@det_y_axZ) = yr_axV - yl_axT
        length_ay0 = sqrt (det_x_axY * det_x_axY + det_y_axZ * det_y_axZ)
        (norecord@((norecord@ul_ay1), vl_ay2, (norecord@thetal_ay3)))
          = getnuvw db_axL nodel_axO uvw_axM
        (norecord@(ur_ay4, vr_ay5, thetar_ay6))
          = getnuvw db_axL noder_axP uvw_axM

==================== Renamer ====================
Printuvwforce.uvwresult ::
  (Array Int Int, Array Int Float) -> Vec Float -> [Char]
Printuvwforce.forceresult ::
  (Array Int Int, Array Int Float) -> Vec Float -> [Char]
Printuvwforce.uvwresult (!s_axM) uvw_axN
  = "\n\
    \\n\
    \DISPLACEMENT OF THE STRUCTURE \n\
    \\n"
    ++
      "     Node     X     Y     BC         U             V"
      ++
        "                  Theta\n"
        ++ (concat (map a_node_s_axO [1 .. (nnode s_axM)]))
  where
      a_node_s_axO = Printuvwforce.a_node s_axM uvw_axN
Printuvwforce.a_node (!s_aDO) (!uvw_aDP) (!node_aDQ)
  = (showrj 8 node_aDQ)
    ++
      (showrj 7 x_aDR)
      ++
        (showrj 6 y_aDS)
        ++
          (showrj 7 bc_aDT)
          ++
            (showrj 15 u_aDU)
            ++ (showrj 15 v_aDV) ++ (showrj 15 theta_aDW) ++ "\n"
  where
      (x_aDR, y_aDS) = getnxy s_aDO node_aDQ
      (!bc_aDT) = getnbc s_aDO node_aDQ
      ((!u_aDU), v_aDV, theta_aDW) = getnuvw s_aDO node_aDQ uvw_aDP
Printuvwforce.forceresult s_aDX frc_aDY
  = "\n\
    \\n\
    \\n\
    \INTERNAL FORCES OF ELEMENT "
    ++
      "\n\
      \\n"
      ++
        "    Element    NodeL   NodeR     TENSION\n"
        ++ concat (map a_element_s_aDZ [1 .. (nelem s_aDX)])
  where
      a_element_s_aDZ = Printuvwforce.a_element s_aDX frc_aDY
Printuvwforce.a_element (!s_aE0) frc_aE1 (!element_aE2)
  = (showrj 8 element_aE2)
    ++
      (showrj 10 nodel_aE3)
      ++ (showrj 8 noder_aE4) ++ (showrj 15 f_aE5) ++ "\n"
  where
      (nodel_aE3, (!noder_aE4)) = getenlr s_aE0 element_aE2
      (!f_aE5) = getefrc s_aE0 element_aE2 frc_aE1


["s_axM","safebang@!s_axM","(!s_axM)","uvw_axN","a_node_s_axO","s_aDO","!s_aDO","(!s_aDO)","uvw_aDP","!uvw_aDP","(!uvw_aDP)","node_aDQ","!node_aDQ","(!node_aDQ)","x_aDR","y_aDS","(x_aDR, y_aDS)","bc_aDT","lazydmd@!bc_aDT","(!bc_aDT)","u_aDU","!u_aDU","(!u_aDU)","v_aDV","theta_aDW","((!u_aDU), v_aDV, theta_aDW)","s_aDX","frc_aDY","a_element_s_aDZ","s_aE0","!s_aE0","(!s_aE0)","frc_aE1","element_aE2","!element_aE2","(!element_aE2)","nodel_aE3","noder_aE4","!noder_aE4","(!noder_aE4)","(nodel_aE3, (!noder_aE4))","f_aE5","lazydmd@!f_aE5","(!f_aE5)"]
module Printuvwforce (uvwresult, forceresult) where
import Basics
import Vector
import DB_interface
import Displacement
import Elemforce

uvwresult ::
          (Array Int Int, Array Int Float) -> Vec Float -> [Char]

forceresult ::
            (Array Int Int, Array Int Float) -> Vec Float -> [Char]
uvwresult (!s_axM) uvw_axN
  = "\n\nDISPLACEMENT OF THE STRUCTURE \n\n" ++
      "     Node     X     Y     BC         U             V"
      ++ "                  Theta\n"
      ++ (concat (map a_node_s_axO [1 .. (nnode s_axM)]))
  where a_node_s_axO = a_node s_axM uvw_axN
a_node (norecord@s_aDO) (norecord@uvw_aDP) (norecord@node_aDQ)
  = (showrj 8 node_aDQ) ++ (showrj 7 x_aDR) ++ (showrj 6 y_aDS) ++
      (showrj 7 bc_aDT)
      ++ (showrj 15 u_aDU)
      ++ (showrj 15 v_aDV)
      ++ (showrj 15 theta_aDW)
      ++ "\n"
  where (x_aDR, y_aDS) = getnxy s_aDO node_aDQ
        (lazydmd@bc_aDT) = getnbc s_aDO node_aDQ
        ((norecord@u_aDU), v_aDV, theta_aDW)
          = getnuvw s_aDO node_aDQ uvw_aDP
forceresult s_aDX frc_aDY
  = "\n\n\nINTERNAL FORCES OF ELEMENT " ++ "\n\n" ++
      "    Element    NodeL   NodeR     TENSION\n"
      ++ concat (map a_element_s_aDZ [1 .. (nelem s_aDX)])
  where a_element_s_aDZ = a_element s_aDX frc_aDY
a_element (norecord@s_aE0) frc_aE1 (norecord@element_aE2)
  = (showrj 8 element_aE2) ++ (showrj 10 nodel_aE3) ++
      (showrj 8 noder_aE4)
      ++ (showrj 15 f_aE5)
      ++ "\n"
  where (nodel_aE3, (norecord@noder_aE4)) = getenlr s_aE0 element_aE2
        (lazydmd@f_aE5) = getefrc s_aE0 element_aE2 frc_aE1

==================== Renamer ====================
Vector.displayvec :: (Show a_aKa) => Vector.Vec a_aKa -> [Char]
Vector.vecprod ::
  (Num a_aK9) => Vector.Vec a_aK9 -> Vector.Vec a_aK9 -> a_aK9
Vector.updvec ::
  Vector.Vec a_aK8 -> [(Int, a_aK8)] -> Vector.Vec a_aK8
Vector.maxupdvec ::
  (Num a_axc, Ord a_axc) =>
  Vector.Vec a_axc -> [(Int, a_axc)] -> Vector.Vec a_axc
Vector.incrvec ::
  (Num a_awe) =>
  Vector.Vec a_awe -> [(Int, a_awe)] -> Vector.Vec a_awe
Vector.vecsub :: Vector.Vec a_awd -> Int -> a_awd
Vector.boundvec :: Vector.Vec a_awc -> Int
Vector.makevec :: Int -> (Int -> a_awb) -> Vector.Vec a_awb
Vector.makevec (!n_aSw) f_aSx
  = Vector.VEC
      n_aSw
      (array (1, n_aSw) [(i_aSy, f_aSx i_aSy) | i_aSy <- [1 .. n_aSw]])
Vector.boundvec ((!(Vector.VEC (!n_aSz) (!_)))) = n_aSz
Vector.vecsub (!((!(Vector.VEC n_aSA va_aSB)))) i_aSC
  = va_aSB ! i_aSC
Vector.updvec (Vector.VEC n_aSD va_aSE) s_aSF
  = Vector.VEC n_aSD (accum f_aSG va_aSE s_aSF)
  where
      f_aSG (!b_aSH) c_aSI = c_aSI
Vector.maxupdvec ((!(Vector.VEC (!n_aSJ) va_aSK))) (!s_aSL)
  = Vector.VEC n_aSJ (accum max va_aSK s_aSL)
Vector.incrvec ((!(Vector.VEC (!n_aSM) va_aSN))) (!s_aSO)
  = Vector.VEC n_aSM (accum (+) va_aSN s_aSO)
Vector.vecprod (!v1_aSP) v2_aSQ
  = sum
      [(Vector.vecsub v1_aSP i_aYR) * (Vector.vecsub v2_aSQ i_aYR) |
         i_aYR <- [1 .. n_aSR]]
  where
      n_aSR = Vector.boundvec v1_aSP
Vector.displayvec (!v_aYS)
  = "< "
    ++
      concat
        ([(showrj 8 (Vector.vecsub v_aYS i_aYU)) | i_aYU <- [1 .. n_aYT]])
      ++ ">\n"
  where
      (!n_aYT) = Vector.boundvec v_aYS

data Vector.Vec a_anu = Vector.VEC Int (Array Int a_anu)


["n_aSw","safebang@!n_aSw","(!n_aSw)","f_aSx","i_aSy","n_aSz","safebang@!n_aSz","(!n_aSz)","_","!_","(!_)","VEC (!n_aSz) (!_)","(VEC (!n_aSz) (!_))","!(VEC (!n_aSz) (!_))","(!(VEC (!n_aSz) (!_)))","((!(VEC (!n_aSz) (!_))))","n_aSA","va_aSB","VEC n_aSA va_aSB","(VEC n_aSA va_aSB)","!(VEC n_aSA va_aSB)","(!(VEC n_aSA va_aSB))","((!(VEC n_aSA va_aSB)))","!((!(VEC n_aSA va_aSB)))","(!((!(VEC n_aSA va_aSB))))","i_aSC","n_aSD","va_aSE","VEC n_aSD va_aSE","(VEC n_aSD va_aSE)","s_aSF","b_aSH","!b_aSH","(!b_aSH)","c_aSI","n_aSJ","safebang@!n_aSJ","(!n_aSJ)","va_aSK","VEC (!n_aSJ) va_aSK","(VEC (!n_aSJ) va_aSK)","!(VEC (!n_aSJ) va_aSK)","(!(VEC (!n_aSJ) va_aSK))","((!(VEC (!n_aSJ) va_aSK)))","s_aSL","safebang@!s_aSL","(!s_aSL)","n_aSM","safebang@!n_aSM","(!n_aSM)","va_aSN","VEC (!n_aSM) va_aSN","(VEC (!n_aSM) va_aSN)","!(VEC (!n_aSM) va_aSN)","(!(VEC (!n_aSM) va_aSN))","((!(VEC (!n_aSM) va_aSN)))","s_aSO","safebang@!s_aSO","(!s_aSO)","v1_aSP","!v1_aSP","(!v1_aSP)","v2_aSQ","i_aYR","n_aSR","v_aYS","!v_aYS","(!v_aYS)","i_aYU","n_aYT","!n_aYT","(!n_aYT)"]
module Vector
       (Vec, makevec, boundvec, vecsub, incrvec, updvec, maxupdvec,
        vecprod, displayvec)
       where
import Data.Array
import Basics

displayvec :: (Show a_aKa) => Vec a_aKa -> [Char]

vecprod :: (Num a_aK9) => Vec a_aK9 -> Vec a_aK9 -> a_aK9

updvec :: Vec a_aK8 -> [(Int, a_aK8)] -> Vec a_aK8

maxupdvec ::
            (Num a_axc, Ord a_axc) => Vec a_axc -> [(Int, a_axc)] -> Vec a_axc

incrvec :: (Num a_awe) => Vec a_awe -> [(Int, a_awe)] -> Vec a_awe

vecsub :: Vec a_awd -> Int -> a_awd

boundvec :: Vec a_awc -> Int

makevec :: Int -> (Int -> a_awb) -> Vec a_awb
makevec (!n_aSw) f_aSx
  = VEC n_aSw
      (array (1, n_aSw) [(i_aSy, f_aSx i_aSy) | i_aSy <- [1 .. n_aSw]])
boundvec ((norecord@(VEC (!n_aSz) (norecord@_)))) = n_aSz
vecsub (norecord@((norecord@(VEC n_aSA va_aSB)))) i_aSC
  = va_aSB ! i_aSC
updvec (VEC n_aSD va_aSE) s_aSF
  = VEC n_aSD (accum f_aSG va_aSE s_aSF)
  where f_aSG (norecord@b_aSH) c_aSI = c_aSI
maxupdvec ((norecord@(VEC (!n_aSJ) va_aSK))) (!s_aSL)
  = VEC n_aSJ (accum max va_aSK s_aSL)
incrvec ((norecord@(VEC (!n_aSM) va_aSN))) (!s_aSO)
  = VEC n_aSM (accum (+) va_aSN s_aSO)
vecprod (norecord@v1_aSP) v2_aSQ
  = sum
      [(vecsub v1_aSP i_aYR) * (vecsub v2_aSQ i_aYR) |
       i_aYR <- [1 .. n_aSR]]
  where n_aSR = boundvec v1_aSP
displayvec (norecord@v_aYS)
  = "< " ++
      concat ([(showrj 8 (vecsub v_aYS i_aYU)) | i_aYU <- [1 .. n_aYT]])
      ++ ">\n"
  where (norecord@n_aYT) = boundvec v_aYS

data Vec a_anu = VEC Int (Array Int a_anu)

==================== Renamer ====================
Assemble_loadvec.loadvec ::
  (Array Int Int, Array Int Float) -> Vec Float
Assemble_loadvec.loadvec (!s_axL)
  = incrvec initial_value_axM index_value_assoc_s_axN
  where
      initial_value_axM = makevec (ndgrs s_axL) (\ i_axO -> 0.0)
      (!index_value_assoc_s_axN)
        = Assemble_loadvec.index_value_assoc s_axL
Assemble_loadvec.index_value_assoc (!s_axP)
  = foldl assemble_s_axQ [] [1 .. (nplds s_axP)]
  where
      (!assemble_s_axQ) = Assemble_loadvec.assemble s_axP
Assemble_loadvec.assemble s_aDQ till_now_d_aDR ii_aDS
  = till_now_d_aDR ++ d_this'_aDT
  where
      (!d_this'_aDT)
        = filter valid_degree_aDU (azip degrees_aDV loads_aDW)
      valid_degree_aDU ((!dgr_aHq), x_aHr) = (dgr_aHq /= 0)
      degrees_aDV = getndgr s_aDQ node_aDX
      loads_aDW = [px_aDY, py_aDZ, m_aE0]
      (!(node_aDX, px_aDY, (!py_aDZ), m_aE0)) = getpld s_aDQ ii_aDS


["s_axL","!s_axL","(!s_axL)","initial_value_axM","i_axO","index_value_assoc_s_axN","safebang@!index_value_assoc_s_axN","(!index_value_assoc_s_axN)","s_axP","!s_axP","(!s_axP)","assemble_s_axQ","!assemble_s_axQ","(!assemble_s_axQ)","s_aDQ","till_now_d_aDR","ii_aDS","d_this'_aDT","lazydmd@!d_this'_aDT","(!d_this'_aDT)","dgr_aHq","!dgr_aHq","(!dgr_aHq)","x_aHr","((!dgr_aHq), x_aHr)","degrees_aDV","loads_aDW","node_aDX","px_aDY","py_aDZ","!py_aDZ","(!py_aDZ)","m_aE0","(node_aDX, px_aDY, (!py_aDZ), m_aE0)","!(node_aDX, px_aDY, (!py_aDZ), m_aE0)","(!(node_aDX, px_aDY, (!py_aDZ), m_aE0))"]
module Assemble_loadvec (loadvec) where
import Basics
import Vector
import DB_interface
import Degrees

loadvec :: (Array Int Int, Array Int Float) -> Vec Float
loadvec (norecord@s_axL)
  = incrvec initial_value_axM index_value_assoc_s_axN
  where initial_value_axM = makevec (ndgrs s_axL) (\ i_axO -> 0.0)
        (!index_value_assoc_s_axN) = index_value_assoc s_axL
index_value_assoc (norecord@s_axP)
  = foldl assemble_s_axQ [] [1 .. (nplds s_axP)]
  where (norecord@assemble_s_axQ) = assemble s_axP
assemble s_aDQ till_now_d_aDR ii_aDS
  = till_now_d_aDR ++ d_this'_aDT
  where (lazydmd@d_this'_aDT)
          = filter valid_degree_aDU (azip degrees_aDV loads_aDW)
        valid_degree_aDU ((norecord@dgr_aHq), x_aHr) = (dgr_aHq /= 0)
        degrees_aDV = getndgr s_aDQ node_aDX
        loads_aDW = [px_aDY, py_aDZ, m_aE0]
        (norecord@(node_aDX, px_aDY, (norecord@py_aDZ), m_aE0))
          = getpld s_aDQ ii_aDS

==================== Renamer ====================
Basics.showlj, Basics.showrj ::
  (Show a_anj) => Int -> a_anj -> [Char]
Basics.rep :: Int -> a_anb -> [a_anb]
Basics.rep (!0) x_avK = []
Basics.rep n_avL (!x_avM) = x_avM : (Basics.rep (n_avL - 1) x_avM)
Basics.showrj (!l_awL) (!x_awM)
  = (Basics.rep bs_awO ' ') ++ ns_awN
  where
      ns_awN = dropWhile ((==) ' ') (show x_awM)
      bs_awO
        | l_awL <= length ns_awN = 1
        | otherwise = l_awL - length ns_awN
Basics.showlj l_aTM (!x_aTN)
  = ns_aTO ++ (Basics.rep bs_aTP ' ')
  where
      (!ns_aTO) = dropWhile ((==) ' ') (show x_aTN)
      bs_aTP
        | l_aTM <= length ns_aTO = 1
        | otherwise = l_aTM - length ns_aTO
Basics.azip :: [a_an9] -> [b_ana] -> [(a_an9, b_ana)]
Basics.azip [] [] = []
Basics.azip (!(x_aTQ : ls_aTR)) (!(x'_aTS : (!ls'_aTT)))
  = (x_aTQ, x'_aTS) : (Basics.azip ls_aTR ls'_aTT)


["0","!0","(!0)","x_avK","n_avL","x_avM","!x_avM","(!x_avM)","l_awL","safebang@!l_awL","(!l_awL)","x_awM","safebang@!x_awM","(!x_awM)","ns_awN","bs_awO","l_aTM","x_aTN","safebang@!x_aTN","(!x_aTN)","ns_aTO","safebang@!ns_aTO","(!ns_aTO)","bs_aTP","[]","[]","x_aTQ","ls_aTR","x_aTQ : ls_aTR","(x_aTQ : ls_aTR)","!(x_aTQ : ls_aTR)","(!(x_aTQ : ls_aTR))","x'_aTS","ls'_aTT","safebang@!ls'_aTT","(!ls'_aTT)","x'_aTS : (!ls'_aTT)","(x'_aTS : (!ls'_aTT))","!(x'_aTS : (!ls'_aTT))","(!(x'_aTS : (!ls'_aTT)))"]
module Basics (showrj, showlj, azip, module Data.Array) where
import Data.Array

showlj, showrj :: (Show a_anj) => Int -> a_anj -> [Char]

rep :: Int -> a_anb -> [a_anb]
rep (norecord@0) x_avK = []
rep n_avL (norecord@x_avM) = x_avM : (rep (n_avL - 1) x_avM)
showrj (!l_awL) (!x_awM) = (rep bs_awO ' ') ++ ns_awN
  where ns_awN = dropWhile ((==) ' ') (show x_awM)
        bs_awO
          | l_awL <= length ns_awN = 1
          | otherwise = l_awL - length ns_awN
showlj l_aTM (!x_aTN) = ns_aTO ++ (rep bs_aTP ' ')
  where (!ns_aTO) = dropWhile ((==) ' ') (show x_aTN)
        bs_aTP
          | l_aTM <= length ns_aTO = 1
          | otherwise = l_aTM - length ns_aTO

azip :: [a_an9] -> [b_ana] -> [(a_an9, b_ana)]
azip [] [] = []
azip (norecord@(x_aTQ : ls_aTR)) (norecord@(x'_aTS : (!ls'_aTT)))
  = (x_aTQ, x'_aTS) : (azip ls_aTR ls'_aTT)

==================== Renamer ====================
Displacement.uvw :: (Array Int Int, Array Int Float) -> Vec Float
Displacement.getnuvw ::
  (Array Int Int, Array Int Float)
  -> Int -> Vec Float -> (Float, Float, Float)
Displacement.t_Ub (!s_aA3)
  = vbllsolution (kdd s_aA3) (loadvec s_aA3)
Displacement.uvw s_aA4
  = incrvec initial_value_aA5 index_value_assoc_aA6
  where
      initial_value_aA5 = makevec (3 * (nnode s_aA4)) (\ (!i_aB6) -> 0.0)
      (!index_value_assoc_aA6)
        = concat (map f_s_aA7 [1 .. (nnode s_aA4)])
      (!f_s_aA7) = Displacement.f s_aA4 tUb_aA8
      tUb_aA8 = Displacement.t_Ub s_aA4
Displacement.f s_aH6 tUb_aH7 (!node_aH8)
  = azip [l_aH9, l_aH9 + 1, l_aH9 + 2] (map ff_aHb dgrs_aHa)
  where
      (!l_aH9) = 3 * (node_aH8 - 1) + 1
      dgrs_aHa = getndgr s_aH6 node_aH8
      ff_aHb i_aHc = if (i_aHc == 0) then 0.0 else vecsub tUb_aH7 i_aHc
Displacement.getnuvw s_aU8 node_aU9 uvw_aUa
  = (u_aUb, v_aUc, theta_aUd)
  where
      u_aUb = vecsub uvw_aUa index_aUe
      (!v_aUc) = vecsub uvw_aUa (index_aUe + 1)
      theta_aUd = vecsub uvw_aUa (index_aUe + 2)
      (!index_aUe) = 3 * (node_aU9 - 1) + 1


["s_aA3","!s_aA3","(!s_aA3)","s_aA4","initial_value_aA5","i_aB6","safebang@!i_aB6","(!i_aB6)","index_value_assoc_aA6","safebang@!index_value_assoc_aA6","(!index_value_assoc_aA6)","f_s_aA7","!f_s_aA7","(!f_s_aA7)","tUb_aA8","s_aH6","tUb_aH7","node_aH8","!node_aH8","(!node_aH8)","l_aH9","!l_aH9","(!l_aH9)","dgrs_aHa","i_aHc","s_aU8","node_aU9","uvw_aUa","u_aUb","v_aUc","!v_aUc","(!v_aUc)","theta_aUd","index_aUe","!index_aUe","(!index_aUe)"]
module Displacement (uvw, getnuvw) where
import Basics
import Vector
import Matrix
import VBmatrix
import VBlldecomp
import DB_interface
import Degrees
import Pre_assemble
import Assemble_stiffness
import Assemble_loadvec

uvw :: (Array Int Int, Array Int Float) -> Vec Float

getnuvw ::
        (Array Int Int, Array Int Float) ->
          Int -> Vec Float -> (Float, Float, Float)
t_Ub (norecord@s_aA3) = vbllsolution (kdd s_aA3) (loadvec s_aA3)
uvw s_aA4 = incrvec initial_value_aA5 index_value_assoc_aA6
  where initial_value_aA5
          = makevec (3 * (nnode s_aA4)) (\ (!i_aB6) -> 0.0)
        (!index_value_assoc_aA6)
          = concat (map f_s_aA7 [1 .. (nnode s_aA4)])
        (norecord@f_s_aA7) = f s_aA4 tUb_aA8
        tUb_aA8 = t_Ub s_aA4
f s_aH6 tUb_aH7 (norecord@node_aH8)
  = azip [l_aH9, l_aH9 + 1, l_aH9 + 2] (map ff_aHb dgrs_aHa)
  where (norecord@l_aH9) = 3 * (node_aH8 - 1) + 1
        dgrs_aHa = getndgr s_aH6 node_aH8
        ff_aHb i_aHc = if (i_aHc == 0) then 0.0 else vecsub tUb_aH7 i_aHc
getnuvw s_aU8 node_aU9 uvw_aUa = (u_aUb, v_aUc, theta_aUd)
  where u_aUb = vecsub uvw_aUa index_aUe
        (norecord@v_aUc) = vecsub uvw_aUa (index_aUe + 1)
        theta_aUd = vecsub uvw_aUa (index_aUe + 2)
        (norecord@index_aUe) = 3 * (node_aU9 - 1) + 1

==================== Renamer ====================
Degrees.ndgrs :: (Array Int Int, Array Int Float) -> Int
Degrees.getndgr :: (Array Int Int, Array Int Float) -> Int -> [Int]
Degrees.ndgrs (!s_axD) = fst (Degrees.ndgrs_and_dgrsn s_axD)
Degrees.getndgr s_axK node_axL
  = [u_axM, v_axN, theta_axO]
  where
      (!u_axM) = dgrsn_s_axP ! index_axQ
      (!v_axN) = dgrsn_s_axP ! (index_axQ + 1)
      (!theta_axO) = dgrsn_s_axP ! (index_axQ + 2)
      dgrsn_s_axP = Degrees.dgrsn s_axK
      index_axQ = (node_axL - 1) * 3 + 1
Degrees.dgrsn :: (Array Int Int, Array Int Float) -> Array Int Int
Degrees.dgrsn s_ayO
  = listArray
      (1, (nnode s_ayO) * 3) (snd (Degrees.ndgrs_and_dgrsn s_ayO))
Degrees.ndgrs_and_dgrsn ::
  (Array Int Int, Array Int Float) -> (Int, [Int])
Degrees.ndgrs_and_dgrsn (!s_ayP)
  = foldl counting_one_node_s_ayQ (0, []) [1 .. (nnode s_ayP)]
  where
      (!counting_one_node_s_ayQ) = Degrees.counting_one_node s_ayP
Degrees.counting_one_node
  s_aEQ
  (ndgrs_till_now_aER, dgrsn_till_now_aES)
  i_aET
  = (ndgrs_till_now_aER + ndgrs_this_node_aEX, 
     dgrsn_till_now_aES ++ dgrsn_this_node_aEY)
  where
      dof_aEU = [fod_aEV j_aF1 | (!j_aF1) <- [2, 1, 0]]
      fod_aEV j_aF2
        = if (mod (div bc_aF0 (e_10_aEW j_aF2)) 10 == 1) then 1 else 0
      e_10_aEW (!j_a113)
        = if (j_a113 == 0) then
              (1 :: Int)
          else
              10 * (e_10_aEW (j_a113 - 1))
      ndgrs_this_node_aEX = sum dof_aEU
      (!dgrsn_this_node_aEY) = [g_aEZ j_a114 | j_a114 <- [0, 1, 2]]
      g_aEZ (!j_a115)
        = if ((dof_aEU !! j_a115) == 0) then
              0
          else
              sum (take (j_a115 + 1) dof_aEU) + ndgrs_till_now_aER
      (!bc_aF0) = getnbc s_aEQ i_aET
Degrees.degreesrlt :: (Array Int Int, Array Int Float) -> [Char]
Degrees.degreesrlt s_a14v
  = "DEGREE INFORMATION :\n\
    \\n"
    ++
      "\t Total degree numbers = "
      ++
        showlj 4 (Degrees.ndgrs s_a14v)
        ++
          "\n\
          \\n"
          ++
            (concat (map a_node_s_a14w [1 .. (nnode s_a14v)]))
            ++
              "\n\
              \\n"
  where
      (!a_node_s_a14w) = Degrees.a_node s_a14v
Degrees.a_node s_a14x (!node_a14y)
  = "  Node.no = "
    ++
      (showrj 2 node_a14y)
      ++
        "   u = "
        ++
          (showrj 8 u_a14A)
          ++
            "   v = "
            ++
              (showrj 8 v_a14B)
              ++
                " theta="
                ++
                  (showrj 8 theta_a14C) ++ "   bc = " ++ (showrj 3 bc_a14z) ++ "\n"
  where
      (!bc_a14z) = getnbc s_a14x node_a14y
      (![u_a14A, v_a14B, theta_a14C]) = Degrees.getndgr s_a14x node_a14y


["s_axD","!s_axD","(!s_axD)","s_axK","node_axL","u_axM","!u_axM","(!u_axM)","v_axN","!v_axN","(!v_axN)","theta_axO","!theta_axO","(!theta_axO)","dgrsn_s_axP","index_axQ","s_ayO","s_ayP","!s_ayP","(!s_ayP)","counting_one_node_s_ayQ","!counting_one_node_s_ayQ","(!counting_one_node_s_ayQ)","s_aEQ","ndgrs_till_now_aER","dgrsn_till_now_aES","(ndgrs_till_now_aER, dgrsn_till_now_aES)","i_aET","dof_aEU","j_aF1","!j_aF1","(!j_aF1)","j_aF2","j_a113","safebang@!j_a113","(!j_a113)","ndgrs_this_node_aEX","dgrsn_this_node_aEY","lazydmd@!dgrsn_this_node_aEY","(!dgrsn_this_node_aEY)","j_a114","j_a115","!j_a115","(!j_a115)","bc_aF0","!bc_aF0","(!bc_aF0)","s_a14v","a_node_s_a14w","!a_node_s_a14w","(!a_node_s_a14w)","s_a14x","node_a14y","!node_a14y","(!node_a14y)","bc_a14z","lazydmd@!bc_a14z","(!bc_a14z)","u_a14A","v_a14B","theta_a14C","[u_a14A, v_a14B, theta_a14C]","![u_a14A, v_a14B, theta_a14C]","(![u_a14A, v_a14B, theta_a14C])"]
module Degrees (ndgrs, getndgr, degreesrlt) where
import Data.Array
import Basics
import Vector
import DB_interface

ndgrs :: (Array Int Int, Array Int Float) -> Int

getndgr :: (Array Int Int, Array Int Float) -> Int -> [Int]
ndgrs (norecord@s_axD) = fst (ndgrs_and_dgrsn s_axD)
getndgr s_axK node_axL = [u_axM, v_axN, theta_axO]
  where (norecord@u_axM) = dgrsn_s_axP ! index_axQ
        (norecord@v_axN) = dgrsn_s_axP ! (index_axQ + 1)
        (norecord@theta_axO) = dgrsn_s_axP ! (index_axQ + 2)
        dgrsn_s_axP = dgrsn s_axK
        index_axQ = (node_axL - 1) * 3 + 1

dgrsn :: (Array Int Int, Array Int Float) -> Array Int Int
dgrsn s_ayO
  = listArray (1, (nnode s_ayO) * 3) (snd (ndgrs_and_dgrsn s_ayO))

ndgrs_and_dgrsn :: (Array Int Int, Array Int Float) -> (Int, [Int])
ndgrs_and_dgrsn (norecord@s_ayP)
  = foldl counting_one_node_s_ayQ (0, []) [1 .. (nnode s_ayP)]
  where (norecord@counting_one_node_s_ayQ) = counting_one_node s_ayP
counting_one_node s_aEQ (ndgrs_till_now_aER, dgrsn_till_now_aES)
  i_aET
  = (ndgrs_till_now_aER + ndgrs_this_node_aEX,
     dgrsn_till_now_aES ++ dgrsn_this_node_aEY)
  where dof_aEU = [fod_aEV j_aF1 | (norecord@j_aF1) <- [2, 1, 0]]
        fod_aEV j_aF2
          = if (mod (div bc_aF0 (e_10_aEW j_aF2)) 10 == 1) then 1 else 0
        e_10_aEW (!j_a113)
          = if (j_a113 == 0) then (1 :: Int) else
              10 * (e_10_aEW (j_a113 - 1))
        ndgrs_this_node_aEX = sum dof_aEU
        (lazydmd@dgrsn_this_node_aEY)
          = [g_aEZ j_a114 | j_a114 <- [0, 1, 2]]
        g_aEZ (norecord@j_a115)
          = if ((dof_aEU !! j_a115) == 0) then 0 else
              sum (take (j_a115 + 1) dof_aEU) + ndgrs_till_now_aER
        (norecord@bc_aF0) = getnbc s_aEQ i_aET

degreesrlt :: (Array Int Int, Array Int Float) -> [Char]
degreesrlt s_a14v
  = "DEGREE INFORMATION :\n\n" ++ "\t Total degree numbers = " ++
      showlj 4 (ndgrs s_a14v)
      ++ "\n\n"
      ++ (concat (map a_node_s_a14w [1 .. (nnode s_a14v)]))
      ++ "\n\n"
  where (norecord@a_node_s_a14w) = a_node s_a14v
a_node s_a14x (norecord@node_a14y)
  = "  Node.no = " ++ (showrj 2 node_a14y) ++ "   u = " ++
      (showrj 8 u_a14A)
      ++ "   v = "
      ++ (showrj 8 v_a14B)
      ++ " theta="
      ++ (showrj 8 theta_a14C)
      ++ "   bc = "
      ++ (showrj 3 bc_a14z)
      ++ "\n"
  where (lazydmd@bc_a14z) = getnbc s_a14x node_a14y
        (norecord@[u_a14A, v_a14B, theta_a14C]) = getndgr s_a14x node_a14y

==================== Renamer ====================
Elemstif.beam2d ::
  (Array Int Int, Array Int Float) -> Int -> Mat Float
Elemstif.beam2d (!str_ays) element_ayt
  = makemat
      (6, 6)
      (\ (!(i_aIO, (!j_aIP)))
         -> if (i_aIO == 1 && j_aIP == 1) || (i_aIO == 4 && j_aIP == 4) then
                b1_ayv
            else
                if (i_aIO == 2 && j_aIP == 1)
                   ||
                     (i_aIO == 5 && j_aIP == 4)
                     || (i_aIO == 1 && j_aIP == 2) || (i_aIO == 4 && j_aIP == 5) then
                    b2_ayw
                else
                    if (i_aIO == 2 && j_aIP == 2) || (i_aIO == 5 && j_aIP == 5) then
                        b3_ayx
                    else
                        if (i_aIO == 1 && j_aIP == 4) || (i_aIO == 4 && j_aIP == 1) then
                            - b1_ayv
                        else
                            if (i_aIO == 2 && j_aIP == 4)
                               ||
                                 (i_aIO == 5 && j_aIP == 1)
                                 || (i_aIO == 1 && j_aIP == 5) || (i_aIO == 4 && j_aIP == 2) then
                                - b2_ayw
                            else
                                if (i_aIO == 2 && j_aIP == 5) || (i_aIO == 5 && j_aIP == 2) then
                                    - b3_ayx
                                else
                                    0.0)
  where
      (!a1_ayu) = ea_ayD / l_ayA
      b1_ayv = a1_ayu * c_ayB * c_ayB
      b2_ayw = a1_ayu * c_ayB * s_ayC
      b3_ayx = a1_ayu * s_ayC * s_ayC
      (!dx_ayy) = xr_ayJ - xl_ayH
      (!dy_ayz) = yr_ayK - yl_ayI
      l_ayA = sqrt (dx_ayy * dx_ayy + dy_ayz * dy_ayz)
      c_ayB = dx_ayy / l_ayA
      s_ayC = dy_ayz / l_ayA
      (ea_ayD, ei_ayE) = getmpro str_ays (getemat str_ays element_ayt)
      (!((!nl_ayF), nr_ayG)) = getenlr str_ays element_ayt
      (xl_ayH, (!yl_ayI)) = getnxy str_ays nl_ayF
      ((!xr_ayJ), (!yr_ayK)) = getnxy str_ays nr_ayG


["str_ays","!str_ays","(!str_ays)","element_ayt","i_aIO","j_aIP","safebang@!j_aIP","(!j_aIP)","(i_aIO, (!j_aIP))","!(i_aIO, (!j_aIP))","(!(i_aIO, (!j_aIP)))","a1_ayu","!a1_ayu","(!a1_ayu)","b1_ayv","b2_ayw","b3_ayx","dx_ayy","!dx_ayy","(!dx_ayy)","dy_ayz","!dy_ayz","(!dy_ayz)","l_ayA","c_ayB","s_ayC","ea_ayD","ei_ayE","(ea_ayD, ei_ayE)","nl_ayF","!nl_ayF","(!nl_ayF)","nr_ayG","((!nl_ayF), nr_ayG)","!((!nl_ayF), nr_ayG)","(!((!nl_ayF), nr_ayG))","xl_ayH","yl_ayI","!yl_ayI","(!yl_ayI)","(xl_ayH, (!yl_ayI))","xr_ayJ","!xr_ayJ","(!xr_ayJ)","yr_ayK","!yr_ayK","(!yr_ayK)","((!xr_ayJ), (!yr_ayK))"]
module Elemstif (beam2d) where
import Basics
import Vector
import Matrix
import DB_interface

beam2d :: (Array Int Int, Array Int Float) -> Int -> Mat Float
beam2d (norecord@str_ays) element_ayt
  = makemat (6, 6)
      (\ (norecord@(i_aIO, (!j_aIP))) ->
         if (i_aIO == 1 && j_aIP == 1) || (i_aIO == 4 && j_aIP == 4) then
           b1_ayv else
           if
             (i_aIO == 2 && j_aIP == 1) || (i_aIO == 5 && j_aIP == 4) ||
               (i_aIO == 1 && j_aIP == 2)
               || (i_aIO == 4 && j_aIP == 5)
             then b2_ayw else
             if (i_aIO == 2 && j_aIP == 2) || (i_aIO == 5 && j_aIP == 5) then
               b3_ayx else
               if (i_aIO == 1 && j_aIP == 4) || (i_aIO == 4 && j_aIP == 1) then
                 -b1_ayv else
                 if
                   (i_aIO == 2 && j_aIP == 4) || (i_aIO == 5 && j_aIP == 1) ||
                     (i_aIO == 1 && j_aIP == 5)
                     || (i_aIO == 4 && j_aIP == 2)
                   then -b2_ayw else
                   if (i_aIO == 2 && j_aIP == 5) || (i_aIO == 5 && j_aIP == 2) then
                     -b3_ayx else 0.0)
  where (norecord@a1_ayu) = ea_ayD / l_ayA
        b1_ayv = a1_ayu * c_ayB * c_ayB
        b2_ayw = a1_ayu * c_ayB * s_ayC
        b3_ayx = a1_ayu * s_ayC * s_ayC
        (norecord@dx_ayy) = xr_ayJ - xl_ayH
        (norecord@dy_ayz) = yr_ayK - yl_ayI
        l_ayA = sqrt (dx_ayy * dx_ayy + dy_ayz * dy_ayz)
        c_ayB = dx_ayy / l_ayA
        s_ayC = dy_ayz / l_ayA
        (ea_ayD, ei_ayE) = getmpro str_ays (getemat str_ays element_ayt)
        (norecord@((norecord@nl_ayF), nr_ayG))
          = getenlr str_ays element_ayt
        (xl_ayH, (norecord@yl_ayI)) = getnxy str_ays nl_ayF
        ((norecord@xr_ayJ), (norecord@yr_ayK)) = getnxy str_ays nr_ayG

==================== Renamer ====================
Main.main
  = do { ls_azE <- hGetContents stdin;
         (getFilename
          $ process
              (\ (!viewdir_azF) -> hiddenline viewdir_azF . map read . lines))
           (lines ls_azE) }


["main","ls_azE","viewdir_azF","lazydmd@!viewdir_azF","(!viewdir_azF)"]
module Main (main) where
import Numbers
import Vectors
import Hide
import MyIO
import EdgePlate (Input(..))
import Postscript (Output(..))
import System.IO
main
  = do ls_azE <- hGetContents stdin
       (getFilename $
          process
            (\ (lazydmd@viewdir_azF) ->
               hiddenline viewdir_azF . map read . lines))
         (lines ls_azE)

==================== Renamer ====================
EdgePlate.edgeT, EdgePlate.edgeH ::
  Vector -> Vector -> EdgePlate.Edge
EdgePlate.edgeH (!v_ari) w_arj = EdgePlate.Edg v_ari w_arj
EdgePlate.edgeT (!v_ark) w_arl
  = EdgePlate.Edg v_ark (w_arl - v_ark)
EdgePlate.s, EdgePlate.h, EdgePlate.t :: EdgePlate.Edge -> Vector
EdgePlate.s (EdgePlate.Edg (!v_ask) w_asl) = v_ask
EdgePlate.h ((!(EdgePlate.Edg (!v_asm) (!w_asn)))) = w_asn
EdgePlate.t (!((!(EdgePlate.Edg (!v_aso) w_asp)))) = v_aso + w_asp
EdgePlate.n :: EdgePlate.Plate -> Vector
EdgePlate.n (!(EdgePlate.Plt _ (!(l1_asq : ((!l2_asr) : ls_ass)))))
  = norm (EdgePlate.h (l1_asq) * EdgePlate.h (l2_asr))
EdgePlate.makeObject :: EdgePlate.Input -> EdgePlate.Object
EdgePlate.makeObject
  = zipWith borders_ast [1 .. ]
  where
      borders_ast :: Int -> [Vector] -> EdgePlate.Plate
      borders_ast (!n_asu) ps_asv
        = EdgePlate.Plt
            n_asu (zipWith EdgePlate.edgeT ps_asv (EdgePlate.ror 1 ps_asv))
EdgePlate.ror :: Int -> [a_arh] -> [a_arh]
EdgePlate.ror (!n_aw4) xs_aw5
  = reverse (take n_aw4 rvxs_aw6) ++ reverse (drop n_aw4 rvxs_aw6)
  where
      (!rvxs_aw6) = reverse xs_aw5

data EdgePlate.Edge = EdgePlate.Edg Vector Vector
type EdgePlate.Input = [[Vector]]
data EdgePlate.Plate = EdgePlate.Plt Int [EdgePlate.Edge]
type EdgePlate.Object = [EdgePlate.Plate]


["v_ari","safebang@!v_ari","(!v_ari)","w_arj","v_ark","safebang@!v_ark","(!v_ark)","w_arl","v_ask","safebang@!v_ask","(!v_ask)","w_asl","Edg (!v_ask) w_asl","(Edg (!v_ask) w_asl)","v_asm","safebang@!v_asm","(!v_asm)","w_asn","safebang@!w_asn","(!w_asn)","Edg (!v_asm) (!w_asn)","(Edg (!v_asm) (!w_asn))","!(Edg (!v_asm) (!w_asn))","(!(Edg (!v_asm) (!w_asn)))","((!(Edg (!v_asm) (!w_asn))))","v_aso","!v_aso","(!v_aso)","w_asp","Edg (!v_aso) w_asp","(Edg (!v_aso) w_asp)","!(Edg (!v_aso) w_asp)","(!(Edg (!v_aso) w_asp))","((!(Edg (!v_aso) w_asp)))","!((!(Edg (!v_aso) w_asp)))","(!((!(Edg (!v_aso) w_asp))))","_","l1_asq","l2_asr","!l2_asr","(!l2_asr)","ls_ass","(!l2_asr) : ls_ass","((!l2_asr) : ls_ass)","l1_asq : ((!l2_asr) : ls_ass)","(l1_asq : ((!l2_asr) : ls_ass))","!(l1_asq : ((!l2_asr) : ls_ass))","(!(l1_asq : ((!l2_asr) : ls_ass)))","Plt _ (!(l1_asq : ((!l2_asr) : ls_ass)))","(Plt _ (!(l1_asq : ((!l2_asr) : ls_ass))))","!(Plt _ (!(l1_asq : ((!l2_asr) : ls_ass))))","(!(Plt _ (!(l1_asq : ((!l2_asr) : ls_ass)))))","makeObject","n_asu","safebang@!n_asu","(!n_asu)","ps_asv","n_aw4","!n_aw4","(!n_aw4)","xs_aw5","rvxs_aw6","safebang@!rvxs_aw6","(!rvxs_aw6)"]
module EdgePlate
       (Edge, edgeT, edgeH, s, h, t, Plate(Plt), n, Input, Object,
        makeObject)
       where
import Numbers
import Vectors

edgeT, edgeH :: Vector -> Vector -> Edge
edgeH (!v_ari) w_arj = Edg v_ari w_arj
edgeT (!v_ark) w_arl = Edg v_ark (w_arl - v_ark)

s, h, t :: Edge -> Vector
s (Edg (!v_ask) w_asl) = v_ask
h ((norecord@(Edg (!v_asm) (!w_asn)))) = w_asn
t (norecord@((norecord@(Edg (norecord@v_aso) w_asp))))
  = v_aso + w_asp

n :: Plate -> Vector
n (norecord@(Plt _
               (norecord@(l1_asq : ((norecord@l2_asr) : ls_ass)))))
  = norm (h (l1_asq) * h (l2_asr))

makeObject :: Input -> Object
makeObject = zipWith borders_ast [1 ..]
  where borders_ast :: Int -> [Vector] -> Plate
        borders_ast (!n_asu) ps_asv
          = Plt n_asu (zipWith edgeT ps_asv (ror 1 ps_asv))

ror :: Int -> [a_arh] -> [a_arh]
ror (norecord@n_aw4) xs_aw5
  = reverse (take n_aw4 rvxs_aw6) ++ reverse (drop n_aw4 rvxs_aw6)
  where (!rvxs_aw6) = reverse xs_aw5

data Edge = Edg Vector Vector

type Input = [[Vector]]

data Plate = Plt Int [Edge]

type Object = [Plate]

==================== Renamer ====================
Cross.cross :: Edge -> Edge -> [(Vector, Vector)]
Cross.cross (!l_ath) k_ati
  = [(s (l_ath) + lambda_auh `mulv` h (l_ath), 
      s (k_ati) + mu_aui `mulv` h (k_ati)) |
       (!((!lambda_auh), mu_aui)) <- solve
                                       (- h l_ath) (h k_ati) (s l_ath - s k_ati),
       0 <= lambda_auh && lambda_auh <= 1 && 0 <= mu_aui && mu_aui <= 1]
Cross.overlap :: Plate -> Plate -> [Vector]
Cross.overlap (!(Plt _ ls_aHK)) p2_aHL@(!(Plt (!_) (!ks_aHM)))
  = nub
      ([s (l_aKl) | (!l_aKl) <- ls_aHK, s (l_aKl) `into` p2_aHL]
       ++
         [p_aKo |
            (!l_aKm) <- ls_aHK,
            k_aKn <- ks_aHM,
            (p_aKo, (!q_aKp)) <- Cross.cross l_aKm k_aKn])


["l_ath","!l_ath","(!l_ath)","k_ati","lambda_auh","!lambda_auh","(!lambda_auh)","mu_aui","((!lambda_auh), mu_aui)","!((!lambda_auh), mu_aui)","(!((!lambda_auh), mu_aui))","_","ls_aHK","Plt _ ls_aHK","(Plt _ ls_aHK)","!(Plt _ ls_aHK)","(!(Plt _ ls_aHK))","_","!_","(!_)","ks_aHM","safebang@!ks_aHM","(!ks_aHM)","Plt (!_) (!ks_aHM)","(Plt (!_) (!ks_aHM))","!(Plt (!_) (!ks_aHM))","(!(Plt (!_) (!ks_aHM)))","p2_aHL@(!(Plt (!_) (!ks_aHM)))","l_aKl","!l_aKl","(!l_aKl)","l_aKm","!l_aKm","(!l_aKm)","k_aKn","p_aKo","q_aKp","safebang@!q_aKp","(!q_aKp)","(p_aKo, (!q_aKp))"]
module Cross (cross, overlap) where
import Numbers
import Vectors
import EdgePlate
import Solve
import Preds
import Data.List (nub)

cross :: Edge -> Edge -> [(Vector, Vector)]
cross (norecord@l_ath) k_ati
  = [(s (l_ath) + lambda_auh `mulv` h (l_ath),
      s (k_ati) + mu_aui `mulv` h (k_ati))
     |
     (norecord@((norecord@lambda_auh), mu_aui)) <- solve (-h l_ath)
                                                     (h k_ati)
                                                     (s l_ath - s k_ati),
     0 <= lambda_auh && lambda_auh <= 1 && 0 <= mu_aui && mu_aui <= 1]

overlap :: Plate -> Plate -> [Vector]
overlap (norecord@(Plt _ ls_aHK))
  p2_aHL@(norecord@(Plt (norecord@_) (!ks_aHM)))
  = nub
      ([s (l_aKl) | (norecord@l_aKl) <- ls_aHK, s (l_aKl) `into` p2_aHL]
         ++
         [p_aKo | (norecord@l_aKm) <- ls_aHK, k_aKn <- ks_aHM,
          (p_aKo, (!q_aKp)) <- cross l_aKm k_aKn])

==================== Renamer ====================
Postscript.draw :: [Edge] -> Postscript.Output
Postscript.draw (!ls_aA8)
  = iniplot_aA9 ++ Postscript.plot ls_aA8 exiplot_aAa
  where
      iniplot_aA9
        = "\n\
          \erasepage gsave 100 100 translate 0 setlinewidth newpath\n"
      (!exiplot_aAa)
        = "\n\
          \stroke grestore\n"
Postscript.plot :: [Edge] -> ShowS
Postscript.plotFrom :: Vector -> [Edge] -> ShowS
Postscript.moveTo, Postscript.lineTo :: Vector -> ShowS
Postscript.flush :: ShowS
Postscript.plot [] = \ (!s_aAb) -> s_aAb
Postscript.plot (!ls_aAc@(!(l_aAd : _)))
  = Postscript.moveTo (s (l_aAd))
    . Postscript.plotFrom (s (l_aAd)) ls_aAc
Postscript.plotFrom (!currentPoint_aAl) [] = \ (!s_aAm) -> s_aAm
Postscript.plotFrom currentPoint_aAn ((!l_aAo) : (!ls_aAp))
  | s (l_aAo) == currentPoint_aAn
  = Postscript.lineTo (t (l_aAo))
    . Postscript.plotFrom (t (l_aAo)) ls_aAp
  | s (l_aAo) /= currentPoint_aAn
  = Postscript.flush . Postscript.plot (l_aAo : ls_aAp)
Postscript.moveTo (!v_aNR)
  = shows (x (v_aNR))
    . showChar ' ' . shows (y (v_aNR)) . showString " moveto "
Postscript.lineTo v_aNS
  = shows (x (v_aNS))
    . showChar ' ' . shows (y (v_aNS)) . showString " lineto "
Postscript.flush
  = showString
      "\n\
      \stroke newpath\n"

type Postscript.Output = String


["ls_aA8","safebang@!ls_aA8","(!ls_aA8)","iniplot_aA9","exiplot_aAa","lazydmd@!exiplot_aAa","(!exiplot_aAa)","[]","s_aAb","!s_aAb","(!s_aAb)","l_aAd","_","l_aAd : _","(l_aAd : _)","!(l_aAd : _)","(!(l_aAd : _))","ls_aAc@(!(l_aAd : _))","!ls_aAc@(!(l_aAd : _))","(!ls_aAc@(!(l_aAd : _)))","currentPoint_aAl","safebang@!currentPoint_aAl","(!currentPoint_aAl)","[]","s_aAm","!s_aAm","(!s_aAm)","currentPoint_aAn","l_aAo","!l_aAo","(!l_aAo)","ls_aAp","!ls_aAp","(!ls_aAp)","(!l_aAo) : (!ls_aAp)","((!l_aAo) : (!ls_aAp))","v_aNR","!v_aNR","(!v_aNR)","v_aNS","flush"]
module Postscript (Output, draw) where
import Numbers
import Vectors
import EdgePlate

draw :: [Edge] -> Output
draw (!ls_aA8) = iniplot_aA9 ++ plot ls_aA8 exiplot_aAa
  where iniplot_aA9
          = "\nerasepage gsave 100 100 translate 0 setlinewidth newpath\n"
        (lazydmd@exiplot_aAa) = "\nstroke grestore\n"

plot :: [Edge] -> ShowS

plotFrom :: Vector -> [Edge] -> ShowS

moveTo, lineTo :: Vector -> ShowS

flush :: ShowS
plot [] = \ (norecord@s_aAb) -> s_aAb
plot (norecord@ls_aAc@(norecord@(l_aAd : _)))
  = moveTo (s (l_aAd)) . plotFrom (s (l_aAd)) ls_aAc
plotFrom (!currentPoint_aAl) [] = \ (norecord@s_aAm) -> s_aAm
plotFrom currentPoint_aAn ((norecord@l_aAo) : (norecord@ls_aAp))
  | s (l_aAo) == currentPoint_aAn =
    lineTo (t (l_aAo)) . plotFrom (t (l_aAo)) ls_aAp
  | s (l_aAo) /= currentPoint_aAn = flush . plot (l_aAo : ls_aAp)
moveTo (norecord@v_aNR)
  = shows (x (v_aNR)) . showChar ' ' . shows (y (v_aNR)) .
      showString " moveto "
lineTo v_aNS
  = shows (x (v_aNS)) . showChar ' ' . shows (y (v_aNS)) .
      showString " lineto "
flush = showString "\nstroke newpath\n"

type Output = String

==================== Renamer ====================
class Geometric.Geom a_as9 where
  (Geometric.|||) :: a_as9 -> a_as9 -> Bool
  Geometric.vertical :: a_as9 -> Bool
  Geometric.rot :: Vector -> a_as9 -> a_as9
  Geometric.proj :: a_as9 -> a_as9
  Geometric.scale :: Number -> Vector -> a_as9 -> a_as9

instance Geometric.Geom Plate where
  plt1_ash Geometric.||| (!plt2_asi)
    = n (plt1_ash) Geometric.||| n (plt2_asi)
  Geometric.vertical plt_asj = z (n (plt_asj)) == 0
  Geometric.rot (!v_aFL) (!(Plt (!n_aFM) (!ls_aFN)))
    = Plt n_aFM [v_aFL `Geometric.rot` l_aFO | l_aFO <- ls_aFN]
  Geometric.proj (!(Plt (!n_aFP) ls_aFQ))
    = Plt n_aFP [Geometric.proj l_aFR | (!l_aFR) <- ls_aFQ]
instance Geometric.Geom Edge where
  (!l_aFS) Geometric.||| k_aFT = h (l_aFS) Geometric.||| h (k_aFT)
  Geometric.vertical (!l_aFU) = Geometric.vertical (h (l_aFU))
  Geometric.rot (!v_aFV) l_aFW
    = edgeT
        (v_aFV `Geometric.rot` s (l_aFW)) (v_aFV `Geometric.rot` t (l_aFW))
  Geometric.proj l_aFX
    = edgeT (Geometric.proj (s (l_aFX))) (Geometric.proj (t (l_aFX)))
  Geometric.scale (!f_aFY) b_aFZ l_aG0
    = edgeT
        (Geometric.scale f_aFY b_aFZ (s (l_aG0)))
        (Geometric.scale f_aFY b_aFZ (t (l_aG0)))
instance Geometric.Geom Vector where
  (!v_aG1) Geometric.||| w_aG2 = v_aG1 * w_aG2 == 0
  Geometric.vertical v_aH1 = v_aH1 Geometric.||| vec [0, 0, 1]
  Geometric.rot = rotate
  Geometric.proj (!v_aH2) = vec [x (v_aH2), y (v_aH2), 0]
  Geometric.scale (!factor_aH3) (!base_aH4) v_aH5
    = factor_aH3 `mulv` (v_aH5 - base_aH4)
instance Geometric.Geom a_aH6 => Geometric.Geom [a_aH6] where
  Geometric.rot (!viewdir_aH7) = map (Geometric.rot viewdir_aH7)
  Geometric.proj = map Geometric.proj
  Geometric.scale (!f_aH8) b_aH9 = map (Geometric.scale f_aH8 b_aH9)


["plt1_ash","plt2_asi","!plt2_asi","(!plt2_asi)","plt_asj","v_aFL","safebang@!v_aFL","(!v_aFL)","n_aFM","safebang@!n_aFM","(!n_aFM)","ls_aFN","safebang@!ls_aFN","(!ls_aFN)","Plt (!n_aFM) (!ls_aFN)","(Plt (!n_aFM) (!ls_aFN))","!(Plt (!n_aFM) (!ls_aFN))","(!(Plt (!n_aFM) (!ls_aFN)))","l_aFO","n_aFP","safebang@!n_aFP","(!n_aFP)","ls_aFQ","Plt (!n_aFP) ls_aFQ","(Plt (!n_aFP) ls_aFQ)","!(Plt (!n_aFP) ls_aFQ)","(!(Plt (!n_aFP) ls_aFQ))","l_aFR","!l_aFR","(!l_aFR)","l_aFS","!l_aFS","(!l_aFS)","k_aFT","l_aFU","!l_aFU","(!l_aFU)","v_aFV","!v_aFV","(!v_aFV)","l_aFW","l_aFX","f_aFY","safebang@!f_aFY","(!f_aFY)","b_aFZ","l_aG0","v_aG1","safebang@!v_aG1","(!v_aG1)","w_aG2","v_aH1","rot","v_aH2","safebang@!v_aH2","(!v_aH2)","factor_aH3","safebang@!factor_aH3","(!factor_aH3)","base_aH4","safebang@!base_aH4","(!base_aH4)","v_aH5","viewdir_aH7","safebang@!viewdir_aH7","(!viewdir_aH7)","proj","f_aH8","safebang@!f_aH8","(!f_aH8)","b_aH9"]
module Geometric (Geom(..)) where
import Numbers
import Vectors
import EdgePlate
import Rotate

class Geom a_as9 where
        (|||) :: a_as9 -> a_as9 -> Bool
        
        vertical :: a_as9 -> Bool
        
        rot :: Vector -> a_as9 -> a_as9
        
        proj :: a_as9 -> a_as9
        
        scale :: Number -> Vector -> a_as9 -> a_as9

instance Geom Plate where
        plt1_ash ||| (norecord@plt2_asi) = n (plt1_ash) ||| n (plt2_asi)
        vertical plt_asj = z (n (plt_asj)) == 0
        rot (!v_aFL) (norecord@(Plt (!n_aFM) (!ls_aFN)))
          = Plt n_aFM [v_aFL `rot` l_aFO | l_aFO <- ls_aFN]
        proj (norecord@(Plt (!n_aFP) ls_aFQ))
          = Plt n_aFP [proj l_aFR | (norecord@l_aFR) <- ls_aFQ]

instance Geom Edge where
        (norecord@l_aFS) ||| k_aFT = h (l_aFS) ||| h (k_aFT)
        vertical (norecord@l_aFU) = vertical (h (l_aFU))
        rot (norecord@v_aFV) l_aFW
          = edgeT (v_aFV `rot` s (l_aFW)) (v_aFV `rot` t (l_aFW))
        proj l_aFX = edgeT (proj (s (l_aFX))) (proj (t (l_aFX)))
        scale (!f_aFY) b_aFZ l_aG0
          = edgeT (scale f_aFY b_aFZ (s (l_aG0)))
              (scale f_aFY b_aFZ (t (l_aG0)))

instance Geom Vector where
        (!v_aG1) ||| w_aG2 = v_aG1 * w_aG2 == 0
        vertical v_aH1 = v_aH1 ||| vec [0, 0, 1]
        rot = rotate
        proj (!v_aH2) = vec [x (v_aH2), y (v_aH2), 0]
        scale (!factor_aH3) (!base_aH4) v_aH5
          = factor_aH3 `mulv` (v_aH5 - base_aH4)

instance Geom a_aH6 => Geom [a_aH6] where
        rot (!viewdir_aH7) = map (rot viewdir_aH7)
        proj = map proj
        scale (!f_aH8) b_aH9 = map (scale f_aH8 b_aH9)

==================== Renamer ====================
Memo.mkmemo ::
  (Plate -> Plate -> a_aVX)
  -> Object -> Array (Memo.Triangle Int) a_aVX
Memo.mkmemo f_aVY (!obj_aVZ)
  = array
      (2 Memo.:^ 1, len_aW0 Memo.:^ (len_aW0 - 1))
      [((top_a12Y Memo.:^ bottom_a130), f_aVY ls_a12X ks_a12Z) |
         (!ls_a12X@((!(Plt (!top_a12Y) _)))) <- obj_aVZ,
         ks_a12Z@(!(Plt bottom_a130 _)) <- obj_aVZ,
         top_a12Y > bottom_a130]
  where
      (!len_aW0) = length obj_aVZ
Memo.lazyAbove ::
  Array (Memo.Triangle Int) Bool -> Plate -> Plate -> Bool
Memo.lazyAbove
  memory_a131
  top_a132@(Plt (!n_a133) _)
  bottom_a134@((!(Plt m_a135 _)))
  | inRange (bounds memory_a131) (n_a133 Memo.:^ m_a135)
  = memory_a131 ! (n_a133 Memo.:^ m_a135)
  | n_a133 == m_a135 = False
  | otherwise
  = if memory_a131 ! (m_a135 Memo.:^ n_a133) then
        False
    else
        top_a132 `above` bottom_a134

data Memo.Triangle a_aAA
  = a_aAA Memo.:^ a_aAA
  deriving (Eq, Ord, Show)

instance (Enum a_a136, Ord a_a136, Ix a_a136) =>
         Ix (Memo.Triangle a_a136) where
  range ((!((!t0_a1ag) Memo.:^ b0_a1ah)), t1_a1ai Memo.:^ (!b1_a1aj))
    = [t_a1ak Memo.:^ b_a1dF |
         t_a1ak <- [t0_a1ag .. t1_a1ai],
         (!b_a1dF) <- take
                        (1 + index (t0_a1ag, t1_a1ai) t_a1ak) [b0_a1ah .. ],
         t_a1ak Memo.:^ b_a1dF <= t1_a1ai Memo.:^ b1_a1aj]
  index
    (!((!t0_a1dG) Memo.:^ (!b0_a1dH), (!((!t1_a1dI) Memo.:^ b1_a1dJ))))
    ((!(t_a1dK Memo.:^ b_a1dL)))
    = ti_a1dM * (ti_a1dM + 1) `div` 2 + index (b0_a1dH, b1_a1dJ) b_a1dL
    where
        ti_a1dM = index (t0_a1dG, t1_a1dI) t_a1dK
  inRange
    (t0_a1mK Memo.:^ (!b0_a1mL), (!((!t1_a1mM) Memo.:^ (!b1_a1mN))))
    ((!((!t_a1mO) Memo.:^ b_a1mP)))
    = inRange (t0_a1mK, t1_a1mM) t_a1mO
      &&
        inRange (b0_a1mL, b1_a1mN) b_a1mP
        &&
          index (t0_a1mK, t1_a1mM) t_a1mO >= index (b0_a1mL, b1_a1mN) b_a1mP


["f_aVY","obj_aVZ","safebang@!obj_aVZ","(!obj_aVZ)","top_a12Y","!top_a12Y","(!top_a12Y)","_","Plt (!top_a12Y) _","(Plt (!top_a12Y) _)","!(Plt (!top_a12Y) _)","(!(Plt (!top_a12Y) _))","((!(Plt (!top_a12Y) _)))","ls_a12X@((!(Plt (!top_a12Y) _)))","!ls_a12X@((!(Plt (!top_a12Y) _)))","(!ls_a12X@((!(Plt (!top_a12Y) _))))","bottom_a130","_","Plt bottom_a130 _","(Plt bottom_a130 _)","!(Plt bottom_a130 _)","(!(Plt bottom_a130 _))","ks_a12Z@(!(Plt bottom_a130 _))","len_aW0","!len_aW0","(!len_aW0)","memory_a131","n_a133","safebang@!n_a133","(!n_a133)","_","Plt (!n_a133) _","(Plt (!n_a133) _)","top_a132@(Plt (!n_a133) _)","m_a135","_","Plt m_a135 _","(Plt m_a135 _)","!(Plt m_a135 _)","(!(Plt m_a135 _))","((!(Plt m_a135 _)))","bottom_a134@((!(Plt m_a135 _)))","t0_a1ag","safebang@!t0_a1ag","(!t0_a1ag)","b0_a1ah","(!t0_a1ag) :^ b0_a1ah","((!t0_a1ag) :^ b0_a1ah)","!((!t0_a1ag) :^ b0_a1ah)","(!((!t0_a1ag) :^ b0_a1ah))","t1_a1ai","b1_a1aj","safebang@!b1_a1aj","(!b1_a1aj)","t1_a1ai :^ (!b1_a1aj)","((!((!t0_a1ag) :^ b0_a1ah)), t1_a1ai :^ (!b1_a1aj))","t_a1ak","b_a1dF","!b_a1dF","(!b_a1dF)","t0_a1dG","safebang@!t0_a1dG","(!t0_a1dG)","b0_a1dH","safebang@!b0_a1dH","(!b0_a1dH)","(!t0_a1dG) :^ (!b0_a1dH)","t1_a1dI","safebang@!t1_a1dI","(!t1_a1dI)","b1_a1dJ","(!t1_a1dI) :^ b1_a1dJ","((!t1_a1dI) :^ b1_a1dJ)","!((!t1_a1dI) :^ b1_a1dJ)","(!((!t1_a1dI) :^ b1_a1dJ))","((!t0_a1dG) :^ (!b0_a1dH), (!((!t1_a1dI) :^ b1_a1dJ)))","!((!t0_a1dG) :^ (!b0_a1dH), (!((!t1_a1dI) :^ b1_a1dJ)))","(!((!t0_a1dG) :^ (!b0_a1dH), (!((!t1_a1dI) :^ b1_a1dJ))))","t_a1dK","b_a1dL","t_a1dK :^ b_a1dL","(t_a1dK :^ b_a1dL)","!(t_a1dK :^ b_a1dL)","(!(t_a1dK :^ b_a1dL))","((!(t_a1dK :^ b_a1dL)))","ti_a1dM","t0_a1mK","b0_a1mL","safebang@!b0_a1mL","(!b0_a1mL)","t0_a1mK :^ (!b0_a1mL)","t1_a1mM","safebang@!t1_a1mM","(!t1_a1mM)","b1_a1mN","safebang@!b1_a1mN","(!b1_a1mN)","(!t1_a1mM) :^ (!b1_a1mN)","((!t1_a1mM) :^ (!b1_a1mN))","!((!t1_a1mM) :^ (!b1_a1mN))","(!((!t1_a1mM) :^ (!b1_a1mN)))","(t0_a1mK :^ (!b0_a1mL), (!((!t1_a1mM) :^ (!b1_a1mN))))","t_a1mO","safebang@!t_a1mO","(!t_a1mO)","b_a1mP","(!t_a1mO) :^ b_a1mP","((!t_a1mO) :^ b_a1mP)","!((!t_a1mO) :^ b_a1mP)","(!((!t_a1mO) :^ b_a1mP))","((!((!t_a1mO) :^ b_a1mP)))"]
module Memo (Triangle, mkmemo, lazyAbove) where
import Numbers
import Vectors
import EdgePlate
import Comparing (above)
import Data.Ix
import Data.Array

mkmemo ::
       (Plate -> Plate -> a_aVX) -> Object -> Array (Triangle Int) a_aVX
mkmemo f_aVY (!obj_aVZ)
  = array (2 :^ 1, len_aW0 :^ (len_aW0 - 1))
      [((top_a12Y :^ bottom_a130), f_aVY ls_a12X ks_a12Z) |
       (norecord@ls_a12X@((norecord@(Plt (norecord@top_a12Y)
                                       _)))) <- obj_aVZ,
       ks_a12Z@(norecord@(Plt bottom_a130 _)) <- obj_aVZ,
       top_a12Y > bottom_a130]
  where (norecord@len_aW0) = length obj_aVZ

lazyAbove :: Array (Triangle Int) Bool -> Plate -> Plate -> Bool
lazyAbove memory_a131 top_a132@(Plt (!n_a133) _)
  bottom_a134@((norecord@(Plt m_a135 _)))
  | inRange (bounds memory_a131) (n_a133 :^ m_a135) =
    memory_a131 ! (n_a133 :^ m_a135)
  | n_a133 == m_a135 = False
  | otherwise =
    if memory_a131 ! (m_a135 :^ n_a133) then False else
      top_a132 `above` bottom_a134

data Triangle a_aAA = a_aAA :^ a_aAA
                    deriving (Eq, Ord, Show)

instance (Enum a_a136, Ord a_a136, Ix a_a136) => Ix
         (Triangle a_a136) where
        range ((norecord@((!t0_a1ag) :^ b0_a1ah)), t1_a1ai :^ (!b1_a1aj))
          = [t_a1ak :^ b_a1dF | t_a1ak <- [t0_a1ag .. t1_a1ai],
             (norecord@b_a1dF) <- take (1 + index (t0_a1ag, t1_a1ai) t_a1ak)
                                    [b0_a1ah ..],
             t_a1ak :^ b_a1dF <= t1_a1ai :^ b1_a1aj]
        index
          (norecord@((!t0_a1dG) :^ (!b0_a1dH),
                     (norecord@((!t1_a1dI) :^ b1_a1dJ))))
          ((norecord@(t_a1dK :^ b_a1dL)))
          = ti_a1dM * (ti_a1dM + 1) `div` 2 + index (b0_a1dH, b1_a1dJ) b_a1dL
          where ti_a1dM = index (t0_a1dG, t1_a1dI) t_a1dK
        inRange
          (t0_a1mK :^ (!b0_a1mL), (norecord@((!t1_a1mM) :^ (!b1_a1mN))))
          ((norecord@((!t_a1mO) :^ b_a1mP)))
          = inRange (t0_a1mK, t1_a1mM) t_a1mO &&
              inRange (b0_a1mL, b1_a1mN) b_a1mP
              && index (t0_a1mK, t1_a1mM) t_a1mO
              >= index (b0_a1mL, b1_a1mN) b_a1mP

==================== Renamer ====================
Preds.onto :: Vector -> Edge -> Bool
Preds.onto (!p_atn) l_ato
  | vertical l_ato = proj (p_atn) == proj (s (l_ato))
  | otherwise
  = v_atp ||| w_atq
    &&
      0 <= v_atp `inpr` w_atq && v_atp `inpr` w_atq <= w_atq `inpr` w_atq
  where
      (!v_atp) = proj (p_atn - s (l_ato))
      w_atq = proj (h (l_ato))
Preds.into :: Vector -> Plate -> Bool
Preds.into (!v_aHQ) (!p_aHR@(!(Plt _ ls_aHS)))
  | vertical p_aHR
  = or [v_aHQ `Preds.onto` l_aO2 | (!l_aO2) <- ls_aHS]
  | otherwise
  = and [a_aO3 >= 0 | a_aO3 <- zs_aHT]
    || and [a_aO4 <= 0 | (!a_aO4) <- zs_aHT]
  where
      zs_aHT = [z ((v_aHQ - s (l_aHU)) * h (l_aHU)) | (!l_aHU) <- ls_aHS]


["p_atn","!p_atn","(!p_atn)","l_ato","v_atp","!v_atp","(!v_atp)","w_atq","v_aHQ","safebang@!v_aHQ","(!v_aHQ)","_","ls_aHS","Plt _ ls_aHS","(Plt _ ls_aHS)","!(Plt _ ls_aHS)","(!(Plt _ ls_aHS))","p_aHR@(!(Plt _ ls_aHS))","!p_aHR@(!(Plt _ ls_aHS))","(!p_aHR@(!(Plt _ ls_aHS)))","l_aO2","!l_aO2","(!l_aO2)","a_aO3","a_aO4","!a_aO4","(!a_aO4)","zs_aHT","l_aHU","!l_aHU","(!l_aHU)"]
module Preds (into, onto) where
import Numbers
import Vectors
import EdgePlate
import Geometric

onto :: Vector -> Edge -> Bool
onto (norecord@p_atn) l_ato
  | vertical l_ato = proj (p_atn) == proj (s (l_ato))
  | otherwise =
    v_atp ||| w_atq && 0 <= v_atp `inpr` w_atq && v_atp `inpr` w_atq <=
      w_atq
      `inpr` w_atq
  where (norecord@v_atp) = proj (p_atn - s (l_ato))
        w_atq = proj (h (l_ato))

into :: Vector -> Plate -> Bool
into (!v_aHQ) (norecord@p_aHR@(norecord@(Plt _ ls_aHS)))
  | vertical p_aHR =
    or [v_aHQ `onto` l_aO2 | (norecord@l_aO2) <- ls_aHS]
  | otherwise =
    and [a_aO3 >= 0 | a_aO3 <- zs_aHT] ||
      and [a_aO4 <= 0 | (norecord@a_aO4) <- zs_aHT]
  where zs_aHT
          = [z ((v_aHQ - s (l_aHU)) * h (l_aHU)) |
             (norecord@l_aHU) <- ls_aHS]

==================== Renamer ====================
MyIO.getFilename :: (String -> MyIO.InputCont) -> MyIO.InputCont
MyIO.getFilename (!success_awe) inp_awf
  = getArgs
    >>=
      \ (!args_aAc)
        -> case args_aAc of {
             "help" : (!_) -> MyIO.usage
             [filename_aAd] -> success_awe filename_aAd inp_awf
             (![]) -> fromInp_awh inp_awf
             (!_) -> MyIO.usage }
  where
      test_awg (!filename_awi) inp_awj ((!'t') : (!('r' : (!_))))
        = success_awe filename_awi inp_awj
      test_awg (!filename_awk) inp_awl (!((!('f' : ('r' : (!_))))))
        = success_awe filename_awk inp_awl
      test_awg (!filename_awm) inp_awn (!_)
        = hPutStr stderr ("Can not read: " ++ filename_awm ++ "\n")
          >> hPutStr stderr "Give the filename of an object: "
          >> fromInp_awh inp_awn
      fromInp_awh = error "fromInp"
MyIO.usage
  = hPutStr stderr "Usage: hiddenline [filename of object]\n"
MyIO.getDirection, MyIO.getit ::
  (Vector -> MyIO.InputCont) -> MyIO.InputCont
MyIO.getDirection success_aAe inp_aAf
  = hPutStr
      stderr
      ("Give a view direction in the form of: x,y,z\n"
       ++ "or 'quit' to stop\n")
    >> MyIO.getit success_aAe inp_aAf
MyIO.getit (!success_aAg) (![]) = return ()
MyIO.getit success_aAh ((!((!"quit") : ls_aAi))) = return ()
MyIO.getit success_aAj (!(l_aAk : (!ls_aAl)))
  = case reads ("vec [" ++ l_aAk ++ "]") of {
      [(v_aBb, (!_))] -> success_aAj v_aBb ls_aAl
      _ -> hPutStr stderr "again: " >> MyIO.getit success_aAj ls_aAl }
MyIO.process ::
  (Vector -> String -> String) -> String -> MyIO.InputCont
MyIO.process f_aBc filename_aBd
  = MyIO.getDirection
      (\ viewdir_aBj (!ls_aBk)
         -> readFile filename_aBd
            >>=
              \ cs_aBl
                -> printFrom_aBe
                     viewdir_aBj (MyIO.process f_aBc filename_aBd) cs_aBl ls_aBk)
  where
      printFrom_aBe viewdir_aBf cont_aBg (!cs_aBh) ls_aBi
        = putStr (f_aBc viewdir_aBf cs_aBh) >> cont_aBg ls_aBi

type MyIO.InputCont = [String] -> IO ()



==================== Renamer ====================
Comparing.cmp :: Plate -> [Edge] -> [Edge]
Comparing.cmp (!p_av9) ls_ava
  = concat [Comparing.comp l_aBa p_av9 | (!l_aBa) <- ls_ava]
Comparing.comp :: Edge -> Plate -> [Edge]
Comparing.comp l_aBb (!p_aBc@(Plt (!_) ks_aBd))
  = if inS_aBe && inT_aBf then
        []
    else
        if crosses_aBg == [] then
            [l_aBb]
        else
            if inS_aBe && not inT_aBf then
                [edgeT w_aBk (t l_aBb)]
            else
                if not inS_aBe && inT_aBf then
                    [edgeT (s l_aBb) v_aBj]
                else
                    [edgeT (s l_aBb) v_aBj, edgeT w_aBk (t l_aBb)]
  where
      (!inS_aBe) = s (l_aBb) `into` p_aBc
      (!inT_aBf) = t (l_aBb) `into` p_aBc
      crosses_aBg
        = nub
            [p_aDJ |
               (!k_aDI) <- ks_aBd, (!(p_aDJ, (!q_aDK))) <- cross l_aBb k_aDI]
      cr1_aBh = head crosses_aBg
      cr2_aBi = last crosses_aBg
      ((!v_aBj), w_aBk)
        = if len (s (l_aBb) - cr1_aBh) <= len (s (l_aBb) - cr2_aBi) then
              (cr1_aBh, cr2_aBi)
          else
              (cr2_aBi, cr1_aBh)
Comparing.above :: Plate -> Plate -> Bool
Comparing.above ls_aVj (!ks_aVk)
  = if vertical ls_aVj then
        if vertical ks_aVk then
            or [z (p_aVq) > z (q_aVr) | p_aVq <- olk_aVl, (!q_aVr) <- okl_aVm]
        else
            or [z (p_aVs) > alt ks_aVk p_aVs | (!p_aVs) <- olk_aVl]
    else
        if vertical ks_aVk then
            or [alt ls_aVj q_aVt > z (q_aVt) | (!q_aVt) <- okl_aVm]
        else
            or [alt ls_aVj p_aVu > alt ks_aVk p_aVu | p_aVu <- ovl_aVn]
  where
      (!olk_aVl) = overlap ls_aVj ks_aVk
      okl_aVm = overlap ks_aVk ls_aVj
      (!ovl_aVn)
        = nub
            ([proj p_aVo | p_aVo <- olk_aVl]
             ++ [proj p_aVp | p_aVp <- okl_aVm])


["p_av9","safebang@!p_av9","(!p_av9)","ls_ava","l_aBa","!l_aBa","(!l_aBa)","l_aBb","_","!_","(!_)","ks_aBd","Plt (!_) ks_aBd","(Plt (!_) ks_aBd)","p_aBc@(Plt (!_) ks_aBd)","!p_aBc@(Plt (!_) ks_aBd)","(!p_aBc@(Plt (!_) ks_aBd))","inS_aBe","safebang@!inS_aBe","(!inS_aBe)","inT_aBf","!inT_aBf","(!inT_aBf)","crosses_aBg","k_aDI","!k_aDI","(!k_aDI)","p_aDJ","q_aDK","safebang@!q_aDK","(!q_aDK)","(p_aDJ, (!q_aDK))","!(p_aDJ, (!q_aDK))","(!(p_aDJ, (!q_aDK)))","cr1_aBh","cr2_aBi","v_aBj","!v_aBj","(!v_aBj)","w_aBk","((!v_aBj), w_aBk)","ls_aVj","ks_aVk","!ks_aVk","(!ks_aVk)","p_aVq","q_aVr","!q_aVr","(!q_aVr)","p_aVs","!p_aVs","(!p_aVs)","q_aVt","!q_aVt","(!q_aVt)","p_aVu","olk_aVl","safebang@!olk_aVl","(!olk_aVl)","okl_aVm","ovl_aVn","lazydmd@!ovl_aVn","(!ovl_aVn)","p_aVo","p_aVp"]
module Comparing (above, cmp) where
import Numbers
import Vectors
import EdgePlate
import Preds
import Solve
import Geometric
import Cross
import Data.List (nub)

cmp :: Plate -> [Edge] -> [Edge]
cmp (!p_av9) ls_ava
  = concat [comp l_aBa p_av9 | (norecord@l_aBa) <- ls_ava]

comp :: Edge -> Plate -> [Edge]
comp l_aBb (norecord@p_aBc@(Plt (norecord@_) ks_aBd))
  = if inS_aBe && inT_aBf then [] else
      if crosses_aBg == [] then [l_aBb] else
        if inS_aBe && not inT_aBf then [edgeT w_aBk (t l_aBb)] else
          if not inS_aBe && inT_aBf then [edgeT (s l_aBb) v_aBj] else
            [edgeT (s l_aBb) v_aBj, edgeT w_aBk (t l_aBb)]
  where (!inS_aBe) = s (l_aBb) `into` p_aBc
        (norecord@inT_aBf) = t (l_aBb) `into` p_aBc
        crosses_aBg
          = nub
              [p_aDJ | (norecord@k_aDI) <- ks_aBd,
               (norecord@(p_aDJ, (!q_aDK))) <- cross l_aBb k_aDI]
        cr1_aBh = head crosses_aBg
        cr2_aBi = last crosses_aBg
        ((norecord@v_aBj), w_aBk)
          = if len (s (l_aBb) - cr1_aBh) <= len (s (l_aBb) - cr2_aBi) then
              (cr1_aBh, cr2_aBi) else (cr2_aBi, cr1_aBh)

above :: Plate -> Plate -> Bool
above ls_aVj (norecord@ks_aVk)
  = if vertical ls_aVj then
      if vertical ks_aVk then
        or
          [z (p_aVq) > z (q_aVr) | p_aVq <- olk_aVl,
           (norecord@q_aVr) <- okl_aVm]
        else
        or [z (p_aVs) > alt ks_aVk p_aVs | (norecord@p_aVs) <- olk_aVl]
      else
      if vertical ks_aVk then
        or [alt ls_aVj q_aVt > z (q_aVt) | (norecord@q_aVt) <- okl_aVm]
        else or [alt ls_aVj p_aVu > alt ks_aVk p_aVu | p_aVu <- ovl_aVn]
  where (!olk_aVl) = overlap ls_aVj ks_aVk
        okl_aVm = overlap ks_aVk ls_aVj
        (lazydmd@ovl_aVn)
          = nub
              ([proj p_aVo | p_aVo <- olk_aVl] ++
                 [proj p_aVp | p_aVp <- okl_aVm])

==================== Renamer ====================
Matrices.mat :: [Vector] -> Matrices.Matrix
Matrices.mat (!m_ar0) = m_ar0
Matrices.rows :: Matrices.Matrix -> [Vector]
Matrices.rows m_ar1 = m_ar1
Matrices.mulm :: Matrices.Matrix -> Vector -> Vector
Matrices.mulm (!m_ar2) v_ar3
  = vec (map (inpr v_ar3) (Matrices.rows m_ar2))

type Matrices.Matrix = [Vector]


["m_ar0","safebang@!m_ar0","(!m_ar0)","m_ar1","m_ar2","safebang@!m_ar2","(!m_ar2)","v_ar3"]
module Matrices (Matrix, mat, rows, mulm) where
import Numbers
import Vectors

mat :: [Vector] -> Matrix
mat (!m_ar0) = m_ar0

rows :: Matrix -> [Vector]
rows m_ar1 = m_ar1

mulm :: Matrix -> Vector -> Vector
mulm (!m_ar2) v_ar3 = vec (map (inpr v_ar3) (rows m_ar2))

type Matrix = [Vector]

==================== Renamer ====================
Numbers.eps = 1.0e-4 :: Float

data Numbers.Number = Numbers.Tolerant Float

instance Show Numbers.Number where
  showsPrec (!p_a14R) ((!(Numbers.Tolerant x_a14S)))
    = showsPrec p_a14R x_a14S
instance Read Numbers.Number where
  readsPrec p_a14T s_a14U
    = [(Numbers.Tolerant n_a14V, t_a14W) |
         (n_a14V, (!t_a14W)) <- readsPrec p_a14T s_a14U]
instance Floating Numbers.Number where
  sqrt (!(Numbers.Tolerant (!a_a14X)))
    = Numbers.Tolerant (sqrt a_a14X)
instance Fractional Numbers.Number where
  (!(Numbers.Tolerant a_a14Y)) / (Numbers.Tolerant (!b_a14Z))
    = Numbers.Tolerant (a_a14Y / b_a14Z)
instance Num Numbers.Number where
  (Numbers.Tolerant a_a150) + (Numbers.Tolerant (!b_a151))
    = Numbers.Tolerant (a_a150 + b_a151)
  (Numbers.Tolerant a_a152) - (Numbers.Tolerant (!b_a153))
    = Numbers.Tolerant (a_a152 - b_a153)
  (!(Numbers.Tolerant (!a_a154))) * (Numbers.Tolerant (!b_a155))
    = Numbers.Tolerant (a_a154 * b_a155)
  negate (!(Numbers.Tolerant (!a_a156)))
    = Numbers.Tolerant (- a_a156)
  fromInteger n_a157 = Numbers.Tolerant (fromInteger n_a157)
instance Ord Numbers.Number where
  (!(Numbers.Tolerant (!a_a158))) <= (Numbers.Tolerant (!b_a159))
    = a_a158 - Numbers.eps < b_a159
  (Numbers.Tolerant (!a_a15a)) < (!(Numbers.Tolerant (!b_a15b)))
    = a_a15a < b_a15b - Numbers.eps
instance Eq Numbers.Number where
  (Numbers.Tolerant (!a_a15c)) == (Numbers.Tolerant (!b_a15d))
    = abs (a_a15c - b_a15d) < Numbers.eps
  (Numbers.Tolerant (!a_a15e)) /= (Numbers.Tolerant b_a15f)
    = abs (a_a15e - b_a15f) > Numbers.eps


["eps","p_a14R","safebang@!p_a14R","(!p_a14R)","x_a14S","Tolerant x_a14S","(Tolerant x_a14S)","!(Tolerant x_a14S)","(!(Tolerant x_a14S))","((!(Tolerant x_a14S)))","p_a14T","s_a14U","n_a14V","t_a14W","safebang@!t_a14W","(!t_a14W)","(n_a14V, (!t_a14W))","a_a14X","safebang@!a_a14X","(!a_a14X)","Tolerant (!a_a14X)","(Tolerant (!a_a14X))","!(Tolerant (!a_a14X))","(!(Tolerant (!a_a14X)))","a_a14Y","Tolerant a_a14Y","(Tolerant a_a14Y)","!(Tolerant a_a14Y)","(!(Tolerant a_a14Y))","b_a14Z","safebang@!b_a14Z","(!b_a14Z)","Tolerant (!b_a14Z)","(Tolerant (!b_a14Z))","a_a150","Tolerant a_a150","(Tolerant a_a150)","b_a151","safebang@!b_a151","(!b_a151)","Tolerant (!b_a151)","(Tolerant (!b_a151))","a_a152","Tolerant a_a152","(Tolerant a_a152)","b_a153","safebang@!b_a153","(!b_a153)","Tolerant (!b_a153)","(Tolerant (!b_a153))","a_a154","safebang@!a_a154","(!a_a154)","Tolerant (!a_a154)","(Tolerant (!a_a154))","!(Tolerant (!a_a154))","(!(Tolerant (!a_a154)))","b_a155","safebang@!b_a155","(!b_a155)","Tolerant (!b_a155)","(Tolerant (!b_a155))","a_a156","safebang@!a_a156","(!a_a156)","Tolerant (!a_a156)","(Tolerant (!a_a156))","!(Tolerant (!a_a156))","(!(Tolerant (!a_a156)))","n_a157","a_a158","safebang@!a_a158","(!a_a158)","Tolerant (!a_a158)","(Tolerant (!a_a158))","!(Tolerant (!a_a158))","(!(Tolerant (!a_a158)))","b_a159","safebang@!b_a159","(!b_a159)","Tolerant (!b_a159)","(Tolerant (!b_a159))","a_a15a","safebang@!a_a15a","(!a_a15a)","Tolerant (!a_a15a)","(Tolerant (!a_a15a))","b_a15b","safebang@!b_a15b","(!b_a15b)","Tolerant (!b_a15b)","(Tolerant (!b_a15b))","!(Tolerant (!b_a15b))","(!(Tolerant (!b_a15b)))","a_a15c","safebang@!a_a15c","(!a_a15c)","Tolerant (!a_a15c)","(Tolerant (!a_a15c))","b_a15d","safebang@!b_a15d","(!b_a15d)","Tolerant (!b_a15d)","(Tolerant (!b_a15d))","a_a15e","safebang@!a_a15e","(!a_a15e)","Tolerant (!a_a15e)","(Tolerant (!a_a15e))","b_a15f","Tolerant b_a15f","(Tolerant b_a15f)"]
module Numbers (Number) where
eps = 1.0e-4 :: Float

data Number = Tolerant Float

instance Show Number where
        showsPrec (!p_a14R) ((norecord@(Tolerant x_a14S)))
          = showsPrec p_a14R x_a14S

instance Read Number where
        readsPrec p_a14T s_a14U
          = [(Tolerant n_a14V, t_a14W) |
             (n_a14V, (!t_a14W)) <- readsPrec p_a14T s_a14U]

instance Floating Number where
        sqrt (norecord@(Tolerant (!a_a14X))) = Tolerant (sqrt a_a14X)

instance Fractional Number where
        (norecord@(Tolerant a_a14Y)) / (Tolerant (!b_a14Z))
          = Tolerant (a_a14Y / b_a14Z)

instance Num Number where
        (Tolerant a_a150) + (Tolerant (!b_a151))
          = Tolerant (a_a150 + b_a151)
        (Tolerant a_a152) - (Tolerant (!b_a153))
          = Tolerant (a_a152 - b_a153)
        (norecord@(Tolerant (!a_a154))) * (Tolerant (!b_a155))
          = Tolerant (a_a154 * b_a155)
        negate (norecord@(Tolerant (!a_a156))) = Tolerant (-a_a156)
        fromInteger n_a157 = Tolerant (fromInteger n_a157)

instance Ord Number where
        (norecord@(Tolerant (!a_a158))) <= (Tolerant (!b_a159))
          = a_a158 - eps < b_a159
        (Tolerant (!a_a15a)) < (norecord@(Tolerant (!b_a15b)))
          = a_a15a < b_a15b - eps

instance Eq Number where
        (Tolerant (!a_a15c)) == (Tolerant (!b_a15d))
          = abs (a_a15c - b_a15d) < eps
        (Tolerant (!a_a15e)) /= (Tolerant b_a15f)
          = abs (a_a15e - b_a15f) > eps

==================== Renamer ====================
Vectors.vec :: [Number] -> Vectors.Vector
Vectors.vec = Vectors.Vec
Vectors.x, Vectors.y, Vectors.z :: Vectors.Vector -> Number
Vectors.x ((!(Vectors.Vec v_aXZ))) = v_aXZ !! 0
Vectors.y (!((!(Vectors.Vec v_a11A)))) = v_a11A !! 1
Vectors.z ((!(Vectors.Vec v_a11B))) = v_a11B !! 2
Vectors.inpr :: Vectors.Vector -> Vectors.Vector -> Number
Vectors.inpr (Vectors.Vec (!v1_a11C)) (Vectors.Vec v2_a11D)
  = sum (zipWith (*) v1_a11C v2_a11D)
Vectors.mulv :: Number -> Vectors.Vector -> Vectors.Vector
Vectors.mulv (!c_a17A) ((!(Vectors.Vec v_a17B)))
  = Vectors.Vec (map (c_a17A *) v_a17B)
Vectors.len :: Vectors.Vector -> Number
Vectors.len (!v_a17C) = sqrt (v_a17C `Vectors.inpr` v_a17C)
Vectors.norm :: Vectors.Vector -> Vectors.Vector
Vectors.norm v_a17D
  = (1 / Vectors.len v_a17D) `Vectors.mulv` v_a17D

data Vectors.Vector
  = Vectors.Vec [Number]
  deriving (Eq)

instance Read Vectors.Vector where
  readsPrec p_a1gG
    = readParen (p_a1gG > 9) rd_a1gH
    where
        rd_a1gH s_a1gI
          = [(Vectors.Vec ns_a1gK, u_a1gL) |
               (!((!"vec"), t_a1gJ)) <- lex s_a1gI,
               ((!ns_a1gK), (!u_a1gL)) <- readList t_a1gJ,
               length ns_a1gK >= 2]
instance Show Vectors.Vector where
  showsPrec p_a1gM ((!(Vectors.Vec v_a1gN)))
    = showParen (p_a1gM > 9) (showString "vec " . showList v_a1gN)
instance Num Vectors.Vector where
  (Vectors.Vec (!v_a1gO)) + (Vectors.Vec (!w_a1gP))
    = Vectors.Vec (zipWith (+) v_a1gO w_a1gP)
  (Vectors.Vec (!v_a1gQ)) - (Vectors.Vec w_a1gR)
    = Vectors.Vec (zipWith (-) v_a1gQ w_a1gR)
  (!v_a1gS) * (!w_a1gT)
    = Vectors.Vec
        [Vectors.y (v_a1gS) * Vectors.z (w_a1gT)
         - Vectors.y (w_a1gT) * Vectors.z (v_a1gS),
         Vectors.z (v_a1gS) * Vectors.x (w_a1gT)
         - Vectors.z (w_a1gT) * Vectors.x (v_a1gS),
         Vectors.x (v_a1gS) * Vectors.y (w_a1gT)
         - Vectors.x (w_a1gT) * Vectors.y (v_a1gS)]
  negate (!(Vectors.Vec (!v_a1gU))) = Vectors.Vec (map negate v_a1gU)
  abs v_a1gV = Vectors.Vec [Vectors.len v_a1gV]
  signum (!v_a1gW) = Vectors.norm v_a1gW
  fromInteger (!0) = Vectors.Vec [0, 0, 0]


["vec","v_aXZ","Vec v_aXZ","(Vec v_aXZ)","!(Vec v_aXZ)","(!(Vec v_aXZ))","((!(Vec v_aXZ)))","v_a11A","Vec v_a11A","(Vec v_a11A)","!(Vec v_a11A)","(!(Vec v_a11A))","((!(Vec v_a11A)))","!((!(Vec v_a11A)))","(!((!(Vec v_a11A))))","v_a11B","Vec v_a11B","(Vec v_a11B)","!(Vec v_a11B)","(!(Vec v_a11B))","((!(Vec v_a11B)))","v1_a11C","safebang@!v1_a11C","(!v1_a11C)","Vec (!v1_a11C)","(Vec (!v1_a11C))","v2_a11D","Vec v2_a11D","(Vec v2_a11D)","c_a17A","safebang@!c_a17A","(!c_a17A)","v_a17B","Vec v_a17B","(Vec v_a17B)","!(Vec v_a17B)","(!(Vec v_a17B))","((!(Vec v_a17B)))","v_a17C","!v_a17C","(!v_a17C)","v_a17D","p_a1gG","s_a1gI","\"vec\"","!\"vec\"","(!\"vec\")","t_a1gJ","((!\"vec\"), t_a1gJ)","!((!\"vec\"), t_a1gJ)","(!((!\"vec\"), t_a1gJ))","ns_a1gK","safebang@!ns_a1gK","(!ns_a1gK)","u_a1gL","safebang@!u_a1gL","(!u_a1gL)","((!ns_a1gK), (!u_a1gL))","p_a1gM","v_a1gN","Vec v_a1gN","(Vec v_a1gN)","!(Vec v_a1gN)","(!(Vec v_a1gN))","((!(Vec v_a1gN)))","v_a1gO","safebang@!v_a1gO","(!v_a1gO)","Vec (!v_a1gO)","(Vec (!v_a1gO))","w_a1gP","safebang@!w_a1gP","(!w_a1gP)","Vec (!w_a1gP)","(Vec (!w_a1gP))","v_a1gQ","safebang@!v_a1gQ","(!v_a1gQ)","Vec (!v_a1gQ)","(Vec (!v_a1gQ))","w_a1gR","Vec w_a1gR","(Vec w_a1gR)","v_a1gS","safebang@!v_a1gS","(!v_a1gS)","w_a1gT","safebang@!w_a1gT","(!w_a1gT)","v_a1gU","safebang@!v_a1gU","(!v_a1gU)","Vec (!v_a1gU)","(Vec (!v_a1gU))","!(Vec (!v_a1gU))","(!(Vec (!v_a1gU)))","v_a1gV","v_a1gW","!v_a1gW","(!v_a1gW)","0","!0","(!0)"]
module Vectors (Vector, vec, x, y, z, inpr, mulv, len, norm) where
import Numbers

vec :: [Number] -> Vector
vec = Vec

x, y, z :: Vector -> Number
x ((norecord@(Vec v_aXZ))) = v_aXZ !! 0
y (norecord@((norecord@(Vec v_a11A)))) = v_a11A !! 1
z ((norecord@(Vec v_a11B))) = v_a11B !! 2

inpr :: Vector -> Vector -> Number
inpr (Vec (!v1_a11C)) (Vec v2_a11D)
  = sum (zipWith (*) v1_a11C v2_a11D)

mulv :: Number -> Vector -> Vector
mulv (!c_a17A) ((norecord@(Vec v_a17B)))
  = Vec (map (c_a17A *) v_a17B)

len :: Vector -> Number
len (norecord@v_a17C) = sqrt (v_a17C `inpr` v_a17C)

norm :: Vector -> Vector
norm v_a17D = (1 / len v_a17D) `mulv` v_a17D

data Vector = Vec [Number]
            deriving Eq

instance Read Vector where
        readsPrec p_a1gG = readParen (p_a1gG > 9) rd_a1gH
          where rd_a1gH s_a1gI
                  = [(Vec ns_a1gK, u_a1gL) |
                     (norecord@((norecord@"vec"), t_a1gJ)) <- lex s_a1gI,
                     ((!ns_a1gK), (!u_a1gL)) <- readList t_a1gJ, length ns_a1gK >= 2]

instance Show Vector where
        showsPrec p_a1gM ((norecord@(Vec v_a1gN)))
          = showParen (p_a1gM > 9) (showString "vec " . showList v_a1gN)

instance Num Vector where
        (Vec (!v_a1gO)) + (Vec (!w_a1gP)) = Vec (zipWith (+) v_a1gO w_a1gP)
        (Vec (!v_a1gQ)) - (Vec w_a1gR) = Vec (zipWith (-) v_a1gQ w_a1gR)
        (!v_a1gS) * (!w_a1gT)
          = Vec
              [y (v_a1gS) * z (w_a1gT) - y (w_a1gT) * z (v_a1gS),
               z (v_a1gS) * x (w_a1gT) - z (w_a1gT) * x (v_a1gS),
               x (v_a1gS) * y (w_a1gT) - x (w_a1gT) * y (v_a1gS)]
        negate (norecord@(Vec (!v_a1gU))) = Vec (map negate v_a1gU)
        abs v_a1gV = Vec [len v_a1gV]
        signum (norecord@v_a1gW) = norm v_a1gW
        fromInteger (norecord@0) = Vec [0, 0, 0]

==================== Renamer ====================
Hide.hiddenline :: Vector -> Input -> Output
Hide.hiddenline (!v_aDW) corners_aDX
  = (draw . scale factor_aE0 base_aDZ . Hide.hideObj . makeObject)
      rotated_aDY
  where
      (!rotated_aDY) = v_aDW `rot` corners_aDX
      (base_aDZ, (!factor_aE0)) = Hide.getExtremes (concat rotated_aDY)
Hide.hide :: Array (Triangle Int) Bool -> Object -> Plate -> [Edge]
Hide.hide
  memory_aK0
  obj_aK1
  (!bottom_aK2@((!(Plt (!_) (!ls_aK3)))))
  = foldr cmp ls_aK3 tops_aK4
  where
      tops_aK4
        = [top_aK5 |
             (!top_aK5) <- obj_aK1, lazyAbove memory_aK0 top_aK5 bottom_aK2]
Hide.hideObj :: Object -> [Edge]
Hide.hideObj (!obj_aK6)
  = concat
      [Hide.hide (mkmemo above obj_aK6) obj_aK6 plt_aK7 |
         plt_aK7 <- obj_aK6]
Hide.getExtremes :: [Vector] -> (Vector, Number)
Hide.getExtremes vs_aK8
  = (vec [minimum xs_aKa, minimum ys_aKb, 0], factor_aK9)
  where
      (!factor_aK9)
        = ((400 / ((maximum xs_aKa - minimum xs_aKa) `max` 1))
           `min` (640 / ((maximum ys_aKb - minimum ys_aKb) `max` 1)))
      xs_aKa = map x vs_aK8
      ys_aKb = map y vs_aK8


["v_aDW","safebang@!v_aDW","(!v_aDW)","corners_aDX","rotated_aDY","safebang@!rotated_aDY","(!rotated_aDY)","base_aDZ","factor_aE0","!factor_aE0","(!factor_aE0)","(base_aDZ, (!factor_aE0))","memory_aK0","obj_aK1","_","!_","(!_)","ls_aK3","!ls_aK3","(!ls_aK3)","Plt (!_) (!ls_aK3)","(Plt (!_) (!ls_aK3))","!(Plt (!_) (!ls_aK3))","(!(Plt (!_) (!ls_aK3)))","((!(Plt (!_) (!ls_aK3))))","bottom_aK2@((!(Plt (!_) (!ls_aK3))))","!bottom_aK2@((!(Plt (!_) (!ls_aK3))))","(!bottom_aK2@((!(Plt (!_) (!ls_aK3)))))","tops_aK4","top_aK5","!top_aK5","(!top_aK5)","obj_aK6","!obj_aK6","(!obj_aK6)","plt_aK7","vs_aK8","factor_aK9","!factor_aK9","(!factor_aK9)","xs_aKa","ys_aKb"]
module Hide (hiddenline) where
import Numbers
import Vectors
import EdgePlate
import Geometric
import Comparing
import Memo
import Postscript
import Data.Array

hiddenline :: Vector -> Input -> Output
hiddenline (!v_aDW) corners_aDX
  = (draw . scale factor_aE0 base_aDZ . hideObj . makeObject)
      rotated_aDY
  where (!rotated_aDY) = v_aDW `rot` corners_aDX
        (base_aDZ, (norecord@factor_aE0))
          = getExtremes (concat rotated_aDY)

hide :: Array (Triangle Int) Bool -> Object -> Plate -> [Edge]
hide memory_aK0 obj_aK1
  (norecord@bottom_aK2@((norecord@(Plt (norecord@_)
                                     (norecord@ls_aK3)))))
  = foldr cmp ls_aK3 tops_aK4
  where tops_aK4
          = [top_aK5 | (norecord@top_aK5) <- obj_aK1,
             lazyAbove memory_aK0 top_aK5 bottom_aK2]

hideObj :: Object -> [Edge]
hideObj (norecord@obj_aK6)
  = concat
      [hide (mkmemo above obj_aK6) obj_aK6 plt_aK7 | plt_aK7 <- obj_aK6]

getExtremes :: [Vector] -> (Vector, Number)
getExtremes vs_aK8
  = (vec [minimum xs_aKa, minimum ys_aKb, 0], factor_aK9)
  where (norecord@factor_aK9)
          = ((400 / ((maximum xs_aKa - minimum xs_aKa) `max` 1)) `min`
               (640 / ((maximum ys_aKb - minimum ys_aKb) `max` 1)))
        xs_aKa = map x vs_aK8
        ys_aKb = map y vs_aK8

==================== Renamer ====================
Solve.solve :: Vector -> Vector -> Vector -> [(Number, Number)]
Solve.solve (!v1_arD) v2_arE (!w_arF)
  = let determinant_arG = z (v1_arD * v2_arE)
    in
      if determinant_arG == 0 then
          []
      else
          [(z (w_arF * v2_arE) / determinant_arG, 
            z (v1_arD * w_arF) / determinant_arG)]
Solve.alt :: Plate -> Vector -> Number
Solve.alt (!(Plt (!_) (!((!(l1_aPb : (!(l2_aPc : _)))))))) p_aPk
  = z (sl1_aPl + lambda_aPo `mulv` hl1_aPm + mu_aPp `mulv` hl2_aPn)
  where
      (!sl1_aPl) = s (l1_aPb)
      (!hl1_aPm) = h (l1_aPb)
      hl2_aPn = h (l2_aPc)
      [(lambda_aPo, (!mu_aPp))]
        = Solve.solve hl1_aPm hl2_aPn (p_aPk - sl1_aPl)


["v1_arD","safebang@!v1_arD","(!v1_arD)","v2_arE","w_arF","safebang@!w_arF","(!w_arF)","determinant_arG","_","!_","(!_)","l1_aPb","l2_aPc","_","l2_aPc : _","(l2_aPc : _)","!(l2_aPc : _)","(!(l2_aPc : _))","l1_aPb : (!(l2_aPc : _))","(l1_aPb : (!(l2_aPc : _)))","!(l1_aPb : (!(l2_aPc : _)))","(!(l1_aPb : (!(l2_aPc : _))))","((!(l1_aPb : (!(l2_aPc : _)))))","!((!(l1_aPb : (!(l2_aPc : _)))))","(!((!(l1_aPb : (!(l2_aPc : _))))))","Plt (!_) (!((!(l1_aPb : (!(l2_aPc : _))))))","(Plt (!_) (!((!(l1_aPb : (!(l2_aPc : _)))))))","!(Plt (!_) (!((!(l1_aPb : (!(l2_aPc : _)))))))","(!(Plt (!_) (!((!(l1_aPb : (!(l2_aPc : _))))))))","p_aPk","sl1_aPl","!sl1_aPl","(!sl1_aPl)","hl1_aPm","safebang@!hl1_aPm","(!hl1_aPm)","hl2_aPn","lambda_aPo","mu_aPp","!mu_aPp","(!mu_aPp)","(lambda_aPo, (!mu_aPp))","[(lambda_aPo, (!mu_aPp))]"]
module Solve (solve, alt) where
import Numbers
import Vectors
import EdgePlate

solve :: Vector -> Vector -> Vector -> [(Number, Number)]
solve (!v1_arD) v2_arE (!w_arF)
  = let determinant_arG = z (v1_arD * v2_arE) in
      if determinant_arG == 0 then [] else
        [(z (w_arF * v2_arE) / determinant_arG,
          z (v1_arD * w_arF) / determinant_arG)]

alt :: Plate -> Vector -> Number
alt
  (norecord@(Plt (norecord@_)
               (norecord@((norecord@(l1_aPb : (norecord@(l2_aPc : _))))))))
  p_aPk
  = z (sl1_aPl + lambda_aPo `mulv` hl1_aPm + mu_aPp `mulv` hl2_aPn)
  where (norecord@sl1_aPl) = s (l1_aPb)
        (!hl1_aPm) = h (l1_aPb)
        hl2_aPn = h (l2_aPc)
        [(lambda_aPo, (norecord@mu_aPp))]
          = solve hl1_aPm hl2_aPn (p_aPk - sl1_aPl)

==================== Renamer ====================
Main.preparse :: String -> [Main.PreLine]
Main.preparse = concatMap Main.preparseLine . zip [1 .. ] . lines
Main.preparseLine :: (Int, String) -> [Main.PreLine]
Main.preparseLine (!(line_number_a1F3, (!s_a1F4)))
  | null cleaned_a1F5 = []
  | looks_like_label_a1F7 cleaned_a1F5
  = case span Main.isLabelIsh cleaned_a1F5 of {
      ((!label_name_a1Fy), rest_a1Fz)
        -> (Main.PreLabel
              line_number_a1F3 (label_name_a1Fy ++ [head rest_a1Fz]))
           : Main.preparseLine (line_number_a1F3, tail rest_a1Fz) }
  | head cleaned_a1F5 `elem` ".#"
  = [Main.PrePseudo line_number_a1F3 s_a1F4]
  | otherwise
  = case span (/= ';') cleaned_a1F5 of {
      (!(presemi_a1FA, (!postsemi_a1FB)))
        -> (Main.PreReal line_number_a1F3 presemi_a1FA)
           : Main.preparseLine (line_number_a1F3, drop 1 postsemi_a1FB) }
  where
      (!cleaned_a1F5) = dropWhile isSpace s_a1F4
      untabbed_a1F6 (!x_a1Fu) = not (null x_a1Fu) && head x_a1Fu /= '\t'
      looks_like_label_a1F7 :: String -> Bool
      looks_like_label_a1F7 x_a1Fv
        = case span Main.isLabelIsh x_a1Fv of {
            ((!label_name_a1Fw), (!rest_a1Fx))
              -> not (null label_name_a1Fw)
                 &&
                   take 1 rest_a1Fx == ":"
                   && (null (tail rest_a1Fx) || isSpace (head (tail rest_a1Fx))) }
Main.getLineNo (Main.Pseudo (!ln_a1FC) s_a1FD) = ln_a1FC
Main.getLineNo (!(Main.Label ln_a1FE (!s_a1FF))) = ln_a1FE
Main.getLineNo (!(Main.Real (!ln_a1FG) (!cc_a1FH) (!i_a1FI)))
  = ln_a1FG
Main.insnOfLine (!((!(Main.Real (!ln_a1FJ) cc_a1FK i_a1FL))))
  = i_a1FL
Main.insnOfLine (!other_a1FM) = internal "insnOfLine"
Main.isReal (Main.Real ln_a1FN (!cc_a1FO) (!i_a1FP)) = True
Main.isReal other_a1FQ = False
Main.isPseudo (Main.Pseudo (!ln_a1FR) s_a1FS) = True
Main.isPseudo other_a1FT = False
Main.setCC (Main.Real ln_a1FU oldcc_a1FV i_a1FW) (!cc_a1FX)
  = Main.Real ln_a1FU cc_a1FX i_a1FW
Main.setCC (!other_a1FY) cc_a1FZ = internal "setCC"
Main.getCC ((!(Main.Real (!ln_a1G0) (!cc_a1G1) (!i_a1G2))))
  = cc_a1G1
Main.getCC (!other_a1G3) = Main.NoCC
Main.isNoCC Main.NoCC = True
Main.isNoCC (Main.CC _ _ (!_)) = False
Main.ccGetFileNm (!(Main.CC (!filenm_a1G4) (!ln_a1G5) funcnm_a1G6))
  = filenm_a1G4
Main.ccGetLineNo ((!(Main.CC (!filenm_a1G7) ln_a1G8 funcnm_a1G9)))
  = ln_a1G8
Main.ccGetFuncNm (Main.CC filenm_a1Ga ln_a1Gb funcnm_a1Gc)
  = funcnm_a1Gc
Main.parse :: [Main.PreLine] -> [Main.Line]
Main.parse
  = map f_a1Gd
  where
      f_a1Gd (Main.PrePseudo (!ln_a1Gf) (!s_a1Gg))
        = Main.Pseudo ln_a1Gf s_a1Gg
      f_a1Gd (Main.PreLabel ln_a1Gh s_a1Gi) = Main.Label ln_a1Gh s_a1Gi
      f_a1Gd ((!(Main.PreReal (!ln_a1Gj) s_a1Gk)))
        = case Main.pInsn (Main.olex s_a1Gk) of {
            POk i_a1Gl (![]) -> Main.Real ln_a1Gj Main.NoCC i_a1Gl
            _ -> bomb_a1Ge ln_a1Gj s_a1Gk }
      bomb_a1Ge ln_a1Gm s_a1Gn
        = inputerr
            ("(stdin):"
             ++ show ln_a1Gm ++ ": syntax error on `" ++ s_a1Gn ++ "'\n")
Main.olex :: String -> [Lex]
Main.olex [] = []
Main.olex ((!c_a1Go) : cs_a1Gp)
  | isSpace c_a1Go = Main.olex cs_a1Gp
  | c_a1Go == '(' = LLParen : Main.olex cs_a1Gp
  | c_a1Go == ')' = LRParen : Main.olex cs_a1Gp
  | c_a1Go == ',' = LComma : Main.olex cs_a1Gp
  | c_a1Go == '+' = LPlus : Main.olex cs_a1Gp
  | c_a1Go == '-' = LMinus : Main.olex cs_a1Gp
  | c_a1Go == '*' = LStar : Main.olex cs_a1Gp
  | c_a1Go == '$' = LDollar : Main.olex cs_a1Gp
  | c_a1Go == '#' = []
  | c_a1Go == '%'
  = case span isAlpha cs_a1Gp of {
      (!((!rname_a1Gq), rest_a1Gr))
        | rname_a1Gq == "st"
          && not (null rest_a1Gr) && head rest_a1Gr == '('
        -> case span (`elem` "(01234567)") rest_a1Gr of {
             (frname_a1Gs, rest2_a1Gt)
               -> (LReg (c_a1Go : rname_a1Gq ++ frname_a1Gs))
                  : Main.olex rest2_a1Gt }
        | (c_a1Go : rname_a1Gq) `elem` Main.reg_names
        -> (LReg (c_a1Go : rname_a1Gq)) : Main.olex rest_a1Gr
        | otherwise -> Main.barf (c_a1Go : cs_a1Gp) }
  | isDigit c_a1Go
  = case span Main.isDigitish cs_a1Gp of {
      ((!num_a1Gu), rest_a1Gv)
        -> (LNum (c_a1Go : num_a1Gu)) : Main.olex rest_a1Gv }
  | isAlpha c_a1Go || c_a1Go == '_'
  = case span Main.isNameIsh cs_a1Gp of {
      (nmcs_a1Gw, rest_a1Gx)
        -> (LName (c_a1Go : nmcs_a1Gw)) : Main.olex rest_a1Gx }
  | c_a1Go == '.'
  = case span Main.isLabelIsh cs_a1Gp of {
      (lbcs_a1Gy, (!rest_a1Gz))
        -> (LLabel (c_a1Go : lbcs_a1Gy)) : Main.olex rest_a1Gz }
  | otherwise = Main.barf (c_a1Go : cs_a1Gp)
Main.isDigitish (!c_a1GA)
  = isDigit c_a1GA || c_a1GA `elem` "xabcdefABCDEF"
Main.isNameIsh c_a1GB
  = isAlpha c_a1GB
    || isDigit c_a1GB || c_a1GB == '_' || c_a1GB == '.'
Main.isLabelIsh (!c_a1GC)
  = isAlpha c_a1GC
    || isDigit c_a1GC || c_a1GC == '.' || c_a1GC == '_'
Main.isRegChar c_a1GD = isAlpha c_a1GD || c_a1GD `elem` "(0)"
Main.barf (!s_a1GE)
  = inputerr ("lexical error on: `" ++ s_a1GE ++ "'")
Main.getAnnOp ((!(Main.AnnR w_a1GF (!o_a1GG)))) = o_a1GG
Main.getAnnOp (Main.AnnM w_a1GH (!o_a1GI)) = o_a1GI
Main.getAnnOp ((!(Main.AnnW w_a1GJ (!o_a1GK)))) = o_a1GK
Main.isAnnC (!(Main.AnnC _)) = True
Main.isAnnC _ = False
Main.mkAnnC comment_a1GL = Main.SomeAnns [Main.AnnC comment_a1GL]
Main.mkNoAnns = Main.SomeAnns []
Main.hasRealAnns (Main.Insn ann_a1GM (!_) (!_))
  = (not . null . filter (not . Main.isAnnC) . Main.getAnns) ann_a1GM
Main.getAnns Main.DontAnnMe = []
Main.getAnns (!(Main.SomeAnns anns_a1GN)) = anns_a1GN
Main.isDontAnnMe (!Main.DontAnnMe) = True
Main.isDontAnnMe (!_) = False
Main.annsOfInsn
  ((!(Main.Insn anns_a1GO opcode_a1GP (!operand_a1GQ))))
  = anns_a1GO
Main.opcodeOfInsn
  ((!(Main.Insn anns_a1GR (!opcode_a1GS) operand_a1GT)))
  = opcode_a1GS
Main.pOpcode :: Parser Opcode
Main.pOpcode
  = pAlts
      (map
         (\ o_a1GU -> pName (drop 2 (show (fst o_a1GU))) (fst o_a1GU))
         x86info)
Main.pInsn :: Parser Main.Insn
Main.pInsn
  = p2
      (Main.Insn (Main.SomeAnns []))
      Main.pOpcode
      (pStarComma Main.pOperand)
Main.pOperand :: Parser Main.Operand
Main.pOperand
  = pAlts
      [pApply Main.OP_REG Main.pReg,
       p2 (\ _ (!c_a1H1) -> Main.OP_LIT c_a1H1) pLDollar Main.pConst,
       p2
         (\ c_a1H2 a_a1H3 -> Main.OP_DA c_a1H2 a_a1H3)
         Main.pConst
         Main.pAMode,
       pApply (\ (!c_a1H4) -> Main.OP_D c_a1H4) Main.pConst,
       pApply (\ a_a1H5 -> Main.OP_A a_a1H5) Main.pAMode,
       p2
         (\ (!_) operand_a1H6 -> Main.OP_STAR operand_a1H6)
         pLStar
         Main.pOperand]
Main.pAMode :: Parser Main.AMode
Main.pAMode
  = pInParens
      (pAlts
         [p3
            Main.AM_BIS Main.pReg (pPreComma Main.pReg) (pPreComma Main.pLNum),
          p2 Main.AM_BI Main.pReg (pPreComma Main.pReg),
          p2 Main.AM_IS (pPreComma Main.pReg) (pPreComma Main.pLNum),
          pApply Main.AM_B Main.pReg])
Main.pUnsignedA :: Parser Main.UnsignedFactor
Main.pUnsignedA
  = pAlts
      [pApply Main.UF_NUM Main.pLNum, pApply Main.UF_NAME Main.pLName,
       pApply Main.UF_LABEL Main.pLLabel]
Main.pUnsignedF :: Parser Main.UnsignedFactor
Main.pUnsignedF
  = pAlts
      [p3
         (\ (!x_a1H7) times_a1H8 y_a1H9 -> Main.UF_TIMES x_a1H7 y_a1H9)
         Main.pUnsignedA
         pLStar
         Main.pUnsignedF,
       p3
         (\ left_a1Ha (!x_a1Hb) right_a1Hc -> x_a1Hb)
         pLLParen
         Main.pUnsignedF
         pLRParen,
       Main.pUnsignedA]
Main.pSignedF :: Parser Main.SignedFactor
Main.pSignedF
  = pAlts
      [p2 (\ _ (!ca_a1Hd) -> Main.Pos ca_a1Hd) pLPlus Main.pUnsignedF,
       p2 (\ (!_) (!ca_a1He) -> Main.Neg ca_a1He) pLMinus Main.pUnsignedF]
Main.pConst :: Parser Main.Const
Main.pConst
  = pAlts
      [p2
         (\ (!ca_a1Hf) (!cas_a1Hg)
            -> Main.Const ((Main.Pos ca_a1Hf) : cas_a1Hg))
         Main.pUnsignedF
         (pStar Main.pSignedF),
       p3
         (\ _ ca_a1Hh cas_a1Hi
            -> Main.Const ((Main.Neg ca_a1Hh) : cas_a1Hi))
         pLMinus
         Main.pUnsignedF
         (pStar Main.pSignedF)]
Main.pReg
  = pApply findReg_a1Hj Main.pLReg
  where
      findReg_a1Hj r_a1Hk
        = case lookup r_a1Hk Main.reg_map of {
            (!Nothing) -> incomplete ("findReg: `" ++ r_a1Hk ++ "'")
            Just reg_a1Hl -> reg_a1Hl }
Main.test = Main.pInsn . Main.olex
Main.pLLiteral = pApply unLLiteral (pSat isLLiteral)
Main.pLNum = pApply unLNum (pSat isLNum)
Main.pLReg = pApply unLReg (pSat isLReg)
Main.pLName = pApply unLName (pSat isLName)
Main.pLLabel = pApply unLLabel (pSat isLLabel)
Main.reg_map
  = [("%eax", Main.EAX), ("%ebx", Main.EBX), ("%ecx", Main.ECX),
     ("%edx", Main.EDX), ("%edi", Main.EDI), ("%esi", Main.ESI),
     ("%ebp", Main.EBP), ("%esp", Main.ESP), ("%ax", Main.AX),
     ("%bx", Main.BX), ("%cx", Main.CX), ("%dx", Main.DX),
     ("%si", Main.SI), ("%di", Main.DI), ("%bp", Main.BP),
     ("%al", Main.AL), ("%bl", Main.BL), ("%cl", Main.CL),
     ("%dl", Main.DL), ("%ah", Main.AH), ("%bh", Main.BH),
     ("%ch", Main.CH), ("%dh", Main.DH), ("%st", Main.ST_0),
     ("%st(0)", Main.ST_0), ("%st(1)", Main.ST_1),
     ("%st(2)", Main.ST_2), ("%st(3)", Main.ST_3),
     ("%st(4)", Main.ST_4), ("%st(5)", Main.ST_5),
     ("%st(6)", Main.ST_6), ("%st(7)", Main.ST_7)]
Main.reg_names = map fst Main.reg_map
Main.paren s_a1Hm = "(" ++ s_a1Hm ++ ")"
Main.simplify :: [Main.Line] -> [Main.Line]
Main.simplify = Main.simpl_wrk 0
Main.simpl_wrk lc_a1Hn (![]) = []
Main.simpl_wrk
  lc_a1Ho
  ((Main.Real ln_a1Hp
              (!cc_a1Hq)
              (!(Main.Insn (Main.SomeAnns (![]))
                           (!O_rep)
                           (![])))) : (!(((!(Main.Real _
                                                       _
                                                       (Main.Insn ((!(Main.SomeAnns (![]))))
                                                                  o_op_a1Hr
                                                                  [])))) : lines_a1Hs)))
  | o_op_a1Hr
    `elem` [O_movsl, O_movsw, O_movsb, O_stosl, O_stosw, O_stosb]
  = let
      (!(l1_a1Ht, l2_a1Hu)) = (lc_a1Ho, lc_a1Ho + 1)
      labelName_a1Hv n_a1Iy
        = "cacheprof_x86_rep_expansion" ++ show n_a1Iy
      mkInsn_a1Hw oc_a1Iz ops_a1IA
        = Main.Real
            ln_a1Hp cc_a1Hq (Main.Insn Main.DontAnnMe oc_a1Iz ops_a1IA)
      mkInsnA_a1Hx oc_a1IB ops_a1IC
        = Main.Real
            ln_a1Hp cc_a1Hq (Main.Insn (Main.SomeAnns []) oc_a1IB ops_a1IC)
      mkLabelD_a1Hy (!ln_a1ID)
        = Main.Pseudo
            ln_a1ID (Main.mk_arch_label_def (labelName_a1Hv ln_a1ID))
      mkLabelU_a1Hz (!ln_a1IE)
        = Main.OP_D
            (Main.Const
               [Main.Pos
                  (Main.UF_LABEL (Main.mk_arch_label_use (labelName_a1Hv ln_a1IE)))])
    in
      [mkInsn_a1Hw O_pushfl [], mkLabelD_a1Hy l1_a1Ht,
       mkInsn_a1Hw O_testl [Main.OP_REG Main.ECX, Main.OP_REG Main.ECX],
       mkInsn_a1Hw O_jz [mkLabelU_a1Hz l2_a1Hu],
       mkInsn_a1Hw O_decl [Main.OP_REG Main.ECX],
       mkInsnA_a1Hx o_op_a1Hr [],
       mkInsn_a1Hw O_jmp [mkLabelU_a1Hz l1_a1Ht], mkLabelD_a1Hy l2_a1Hu,
       mkInsn_a1Hw O_popfl []]
      ++ Main.simpl_wrk (lc_a1Ho + 2) lines_a1Hs
Main.simpl_wrk
  (!lc_a1IF)
  (!((!((Main.Real (!ln_a1IG)
                   cc_a1IH
                   (!(Main.Insn (Main.SomeAnns [])
                                o_reppy_a1II
                                []))) : (((!(Main.Real (!_)
                                                       (!_)
                                                       (!(Main.Insn ((!(Main.SomeAnns (![]))))
                                                                    o_op_a1IJ
                                                                    (![])))))) : lines_a1IK)))))
  | o_reppy_a1II `elem` [O_repz, O_repnz]
    && o_op_a1IJ `elem` [O_cmpsb, O_scasb]
  = let
      (!o_exit_a1IL)
        | o_reppy_a1II `elem` [O_repnz] = O_jz
        | o_reppy_a1II `elem` [O_repz] = O_jnz
        | otherwise
        = incomplete
            ("simpl_wrk rep: can't handle "
             ++ show (o_reppy_a1II, o_op_a1IJ) ++ "\n")
      (!(l1_a1IM, (!l2_a1IN), (!l3_a1IO)))
        = (lc_a1IF, lc_a1IF + 1, lc_a1IF + 2)
      labelName_a1IP n_a1IU
        = "cacheprof_x86_rep_expansion" ++ show n_a1IU
      mkInsn_a1IQ (!oc_a1IV) (!ops_a1IW)
        = Main.Real
            ln_a1IG cc_a1IH (Main.Insn Main.DontAnnMe oc_a1IV ops_a1IW)
      mkInsnA_a1IR oc_a1IX ops_a1IY
        = Main.Real
            ln_a1IG cc_a1IH (Main.Insn (Main.SomeAnns []) oc_a1IX ops_a1IY)
      mkLabelD_a1IS (!ln_a1IZ)
        = Main.Pseudo
            ln_a1IZ (Main.mk_arch_label_def (labelName_a1IP ln_a1IZ))
      mkLabelU_a1IT ln_a1J0
        = Main.OP_D
            (Main.Const
               [Main.Pos
                  (Main.UF_LABEL (Main.mk_arch_label_use (labelName_a1IP ln_a1J0)))])
    in
      [mkLabelD_a1IS l1_a1IM, mkInsn_a1IQ O_pushfl [],
       mkInsn_a1IQ O_testl [Main.OP_REG Main.ECX, Main.OP_REG Main.ECX],
       mkInsn_a1IQ O_jz [mkLabelU_a1IT l2_a1IN], mkInsn_a1IQ O_popfl [],
       mkInsnA_a1IR o_op_a1IJ [], mkInsn_a1IQ O_pushfl [],
       mkInsn_a1IQ O_decl [Main.OP_REG Main.ECX], mkInsn_a1IQ O_popfl [],
       mkInsn_a1IQ o_exit_a1IL [mkLabelU_a1IT l3_a1IO],
       mkInsn_a1IQ O_jmp [mkLabelU_a1IT l1_a1IM], mkLabelD_a1IS l2_a1IN,
       mkInsn_a1IQ O_popfl [], mkLabelD_a1IS l3_a1IO]
      ++ Main.simpl_wrk (lc_a1IF + 3) lines_a1IK
Main.simpl_wrk
  (!lc_a1J1)
  ((!((!(Main.Real (!ln_a1J2)
                   cc_a1J3
                   (Main.Insn (Main.SomeAnns []) (!O_leave) (![])))))) : lines_a1J4)
  = [Main.Real
       ln_a1J2
       cc_a1J3
       (Main.Insn
          Main.mkNoAnns O_movl [Main.OP_REG Main.EBP, Main.OP_REG Main.ESP]),
     Main.Real
       ln_a1J2
       cc_a1J3
       (Main.Insn Main.mkNoAnns O_popl [Main.OP_REG Main.EBP])]
    ++ Main.simpl_wrk lc_a1J1 lines_a1J4
Main.simpl_wrk lc_a1J5 (line_a1J6 : lines_a1J7)
  = line_a1J6 : Main.simpl_wrk lc_a1J5 lines_a1J7
Main.identify_bbs :: [Main.Line] -> [Main.BB]
Main.identify_bbs
  = merge_bbs_a1J8 . map (\ line_a1Ji -> Main.BB [line_a1Ji])
  where
      merge_bbs_a1J8 (![]) = []
      merge_bbs_a1J8 (![(!bb_a1J9)]) = [bb_a1J9]
      merge_bbs_a1J8
        (bb1_a1Ja@(!(Main.BB lines1_a1Jb)) : ((!bb2_a1Jc@(Main.BB (![line_a1Jd]))) : bbs_a1Je))
        | Main.isPseudo line_a1Jd
        = let (!bigger_bb_a1Jg) = Main.BB (lines1_a1Jb ++ [line_a1Jd])
          in merge_bbs_a1J8 (bigger_bb_a1Jg : bbs_a1Je)
        | Main.isOriginalInsn line_a1Jd
          &&
            any Main.isReal lines1_a1Jb
            &&
              Main.isOriginalInsn last_Real_lines1_a1Jf
              &&
                Main.opcodeOfInsn (Main.insnOfLine last_Real_lines1_a1Jf)
                `elem` nonJumpyOpcodes
        = let (!bigger_bb_a1Jh) = Main.BB (lines1_a1Jb ++ [line_a1Jd])
          in merge_bbs_a1J8 (bigger_bb_a1Jh : bbs_a1Je)
        | otherwise = bb1_a1Ja : merge_bbs_a1J8 (bb2_a1Jc : bbs_a1Je)
        where
            last_Real_lines1_a1Jf = last (filter Main.isReal lines1_a1Jb)
Main.use_bbs :: [Main.BB] -> [Main.Line]
Main.use_bbs = concatMap Main.use_bb
Main.use_bb :: Main.BB -> [Main.Line]
Main.use_bb (Main.BB []) = internal "use_bb: empty bb"
Main.use_bb ((!(Main.BB lines_a1Jj)))
  = let
      (!n_original_insns_a1Jk)
        = length (filter Main.isOriginalInsn lines_a1Jj)
      lineNo_a1Jl = Main.getLineNo (head lines_a1Jj)
      synthd_insns_a1Jm
        = map
            (Main.Real lineNo_a1Jl Main.NoCC)
            (Main.incSequence n_original_insns_a1Jk "cacheprof_icount")
    in
      if n_original_insns_a1Jk == 0 then
          lines_a1Jj
      else
          synthd_insns_a1Jm ++ lines_a1Jj
Main.isOriginalInsn ((!(Main.Real ln_a1Jn (!cc_a1Jo) insn_a1Jp)))
  = case Main.annsOfInsn insn_a1Jp of {
      Main.DontAnnMe -> False
      Main.SomeAnns (![]) -> True
      (!other_a1Jq) -> internal "isOriginalInsn" }
Main.isOriginalInsn (!other_a1Jr) = False
Main.annotate :: [Main.Line] -> [Main.Line]
Main.annotate
  = map f_a1Js
  where
      f_a1Js (!((!(Main.Real (!ln_a1Jt) cc_a1Ju (!insn_a1Jv)))))
        = Main.Real ln_a1Jt cc_a1Ju (Main.annotate_insn insn_a1Jv)
      f_a1Js label_or_pseudo_a1Jw = label_or_pseudo_a1Jw
Main.annotate_insn :: Main.Insn -> Main.Insn
Main.annotate_insn
  (!insn_a1Jx@(!(Main.Insn (!old_ann_a1Jy)
                           opcode_a1Jz
                           operands_a1JA)))
  | Main.isDontAnnMe old_ann_a1Jy = insn_a1Jx
  | otherwise
  = Main.Insn
      (Main.SomeAnns
         (filter
            (Main.isMemOp . Main.getAnnOp)
            (Main.annsOf opcode_a1Jz operands_a1JA)))
      opcode_a1Jz
      operands_a1JA
Main.isMemOp (Main.OP_REG r_a1JB) = False
Main.isMemOp (!(Main.OP_LIT c_a1JC)) = False
Main.isMemOp (!(Main.OP_D d_a1JD)) = True
Main.isMemOp (!(Main.OP_DA d_a1JE a_a1JF)) = True
Main.isMemOp ((!(Main.OP_A a_a1JG))) = True
Main.isMemOp (Main.OP_STAR (!o_a1JH))
  = incomplete "isMemOp: not sure about *-form"
Main.the_edi = Main.OP_A (Main.AM_B Main.EDI)
Main.the_esi = Main.OP_A (Main.AM_B Main.ESI)
Main.the_sp = Main.OP_A (Main.AM_B Main.ESP)
Main.the_sp_plus_4
  = Main.OP_DA
      (Main.Const [Main.Pos (Main.UF_NUM "4")]) (Main.AM_B Main.ESP)
Main.the_sp_plus_8
  = Main.OP_DA
      (Main.Const [Main.Pos (Main.UF_NUM "8")]) (Main.AM_B Main.ESP)
Main.annsOf :: Opcode -> [Main.Operand] -> [Main.Annot]
Main.annsOf (!opcode_a1JI) operands_a1JJ
  = let
      opInfo_a1JK = Main.getOperandInfo opcode_a1JI
      no_applicable_info_a1JL
        = incomplete
            ("operand info ("
             ++
               show opInfo_a1JK
               ++
                 ") doesn't match operand(s): "
                 ++ Main.ppd (Main.Insn Main.mkNoAnns opcode_a1JI operands_a1JJ))
    in
      case opInfo_a1JK of {
        (!(OI effects_a1JM))
          -> case Main.annsFromEffects effects_a1JM operands_a1JJ of {
               Just (!anns_a1JN) -> anns_a1JN
               (!Nothing) -> no_applicable_info_a1JL }
        OI_Jumpy
          -> case operands_a1JJ of {
               [(!op1_a1JO)]
                 -> case op1_a1JO of {
                      (!(Main.OP_STAR o_a1JP)) -> [Main.AnnR 4 o_a1JP]
                      (!_) -> [] }
               other_a1JQ -> no_applicable_info_a1JL }
        OI_NoEffect -> []
        OI_Error
          -> internal
               ("unsimplified opcode: "
                ++ Main.ppd (Main.Insn Main.mkNoAnns opcode_a1JI operands_a1JJ))
        OI_Special
          | opcode_a1JI == O_pushl
          -> case operands_a1JJ of {
               [op1_a1JR]
                 -> [Main.AnnR 4 op1_a1JR, Main.AnnW 4 Main.the_sp_plus_4]
               (!other_a1JS) -> no_applicable_info_a1JL }
          | opcode_a1JI == O_call
          -> case operands_a1JJ of {
               (![(!op1_a1JT)])
                 -> case op1_a1JT of {
                      (!(Main.OP_STAR o_a1JU))
                        -> [Main.AnnR 4 o_a1JU, Main.AnnW 4 Main.the_sp_plus_4]
                      direct_a1JV -> [Main.AnnW 4 Main.the_sp_plus_4] }
               other_a1JW -> no_applicable_info_a1JL }
          | opcode_a1JI == O_popl
          -> case operands_a1JJ of {
               [op1_a1JX]
                 -> [Main.AnnR 4 Main.the_sp_plus_8, Main.AnnW 4 op1_a1JX] }
          | opcode_a1JI == O_ret -> [Main.AnnR 4 Main.the_sp_plus_8]
          | opcode_a1JI == O_scasb -> [Main.AnnR 1 Main.the_edi]
          | opcode_a1JI == O_cmpsb
          -> [Main.AnnR 1 Main.the_edi, Main.AnnR 1 Main.the_esi]
          | opcode_a1JI == O_movsl
          -> [Main.AnnR 4 Main.the_esi, Main.AnnW 4 Main.the_edi]
          | opcode_a1JI == O_movsw
          -> [Main.AnnR 2 Main.the_esi, Main.AnnW 2 Main.the_edi]
          | opcode_a1JI == O_movsb
          -> [Main.AnnR 1 Main.the_esi, Main.AnnW 1 Main.the_edi]
          | opcode_a1JI == O_stosl -> [Main.AnnW 4 Main.the_edi]
          | opcode_a1JI == O_stosw -> [Main.AnnW 2 Main.the_edi]
          | opcode_a1JI == O_stosb -> [Main.AnnW 1 Main.the_edi]
        (!other_a1JY)
          -> incomplete
               ("\n\
                \unclassifiable opcode: "
                ++ Main.ppd (Main.Insn Main.mkNoAnns opcode_a1JI operands_a1JJ)) }
Main.annsFromEffects ::
  [OperandEffect] -> [Main.Operand] -> Maybe [Main.Annot]
Main.annsFromEffects (!effects_a1JZ) (!operands_a1K0)
  | null effects_a1JZ = Nothing
  | otherwise
  = let
      mismatch_a1K1
        = Main.annsFromEffects (tail effects_a1JZ) operands_a1K0
    in
      case head effects_a1JZ of {
        OE_RR (!s1_a1K2) s2_a1K3
          -> case operands_a1K0 of {
               [(!op1_a1K4), (!op2_a1K5)]
                 -> Just [Main.AnnR s1_a1K2 op1_a1K4, Main.AnnR s2_a1K3 op2_a1K5]
               (!other_a1K6) -> mismatch_a1K1 }
        OE_RM s1_a1K7 (!s2_a1K8)
          -> case operands_a1K0 of {
               (![op1_a1K9, op2_a1Ka])
                 -> Just [Main.AnnR s1_a1K7 op1_a1K9, Main.AnnM s2_a1K8 op2_a1Ka]
               (!other_a1Kb) -> mismatch_a1K1 }
        OE_RW s1_a1Kc (!s2_a1Kd)
          -> case operands_a1K0 of {
               (![(!op1_a1Ke), op2_a1Kf])
                 -> Just [Main.AnnR s1_a1Kc op1_a1Ke, Main.AnnW s2_a1Kd op2_a1Kf]
               other_a1Kg -> mismatch_a1K1 }
        (!(OE_R (!s1_a1Kh)))
          -> case operands_a1K0 of {
               (![op1_a1Ki]) -> Just [Main.AnnR s1_a1Kh op1_a1Ki]
               other_a1Kj -> mismatch_a1K1 }
        OE_M (!s1_a1Kk)
          -> case operands_a1K0 of {
               [op1_a1Kl] -> Just [Main.AnnM s1_a1Kk op1_a1Kl]
               other_a1Km -> mismatch_a1K1 }
        OE_W s1_a1Kn
          -> case operands_a1K0 of {
               [(!op1_a1Ko)] -> Just [Main.AnnW s1_a1Kn op1_a1Ko]
               (!other_a1Kp) -> mismatch_a1K1 }
        OE_nW s2_a1Kq
          -> case operands_a1K0 of {
               [(!op1_a1Kr), (!op2_a1Ks)] -> Just [Main.AnnW s2_a1Kq op2_a1Ks]
               other_a1Kt -> mismatch_a1K1 }
        OE_RRM s1_a1Ku s2_a1Kv s3_a1Kw
          -> case operands_a1K0 of {
               [(!op1_a1Kx), op2_a1Ky, op3_a1Kz]
                 -> Just
                      [Main.AnnR s1_a1Ku op1_a1Kx, Main.AnnR s2_a1Kv op2_a1Ky,
                       Main.AnnM s3_a1Kw op3_a1Kz]
               (!other_a1KA) -> mismatch_a1K1 } }
Main.getOperandInfo :: Opcode -> OperandInfo
Main.getOperandInfo opcR_a1KB
  = case
        [oi_a1KD |
           (opc_a1KC, (!oi_a1KD)) <- x86info, opc_a1KC == opcR_a1KB]
    of {
      [(!oi_a1KE)] -> oi_a1KE
      (!_)
        -> incomplete
             ("getOperandInfo: no info for: " ++ show opcR_a1KB ++ "\n") }
Main.addCCs :: [Main.Line] -> [Main.Line]
Main.addCCs
  = Main.addCCs_wrk
      (Main.Guessed "_unknown_file_")
      0
      (Main.Guessed "_unknown_function_")
Main.isGuessed ps_a1KF
  = case ps_a1KF of {
      Main.Guessed (!_) -> True
      _ -> False }
Main.getTheString (Main.Stated (!s_a1KG)) = s_a1KG
Main.getTheString (Main.Guessed (!s_a1KH)) = s_a1KH
Main.addCCs_wrk ::
  Main.PossiblyString
  -> Int -> Main.PossiblyString -> [Main.Line] -> [Main.Line]
Main.addCCs_wrk (!inm_a1KI) (!lno_a1KJ) (!fnm_a1KK) (![]) = []
Main.addCCs_wrk
  (!inm_a1KL)
  lno_a1KM
  (!fnm_a1KN)
  (!((!(l_a1KO : (!ls_a1KP)))))
  = case l_a1KO of {
      (!(Main.Real (!_) _ insn_a1M8))
        | Main.hasRealAnns insn_a1M8
        -> Main.setCC
             l_a1KO
             (Main.CC
                (Main.getTheString inm_a1KL) lno_a1KM (Main.getTheString fnm_a1KN))
           : Main.addCCs_wrk inm_a1KL lno_a1KM fnm_a1KN ls_a1KP
        | otherwise
        -> l_a1KO : Main.addCCs_wrk inm_a1KL lno_a1KM fnm_a1KN ls_a1KP
      (!(Main.Pseudo ln_a1M9 s_a1Ma))
        -> case updCC_a1KQ s_a1Ma of {
             (!(inm2_a1Mb, lno2_a1Mc, (!fnm2_a1Md)))
               -> l_a1KO : Main.addCCs_wrk inm2_a1Mb lno2_a1Mc fnm2_a1Md ls_a1KP }
      (!(Main.Label ln_a1Me (!s_a1Mf)))
        -> case updL_a1KS s_a1Mf of {
             (!(inm2_a1Mg, lno2_a1Mh, fnm2_a1Mi))
               -> l_a1KO
                  : Main.addCCs_wrk inm2_a1Mg lno2_a1Mh fnm2_a1Mi ls_a1KP } }
  where
      updCC_a1KQ s_a1L0 = upd2_a1KR (words (dropWhile isSpace s_a1L0))
      upd2_a1KR (!((!(".stabn" : ((!args_a1L1) : _)))))
        = case splitArgs_a1KT args_a1L1 of {
            ("68" : (!(_ : ((!lns_a1L2) : _))))
              -> (inm_a1KL, read lns_a1L2, fnm_a1KN)
            _ -> (inm_a1KL, lno_a1KM, fnm_a1KN) }
      upd2_a1KR (".stabs" : (!((!args_a1LR) : (!_))))
        = case splitArgs_a1KT args_a1LR of {
            ((!((!filenm_a1LS) : ("100" : _))))
              | last filenm_a1LS /= '/'
              -> (Main.Stated (deQuote_a1KZ filenm_a1LS), lno_a1KM, fnm_a1KN)
            ((!(filenm_a1LT : ("132" : (!_)))))
              -> (Main.Stated (deQuote_a1KZ filenm_a1LT), lno_a1KM, fnm_a1KN)
            ((!((!fnnm_a1LU) : (!("36" : (!_))))))
              | (not . null . deQuote_a1KZ) fnnm_a1LU
              -> (inm_a1KL, lno_a1KM, 
                  Main.Stated (deQuote_a1KZ (takeWhile (/= ':') fnnm_a1LU)))
            (!_) -> (inm_a1KL, lno_a1KM, fnm_a1KN) }
      upd2_a1KR [(!".file"), filenm_a1LV]
        | Main.isGuessed inm_a1KL && isQuoted_a1KY filenm_a1LV
        = (Main.Guessed (deQuote_a1KZ filenm_a1LV), lno_a1KM, fnm_a1KN)
      upd2_a1KR _ = (inm_a1KL, lno_a1KM, fnm_a1KN)
      updL_a1KS (!label_text_a1LW)
        | Main.isGuessed fnm_a1KN && take 2 cleaned_a1LX /= ".L"
        = (inm_a1KL, lno_a1KM, Main.Guessed (init cleaned_a1LX))
        | otherwise = (inm_a1KL, lno_a1KM, fnm_a1KN)
        where
            cleaned_a1LX = dropWhile isSpace label_text_a1LW
      splitArgs_a1KT = breakOnComma_a1KX . zapCIQ_a1KU
      zapCIQ_a1KU s_a1LY = out_a1KV s_a1LY
      out_a1KV (![]) = []
      out_a1KV ((!(c_a1LZ : cs_a1M0)))
        | c_a1LZ == '"' = c_a1LZ : inn_a1KW cs_a1M0
        | otherwise = c_a1LZ : out_a1KV cs_a1M0
      inn_a1KW (![]) = []
      inn_a1KW (c_a1M1 : (!cs_a1M2))
        | c_a1M1 == '"' = c_a1M1 : out_a1KV cs_a1M2
        | c_a1M1 == ',' = '_' : inn_a1KW cs_a1M2
        | otherwise = c_a1M1 : inn_a1KW cs_a1M2
      breakOnComma_a1KX :: String -> [String]
      breakOnComma_a1KX (![]) = []
      breakOnComma_a1KX s_a1M3
        = case span (/= ',') s_a1M3 of {
            (pre_a1M4, (!post_a1M5))
              -> pre_a1M4 : breakOnComma_a1KX (drop 1 post_a1M5) }
      isQuoted_a1KY (!s_a1M6)
        = length s_a1M6 >= 2 && head s_a1M6 == '"' && last s_a1M6 == '"'
      deQuote_a1KZ (!s_a1M7) = filter (/= '"') s_a1M7
Main.synth_2 :: [Main.Line] -> [Main.Line]
Main.synth_2 ccd_assy_a1Mj
  = let
      ccs_a1Mk = map Main.getCC ccd_assy_a1Mj
      cc_descriptors_a1Ml = Main.makeCCdescriptors ccs_a1Mk
      (!data_areas_a1Mm) = Main.useCCdescriptors cc_descriptors_a1Ml
      (!num_ccs_avail_a1Mn)
        = case cc_descriptors_a1Ml of {
            (dbg_a1Mr, file_names_a1Ms, fn_names_a1Mt, src_points_a1Mu)
              -> length src_points_a1Mu }
      ((!num_ccs_used_a1Mo), (!synthd_assy_grps_a1Mp))
        = mapAccumL Main.synthLine 0 ccd_assy_a1Mj
      synthd_assy_a1Mq
        = if num_ccs_used_a1Mo == num_ccs_avail_a1Mn then
              concat synthd_assy_grps_a1Mp
          else
              internal "doFile: cc supply/usage mismatch\n"
    in synthd_assy_a1Mq ++ data_areas_a1Mm
Main.makeCCdescriptors ::
  [Main.CC] -> ([String], [String], [String], [(Int, Int, Int)])
Main.makeCCdescriptors allCcs_a1Qa
  = let
      ccs_a1Qb = filter (not . Main.isNoCC) allCcs_a1Qa
      filenames_a1Qc = nub (map Main.ccGetFileNm ccs_a1Qb)
      canonical_fn_map_a1Qd
        = canonicalise_a1Qg
            (zip
               (map Main.ccGetFuncNm ccs_a1Qb) (map Main.ccGetFileNm ccs_a1Qb))
      (!(canonical_fn_map_fsts_a1Qe, (!canonical_fn_map_snds_a1Qf)))
        = unzip canonical_fn_map_a1Qd
      canonicalise_a1Qg (![]) = []
      canonicalise_a1Qg (!((!(fn_a1Qm, file_a1Qn)) : rest_a1Qo))
        = (fn_a1Qm, fn_a1Qm ++ "(" ++ file_a1Qn ++ ")")
          : canonicalise_a1Qg (filter ((/= fn_a1Qm) . fst) rest_a1Qo)
      toSrcPoint_a1Qh :: Main.CC -> (Int, Int, Int)
      toSrcPoint_a1Qh cc_a1Qp
        = (indexOf_a1Ql filenames_a1Qc (Main.ccGetFileNm cc_a1Qp), 
           Main.ccGetLineNo cc_a1Qp, 
           indexOf_a1Ql canonical_fn_map_fsts_a1Qe (Main.ccGetFuncNm cc_a1Qp))
      srcPoints_a1Qi = map toSrcPoint_a1Qh ccs_a1Qb
      (!debugging_text_a1Qj)
        = ["file names:"]
          ++
            map indent_a1Qk filenames_a1Qc
            ++
              ["canonicalised function names:"]
              ++
                map indent_a1Qk canonical_fn_map_snds_a1Qf
                ++
                  ["raw source points:"]
                  ++
                    map indent_a1Qk (map show ccs_a1Qb)
                    ++
                      ["cooked source points:"]
                      ++ map indent_a1Qk (map show srcPoints_a1Qi)
      indent_a1Qk s_a1Qq = "   " ++ s_a1Qq
      indexOf_a1Ql (!xs_a1Qr) y_a1Qs
        = f_a1Qt 0 xs_a1Qr
        where
            f_a1Qt (!n_a1Qu) (![])
              = internal ("indexOf: " ++ show y_a1Qs ++ "\n")
            f_a1Qt (!n_a1Qv) (z_a1Qw : (!zs_a1Qx))
              = if y_a1Qs == z_a1Qw then n_a1Qv else f_a1Qt (n_a1Qv + 1) zs_a1Qx
    in
      (debugging_text_a1Qj, filenames_a1Qc, canonical_fn_map_snds_a1Qf, 
       srcPoints_a1Qi)
Main.mk_arch_label_def (!s_a1Qy) = ".L" ++ s_a1Qy ++ ":"
Main.mk_arch_label_use s_a1Qz = ".L" ++ s_a1Qz
Main.tABLE_START_STRING = "cacheprof_magic_table"
Main.bUCKETS_START_STRING = "cacheprof_magic_buckets"
Main.useCCdescriptors ::
  ([String], [String], [String], [(Int, Int, Int)]) -> [Main.Line]
Main.useCCdescriptors
  (!((!debugging_text_a1QA),
     (!filenames_a1QB),
     (!funcnames_a1QC),
     points_a1QD))
  = let
      length_words_a1QE
        = [mk_comment_a1QS
             "number of filenames, funcnames, points, cc addr"]
          ++
            map
              mk_word_a1QP
              [length filenames_a1QB, length funcnames_a1QC, length points_a1QD]
            ++ [mk_word_l_a1QQ Main.bUCKETS_START_STRING]
      strings_a1QF = filenames_a1QB ++ funcnames_a1QC
      (!string_bytes_a1QG) = concatMap mk_string_a1QT strings_a1QF
      point_words_a1QH = concatMap mk_point_words_a1QL points_a1QD
      comments_a1QI = map mk_comment_a1QS debugging_text_a1QA
      pre_comments_a1QJ
        = map mk_comment_a1QS ["", "---- start of the cost centers ----"]
      (!post_comments_a1QK)
        = map mk_comment_a1QS ["", "---- end of the cost centers ----"]
      mk_point_words_a1QL
        (!p_a1QW@((!fileno_a1QX), (!lineno_a1QY), (!funcno_a1QZ)))
        = mk_comment_a1QS (show p_a1QW)
          : map
              mk_word_a1QP [fileno_a1QX, lineno_a1QY, funcno_a1QZ, 0, 0, 0, 0]
      (!preamble_a1QM) = mk_dataSeg_a1QU ++ mk_align_a1QV
      mk_Pseudo_a1QN = Main.Pseudo 0
      mk_label_def_a1QO s_a1R0 = Main.mk_arch_label_def s_a1R0
      mk_word_a1QP i_a1R1 = "\t.long " ++ show i_a1R1
      mk_word_l_a1QQ l_a1R2 = "\t.long " ++ Main.mk_arch_label_use l_a1R2
      mk_byte_a1QR i_a1R3 = "\t.byte " ++ show i_a1R3
      mk_comment_a1QS s_a1R4 = "\t# " ++ s_a1R4
      mk_string_a1QT (!s_a1R5)
        = [mk_comment_a1QS (show s_a1R5)]
          ++ map (mk_byte_a1QR . ord) s_a1R5 ++ [mk_byte_a1QR 0]
      (!mk_dataSeg_a1QU) = ["\t.data"]
      mk_align_a1QV = ["\t.align 4"]
    in
      map
        mk_Pseudo_a1QN
        (concat
           [pre_comments_a1QJ, comments_a1QI, preamble_a1QM,
            [mk_label_def_a1QO Main.tABLE_START_STRING], length_words_a1QE,
            string_bytes_a1QG, mk_align_a1QV,
            [mk_label_def_a1QO Main.bUCKETS_START_STRING], point_words_a1QH,
            post_comments_a1QK])
Main.synthLine :: Int -> Main.Line -> (Int, [Main.Line])
Main.synthLine nextcc_a1R6 (Main.Pseudo ln_a1R7 stuff_a1R8)
  = (nextcc_a1R6, [Main.Pseudo ln_a1R7 stuff_a1R8])
Main.synthLine nextcc_a1R9 (!(Main.Label (!ln_a1Ra) (!stuff_a1Rb)))
  = (nextcc_a1R9, [Main.Label ln_a1Ra stuff_a1Rb])
Main.synthLine
  nextcc_a1Rc
  (!((!(Main.Real ln_a1Rd (!cc_a1Re) (!insn_a1Rf)))))
  | Main.hasRealAnns insn_a1Rf
  = (nextcc_a1Rc + 1, 
     map
       (Main.Real ln_a1Rd cc_a1Re) (Main.synth_wrk nextcc_a1Rc insn_a1Rf))
  | otherwise = (nextcc_a1Rc, [Main.Real ln_a1Rd cc_a1Re insn_a1Rf])
Main.synth_wrk :: Int -> Main.Insn -> [Main.Insn]
Main.synth_wrk
  ccid_to_use_a1Rg
  (!insn_a1Rh@(Main.Insn ann_a1Ri opcode_a1Rj operands_a1Rk))
  = concatMap
      (Main.useAnnot ccid_to_use_a1Rg) (Main.getAnns ann_a1Ri)
    ++ [insn_a1Rh]
Main.insn_pushl (!reg_a1Rl)
  = Main.Insn (Main.mkAnnC "save") O_pushl [Main.OP_REG reg_a1Rl]
Main.insn_popl reg_a1Rm
  = Main.Insn (Main.mkAnnC "rest") O_popl [Main.OP_REG reg_a1Rm]
Main.std_preamble
  = [Main.insn_pushl Main.EAX, Main.insn_pushl Main.EBX]
Main.std_postamble
  = [Main.insn_popl Main.EBX, Main.insn_popl Main.EAX]
Main.useAnnot :: Int -> Main.Annot -> [Main.Insn]
Main.useAnnot ccid_a1Rn ((!(Main.AnnC c_a1Ro)))
  = internal "useAnnot on comment annotation"
Main.useAnnot (!ccid_a1Rp) (!(Main.AnnR (!sz_a1Rq) op_a1Rr))
  = Main.std_preamble
    ++
      [Main.Insn
         (Main.mkAnnC "rd-1") O_leal [op_a1Rr, Main.OP_REG Main.EAX],
       Main.Insn
         (Main.mkAnnC "rd-2")
         O_movl
         [Main.mk_bucket_addr ccid_a1Rp, Main.OP_REG Main.EBX],
       Main.Insn
         (Main.mkAnnC "rd-3")
         O_call
         [Main.OP_D (Main.Const [Main.Pos (Main.mk_rd_hook_name sz_a1Rq)])]]
      ++ Main.std_postamble
Main.useAnnot (!ccid_a1Rs) (Main.AnnM (!sz_a1Rt) (!op_a1Ru))
  = Main.std_preamble
    ++
      [Main.Insn
         (Main.mkAnnC "mo-1") O_leal [op_a1Ru, Main.OP_REG Main.EAX],
       Main.Insn
         (Main.mkAnnC "mo-2")
         O_movl
         [Main.mk_bucket_addr ccid_a1Rs, Main.OP_REG Main.EBX],
       Main.Insn
         (Main.mkAnnC "mo-3")
         O_call
         [Main.OP_D (Main.Const [Main.Pos (Main.mk_mo_hook_name sz_a1Rt)])]]
      ++ Main.std_postamble
Main.useAnnot (!ccid_a1Rv) (Main.AnnW sz_a1Rw op_a1Rx)
  = Main.std_preamble
    ++
      [Main.Insn
         (Main.mkAnnC "wr-1") O_leal [op_a1Rx, Main.OP_REG Main.EAX],
       Main.Insn
         (Main.mkAnnC "wr-2")
         O_movl
         [Main.mk_bucket_addr ccid_a1Rv, Main.OP_REG Main.EBX],
       Main.Insn
         (Main.mkAnnC "wr-3")
         O_call
         [Main.OP_D (Main.Const [Main.Pos (Main.mk_wr_hook_name sz_a1Rw)])]]
      ++ Main.std_postamble
Main.mk_bucket_addr ccid_a1Ry
  = Main.OP_D
      (Main.Const
         [Main.Pos
            (Main.UF_LABEL
               ("$" ++ Main.mk_arch_label_use Main.bUCKETS_START_STRING)),
          Main.Pos (Main.UF_NUM (show (28 * ccid_a1Ry)))])
Main.mk_rd_hook_name sz_a1Rz
  = Main.UF_NAME ("cacheprof_hook_Rd" ++ show sz_a1Rz)
Main.mk_mo_hook_name (!sz_a1RA)
  = Main.UF_NAME ("cacheprof_hook_Mo" ++ show sz_a1RA)
Main.mk_wr_hook_name sz_a1RB
  = Main.UF_NAME ("cacheprof_hook_Wr" ++ show sz_a1RB)
Main.synth_1 :: [Main.Line] -> [Main.Line]
Main.synth_1 = concatMap Main.synth_1_wrk
Main.synth_1_wrk :: Main.Line -> [Main.Line]
Main.synth_1_wrk (Main.Pseudo ln_a1RC (!stuff_a1RD))
  = [Main.Pseudo ln_a1RC stuff_a1RD]
Main.synth_1_wrk (!(Main.Label ln_a1RE (!stuff_a1RF)))
  = [Main.Label ln_a1RE stuff_a1RF]
Main.synth_1_wrk
  line_a1RG@(!((!(Main.Real (!ln_a1RH)
                            cc_a1RI
                            insn_a1RJ@(Main.Insn (!ann_a1RK) opcode_a1RL operands_a1RM)))))
  | Main.hasRealAnns insn_a1RJ
  = map
      (Main.Real ln_a1RH cc_a1RI)
      (concatMap useIncAnns_a1RN (Main.getAnns ann_a1RK))
    ++ [line_a1RG]
  | otherwise = [Main.Real ln_a1RH cc_a1RI insn_a1RJ]
  where
      useIncAnns_a1RN (Main.AnnW (!sz_a1RO) op_a1RP)
        = Main.incSequence 1 "cacheprof_level1_writes"
      useIncAnns_a1RN (!((!(Main.AnnR sz_a1RQ op_a1RR))))
        = Main.incSequence 1 "cacheprof_level1_reads"
      useIncAnns_a1RN (!(Main.AnnM sz_a1RS op_a1RT))
        = Main.incSequence 1 "cacheprof_level1_reads"
          ++ Main.incSequence 1 "cacheprof_level1_writes"
Main.incSequence :: Int -> String -> [Main.Insn]
Main.incSequence k_a1RU name_a1RV
  = [Main.Insn Main.DontAnnMe O_pushfl [],
     Main.Insn
       Main.DontAnnMe
       O_addl
       [Main.OP_LIT (Main.Const [Main.Pos (Main.UF_NUM (show k_a1RU))]),
        Main.OP_D (Main.Const [Main.Pos (Main.UF_NAME name_a1RV)])],
     Main.Insn
       Main.DontAnnMe
       O_adcl
       [Main.OP_LIT (Main.Const [Main.Pos (Main.UF_NUM "0")]),
        Main.OP_D
          (Main.Const
             [Main.Pos (Main.UF_NUM "4"), Main.Pos (Main.UF_NAME name_a1RV)])],
     Main.Insn Main.DontAnnMe O_popfl []]
Main.peephole :: [Main.Line] -> [Main.Line]
Main.peephole
  (line1_a1RW@(!((!(Main.Real ln1_a1RX
                              (!cc1_a1RY)
                              insn1_a1RZ)))) : (line2_a1S0@(Main.Real ln2_a1S1
                                                                      cc2_a1S2
                                                                      (!insn2_a1S3)) : (line3_a1S4@(!(Main.Real ln3_a1S5
                                                                                                                cc3_a1S6
                                                                                                                (Main.Insn anns3_a1S7
                                                                                                                           (!O_popfl)
                                                                                                                           []))) : (line4_a1S8@(Main.Real ln4_a1S9
                                                                                                                                                          (!cc4_a1Sa)
                                                                                                                                                          ((!(Main.Insn anns4_a1Sb
                                                                                                                                                                        (!O_pushfl)
                                                                                                                                                                        (![]))))) : (line5_a1Sc@(!((!(Main.Real (!ln5_a1Sd)
                                                                                                                                                                                                                cc5_a1Se
                                                                                                                                                                                                                (!insn5_a1Sf))))) : ((!line6_a1Sg@(!(Main.Real ln6_a1Sh
                                                                                                                                                                                                                                                               cc6_a1Si
                                                                                                                                                                                                                                                               insn6_a1Sj))) : (!the_rest_a1Sk)))))))
  | Main.incs_a_counter insn1_a1RZ insn2_a1S3
    && Main.incs_a_counter insn5_a1Sf insn6_a1Sj
  = Main.peephole
      (line1_a1RW : line2_a1S0 : line5_a1Sc : line6_a1Sg : the_rest_a1Sk)
Main.peephole (!(line_a1Sl : the_rest_a1Sm))
  = line_a1Sl : Main.peephole the_rest_a1Sm
Main.peephole [] = []
Main.incs_a_counter
  (!((!(Main.Insn anns1_a1Sn
                  O_addl
                  (![(!(Main.OP_LIT (!((!(Main.Const (![(!(Main.Pos ((!(Main.UF_NUM (!n_a1So))))))]))))))),
                     Main.OP_D (Main.Const [Main.Pos ((!(Main.UF_NAME name1_a1Sp)))])])))))
  (!((!(Main.Insn (!anns2_a1Sq)
                  O_adcl
                  (![(!(Main.OP_LIT (Main.Const (![(!(Main.Pos ((!(Main.UF_NUM (!zero_a1Sr))))))])))),
                     Main.OP_D (!(Main.Const (![Main.Pos (Main.UF_NUM four_a1Ss),
                                                Main.Pos (Main.UF_NAME name2_a1St)])))])))))
  = take 10 name1_a1Sp == "cacheprof_"
    &&
      take 10 name2_a1St == "cacheprof_"
      && zero_a1Sr == "0" && four_a1Ss == "4"
Main.incs_a_counter insn1_a1Su insn2_a1Sv = False
Main.final_cleanup :: [Main.Line] -> String
Main.final_cleanup
  = unlines . map Main.ppu . filter (not . isStabLine_a1Sw)
  where
      isStabLine_a1Sw (!((!(Main.Pseudo ln_a1Sx (!s_a1Sy)))))
        = take 5 (dropWhile isSpace s_a1Sy) == ".stab"
      isStabLine_a1Sw (!other_a1Sz) = False
Main.main
  = seq
      stderr
      (do { (!args_a1Uf) <- return ["--level2"];
            let prof_level_a1Ug
                  = if "--level0" `elem` args_a1Uf then
                        0
                    else
                        if "--level1" `elem` args_a1Uf then
                            1
                        else
                            if "--level2" `elem` args_a1Uf then
                                2
                            else
                                internal "profiling level not supplied by `cacheprof'";
            let bad_ddump_flags_a1Uh
                  = filter
                      (`notElem` Main.ddump_flags)
                      (filter ((== "--ddump-") . take 8) args_a1Uf);
            if (not (null bad_ddump_flags_a1Uh)) then
                do { hPutStr
                       stderr
                       ("cacheann: bad debugging flag(s): "
                        ++
                          unwords bad_ddump_flags_a1Uh
                          ++
                            "\n\
                            \   valid debugging flags are\n"
                            ++ unlines (map ("      " ++) Main.ddump_flags));
                     exitWith (ExitFailure 1) }
            else
                return ();
            Main.ifVerb
              args_a1Uf (hPutStr stderr "cacheann-0.01: annotating ...\n");
            f_a26a <- getContents;
            aux_a26b <- case prof_level_a1Ug of {
                          0 -> return ""
                          1 -> readFile "cacheprof_hooks1_x86.s"
                          2 -> readFile "cacheprof_hooks2_x86.s" };
            out_a26c <- Main.doFile prof_level_a1Ug args_a1Uf f_a26a;
            putStr out_a26c;
            putStr aux_a26b;
            Main.ifVerb args_a1Uf (hPutStr stderr "cacheann-0.01: done\n") })
Main.ifVerb :: [String] -> IO () -> IO ()
Main.ifVerb flags_a26d (!ioact_a26e)
  = if "-v" `elem` flags_a26d then ioact_a26e else return ()
Main.doFile :: Int -> [String] -> String -> IO String
Main.doFile prof_level_a26f (!args_a26g) (!input_text_a26h)
  = let
      (!preparsed_a26i) = Main.preparse input_text_a26h
      parsed_a26j = map forceLine_a26w (Main.parse preparsed_a26i)
      simplified_a26k = Main.simplify parsed_a26j
      with_bbs_ident_a26l = Main.identify_bbs simplified_a26k
      with_icounts_a26m = Main.use_bbs with_bbs_ident_a26l
      annotated_a26n = Main.annotate with_icounts_a26m
      with_ccs_a26o = Main.addCCs annotated_a26n
      with_synth_2_a26p = Main.synth_2 with_ccs_a26o
      with_synth_1_a26q = Main.synth_1 annotated_a26n
      with_synth_a26r
        = case prof_level_a26f of {
            (!0) -> simplified_a26k
            (!1) -> with_synth_1_a26q
            2 -> with_synth_2_a26p }
      peepholed_a26s = Main.peephole with_synth_a26r
      final_a26t = Main.final_cleanup peepholed_a26s
      debugging_io_a26u
        = do { ifopt_a26v [0, 1, 2] Main.ddump_preparsed preparsed_a26i;
               ifopt_a26v [0, 1, 2] Main.ddump_parsed parsed_a26j;
               ifopt_a26v [0, 1, 2] Main.ddump_simplified simplified_a26k;
               ifopt_a26v [1, 2] Main.ddump_ident_bbs with_bbs_ident_a26l;
               ifopt_a26v [1, 2] Main.ddump_use_bbs with_icounts_a26m;
               ifopt_a26v [1, 2] Main.ddump_annotated annotated_a26n;
               ifopt_a26v [2] Main.ddump_ccs with_ccs_a26o;
               ifopt_a26v [0, 1, 2] Main.ddump_synth with_synth_a26r;
               ifopt_a26v [0, 1, 2] Main.ddump_peephole peepholed_a26s }
      ifopt_a26v valid_levels_a26x flag_a26y stuff_a26z
        | prof_level_a26f `elem` valid_levels_a26x
          && flag_a26y `elem` args_a26g
        = hPutStr
            stderr
            ("\n\
             \\n\
             \-------- DEBUGGING OUTPUT FOR "
             ++
               flag_a26y
               ++
                 ":\n\
                 \\n"
                 ++
                   unlines (map Main.ppd stuff_a26z)
                   ++
                     "\n\
                     \\n")
        | otherwise = return ()
      forceLine_a26w :: Main.Line -> Main.Line
      forceLine_a26w line_a26A
        | line_a26A == line_a26A = line_a26A
        | otherwise = internal "forceLine"
    in debugging_io_a26u >> return final_a26t
Main.ddump_preparsed = "--ddump-preparsed"
Main.ddump_parsed = "--ddump-parsed"
Main.ddump_simplified = "--ddump-simplified"
Main.ddump_ident_bbs = "--ddump-ident-bbs"
Main.ddump_use_bbs = "--ddump-use-bbs"
Main.ddump_annotated = "--ddump-annotated"
Main.ddump_ccs = "--ddump-ccs"
Main.ddump_synth = "--ddump-synth"
Main.ddump_peephole = "--ddump-peephole"
Main.ddump_flags
  = [Main.ddump_preparsed, Main.ddump_parsed, Main.ddump_simplified,
     Main.ddump_ident_bbs, Main.ddump_use_bbs, Main.ddump_annotated,
     Main.ddump_ccs, Main.ddump_synth, Main.ddump_peephole]

data Main.PreLine
  = Main.PrePseudo Int String |
    Main.PreLabel Int String |
    Main.PreReal Int String
  deriving (Show)
data Main.PPM
  = Main.PPM_Debug | Main.PPM_User
  deriving (Eq)
class Main.PP a_a1ts where
  Main.pp :: Main.PPM -> a_a1ts -> String
  Main.ppu :: a_a1ts -> String
  Main.ppd :: a_a1ts -> String
  Main.ppl :: Main.PPM -> [a_a1ts] -> String
  Main.ppu = Main.pp Main.PPM_User
  Main.ppd = Main.pp Main.PPM_Debug
  Main.ppl (!m_a1tt)
    = concat . intersperse "," . map (Main.pp m_a1tt)
data Main.CC
  = Main.NoCC | Main.CC String Int String
  deriving (Show, Eq)
data Main.UnsignedFactor
  = Main.UF_NUM String |
    Main.UF_NAME String |
    Main.UF_LABEL String |
    Main.UF_TIMES Main.UnsignedFactor Main.UnsignedFactor
  deriving (Show, Eq)
data Main.SignedFactor
  = Main.Neg Main.UnsignedFactor | Main.Pos Main.UnsignedFactor
  deriving (Show, Eq)
newtype Main.Const
  = Main.Const [Main.SignedFactor]
  deriving (Show, Eq)
data Main.Reg
  = Main.EAX |
    Main.EBX |
    Main.ECX |
    Main.EDX |
    Main.EDI |
    Main.ESI |
    Main.EBP |
    Main.ESP |
    Main.AX |
    Main.BX |
    Main.CX |
    Main.DX |
    Main.SI |
    Main.DI |
    Main.BP |
    Main.AL |
    Main.BL |
    Main.CL |
    Main.DL |
    Main.AH |
    Main.BH |
    Main.CH |
    Main.DH |
    Main.ST_0 |
    Main.ST_1 |
    Main.ST_2 |
    Main.ST_3 |
    Main.ST_4 |
    Main.ST_5 |
    Main.ST_6 |
    Main.ST_7
  deriving (Show, Eq)
data Main.AMode
  = Main.AM_B Main.Reg |
    Main.AM_BI Main.Reg Main.Reg |
    Main.AM_IS Main.Reg String |
    Main.AM_BIS Main.Reg Main.Reg String
  deriving (Show, Eq)
data Main.Operand
  = Main.OP_REG Main.Reg |
    Main.OP_LIT Main.Const |
    Main.OP_D Main.Const |
    Main.OP_DA Main.Const Main.AMode |
    Main.OP_A Main.AMode |
    Main.OP_STAR Main.Operand
  deriving (Show, Eq)
data Main.Annot
  = Main.AnnR Int Main.Operand |
    Main.AnnM Int Main.Operand |
    Main.AnnW Int Main.Operand |
    Main.AnnC String
  deriving (Show, Eq)
data Main.Anns
  = Main.DontAnnMe | Main.SomeAnns [Main.Annot]
  deriving (Show, Eq)
data Main.Insn
  = Main.Insn Main.Anns Opcode [Main.Operand]
  deriving (Show, Eq)
data Main.Line
  = Main.Pseudo Int String |
    Main.Label Int String |
    Main.Real Int Main.CC Main.Insn
  deriving (Show, Eq)
newtype Main.BB = Main.BB [Main.Line]
data Main.PossiblyString = Main.Stated String | Main.Guessed String

instance Main.PP Main.BB where
  Main.pp (!ppm_a26B) (!(Main.BB (!ls_a26C)))
    = "{ -- basic block\n"
      ++ unlines (map (Main.pp ppm_a26B) ls_a26C) ++ "}"
instance Main.PP Opcode where
  Main.pp (!ppm_a26D) o_a26E = (drop 2 . show) o_a26E
instance Main.PP Main.Reg where
  Main.pp (!ppm_a26F) Main.ST_0 = "%st"
  Main.pp (!ppm_a26G) Main.ST_1 = "%st(1)"
  Main.pp ppm_a26H Main.ST_2 = "%st(2)"
  Main.pp ppm_a26I Main.ST_3 = "%st(3)"
  Main.pp (!ppm_a26J) (!Main.ST_4) = "%st(4)"
  Main.pp ppm_a26K Main.ST_5 = "%st(5)"
  Main.pp ppm_a26L Main.ST_6 = "%st(6)"
  Main.pp ppm_a26M Main.ST_7 = "%st(7)"
  Main.pp ppm_a26N r_a26O = "%" ++ map toLower (show r_a26O)
instance Main.PP Main.UnsignedFactor where
  Main.pp ppm_a26P (!(Main.UF_NUM n_a26Q)) = n_a26Q
  Main.pp ppm_a26R (!(Main.UF_NAME n_a26S)) = n_a26S
  Main.pp (!ppm_a26T) ((!(Main.UF_LABEL l_a26U))) = l_a26U
  Main.pp (!ppm_a26V) (!(Main.UF_TIMES a_a26W b_a26X))
    = Main.pp ppm_a26V a_a26W ++ "*" ++ Main.pp ppm_a26V b_a26X
instance Main.PP Main.SignedFactor where
  Main.pp (!ppm_a26Y) (!(Main.Neg (!factor_a26Z)))
    = "-" ++ Main.pp ppm_a26Y factor_a26Z
  Main.pp ppm_a270 ((!(Main.Pos factor_a271)))
    = "+" ++ Main.pp ppm_a270 factor_a271
instance Main.PP Main.Const where
  Main.pp ppm_a272 (Main.Const signed_factors_a273)
    = dropWhile
        (== '+') (concatMap (Main.pp ppm_a272) signed_factors_a273)
instance Main.PP Main.AMode where
  Main.pp ppm_a274 (!((!(Main.AM_B r1_a275))))
    = Main.paren (Main.pp ppm_a274 r1_a275)
  Main.pp ppm_a276 (!((!(Main.AM_BI (!r1_a277) (!r2_a278)))))
    = Main.paren
        (Main.pp ppm_a276 r1_a277 ++ "," ++ Main.pp ppm_a276 r2_a278)
  Main.pp ppm_a279 (Main.AM_IS (!r1_a27a) n_a27b)
    = Main.paren ("," ++ Main.pp ppm_a279 r1_a27a ++ "," ++ n_a27b)
  Main.pp (!ppm_a27c) (Main.AM_BIS (!r1_a27d) (!r2_a27e) (!n_a27f))
    = Main.paren
        (Main.pp ppm_a27c r1_a27d
         ++ "," ++ Main.pp ppm_a27c r2_a27e ++ "," ++ n_a27f)
instance Main.PP Main.Operand where
  Main.pp ppm_a27g (!(Main.OP_REG r_a27h)) = Main.pp ppm_a27g r_a27h
  Main.pp (!ppm_a27i) (!((!(Main.OP_LIT (!c_a27j)))))
    = "$" ++ Main.pp ppm_a27i c_a27j
  Main.pp ppm_a27k (Main.OP_D (!c_a27l)) = Main.pp ppm_a27k c_a27l
  Main.pp (!ppm_a27m) (!(Main.OP_A a_a27n)) = Main.pp ppm_a27m a_a27n
  Main.pp (!ppm_a27o) (Main.OP_DA c_a27p (!a_a27q))
    = Main.pp ppm_a27o c_a27p ++ Main.pp ppm_a27o a_a27q
  Main.pp ppm_a27r (Main.OP_STAR o_a27s)
    = "*" ++ Main.pp ppm_a27r o_a27s
instance Main.PP Main.Annot where
  Main.pp ppm_a27t (Main.AnnR w_a27u op_a27v)
    = "r" ++ show w_a27u ++ ": " ++ Main.pp ppm_a27t op_a27v
  Main.pp (!ppm_a27w) (Main.AnnM (!w_a27x) (!op_a27y))
    = "m" ++ show w_a27x ++ ": " ++ Main.pp ppm_a27w op_a27y
  Main.pp (!ppm_a27z) ((!(Main.AnnW w_a27A op_a27B)))
    = "w" ++ show w_a27A ++ ": " ++ Main.pp ppm_a27z op_a27B
  Main.pp ppm_a27C (Main.AnnC comm_a27D) = comm_a27D
  Main.ppl ppm_a27E
    = concat . intersperse "   " . map (Main.pp ppm_a27E)
instance Main.PP Main.Insn where
  Main.pp
    (!ppm_a27F)
    insn_a27G@((!(Main.Insn (!ann_a27H) (!opcode_a27I) operands_a27J)))
    = main_part_a27K
      ++
        (if ppm_a27F == Main.PPM_User || null (Main.getAnns ann_a27H) then
             []
         else
             take (max 0 (36 - length main_part_a27K)) (repeat ' ')
             ++
               (if Main.hasRealAnns insn_a27G then " # ANN " else " #     ")
               ++ Main.ppl ppm_a27F (Main.getAnns ann_a27H))
    where
        main_part_a27K
          = Main.pp ppm_a27F opcode_a27I
            ++
              (if null operands_a27J then
                   []
               else
                   " " ++ Main.ppl ppm_a27F operands_a27J)
instance Main.PP Main.CC where
  Main.pp ppm_a27L Main.NoCC = "NoCC"
  Main.pp
    ppm_a27M
    ((!(Main.CC filename_a27N (!lineno_a27O) (!fnname_a27P))))
    = filename_a27N ++ ":" ++ show lineno_a27O ++ " " ++ fnname_a27P
instance Main.PP Main.Line where
  Main.pp Main.PPM_User (Main.Pseudo ln_a27Q (!s_a27R)) = s_a27R
  Main.pp (!Main.PPM_Debug) (Main.Pseudo (!ln_a27S) s_a27T)
    = "P: " ++ s_a27T
  Main.pp (!Main.PPM_User) (!((!(Main.Label ln_a27U s_a27V))))
    = s_a27V
  Main.pp (!Main.PPM_Debug) (Main.Label ln_a27W (!s_a27X))
    = "L: " ++ s_a27X
  Main.pp Main.PPM_User (Main.Real (!ln_a27Y) cc_a27Z insn_a280)
    = "\t" ++ Main.pp Main.PPM_User insn_a280
  Main.pp
    Main.PPM_Debug
    (!((!(Main.Real (!ln_a281) (!cc_a282) (!insn_a283)))))
    = "R:        "
      ++
        Main.pp Main.PPM_Debug insn_a283
        ++
          if Main.isNoCC cc_a282 then
              ""
          else
              "\n\
              \             CC = "
              ++ Main.pp Main.PPM_Debug cc_a282
instance Main.PP Main.PreLine where
  Main.pp (!m_a284) (Main.PrePseudo ln_a285 (!s_a286))
    = "preP: " ++ s_a286
  Main.pp (!m_a287) (!((!(Main.PreLabel ln_a288 s_a289))))
    = "preL: " ++ s_a289
  Main.pp (!m_a28a) (!(Main.PreReal (!ln_a28b) (!s_a28c)))
    = "preR: " ++ s_a28c



==================== Renamer ====================
Arch_x86.x86info :: [(Arch_x86.Opcode, Arch_x86.OperandInfo)]
Arch_x86.x86info
  = [(Arch_x86.O_movl, Arch_x86.OI [Arch_x86.OE_RW 4 4]),
     (Arch_x86.O_movw, Arch_x86.OI [Arch_x86.OE_RW 2 2]),
     (Arch_x86.O_movb, Arch_x86.OI [Arch_x86.OE_RW 1 1]),
     (Arch_x86.O_movzbw, Arch_x86.OI [Arch_x86.OE_RW 1 2]),
     (Arch_x86.O_movzbl, Arch_x86.OI [Arch_x86.OE_RW 1 4]),
     (Arch_x86.O_movzwl, Arch_x86.OI [Arch_x86.OE_RW 2 4]),
     (Arch_x86.O_movsbw, Arch_x86.OI [Arch_x86.OE_RW 1 2]),
     (Arch_x86.O_movsbl, Arch_x86.OI [Arch_x86.OE_RW 1 4]),
     (Arch_x86.O_movswl, Arch_x86.OI [Arch_x86.OE_RW 2 4]),
     (Arch_x86.O_pushl, Arch_x86.OI_Special),
     (Arch_x86.O_popl, Arch_x86.OI_Special),
     (Arch_x86.O_pushfl, Arch_x86.OI_Error),
     (Arch_x86.O_popfl, Arch_x86.OI_Error),
     (Arch_x86.O_sall, Arch_x86.OI [Arch_x86.OE_RM 1 4]),
     (Arch_x86.O_salw, Arch_x86.OI [Arch_x86.OE_RM 1 2]),
     (Arch_x86.O_salb, Arch_x86.OI [Arch_x86.OE_RM 1 1]),
     (Arch_x86.O_sarl, Arch_x86.OI [Arch_x86.OE_RM 1 4]),
     (Arch_x86.O_sarw, Arch_x86.OI [Arch_x86.OE_RM 1 2]),
     (Arch_x86.O_sarb, Arch_x86.OI [Arch_x86.OE_RM 1 1]),
     (Arch_x86.O_shrl, Arch_x86.OI [Arch_x86.OE_RM 1 4]),
     (Arch_x86.O_shrw, Arch_x86.OI [Arch_x86.OE_RM 1 2]),
     (Arch_x86.O_shrb, Arch_x86.OI [Arch_x86.OE_RM 1 1]),
     (Arch_x86.O_roll, Arch_x86.OI [Arch_x86.OE_RM 1 4]),
     (Arch_x86.O_rolw, Arch_x86.OI [Arch_x86.OE_RM 1 2]),
     (Arch_x86.O_rolb, Arch_x86.OI [Arch_x86.OE_RM 1 1]),
     (Arch_x86.O_rorl, Arch_x86.OI [Arch_x86.OE_RM 1 4]),
     (Arch_x86.O_rorw, Arch_x86.OI [Arch_x86.OE_RM 1 2]),
     (Arch_x86.O_rorb, Arch_x86.OI [Arch_x86.OE_RM 1 1]),
     (Arch_x86.O_shldl, 
      Arch_x86.OI [Arch_x86.OE_RRM 4 4 4, Arch_x86.OE_RM 4 4]),
     (Arch_x86.O_shrdl, 
      Arch_x86.OI [Arch_x86.OE_RRM 4 4 4, Arch_x86.OE_RM 4 4]),
     (Arch_x86.O_addl, Arch_x86.OI [Arch_x86.OE_RM 4 4]),
     (Arch_x86.O_addw, Arch_x86.OI [Arch_x86.OE_RM 2 2]),
     (Arch_x86.O_addb, Arch_x86.OI [Arch_x86.OE_RM 1 1]),
     (Arch_x86.O_adcl, Arch_x86.OI [Arch_x86.OE_RM 4 4]),
     (Arch_x86.O_subl, Arch_x86.OI [Arch_x86.OE_RM 4 4]),
     (Arch_x86.O_subw, Arch_x86.OI [Arch_x86.OE_RM 2 2]),
     (Arch_x86.O_subb, Arch_x86.OI [Arch_x86.OE_RM 1 1]),
     (Arch_x86.O_sbbl, Arch_x86.OI [Arch_x86.OE_RM 4 4]),
     (Arch_x86.O_imull, 
      Arch_x86.OI
        [Arch_x86.OE_M 4, Arch_x86.OE_RM 4 4, Arch_x86.OE_RRM 4 4 4]),
     (Arch_x86.O_imulb, Arch_x86.OI [Arch_x86.OE_M 1]),
     (Arch_x86.O_imulw, 
      Arch_x86.OI [Arch_x86.OE_M 2, Arch_x86.OE_RM 2 2]),
     (Arch_x86.O_mull, Arch_x86.OI [Arch_x86.OE_M 4]),
     (Arch_x86.O_idivl, Arch_x86.OI [Arch_x86.OE_M 4]),
     (Arch_x86.O_divl, Arch_x86.OI [Arch_x86.OE_M 4]),
     (Arch_x86.O_divw, Arch_x86.OI [Arch_x86.OE_M 2]),
     (Arch_x86.O_divb, Arch_x86.OI [Arch_x86.OE_M 1]),
     (Arch_x86.O_xorl, Arch_x86.OI [Arch_x86.OE_RM 4 4]),
     (Arch_x86.O_xorw, Arch_x86.OI [Arch_x86.OE_RM 2 2]),
     (Arch_x86.O_xorb, Arch_x86.OI [Arch_x86.OE_RM 1 1]),
     (Arch_x86.O_andl, Arch_x86.OI [Arch_x86.OE_RM 4 4]),
     (Arch_x86.O_andw, Arch_x86.OI [Arch_x86.OE_RM 2 2]),
     (Arch_x86.O_andb, Arch_x86.OI [Arch_x86.OE_RM 1 1]),
     (Arch_x86.O_orl, Arch_x86.OI [Arch_x86.OE_RM 4 4]),
     (Arch_x86.O_orw, Arch_x86.OI [Arch_x86.OE_RM 2 2]),
     (Arch_x86.O_orb, Arch_x86.OI [Arch_x86.OE_RM 1 1]),
     (Arch_x86.O_incl, Arch_x86.OI [Arch_x86.OE_M 4]),
     (Arch_x86.O_incw, Arch_x86.OI [Arch_x86.OE_M 2]),
     (Arch_x86.O_incb, Arch_x86.OI [Arch_x86.OE_M 1]),
     (Arch_x86.O_decl, Arch_x86.OI [Arch_x86.OE_M 4]),
     (Arch_x86.O_decw, Arch_x86.OI [Arch_x86.OE_M 2]),
     (Arch_x86.O_decb, Arch_x86.OI [Arch_x86.OE_M 1]),
     (Arch_x86.O_negl, Arch_x86.OI [Arch_x86.OE_M 4]),
     (Arch_x86.O_negw, Arch_x86.OI [Arch_x86.OE_M 2]),
     (Arch_x86.O_negb, Arch_x86.OI [Arch_x86.OE_M 1]),
     (Arch_x86.O_notl, Arch_x86.OI [Arch_x86.OE_M 4]),
     (Arch_x86.O_notw, Arch_x86.OI [Arch_x86.OE_M 2]),
     (Arch_x86.O_notb, Arch_x86.OI [Arch_x86.OE_M 1]),
     (Arch_x86.O_testl, Arch_x86.OI [Arch_x86.OE_RR 4 4]),
     (Arch_x86.O_testw, Arch_x86.OI [Arch_x86.OE_RR 2 2]),
     (Arch_x86.O_testb, Arch_x86.OI [Arch_x86.OE_RR 1 1]),
     (Arch_x86.O_leal, Arch_x86.OI [Arch_x86.OE_nW 4]),
     (Arch_x86.O_cmpl, Arch_x86.OI [Arch_x86.OE_RR 4 4]),
     (Arch_x86.O_cmpw, Arch_x86.OI [Arch_x86.OE_RR 2 2]),
     (Arch_x86.O_cmpb, Arch_x86.OI [Arch_x86.OE_RR 1 1]),
     (Arch_x86.O_cmpsb, Arch_x86.OI_Special),
     (Arch_x86.O_scasb, Arch_x86.OI_Special),
     (Arch_x86.O_movsl, Arch_x86.OI_Special),
     (Arch_x86.O_movsw, Arch_x86.OI_Special),
     (Arch_x86.O_movsb, Arch_x86.OI_Special),
     (Arch_x86.O_stosl, Arch_x86.OI_Special),
     (Arch_x86.O_stosw, Arch_x86.OI_Special),
     (Arch_x86.O_stosb, Arch_x86.OI_Special),
     (Arch_x86.O_leave, Arch_x86.OI_Error),
     (Arch_x86.O_ret, Arch_x86.OI_Special),
     (Arch_x86.O_call, Arch_x86.OI_Special),
     (Arch_x86.O_jmp, Arch_x86.OI_Jumpy),
     (Arch_x86.O_je, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jne, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jl, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jle, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jg, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jge, Arch_x86.OI_Jumpy),
     (Arch_x86.O_js, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jns, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jz, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jnz, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jc, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jnc, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jo, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jno, Arch_x86.OI_Jumpy),
     (Arch_x86.O_ja, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jae, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jb, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jbe, Arch_x86.OI_Jumpy),
     (Arch_x86.O_jp, Arch_x86.OI_Jumpy),
     (Arch_x86.O_seta, Arch_x86.OI [Arch_x86.OE_W 1]),
     (Arch_x86.O_setae, Arch_x86.OI [Arch_x86.OE_W 1]),
     (Arch_x86.O_setb, Arch_x86.OI [Arch_x86.OE_W 1]),
     (Arch_x86.O_setbe, Arch_x86.OI [Arch_x86.OE_W 1]),
     (Arch_x86.O_sete, Arch_x86.OI [Arch_x86.OE_W 1]),
     (Arch_x86.O_setne, Arch_x86.OI [Arch_x86.OE_W 1]),
     (Arch_x86.O_setl, Arch_x86.OI [Arch_x86.OE_W 1]),
     (Arch_x86.O_setle, Arch_x86.OI [Arch_x86.OE_W 1]),
     (Arch_x86.O_setg, Arch_x86.OI [Arch_x86.OE_W 1]),
     (Arch_x86.O_setge, Arch_x86.OI [Arch_x86.OE_W 1]),
     (Arch_x86.O_setc, Arch_x86.OI [Arch_x86.OE_W 1]),
     (Arch_x86.O_setcb, Arch_x86.OI [Arch_x86.OE_W 1]),
     (Arch_x86.O_btl, Arch_x86.OI [Arch_x86.OE_RR 4 4]),
     (Arch_x86.O_btsl, Arch_x86.OI [Arch_x86.OE_RM 4 4]),
     (Arch_x86.O_btcl, Arch_x86.OI [Arch_x86.OE_RM 4 4]),
     (Arch_x86.O_btrl, Arch_x86.OI [Arch_x86.OE_RM 4 4]),
     (Arch_x86.O_cld, Arch_x86.OI_NoEffect),
     (Arch_x86.O_cltd, Arch_x86.OI_NoEffect),
     (Arch_x86.O_cwtl, Arch_x86.OI_NoEffect),
     (Arch_x86.O_cbtw, Arch_x86.OI_NoEffect),
     (Arch_x86.O_rep, Arch_x86.OI_Error),
     (Arch_x86.O_repz, Arch_x86.OI_Error),
     (Arch_x86.O_repnz, Arch_x86.OI_Error),
     (Arch_x86.O_fld, Arch_x86.OI [Arch_x86.OE_R 8]),
     (Arch_x86.O_fldt, Arch_x86.OI [Arch_x86.OE_R 8]),
     (Arch_x86.O_fldl, Arch_x86.OI [Arch_x86.OE_R 8]),
     (Arch_x86.O_flds, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_fild, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_fildl, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_fildll, Arch_x86.OI [Arch_x86.OE_R 8]),
     (Arch_x86.O_fstl, Arch_x86.OI [Arch_x86.OE_W 8]),
     (Arch_x86.O_fstpl, Arch_x86.OI [Arch_x86.OE_W 8]),
     (Arch_x86.O_fstp, Arch_x86.OI [Arch_x86.OE_W 8]),
     (Arch_x86.O_fstps, Arch_x86.OI [Arch_x86.OE_W 4]),
     (Arch_x86.O_fsts, Arch_x86.OI [Arch_x86.OE_W 4]),
     (Arch_x86.O_fstpt, Arch_x86.OI [Arch_x86.OE_W 8]),
     (Arch_x86.O_fistl, Arch_x86.OI [Arch_x86.OE_W 4]),
     (Arch_x86.O_fistpl, Arch_x86.OI [Arch_x86.OE_W 4]),
     (Arch_x86.O_fistpll, Arch_x86.OI [Arch_x86.OE_W 8]),
     (Arch_x86.O_fst, Arch_x86.OI [Arch_x86.OE_W 8]),
     (Arch_x86.O_fldz, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fld1, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fldl2e, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fldln2, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fchs, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fsin, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fcos, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fptan, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fsqrt, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fpatan, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fabs, Arch_x86.OI_NoEffect),
     (Arch_x86.O_f2xm1, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fscale, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fyl2x, Arch_x86.OI_NoEffect),
     (Arch_x86.O_faddp, 
      Arch_x86.OI [Arch_x86.OE_R 8, Arch_x86.OE_RM 8 8]),
     (Arch_x86.O_fadds, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_faddl, Arch_x86.OI [Arch_x86.OE_R 8]),
     (Arch_x86.O_fiaddl, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_fadd, 
      Arch_x86.OI [Arch_x86.OE_R 8, Arch_x86.OE_RM 8 8]),
     (Arch_x86.O_fsubp, Arch_x86.OI [Arch_x86.OE_RM 8 8]),
     (Arch_x86.O_fsubrp, Arch_x86.OI [Arch_x86.OE_RM 8 8]),
     (Arch_x86.O_fsubrl, Arch_x86.OI [Arch_x86.OE_R 8]),
     (Arch_x86.O_fsubrs, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_fsubs, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_fsubl, Arch_x86.OI [Arch_x86.OE_R 8]),
     (Arch_x86.O_fsub, 
      Arch_x86.OI [Arch_x86.OE_R 8, Arch_x86.OE_RM 8 8]),
     (Arch_x86.O_fsubr, 
      Arch_x86.OI [Arch_x86.OE_R 8, Arch_x86.OE_RM 8 8]),
     (Arch_x86.O_fmul, 
      Arch_x86.OI [Arch_x86.OE_R 8, Arch_x86.OE_RM 8 8]),
     (Arch_x86.O_fmuls, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_fmull, Arch_x86.OI [Arch_x86.OE_R 8]),
     (Arch_x86.O_fmulp, 
      Arch_x86.OI [Arch_x86.OE_R 8, Arch_x86.OE_RM 8 8]),
     (Arch_x86.O_fimull, Arch_x86.OI [Arch_x86.OE_R 8]),
     (Arch_x86.O_fdiv, Arch_x86.OI [Arch_x86.OE_RM 8 8]),
     (Arch_x86.O_fdivp, Arch_x86.OI [Arch_x86.OE_RM 8 8]),
     (Arch_x86.O_fdivr, Arch_x86.OI [Arch_x86.OE_RM 8 8]),
     (Arch_x86.O_fdivrl, Arch_x86.OI [Arch_x86.OE_R 8]),
     (Arch_x86.O_fdivrs, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_fdivrp, Arch_x86.OI [Arch_x86.OE_RM 8 8]),
     (Arch_x86.O_fidivrl, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_fidivl, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_fdivl, Arch_x86.OI [Arch_x86.OE_R 8]),
     (Arch_x86.O_fdivs, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_fprem, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fucom, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fucomp, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fucompp, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fcomp, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fcompp, Arch_x86.OI_NoEffect),
     (Arch_x86.O_fcoms, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_fcoml, Arch_x86.OI [Arch_x86.OE_R 8]),
     (Arch_x86.O_fcom, Arch_x86.OI [Arch_x86.OE_R 8]),
     (Arch_x86.O_fcomps, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_fcompl, Arch_x86.OI [Arch_x86.OE_R 8]),
     (Arch_x86.O_ficompl, Arch_x86.OI [Arch_x86.OE_R 4]),
     (Arch_x86.O_fnstsw, Arch_x86.OI [Arch_x86.OE_W 2]),
     (Arch_x86.O_fnstcw, Arch_x86.OI [Arch_x86.OE_W 2]),
     (Arch_x86.O_fldcw, Arch_x86.OI [Arch_x86.OE_R 2]),
     (Arch_x86.O_fxch, Arch_x86.OI_NoEffect),
     (Arch_x86.O_frndint, Arch_x86.OI_NoEffect),
     (Arch_x86.O_sahf, Arch_x86.OI_NoEffect),
     (Arch_x86.O_nop, Arch_x86.OI_NoEffect)]
Arch_x86.nonJumpyOpcodes :: [Arch_x86.Opcode]
Arch_x86.nonJumpyOpcodes
  = [Arch_x86.O_pushl, Arch_x86.O_popl, Arch_x86.O_movl,
     Arch_x86.O_movw, Arch_x86.O_movb, Arch_x86.O_andl, Arch_x86.O_andw,
     Arch_x86.O_andb, Arch_x86.O_orl, Arch_x86.O_orw, Arch_x86.O_orb,
     Arch_x86.O_xorl, Arch_x86.O_xorw, Arch_x86.O_xorb, Arch_x86.O_addl,
     Arch_x86.O_addw, Arch_x86.O_addb, Arch_x86.O_subl, Arch_x86.O_subw,
     Arch_x86.O_subb, Arch_x86.O_incl, Arch_x86.O_incw, Arch_x86.O_incb,
     Arch_x86.O_decl, Arch_x86.O_decw, Arch_x86.O_decb, Arch_x86.O_cmpl,
     Arch_x86.O_cmpw, Arch_x86.O_cmpb, Arch_x86.O_sall, Arch_x86.O_salw,
     Arch_x86.O_salb, Arch_x86.O_shrl, Arch_x86.O_shrw, Arch_x86.O_shrb,
     Arch_x86.O_sarl, Arch_x86.O_leal, Arch_x86.O_movzbw,
     Arch_x86.O_movzbl, Arch_x86.O_movzwl, Arch_x86.O_movsbw,
     Arch_x86.O_movsbl, Arch_x86.O_movswl, Arch_x86.O_seta,
     Arch_x86.O_setae, Arch_x86.O_setb, Arch_x86.O_setbe,
     Arch_x86.O_sete, Arch_x86.O_setne, Arch_x86.O_setl,
     Arch_x86.O_setle, Arch_x86.O_setg, Arch_x86.O_setge,
     Arch_x86.O_setc, Arch_x86.O_setcb, Arch_x86.O_testl,
     Arch_x86.O_testw, Arch_x86.O_testb, Arch_x86.O_fld1,
     Arch_x86.O_fcoml, Arch_x86.O_fnstsw, Arch_x86.O_fstpl,
     Arch_x86.O_fstp, Arch_x86.O_fsubrl, Arch_x86.O_fldl,
     Arch_x86.O_faddl, Arch_x86.O_fsubl]

data Arch_x86.Opcode
  = Arch_x86.O_movl |
    Arch_x86.O_movw |
    Arch_x86.O_movb |
    Arch_x86.O_movzbw |
    Arch_x86.O_movzbl |
    Arch_x86.O_movzwl |
    Arch_x86.O_movsbw |
    Arch_x86.O_movsbl |
    Arch_x86.O_movswl |
    Arch_x86.O_pushl |
    Arch_x86.O_popl |
    Arch_x86.O_pushfl |
    Arch_x86.O_popfl |
    Arch_x86.O_notl |
    Arch_x86.O_notw |
    Arch_x86.O_notb |
    Arch_x86.O_sall |
    Arch_x86.O_salw |
    Arch_x86.O_salb |
    Arch_x86.O_sarl |
    Arch_x86.O_sarw |
    Arch_x86.O_sarb |
    Arch_x86.O_shrl |
    Arch_x86.O_shrw |
    Arch_x86.O_shrb |
    Arch_x86.O_roll |
    Arch_x86.O_rolw |
    Arch_x86.O_rolb |
    Arch_x86.O_rorl |
    Arch_x86.O_rorw |
    Arch_x86.O_rorb |
    Arch_x86.O_shldl |
    Arch_x86.O_shrdl |
    Arch_x86.O_addl |
    Arch_x86.O_addw |
    Arch_x86.O_addb |
    Arch_x86.O_adcl |
    Arch_x86.O_subl |
    Arch_x86.O_subw |
    Arch_x86.O_subb |
    Arch_x86.O_sbbl |
    Arch_x86.O_imull |
    Arch_x86.O_imulw |
    Arch_x86.O_imulb |
    Arch_x86.O_mull |
    Arch_x86.O_divl |
    Arch_x86.O_divw |
    Arch_x86.O_divb |
    Arch_x86.O_idivl |
    Arch_x86.O_xorl |
    Arch_x86.O_xorw |
    Arch_x86.O_xorb |
    Arch_x86.O_andl |
    Arch_x86.O_andw |
    Arch_x86.O_andb |
    Arch_x86.O_orl |
    Arch_x86.O_orw |
    Arch_x86.O_orb |
    Arch_x86.O_incl |
    Arch_x86.O_incw |
    Arch_x86.O_incb |
    Arch_x86.O_decl |
    Arch_x86.O_decw |
    Arch_x86.O_decb |
    Arch_x86.O_negl |
    Arch_x86.O_negw |
    Arch_x86.O_negb |
    Arch_x86.O_testl |
    Arch_x86.O_testw |
    Arch_x86.O_testb |
    Arch_x86.O_leal |
    Arch_x86.O_cmpl |
    Arch_x86.O_cmpw |
    Arch_x86.O_cmpb |
    Arch_x86.O_cmpsb |
    Arch_x86.O_scasb |
    Arch_x86.O_movsl |
    Arch_x86.O_movsw |
    Arch_x86.O_movsb |
    Arch_x86.O_stosl |
    Arch_x86.O_stosw |
    Arch_x86.O_stosb |
    Arch_x86.O_leave |
    Arch_x86.O_ret |
    Arch_x86.O_call |
    Arch_x86.O_jmp |
    Arch_x86.O_je |
    Arch_x86.O_jne |
    Arch_x86.O_jl |
    Arch_x86.O_jle |
    Arch_x86.O_jg |
    Arch_x86.O_jge |
    Arch_x86.O_js |
    Arch_x86.O_jns |
    Arch_x86.O_jz |
    Arch_x86.O_jnz |
    Arch_x86.O_jc |
    Arch_x86.O_jnc |
    Arch_x86.O_jo |
    Arch_x86.O_jno |
    Arch_x86.O_ja |
    Arch_x86.O_jae |
    Arch_x86.O_jb |
    Arch_x86.O_jbe |
    Arch_x86.O_jp |
    Arch_x86.O_seta |
    Arch_x86.O_setae |
    Arch_x86.O_setb |
    Arch_x86.O_setbe |
    Arch_x86.O_sete |
    Arch_x86.O_setne |
    Arch_x86.O_setl |
    Arch_x86.O_setle |
    Arch_x86.O_setg |
    Arch_x86.O_setge |
    Arch_x86.O_setc |
    Arch_x86.O_setcb |
    Arch_x86.O_btl |
    Arch_x86.O_btsl |
    Arch_x86.O_btrl |
    Arch_x86.O_btcl |
    Arch_x86.O_cld |
    Arch_x86.O_cltd |
    Arch_x86.O_cwtl |
    Arch_x86.O_cbtw |
    Arch_x86.O_rep |
    Arch_x86.O_repz |
    Arch_x86.O_repnz |
    Arch_x86.O_fild |
    Arch_x86.O_fildl |
    Arch_x86.O_fildll |
    Arch_x86.O_fsubp |
    Arch_x86.O_fsubr |
    Arch_x86.O_fsubrp |
    Arch_x86.O_fsubrl |
    Arch_x86.O_fsubrs |
    Arch_x86.O_fsubs |
    Arch_x86.O_fsubl |
    Arch_x86.O_fsub |
    Arch_x86.O_faddp |
    Arch_x86.O_fadds |
    Arch_x86.O_faddl |
    Arch_x86.O_fadd |
    Arch_x86.O_fiaddl |
    Arch_x86.O_fmul |
    Arch_x86.O_fmuls |
    Arch_x86.O_fmull |
    Arch_x86.O_fmulp |
    Arch_x86.O_fimull |
    Arch_x86.O_fdiv |
    Arch_x86.O_fdivp |
    Arch_x86.O_fdivr |
    Arch_x86.O_fdivrs |
    Arch_x86.O_fdivrl |
    Arch_x86.O_fdivrp |
    Arch_x86.O_fidivl |
    Arch_x86.O_fidivrl |
    Arch_x86.O_fdivl |
    Arch_x86.O_fdivs |
    Arch_x86.O_fprem |
    Arch_x86.O_fstp |
    Arch_x86.O_fsts |
    Arch_x86.O_fstps |
    Arch_x86.O_fstl |
    Arch_x86.O_fstpl |
    Arch_x86.O_fstpt |
    Arch_x86.O_fst |
    Arch_x86.O_fistl |
    Arch_x86.O_fistpl |
    Arch_x86.O_fistpll |
    Arch_x86.O_fld |
    Arch_x86.O_flds |
    Arch_x86.O_fldl |
    Arch_x86.O_fldt |
    Arch_x86.O_fldz |
    Arch_x86.O_fld1 |
    Arch_x86.O_fldl2e |
    Arch_x86.O_fldln2 |
    Arch_x86.O_fchs |
    Arch_x86.O_fsin |
    Arch_x86.O_fcos |
    Arch_x86.O_fptan |
    Arch_x86.O_fsqrt |
    Arch_x86.O_fpatan |
    Arch_x86.O_fabs |
    Arch_x86.O_f2xm1 |
    Arch_x86.O_fscale |
    Arch_x86.O_fyl2x |
    Arch_x86.O_fucom |
    Arch_x86.O_fucomp |
    Arch_x86.O_fucompp |
    Arch_x86.O_fcomp |
    Arch_x86.O_fcompp |
    Arch_x86.O_fcoml |
    Arch_x86.O_fcompl |
    Arch_x86.O_ficompl |
    Arch_x86.O_fcoms |
    Arch_x86.O_fcom |
    Arch_x86.O_fcomps |
    Arch_x86.O_fnstsw |
    Arch_x86.O_fnstcw |
    Arch_x86.O_fldcw |
    Arch_x86.O_frndint |
    Arch_x86.O_fxch |
    Arch_x86.O_sahf |
    Arch_x86.O_nop
  deriving (Show, Eq)
data Arch_x86.OperandEffect
  = Arch_x86.OE_RR Int Int |
    Arch_x86.OE_RM Int Int |
    Arch_x86.OE_RW Int Int |
    Arch_x86.OE_nW Int |
    Arch_x86.OE_RRM Int Int Int |
    Arch_x86.OE_R Int |
    Arch_x86.OE_M Int |
    Arch_x86.OE_W Int
  deriving (Show, Eq)
data Arch_x86.OperandInfo
  = Arch_x86.OI_Special |
    Arch_x86.OI_Jumpy |
    Arch_x86.OI_NoEffect |
    Arch_x86.OI_Error |
    Arch_x86.OI [Arch_x86.OperandEffect]
  deriving (Show, Eq)


["x86info","nonJumpyOpcodes"]
module Arch_x86
       (Opcode(..), OperandInfo(..), OperandEffect(..), x86info,
        nonJumpyOpcodes)
       where

x86info :: [(Opcode, OperandInfo)]
x86info
  = [(O_movl, OI [OE_RW 4 4]), (O_movw, OI [OE_RW 2 2]),
     (O_movb, OI [OE_RW 1 1]), (O_movzbw, OI [OE_RW 1 2]),
     (O_movzbl, OI [OE_RW 1 4]), (O_movzwl, OI [OE_RW 2 4]),
     (O_movsbw, OI [OE_RW 1 2]), (O_movsbl, OI [OE_RW 1 4]),
     (O_movswl, OI [OE_RW 2 4]), (O_pushl, OI_Special),
     (O_popl, OI_Special), (O_pushfl, OI_Error), (O_popfl, OI_Error),
     (O_sall, OI [OE_RM 1 4]), (O_salw, OI [OE_RM 1 2]),
     (O_salb, OI [OE_RM 1 1]), (O_sarl, OI [OE_RM 1 4]),
     (O_sarw, OI [OE_RM 1 2]), (O_sarb, OI [OE_RM 1 1]),
     (O_shrl, OI [OE_RM 1 4]), (O_shrw, OI [OE_RM 1 2]),
     (O_shrb, OI [OE_RM 1 1]), (O_roll, OI [OE_RM 1 4]),
     (O_rolw, OI [OE_RM 1 2]), (O_rolb, OI [OE_RM 1 1]),
     (O_rorl, OI [OE_RM 1 4]), (O_rorw, OI [OE_RM 1 2]),
     (O_rorb, OI [OE_RM 1 1]), (O_shldl, OI [OE_RRM 4 4 4, OE_RM 4 4]),
     (O_shrdl, OI [OE_RRM 4 4 4, OE_RM 4 4]), (O_addl, OI [OE_RM 4 4]),
     (O_addw, OI [OE_RM 2 2]), (O_addb, OI [OE_RM 1 1]),
     (O_adcl, OI [OE_RM 4 4]), (O_subl, OI [OE_RM 4 4]),
     (O_subw, OI [OE_RM 2 2]), (O_subb, OI [OE_RM 1 1]),
     (O_sbbl, OI [OE_RM 4 4]),
     (O_imull, OI [OE_M 4, OE_RM 4 4, OE_RRM 4 4 4]),
     (O_imulb, OI [OE_M 1]), (O_imulw, OI [OE_M 2, OE_RM 2 2]),
     (O_mull, OI [OE_M 4]), (O_idivl, OI [OE_M 4]),
     (O_divl, OI [OE_M 4]), (O_divw, OI [OE_M 2]),
     (O_divb, OI [OE_M 1]), (O_xorl, OI [OE_RM 4 4]),
     (O_xorw, OI [OE_RM 2 2]), (O_xorb, OI [OE_RM 1 1]),
     (O_andl, OI [OE_RM 4 4]), (O_andw, OI [OE_RM 2 2]),
     (O_andb, OI [OE_RM 1 1]), (O_orl, OI [OE_RM 4 4]),
     (O_orw, OI [OE_RM 2 2]), (O_orb, OI [OE_RM 1 1]),
     (O_incl, OI [OE_M 4]), (O_incw, OI [OE_M 2]),
     (O_incb, OI [OE_M 1]), (O_decl, OI [OE_M 4]),
     (O_decw, OI [OE_M 2]), (O_decb, OI [OE_M 1]),
     (O_negl, OI [OE_M 4]), (O_negw, OI [OE_M 2]),
     (O_negb, OI [OE_M 1]), (O_notl, OI [OE_M 4]),
     (O_notw, OI [OE_M 2]), (O_notb, OI [OE_M 1]),
     (O_testl, OI [OE_RR 4 4]), (O_testw, OI [OE_RR 2 2]),
     (O_testb, OI [OE_RR 1 1]), (O_leal, OI [OE_nW 4]),
     (O_cmpl, OI [OE_RR 4 4]), (O_cmpw, OI [OE_RR 2 2]),
     (O_cmpb, OI [OE_RR 1 1]), (O_cmpsb, OI_Special),
     (O_scasb, OI_Special), (O_movsl, OI_Special),
     (O_movsw, OI_Special), (O_movsb, OI_Special),
     (O_stosl, OI_Special), (O_stosw, OI_Special),
     (O_stosb, OI_Special), (O_leave, OI_Error), (O_ret, OI_Special),
     (O_call, OI_Special), (O_jmp, OI_Jumpy), (O_je, OI_Jumpy),
     (O_jne, OI_Jumpy), (O_jl, OI_Jumpy), (O_jle, OI_Jumpy),
     (O_jg, OI_Jumpy), (O_jge, OI_Jumpy), (O_js, OI_Jumpy),
     (O_jns, OI_Jumpy), (O_jz, OI_Jumpy), (O_jnz, OI_Jumpy),
     (O_jc, OI_Jumpy), (O_jnc, OI_Jumpy), (O_jo, OI_Jumpy),
     (O_jno, OI_Jumpy), (O_ja, OI_Jumpy), (O_jae, OI_Jumpy),
     (O_jb, OI_Jumpy), (O_jbe, OI_Jumpy), (O_jp, OI_Jumpy),
     (O_seta, OI [OE_W 1]), (O_setae, OI [OE_W 1]),
     (O_setb, OI [OE_W 1]), (O_setbe, OI [OE_W 1]),
     (O_sete, OI [OE_W 1]), (O_setne, OI [OE_W 1]),
     (O_setl, OI [OE_W 1]), (O_setle, OI [OE_W 1]),
     (O_setg, OI [OE_W 1]), (O_setge, OI [OE_W 1]),
     (O_setc, OI [OE_W 1]), (O_setcb, OI [OE_W 1]),
     (O_btl, OI [OE_RR 4 4]), (O_btsl, OI [OE_RM 4 4]),
     (O_btcl, OI [OE_RM 4 4]), (O_btrl, OI [OE_RM 4 4]),
     (O_cld, OI_NoEffect), (O_cltd, OI_NoEffect), (O_cwtl, OI_NoEffect),
     (O_cbtw, OI_NoEffect), (O_rep, OI_Error), (O_repz, OI_Error),
     (O_repnz, OI_Error), (O_fld, OI [OE_R 8]), (O_fldt, OI [OE_R 8]),
     (O_fldl, OI [OE_R 8]), (O_flds, OI [OE_R 4]),
     (O_fild, OI [OE_R 4]), (O_fildl, OI [OE_R 4]),
     (O_fildll, OI [OE_R 8]), (O_fstl, OI [OE_W 8]),
     (O_fstpl, OI [OE_W 8]), (O_fstp, OI [OE_W 8]),
     (O_fstps, OI [OE_W 4]), (O_fsts, OI [OE_W 4]),
     (O_fstpt, OI [OE_W 8]), (O_fistl, OI [OE_W 4]),
     (O_fistpl, OI [OE_W 4]), (O_fistpll, OI [OE_W 8]),
     (O_fst, OI [OE_W 8]), (O_fldz, OI_NoEffect), (O_fld1, OI_NoEffect),
     (O_fldl2e, OI_NoEffect), (O_fldln2, OI_NoEffect),
     (O_fchs, OI_NoEffect), (O_fsin, OI_NoEffect),
     (O_fcos, OI_NoEffect), (O_fptan, OI_NoEffect),
     (O_fsqrt, OI_NoEffect), (O_fpatan, OI_NoEffect),
     (O_fabs, OI_NoEffect), (O_f2xm1, OI_NoEffect),
     (O_fscale, OI_NoEffect), (O_fyl2x, OI_NoEffect),
     (O_faddp, OI [OE_R 8, OE_RM 8 8]), (O_fadds, OI [OE_R 4]),
     (O_faddl, OI [OE_R 8]), (O_fiaddl, OI [OE_R 4]),
     (O_fadd, OI [OE_R 8, OE_RM 8 8]), (O_fsubp, OI [OE_RM 8 8]),
     (O_fsubrp, OI [OE_RM 8 8]), (O_fsubrl, OI [OE_R 8]),
     (O_fsubrs, OI [OE_R 4]), (O_fsubs, OI [OE_R 4]),
     (O_fsubl, OI [OE_R 8]), (O_fsub, OI [OE_R 8, OE_RM 8 8]),
     (O_fsubr, OI [OE_R 8, OE_RM 8 8]),
     (O_fmul, OI [OE_R 8, OE_RM 8 8]), (O_fmuls, OI [OE_R 4]),
     (O_fmull, OI [OE_R 8]), (O_fmulp, OI [OE_R 8, OE_RM 8 8]),
     (O_fimull, OI [OE_R 8]), (O_fdiv, OI [OE_RM 8 8]),
     (O_fdivp, OI [OE_RM 8 8]), (O_fdivr, OI [OE_RM 8 8]),
     (O_fdivrl, OI [OE_R 8]), (O_fdivrs, OI [OE_R 4]),
     (O_fdivrp, OI [OE_RM 8 8]), (O_fidivrl, OI [OE_R 4]),
     (O_fidivl, OI [OE_R 4]), (O_fdivl, OI [OE_R 8]),
     (O_fdivs, OI [OE_R 4]), (O_fprem, OI_NoEffect),
     (O_fucom, OI_NoEffect), (O_fucomp, OI_NoEffect),
     (O_fucompp, OI_NoEffect), (O_fcomp, OI_NoEffect),
     (O_fcompp, OI_NoEffect), (O_fcoms, OI [OE_R 4]),
     (O_fcoml, OI [OE_R 8]), (O_fcom, OI [OE_R 8]),
     (O_fcomps, OI [OE_R 4]), (O_fcompl, OI [OE_R 8]),
     (O_ficompl, OI [OE_R 4]), (O_fnstsw, OI [OE_W 2]),
     (O_fnstcw, OI [OE_W 2]), (O_fldcw, OI [OE_R 2]),
     (O_fxch, OI_NoEffect), (O_frndint, OI_NoEffect),
     (O_sahf, OI_NoEffect), (O_nop, OI_NoEffect)]

nonJumpyOpcodes :: [Opcode]
nonJumpyOpcodes
  = [O_pushl, O_popl, O_movl, O_movw, O_movb, O_andl, O_andw, O_andb,
     O_orl, O_orw, O_orb, O_xorl, O_xorw, O_xorb, O_addl, O_addw,
     O_addb, O_subl, O_subw, O_subb, O_incl, O_incw, O_incb, O_decl,
     O_decw, O_decb, O_cmpl, O_cmpw, O_cmpb, O_sall, O_salw, O_salb,
     O_shrl, O_shrw, O_shrb, O_sarl, O_leal, O_movzbw, O_movzbl,
     O_movzwl, O_movsbw, O_movsbl, O_movswl, O_seta, O_setae, O_setb,
     O_setbe, O_sete, O_setne, O_setl, O_setle, O_setg, O_setge, O_setc,
     O_setcb, O_testl, O_testw, O_testb, O_fld1, O_fcoml, O_fnstsw,
     O_fstpl, O_fstp, O_fsubrl, O_fldl, O_faddl, O_fsubl]

data Opcode = O_movl
            | O_movw
            | O_movb
            | O_movzbw
            | O_movzbl
            | O_movzwl
            | O_movsbw
            | O_movsbl
            | O_movswl
            | O_pushl
            | O_popl
            | O_pushfl
            | O_popfl
            | O_notl
            | O_notw
            | O_notb
            | O_sall
            | O_salw
            | O_salb
            | O_sarl
            | O_sarw
            | O_sarb
            | O_shrl
            | O_shrw
            | O_shrb
            | O_roll
            | O_rolw
            | O_rolb
            | O_rorl
            | O_rorw
            | O_rorb
            | O_shldl
            | O_shrdl
            | O_addl
            | O_addw
            | O_addb
            | O_adcl
            | O_subl
            | O_subw
            | O_subb
            | O_sbbl
            | O_imull
            | O_imulw
            | O_imulb
            | O_mull
            | O_divl
            | O_divw
            | O_divb
            | O_idivl
            | O_xorl
            | O_xorw
            | O_xorb
            | O_andl
            | O_andw
            | O_andb
            | O_orl
            | O_orw
            | O_orb
            | O_incl
            | O_incw
            | O_incb
            | O_decl
            | O_decw
            | O_decb
            | O_negl
            | O_negw
            | O_negb
            | O_testl
            | O_testw
            | O_testb
            | O_leal
            | O_cmpl
            | O_cmpw
            | O_cmpb
            | O_cmpsb
            | O_scasb
            | O_movsl
            | O_movsw
            | O_movsb
            | O_stosl
            | O_stosw
            | O_stosb
            | O_leave
            | O_ret
            | O_call
            | O_jmp
            | O_je
            | O_jne
            | O_jl
            | O_jle
            | O_jg
            | O_jge
            | O_js
            | O_jns
            | O_jz
            | O_jnz
            | O_jc
            | O_jnc
            | O_jo
            | O_jno
            | O_ja
            | O_jae
            | O_jb
            | O_jbe
            | O_jp
            | O_seta
            | O_setae
            | O_setb
            | O_setbe
            | O_sete
            | O_setne
            | O_setl
            | O_setle
            | O_setg
            | O_setge
            | O_setc
            | O_setcb
            | O_btl
            | O_btsl
            | O_btrl
            | O_btcl
            | O_cld
            | O_cltd
            | O_cwtl
            | O_cbtw
            | O_rep
            | O_repz
            | O_repnz
            | O_fild
            | O_fildl
            | O_fildll
            | O_fsubp
            | O_fsubr
            | O_fsubrp
            | O_fsubrl
            | O_fsubrs
            | O_fsubs
            | O_fsubl
            | O_fsub
            | O_faddp
            | O_fadds
            | O_faddl
            | O_fadd
            | O_fiaddl
            | O_fmul
            | O_fmuls
            | O_fmull
            | O_fmulp
            | O_fimull
            | O_fdiv
            | O_fdivp
            | O_fdivr
            | O_fdivrs
            | O_fdivrl
            | O_fdivrp
            | O_fidivl
            | O_fidivrl
            | O_fdivl
            | O_fdivs
            | O_fprem
            | O_fstp
            | O_fsts
            | O_fstps
            | O_fstl
            | O_fstpl
            | O_fstpt
            | O_fst
            | O_fistl
            | O_fistpl
            | O_fistpll
            | O_fld
            | O_flds
            | O_fldl
            | O_fldt
            | O_fldz
            | O_fld1
            | O_fldl2e
            | O_fldln2
            | O_fchs
            | O_fsin
            | O_fcos
            | O_fptan
            | O_fsqrt
            | O_fpatan
            | O_fabs
            | O_f2xm1
            | O_fscale
            | O_fyl2x
            | O_fucom
            | O_fucomp
            | O_fucompp
            | O_fcomp
            | O_fcompp
            | O_fcoml
            | O_fcompl
            | O_ficompl
            | O_fcoms
            | O_fcom
            | O_fcomps
            | O_fnstsw
            | O_fnstcw
            | O_fldcw
            | O_frndint
            | O_fxch
            | O_sahf
            | O_nop
            deriving (Show, Eq)

data OperandEffect = OE_RR Int Int
                   | OE_RM Int Int
                   | OE_RW Int Int
                   | OE_nW Int
                   | OE_RRM Int Int Int
                   | OE_R Int
                   | OE_M Int
                   | OE_W Int
                   deriving (Show, Eq)

data OperandInfo = OI_Special
                 | OI_Jumpy
                 | OI_NoEffect
                 | OI_Error
                 | OI [OperandEffect]
                 deriving (Show, Eq)

==================== Renamer ====================
infixr 4 `Parse.orelse`
infixl 5 `Parse.doo`
infixr 6 `Parse.seQ`

Parse.faiL :: Parse.Parser a_anq
Parse.faiL inn_anr = []
Parse.okay :: a_anp -> Parse.Parser a_anp
Parse.okay v_ans inn_ant = [(v_ans, inn_ant)]
Parse.tok :: [Char] -> Parse.Parser [Char]
Parse.tok w_anu inn_anv
  = [(w_anu, drop n_anw inn_anv) | w_anu == take n_anw inn_anv]
  where
      n_anw = length w_anu
Parse.sat :: (Char -> Bool) -> Parse.Parser Char
Parse.sat p_aKw (![]) = []
Parse.sat (!p_aKx) (c_aKy : (!inn_aKz))
  = [(c_aKy, inn_aKz) | p_aKx c_aKy]
Parse.orelse ::
  Parse.Parser a_ano -> Parse.Parser a_ano -> Parse.Parser a_ano
Parse.orelse (!p1_aKA) (!p2_aKB) inn_aKC
  = p1_aKA inn_aKC ++ p2_aKB inn_aKC
Parse.seQ ::
  Parse.Parser a_anm
  -> Parse.Parser b_ann -> Parse.Parser (a_anm, b_ann)
Parse.seQ p1_aKD p2_aKE inn_aKF
  = [((v1_aKG, v2_aKI), inn2_aKJ) |
       (v1_aKG, inn1_aKH) <- p1_aKD inn_aKF,
       (!(v2_aKI, (!inn2_aKJ))) <- p2_aKE inn1_aKH]
Parse.doo ::
  Parse.Parser a_ank -> (a_ank -> b_anl) -> Parse.Parser b_anl
Parse.doo p_aKK (!f_aKL) inn_aKM
  = [(f_aKL v_aKN, inn1_aKO) | (!(v_aKN, inn1_aKO)) <- p_aKK inn_aKM]
Parse.just :: Parse.Parser a_anj -> Parse.Parser a_anj
Parse.just (!p_aKP) inn_aKQ
  = [(v_aKR, "") |
       (v_aKR, inn'_aKS) <- p_aKP inn_aKQ,
       dropWhile (' ' ==) inn'_aKS == ""]
Parse.sp :: Parse.Parser a_ani -> Parse.Parser a_ani
Parse.sp p_aKT = p_aKT . dropWhile (' ' ==)
Parse.sptok :: [Char] -> Parse.Parser [Char]
Parse.sptok = Parse.sp . Parse.tok
Parse.many :: Parse.Parser a_anh -> Parse.Parser [a_anh]
Parse.many (!p_aKU)
  = q_aKV
  where
      q_aKV
        = ((p_aKU `Parse.seQ` q_aKV) `Parse.doo` Parse.makeList)
          `Parse.orelse` (Parse.okay [])
Parse.many1 :: Parse.Parser a_ang -> Parse.Parser [a_ang]
Parse.many1 p_aKW
  = p_aKW `Parse.seQ` Parse.many p_aKW `Parse.doo` Parse.makeList
Parse.listOf ::
  Parse.Parser a_ane -> Parse.Parser b_anf -> Parse.Parser [a_ane]
Parse.listOf (!p_aKX) s_aKY
  = p_aKX `Parse.seQ` Parse.many (s_aKY `Parse.seQ` p_aKX)
    `Parse.doo` nonempty_aKZ
    `Parse.orelse` Parse.okay []
  where
      nonempty_aKZ (!(x_aL0, (!xs_aL1))) = x_aL0 : (map snd xs_aL1)
Parse.makeList :: (a_and, [a_and]) -> [a_and]
Parse.makeList (x_aL8, xs_aL9) = x_aL8 : xs_aL9

type Parse.Parser a_an5 = [Char] -> [(a_an5, [Char])]


["inn_anr","v_ans","inn_ant","w_anu","inn_anv","n_anw","p_aKw","[]","![]","(![])","p_aKx","!p_aKx","(!p_aKx)","c_aKy","inn_aKz","!inn_aKz","(!inn_aKz)","c_aKy : (!inn_aKz)","(c_aKy : (!inn_aKz))","p1_aKA","safebang@!p1_aKA","(!p1_aKA)","p2_aKB","safebang@!p2_aKB","(!p2_aKB)","inn_aKC","p1_aKD","p2_aKE","inn_aKF","v1_aKG","inn1_aKH","(v1_aKG, inn1_aKH)","v2_aKI","inn2_aKJ","safebang@!inn2_aKJ","(!inn2_aKJ)","(v2_aKI, (!inn2_aKJ))","!(v2_aKI, (!inn2_aKJ))","(!(v2_aKI, (!inn2_aKJ)))","p_aKK","f_aKL","safebang@!f_aKL","(!f_aKL)","inn_aKM","v_aKN","inn1_aKO","(v_aKN, inn1_aKO)","!(v_aKN, inn1_aKO)","(!(v_aKN, inn1_aKO))","p_aKP","safebang@!p_aKP","(!p_aKP)","inn_aKQ","v_aKR","inn'_aKS","(v_aKR, inn'_aKS)","p_aKT","sptok","p_aKU","safebang@!p_aKU","(!p_aKU)","q_aKV","p_aKW","p_aKX","safebang@!p_aKX","(!p_aKX)","s_aKY","x_aL0","xs_aL1","!xs_aL1","(!xs_aL1)","(x_aL0, (!xs_aL1))","!(x_aL0, (!xs_aL1))","(!(x_aL0, (!xs_aL1)))","x_aL8","xs_aL9","(x_aL8, xs_aL9)"]
module Parse
       (Parser, faiL, okay, tok, sat, orelse, seQ, doo, sptok, just,
        listOf, many, sp, many1)
       where

infixr 4 `orelse`

infixl 5 `doo`

infixr 6 `seQ`

faiL :: Parser a_anq
faiL inn_anr = []

okay :: a_anp -> Parser a_anp
okay v_ans inn_ant = [(v_ans, inn_ant)]

tok :: [Char] -> Parser [Char]
tok w_anu inn_anv
  = [(w_anu, drop n_anw inn_anv) | w_anu == take n_anw inn_anv]
  where n_anw = length w_anu

sat :: (Char -> Bool) -> Parser Char
sat p_aKw (norecord@[]) = []
sat (norecord@p_aKx) (c_aKy : (norecord@inn_aKz))
  = [(c_aKy, inn_aKz) | p_aKx c_aKy]

orelse :: Parser a_ano -> Parser a_ano -> Parser a_ano
orelse (!p1_aKA) (!p2_aKB) inn_aKC
  = p1_aKA inn_aKC ++ p2_aKB inn_aKC

seQ :: Parser a_anm -> Parser b_ann -> Parser (a_anm, b_ann)
seQ p1_aKD p2_aKE inn_aKF
  = [((v1_aKG, v2_aKI), inn2_aKJ) |
     (v1_aKG, inn1_aKH) <- p1_aKD inn_aKF,
     (norecord@(v2_aKI, (!inn2_aKJ))) <- p2_aKE inn1_aKH]

doo :: Parser a_ank -> (a_ank -> b_anl) -> Parser b_anl
doo p_aKK (!f_aKL) inn_aKM
  = [(f_aKL v_aKN, inn1_aKO) |
     (norecord@(v_aKN, inn1_aKO)) <- p_aKK inn_aKM]

just :: Parser a_anj -> Parser a_anj
just (!p_aKP) inn_aKQ
  = [(v_aKR, "") | (v_aKR, inn'_aKS) <- p_aKP inn_aKQ,
     dropWhile (' ' ==) inn'_aKS == ""]

sp :: Parser a_ani -> Parser a_ani
sp p_aKT = p_aKT . dropWhile (' ' ==)

sptok :: [Char] -> Parser [Char]
sptok = sp . tok

many :: Parser a_anh -> Parser [a_anh]
many (!p_aKU) = q_aKV
  where q_aKV
          = ((p_aKU `seQ` q_aKV) `doo` makeList) `orelse` (okay [])

many1 :: Parser a_ang -> Parser [a_ang]
many1 p_aKW = p_aKW `seQ` many p_aKW `doo` makeList

listOf :: Parser a_ane -> Parser b_anf -> Parser [a_ane]
listOf (!p_aKX) s_aKY
  = p_aKX `seQ` many (s_aKY `seQ` p_aKX) `doo` nonempty_aKZ `orelse`
      okay []
  where nonempty_aKZ (norecord@(x_aL0, (norecord@xs_aL1)))
          = x_aL0 : (map snd xs_aL1)

makeList :: (a_and, [a_and]) -> [a_and]
makeList (x_aL8, xs_aL9) = x_aL8 : xs_aL9

type Parser a_an5 = [Char] -> [(a_an5, [Char])]

==================== Renamer ====================
infix 4 Subst.->>
infixr 3 Subst.@@

Subst.apply :: Subst.Subst -> Term -> Term
Subst.apply s_apa (Var i_apb) = s_apa i_apb
Subst.apply s_apc (!((!(Struct a_apd ts_ape))))
  = Struct a_apd (map (Subst.apply s_apc) ts_ape)
Subst.nullSubst :: Subst.Subst
Subst.nullSubst i_apf = Var i_apf
(Subst.->>) :: Id -> Term -> Subst.Subst
((!i_apg) Subst.->> t_aph) j_api
  | j_api == i_apg = t_aph
  | otherwise = Var j_api
(Subst.@@) :: Subst.Subst -> Subst.Subst -> Subst.Subst
(!s1_aCJ) Subst.@@ (!s2_aCK) = Subst.apply s1_aCJ . s2_aCK
Subst.unify :: Term -> Term -> [Subst.Subst]
Subst.unify (Var x_aCL) (Var y_aCM)
  = if x_aCL == y_aCM then
        [Subst.nullSubst]
    else
        [x_aCL Subst.->> Var y_aCM]
Subst.unify (!(Var x_aCN)) (!t2_aCO)
  = [x_aCN Subst.->> t2_aCO | not (x_aCN `elem` varsIn t2_aCO)]
Subst.unify t1_aIW (Var (!y_aIX))
  = [y_aIX Subst.->> t1_aIW | not (y_aIX `elem` varsIn t1_aIW)]
Subst.unify ((!(Struct a_aIY (!ts_aIZ)))) (Struct b_aJ0 ss_aJ1)
  = [u_aJ2 |
       a_aIY == b_aJ0, (!u_aJ2) <- Subst.listUnify ts_aIZ ss_aJ1]
Subst.listUnify :: [Term] -> [Term] -> [Subst.Subst]
Subst.listUnify (![]) [] = [Subst.nullSubst]
Subst.listUnify [] (!((!r_aJ3) : rs_aJ4)) = []
Subst.listUnify ((!t_aJc) : ts_aJd) (![]) = []
Subst.listUnify ((!t_aJe) : (!ts_aJf)) (!(r_aJg : rs_aJh))
  = [u2_aJj Subst.@@ u1_aJi |
       u1_aJi <- Subst.unify t_aJe r_aJg,
       u2_aJj <- Subst.listUnify
                   (map (Subst.apply u1_aJi) ts_aJf)
                   (map (Subst.apply u1_aJi) rs_aJh)]

type Subst.Subst = Id -> Term


["s_apa","i_apb","Var i_apb","(Var i_apb)","s_apc","a_apd","ts_ape","Struct a_apd ts_ape","(Struct a_apd ts_ape)","!(Struct a_apd ts_ape)","(!(Struct a_apd ts_ape))","((!(Struct a_apd ts_ape)))","!((!(Struct a_apd ts_ape)))","(!((!(Struct a_apd ts_ape))))","i_apf","i_apg","!i_apg","(!i_apg)","t_aph","j_api","s1_aCJ","safebang@!s1_aCJ","(!s1_aCJ)","s2_aCK","safebang@!s2_aCK","(!s2_aCK)","x_aCL","Var x_aCL","(Var x_aCL)","y_aCM","Var y_aCM","(Var y_aCM)","x_aCN","Var x_aCN","(Var x_aCN)","!(Var x_aCN)","(!(Var x_aCN))","t2_aCO","!t2_aCO","(!t2_aCO)","t1_aIW","y_aIX","safebang@!y_aIX","(!y_aIX)","Var (!y_aIX)","(Var (!y_aIX))","a_aIY","ts_aIZ","!ts_aIZ","(!ts_aIZ)","Struct a_aIY (!ts_aIZ)","(Struct a_aIY (!ts_aIZ))","!(Struct a_aIY (!ts_aIZ))","(!(Struct a_aIY (!ts_aIZ)))","((!(Struct a_aIY (!ts_aIZ))))","b_aJ0","ss_aJ1","Struct b_aJ0 ss_aJ1","(Struct b_aJ0 ss_aJ1)","u_aJ2","!u_aJ2","(!u_aJ2)","[]","![]","(![])","[]","[]","r_aJ3","safebang@!r_aJ3","(!r_aJ3)","rs_aJ4","(!r_aJ3) : rs_aJ4","((!r_aJ3) : rs_aJ4)","!((!r_aJ3) : rs_aJ4)","(!((!r_aJ3) : rs_aJ4))","t_aJc","safebang@!t_aJc","(!t_aJc)","ts_aJd","(!t_aJc) : ts_aJd","((!t_aJc) : ts_aJd)","[]","![]","(![])","t_aJe","!t_aJe","(!t_aJe)","ts_aJf","!ts_aJf","(!ts_aJf)","(!t_aJe) : (!ts_aJf)","((!t_aJe) : (!ts_aJf))","r_aJg","rs_aJh","r_aJg : rs_aJh","(r_aJg : rs_aJh)","!(r_aJg : rs_aJh)","(!(r_aJg : rs_aJh))","u1_aJi","u2_aJj"]
module Subst (Subst, nullSubst, (->>), (@@), apply, unify) where
import PrologData

infix 4 ->>

infixr 3 @@

apply :: Subst -> Term -> Term
apply s_apa (Var i_apb) = s_apa i_apb
apply s_apc (norecord@((norecord@(Struct a_apd ts_ape))))
  = Struct a_apd (map (apply s_apc) ts_ape)

nullSubst :: Subst
nullSubst i_apf = Var i_apf

(->>) :: Id -> Term -> Subst
((norecord@i_apg) ->> t_aph) j_api
  | j_api == i_apg = t_aph
  | otherwise = Var j_api

(@@) :: Subst -> Subst -> Subst
(!s1_aCJ) @@ (!s2_aCK) = apply s1_aCJ . s2_aCK

unify :: Term -> Term -> [Subst]
unify (Var x_aCL) (Var y_aCM)
  = if x_aCL == y_aCM then [nullSubst] else [x_aCL ->> Var y_aCM]
unify (norecord@(Var x_aCN)) (norecord@t2_aCO)
  = [x_aCN ->> t2_aCO | not (x_aCN `elem` varsIn t2_aCO)]
unify t1_aIW (Var (!y_aIX))
  = [y_aIX ->> t1_aIW | not (y_aIX `elem` varsIn t1_aIW)]
unify ((norecord@(Struct a_aIY (norecord@ts_aIZ))))
  (Struct b_aJ0 ss_aJ1)
  = [u_aJ2 | a_aIY == b_aJ0,
     (norecord@u_aJ2) <- listUnify ts_aIZ ss_aJ1]

listUnify :: [Term] -> [Term] -> [Subst]
listUnify (norecord@[]) [] = [nullSubst]
listUnify [] (norecord@((!r_aJ3) : rs_aJ4)) = []
listUnify ((!t_aJc) : ts_aJd) (norecord@[]) = []
listUnify ((norecord@t_aJe) : (norecord@ts_aJf))
  (norecord@(r_aJg : rs_aJh))
  = [u2_aJj @@ u1_aJi | u1_aJi <- unify t_aJe r_aJg,
     u2_aJj <- listUnify (map (apply u1_aJi) ts_aJf)
                 (map (apply u1_aJi) rs_aJh)]

type Subst = Id -> Term

==================== Renamer ====================
Version.version = "stack based"


["version"]
module Version where
version = "stack based"

==================== Renamer ====================
Interact.skip :: Interact.Interactive -> Interact.Interactive
Interact.skip p_an6 inn_an7 = p_an6 inn_an7
Interact.end :: Interact.Interactive
Interact.end inn_an8 = ""
Interact.writeln ::
  String -> Interact.Interactive -> Interact.Interactive
Interact.writeln txt_an9 p_ana inn_anb = txt_an9 ++ p_ana inn_anb
Interact.readch ::
  (Char -> Interact.Interactive) -> String -> Interact.Interactive
Interact.readch act_anc (!def_and) (!"") = def_and
Interact.readch act_ane (!def_anf) (!((!(c_ang : cs_anh))))
  = act_ane c_ang cs_anh
Interact.readln ::
  String -> (String -> Interact.Interactive) -> Interact.Interactive
Interact.readln prompt_ani g_anj inn_ank
  = prompt_ani
    ++
      Interact.lineOut 0 line_anl
      ++ "\n" ++ g_anj (Interact.noBackSpaces line_anl) input'_anm
  where
      line_anl = before_ano '\n' inn_ank
      input'_anm = after_ann '\n' inn_ank
      after_ann x_anp = tail . dropWhile (x_anp /=)
      before_ano x_aEt = takeWhile (x_aEt /=)
Interact.rubout :: Char -> Bool
Interact.rubout c_aEu = (c_aEu == '\DEL' || c_aEu == '\b')
Interact.lineOut :: Int -> String -> String
Interact.lineOut (!n_aEv) (!"") = ""
Interact.lineOut n_aEw ((!c_aEx) : cs_aEy)
  | n_aEw > 0 && Interact.rubout c_aEx
  = "\b \b" ++ Interact.lineOut (n_aEw - 1) cs_aEy
  | n_aEw == 0 && Interact.rubout c_aEx = Interact.lineOut 0 cs_aEy
  | otherwise = c_aEx : Interact.lineOut (n_aEw + 1) cs_aEy
Interact.noBackSpaces :: String -> String
Interact.noBackSpaces
  = reverse . delete_aFx 0 . reverse
  where
      delete_aFx (!n_aFy) "" = ""
      delete_aFx n_aFz (!(c_aFA : cs_aFB))
        | Interact.rubout c_aFA = delete_aFx (n_aFz + 1) cs_aFB
        | n_aFz > 0 = delete_aFx (n_aFz - 1) cs_aFB
        | otherwise = c_aFA : delete_aFx 0 cs_aFB

type Interact.Interactive = String -> String


["p_an6","inn_an7","inn_an8","txt_an9","p_ana","inn_anb","act_anc","def_and","safebang@!def_and","(!def_and)","\"\"","!\"\"","(!\"\")","act_ane","def_anf","!def_anf","(!def_anf)","c_ang","cs_anh","c_ang : cs_anh","(c_ang : cs_anh)","!(c_ang : cs_anh)","(!(c_ang : cs_anh))","((!(c_ang : cs_anh)))","!((!(c_ang : cs_anh)))","(!((!(c_ang : cs_anh))))","prompt_ani","g_anj","inn_ank","line_anl","input'_anm","x_anp","x_aEt","c_aEu","n_aEv","safebang@!n_aEv","(!n_aEv)","\"\"","!\"\"","(!\"\")","n_aEw","c_aEx","!c_aEx","(!c_aEx)","cs_aEy","(!c_aEx) : cs_aEy","((!c_aEx) : cs_aEy)","noBackSpaces","n_aFy","safebang@!n_aFy","(!n_aFy)","\"\"","n_aFz","c_aFA","cs_aFB","c_aFA : cs_aFB","(c_aFA : cs_aFB)","!(c_aFA : cs_aFB)","(!(c_aFA : cs_aFB))"]
module Interact (Interactive, skip, end, readln, writeln, readch)
       where

skip :: Interactive -> Interactive
skip p_an6 inn_an7 = p_an6 inn_an7

end :: Interactive
end inn_an8 = ""

writeln :: String -> Interactive -> Interactive
writeln txt_an9 p_ana inn_anb = txt_an9 ++ p_ana inn_anb

readch :: (Char -> Interactive) -> String -> Interactive
readch act_anc (!def_and) (norecord@"") = def_and
readch act_ane (norecord@def_anf)
  (norecord@((norecord@(c_ang : cs_anh)))) = act_ane c_ang cs_anh

readln :: String -> (String -> Interactive) -> Interactive
readln prompt_ani g_anj inn_ank
  = prompt_ani ++ lineOut 0 line_anl ++ "\n" ++
      g_anj (noBackSpaces line_anl) input'_anm
  where line_anl = before_ano '\n' inn_ank
        input'_anm = after_ann '\n' inn_ank
        after_ann x_anp = tail . dropWhile (x_anp /=)
        before_ano x_aEt = takeWhile (x_aEt /=)

rubout :: Char -> Bool
rubout c_aEu = (c_aEu == '\DEL' || c_aEu == '\b')

lineOut :: Int -> String -> String
lineOut (!n_aEv) (norecord@"") = ""
lineOut n_aEw ((norecord@c_aEx) : cs_aEy)
  | n_aEw > 0 && rubout c_aEx = "\b \b" ++ lineOut (n_aEw - 1) cs_aEy
  | n_aEw == 0 && rubout c_aEx = lineOut 0 cs_aEy
  | otherwise = c_aEx : lineOut (n_aEw + 1) cs_aEy

noBackSpaces :: String -> String
noBackSpaces = reverse . delete_aFx 0 . reverse
  where delete_aFx (!n_aFy) "" = ""
        delete_aFx n_aFz (norecord@(c_aFA : cs_aFB))
          | rubout c_aFA = delete_aFx (n_aFz + 1) cs_aFB
          | n_aFz > 0 = delete_aFx (n_aFz - 1) cs_aFB
          | otherwise = c_aFA : delete_aFx 0 cs_aFB

type Interactive = String -> String

==================== Renamer ====================
Engine.alts :: Database -> Int -> Term -> [Engine.Alt]
Engine.alts db_apE n_apF g_apG
  = [(tp_apI, u_apJ) |
       (tm_apH :== tp_apI) <- renClauses db_apE n_apF g_apG,
       (!u_apJ) <- unify g_apG tm_apH]
Engine.prove :: Database -> [Term] -> [Subst]
Engine.prove (!db_apK) gl_apL
  = solve_apM 1 nullSubst gl_apL []
  where
      solve_apM :: Int -> Subst -> [Term] -> Engine.Stack -> [Subst]
      solve_apM (!n_apP) s_apQ [] (!ow_apR)
        = s_apQ : backtrack_apO n_apP ow_apR
      solve_apM (!n_apS) s_apT (g_apU : gs_apV) ow_apW
        | g_apU == Engine.theCut
        = solve_apM n_apS s_apT gs_apV (Engine.cut ow_apW)
        | otherwise
        = choose_apN
            n_apS
            s_apT
            gs_apV
            (Engine.alts db_apK n_apS (apply s_apT g_apU))
            ow_apW
      choose_apN ::
        Int -> Subst -> [Term] -> [Engine.Alt] -> Engine.Stack -> [Subst]
      choose_apN n_aDi s_aDj (!gs_aDk) (![]) ow_aDl
        = backtrack_apO n_aDi ow_aDl
      choose_apN
        (!n_aDm)
        s_aDn
        gs_aDo
        ((!(tp_aDp, (!u_aDq))) : rs_aDr)
        ow_aDs
        = solve_apM
            (n_aDm + 1)
            (u_aDq @@ s_aDn)
            (tp_aDp ++ gs_aDo)
            ((s_aDn, gs_aDo, rs_aDr) : ow_aDs)
      backtrack_apO :: Int -> Engine.Stack -> [Subst]
      backtrack_apO n_aEr (![]) = []
      backtrack_apO
        (!n_aEs)
        (!((!((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw))))
        = choose_apN (n_aEs - 1) s_aEt gs_aEu rs_aEv ow_aEw
Engine.theCut :: Term
Engine.theCut = Struct "!" []
Engine.cut :: Engine.Stack -> Engine.Stack
Engine.cut (top_aEx : ((!(s_aEy, (!gl_aEz), (!_))) : ss_aEA))
  = top_aEx : (s_aEy, gl_aEz, []) : ss_aEA
Engine.cut ss_aEB = ss_aEB

type Engine.Alt = ([Term], Subst)
type Engine.Stack = [(Subst, [Term], [Engine.Alt])]


["db_apE","n_apF","g_apG","tm_apH","tp_apI","tm_apH :== tp_apI","(tm_apH :== tp_apI)","u_apJ","!u_apJ","(!u_apJ)","db_apK","safebang@!db_apK","(!db_apK)","gl_apL","n_apP","safebang@!n_apP","(!n_apP)","s_apQ","[]","ow_apR","!ow_apR","(!ow_apR)","n_apS","!n_apS","(!n_apS)","s_apT","g_apU","gs_apV","g_apU : gs_apV","(g_apU : gs_apV)","ow_apW","n_aDi","s_aDj","gs_aDk","safebang@!gs_aDk","(!gs_aDk)","[]","![]","(![])","ow_aDl","n_aDm","!n_aDm","(!n_aDm)","s_aDn","gs_aDo","tp_aDp","u_aDq","safebang@!u_aDq","(!u_aDq)","(tp_aDp, (!u_aDq))","!(tp_aDp, (!u_aDq))","(!(tp_aDp, (!u_aDq)))","rs_aDr","(!(tp_aDp, (!u_aDq))) : rs_aDr","((!(tp_aDp, (!u_aDq))) : rs_aDr)","ow_aDs","n_aEr","[]","![]","(![])","n_aEs","!n_aEs","(!n_aEs)","s_aEt","gs_aEu","rs_aEv","safebang@!rs_aEv","(!rs_aEv)","(s_aEt, gs_aEu, (!rs_aEv))","ow_aEw","(s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw","((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw)","!((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw)","(!((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw))","((!((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw)))","!((!((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw)))","(!((!((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw))))","theCut","top_aEx","s_aEy","gl_aEz","safebang@!gl_aEz","(!gl_aEz)","_","!_","(!_)","(s_aEy, (!gl_aEz), (!_))","!(s_aEy, (!gl_aEz), (!_))","(!(s_aEy, (!gl_aEz), (!_)))","ss_aEA","(!(s_aEy, (!gl_aEz), (!_))) : ss_aEA","((!(s_aEy, (!gl_aEz), (!_))) : ss_aEA)","top_aEx : ((!(s_aEy, (!gl_aEz), (!_))) : ss_aEA)","(top_aEx : ((!(s_aEy, (!gl_aEz), (!_))) : ss_aEA))","ss_aEB"]
module Engine (prove) where
import PrologData
import Subst

alts :: Database -> Int -> Term -> [Alt]
alts db_apE n_apF g_apG
  = [(tp_apI, u_apJ) |
     (tm_apH :== tp_apI) <- renClauses db_apE n_apF g_apG,
     (norecord@u_apJ) <- unify g_apG tm_apH]

prove :: Database -> [Term] -> [Subst]
prove (!db_apK) gl_apL = solve_apM 1 nullSubst gl_apL []
  where solve_apM :: Int -> Subst -> [Term] -> Stack -> [Subst]
        solve_apM (!n_apP) s_apQ [] (norecord@ow_apR)
          = s_apQ : backtrack_apO n_apP ow_apR
        solve_apM (norecord@n_apS) s_apT (g_apU : gs_apV) ow_apW
          | g_apU == theCut = solve_apM n_apS s_apT gs_apV (cut ow_apW)
          | otherwise =
            choose_apN n_apS s_apT gs_apV
              (alts db_apK n_apS (apply s_apT g_apU))
              ow_apW
        
        choose_apN :: Int -> Subst -> [Term] -> [Alt] -> Stack -> [Subst]
        choose_apN n_aDi s_aDj (!gs_aDk) (norecord@[]) ow_aDl
          = backtrack_apO n_aDi ow_aDl
        choose_apN (norecord@n_aDm) s_aDn gs_aDo
          ((norecord@(tp_aDp, (!u_aDq))) : rs_aDr) ow_aDs
          = solve_apM (n_aDm + 1) (u_aDq @@ s_aDn) (tp_aDp ++ gs_aDo)
              ((s_aDn, gs_aDo, rs_aDr) : ow_aDs)
        
        backtrack_apO :: Int -> Stack -> [Subst]
        backtrack_apO n_aEr (norecord@[]) = []
        backtrack_apO (norecord@n_aEs)
          (norecord@((norecord@((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw))))
          = choose_apN (n_aEs - 1) s_aEt gs_aEu rs_aEv ow_aEw

theCut :: Term
theCut = Struct "!" []

cut :: Stack -> Stack
cut
  (top_aEx : ((norecord@(s_aEy, (!gl_aEz), (norecord@_))) : ss_aEA))
  = top_aEx : (s_aEy, gl_aEz, []) : ss_aEA
cut ss_aEB = ss_aEB

type Alt = ([Term], Subst)

type Stack = [(Subst, [Term], [Alt])]

==================== Renamer ====================
ElecField.elecField :: Phi -> Electric
ElecField.elecField phi_anF
  = (array
       ((0, 0), (n_anG, n_anG))
       ([((i_axd, j_axe), 
          (phi_anF ! (i_axd - 1, j_axe) - phi_anF ! (i_axd, j_axe))) |
           i_axd <- [1 .. n_anG], j_axe <- [0 .. n_anG]]
        ++
          [((0, j_axf), (phi_anF ! (n_anG, j_axf) - phi_anF ! (0, j_axf))) |
             (!j_axf) <- [0 .. n_anG]]), 
     array
       ((0, 0), (n_anG, n_anG))
       ([((i_axg, j_axh), 
          (phi_anF ! (i_axg, j_axh + 1) - phi_anF ! (i_axg, j_axh))) |
           i_axg <- [0 .. n_anG], (!j_axh) <- [0 .. (n_anG - 1)]]
        ++
          [((i_axi, n_anG), 
            (phi_anF ! (i_axi, 0) - phi_anF ! (i_axi, n_anG))) |
             (!i_axi) <- [0 .. n_anG]]))
  where
      n_anG = nCell - 1


["phi_anF","i_axd","j_axe","j_axf","!j_axf","(!j_axf)","i_axg","j_axh","!j_axh","(!j_axh)","i_axi","!i_axi","(!i_axi)","n_anG"]
module ElecField (elecField) where
import PicType
import Consts
import Data.Array

elecField :: Phi -> Electric
elecField phi_anF
  = (array ((0, 0), (n_anG, n_anG))
       ([((i_axd, j_axe),
          (phi_anF ! (i_axd - 1, j_axe) - phi_anF ! (i_axd, j_axe)))
         | i_axd <- [1 .. n_anG], j_axe <- [0 .. n_anG]]
          ++
          [((0, j_axf), (phi_anF ! (n_anG, j_axf) - phi_anF ! (0, j_axf))) |
           (norecord@j_axf) <- [0 .. n_anG]]),
     array ((0, 0), (n_anG, n_anG))
       ([((i_axg, j_axh),
          (phi_anF ! (i_axg, j_axh + 1) - phi_anF ! (i_axg, j_axh)))
         | i_axg <- [0 .. n_anG], (norecord@j_axh) <- [0 .. (n_anG - 1)]]
          ++
          [((i_axi, n_anG),
            (phi_anF ! (i_axi, 0) - phi_anF ! (i_axi, n_anG)))
           | (norecord@i_axi) <- [0 .. n_anG]]))
  where n_anG = nCell - 1

==================== Renamer ====================
Main.main
  = do { hPutStr stderr "Enter the number of particles: ";
         s_auO <- getContents;
         let (nPart_auP, (!rest_auQ))
               = (head (reads s_auO)) :: (Int, String);
         putStrLn (takeWhile ((/=) '\n') s_auO ++ (pic nPart_auP)) }



==================== Renamer ====================
Consts.nCell, Consts.nStep, Consts.maxDepth :: Indx
Consts.charge, Consts.mass :: Value
Consts.nCell = 16
Consts.nStep = 10
Consts.maxDepth = (log2 Consts.nCell) - 1
Consts.charge = 1.0
Consts.mass = 1.0


["nCell","nStep","maxDepth","charge","mass"]
module Consts (charge, mass, nCell, nStep, maxDepth) where
import PicType
import Utils

nCell, nStep, maxDepth :: Indx

charge, mass :: Value
nCell = 16
nStep = 10
maxDepth = (log2 nCell) - 1
charge = 1.0
mass = 1.0

==================== Renamer ====================
Potential.potential :: Phi -> Rho -> Indx -> Indx -> Phi
Potential.potential phi_aob rho_aoc depth_aod (!nIter_aoe)
  | nIter_aoe == 0 = phi_aob
  | otherwise
  = Potential.potential phi'_aof rho_aoc depth_aod (nIter_aoe - 1)
  where
      phi'_aof = Potential.vCycle rho_aoc phi_aob nCell depth_aod
Potential.vCycle :: Phi -> Rho -> Indx -> Indx -> Phi
Potential.vCycle (!phi_aCG) (!rho_aCH) n_aCI (!depth_aCJ)
  = if (depth_aCJ == 0) then
        Potential.relax phi'_aCM rho_aCH n_aCI
    else
        Potential.correct phi'_aCM eCoarse_aCQ n_aCI nHalf_aCK
  where
      nHalf_aCK = n_aCI `div` 2
      nHalf'_aCL = nHalf_aCK - 1
      (!phi'_aCM) = Potential.relax phi_aCG rho_aCH n_aCI
      rho'_aCN = Potential.residual phi'_aCM rho_aCH n_aCI
      rCoarse_aCO = coarseMesh rho'_aCN n_aCI
      eZero_aCP
        = array
            ((0, 0), (nHalf'_aCL, nHalf'_aCL))
            [((i_aTX, j_aTY), 0.0) |
               i_aTX <- [0 .. nHalf'_aCL], (!j_aTY) <- [0 .. nHalf'_aCL]]
      eCoarse_aCQ
        = Potential.vCycle eZero_aCP rCoarse_aCO nHalf_aCK (depth_aCJ - 1)
Potential.laplacianOp :: Mesh -> Range -> Value
Potential.laplacianOp
  mesh_aTZ
  [iLo_aU0, i_aU1, (!iHi_aU2), jLo_aU3, j_aU4, (!jHi_aU5)]
  = - (mesh_aTZ ! (iLo_aU0, j_aU4) + mesh_aTZ ! (i_aU1, jHi_aU5)
       + mesh_aTZ ! (i_aU1, jLo_aU3)
       + mesh_aTZ ! (iHi_aU2, j_aU4)
       - 4 * mesh_aTZ ! (i_aU1, j_aU4))
Potential.residual :: Phi -> Rho -> Indx -> Rho
Potential.residual (!mesh_aU6) mesh'_aU7 n_aU8
  = applyOpToMesh (residualOp_aU9 mesh'_aU7) mesh_aU6 n_aU8
  where
      residualOp_aU9
        (!mesh'_aUa)
        mesh_aUb
        [(!iLo_aUc), i_aUd, (!iHi_aUe), (!jLo_aUf), j_aUg, jHi_aUh]
        = mesh'_aUa ! (i_aUd, j_aUg)
          - Potential.laplacianOp
              mesh_aUb [iLo_aUc, i_aUd, iHi_aUe, jLo_aUf, j_aUg, jHi_aUh]
Potential.relax :: Phi -> Rho -> Indx -> Phi
Potential.relax mesh_aUi mesh'_aUj (!n_aUk)
  = applyOpToMesh (relaxOp_aUl mesh'_aUj) mesh_aUi n_aUk
  where
      relaxOp_aUl
        mesh'_aUm
        mesh_aUn
        [(!iLo_aUo), (!i_aUp), iHi_aUq, (!jLo_aUr), j_aUs, jHi_aUt]
        = 0.25 * mesh'_aUm ! (i_aUp, j_aUs)
          + 0.25
            * (mesh_aUn ! (iLo_aUo, j_aUs) + mesh_aUn ! (i_aUp, jLo_aUr)
               + mesh_aUn ! (i_aUp, jHi_aUt)
               + mesh_aUn ! (iHi_aUq, j_aUs))
Potential.correct :: Phi -> Mesh -> Indx -> Indx -> Phi
Potential.correct (!phi_aUu) eCoarse_aUv n'_aUw nHalf_aUx
  = array
      ((0, 0), (n_aUz, n_aUz))
      [((i_aUA, j_aUB), 
        phi_aUu ! (i_aUA, j_aUB) + eFine_aUy ! (i_aUA, j_aUB)) |
         i_aUA <- [0 .. n_aUz], j_aUB <- [0 .. n_aUz]]
  where
      eFine_aUy = fineMesh eCoarse_aUv nHalf_aUx
      n_aUz = n'_aUw - 1


["phi_aob","rho_aoc","depth_aod","nIter_aoe","!nIter_aoe","(!nIter_aoe)","phi'_aof","phi_aCG","!phi_aCG","(!phi_aCG)","rho_aCH","!rho_aCH","(!rho_aCH)","n_aCI","depth_aCJ","!depth_aCJ","(!depth_aCJ)","nHalf_aCK","nHalf'_aCL","phi'_aCM","lazydmd@!phi'_aCM","(!phi'_aCM)","rho'_aCN","rCoarse_aCO","eZero_aCP","i_aTX","j_aTY","!j_aTY","(!j_aTY)","eCoarse_aCQ","mesh_aTZ","iLo_aU0","i_aU1","iHi_aU2","!iHi_aU2","(!iHi_aU2)","jLo_aU3","j_aU4","jHi_aU5","!jHi_aU5","(!jHi_aU5)","[iLo_aU0, i_aU1, (!iHi_aU2), jLo_aU3, j_aU4, (!jHi_aU5)]","mesh_aU6","!mesh_aU6","(!mesh_aU6)","mesh'_aU7","n_aU8","mesh'_aUa","!mesh'_aUa","(!mesh'_aUa)","mesh_aUb","iLo_aUc","!iLo_aUc","(!iLo_aUc)","i_aUd","iHi_aUe","!iHi_aUe","(!iHi_aUe)","jLo_aUf","!jLo_aUf","(!jLo_aUf)","j_aUg","jHi_aUh","[(!iLo_aUc), i_aUd, (!iHi_aUe), (!jLo_aUf), j_aUg, jHi_aUh]","mesh_aUi","mesh'_aUj","n_aUk","safebang@!n_aUk","(!n_aUk)","mesh'_aUm","mesh_aUn","iLo_aUo","safebang@!iLo_aUo","(!iLo_aUo)","i_aUp","safebang@!i_aUp","(!i_aUp)","iHi_aUq","jLo_aUr","safebang@!jLo_aUr","(!jLo_aUr)","j_aUs","jHi_aUt","[(!iLo_aUo), (!i_aUp), iHi_aUq, (!jLo_aUr), j_aUs, jHi_aUt]","phi_aUu","!phi_aUu","(!phi_aUu)","eCoarse_aUv","n'_aUw","nHalf_aUx","i_aUA","j_aUB","eFine_aUy","n_aUz"]
module Potential (potential) where
import PicType
import Consts
import Utils
import Data.Array

potential :: Phi -> Rho -> Indx -> Indx -> Phi
potential phi_aob rho_aoc depth_aod (norecord@nIter_aoe)
  | nIter_aoe == 0 = phi_aob
  | otherwise = potential phi'_aof rho_aoc depth_aod (nIter_aoe - 1)
  where phi'_aof = vCycle rho_aoc phi_aob nCell depth_aod

vCycle :: Phi -> Rho -> Indx -> Indx -> Phi
vCycle (norecord@phi_aCG) (norecord@rho_aCH) n_aCI
  (norecord@depth_aCJ)
  = if (depth_aCJ == 0) then relax phi'_aCM rho_aCH n_aCI else
      correct phi'_aCM eCoarse_aCQ n_aCI nHalf_aCK
  where nHalf_aCK = n_aCI `div` 2
        nHalf'_aCL = nHalf_aCK - 1
        (lazydmd@phi'_aCM) = relax phi_aCG rho_aCH n_aCI
        rho'_aCN = residual phi'_aCM rho_aCH n_aCI
        rCoarse_aCO = coarseMesh rho'_aCN n_aCI
        eZero_aCP
          = array ((0, 0), (nHalf'_aCL, nHalf'_aCL))
              [((i_aTX, j_aTY), 0.0) | i_aTX <- [0 .. nHalf'_aCL],
               (norecord@j_aTY) <- [0 .. nHalf'_aCL]]
        eCoarse_aCQ
          = vCycle eZero_aCP rCoarse_aCO nHalf_aCK (depth_aCJ - 1)

laplacianOp :: Mesh -> Range -> Value
laplacianOp mesh_aTZ
  [iLo_aU0, i_aU1, (norecord@iHi_aU2), jLo_aU3, j_aU4,
   (norecord@jHi_aU5)]
  = -(mesh_aTZ ! (iLo_aU0, j_aU4) + mesh_aTZ ! (i_aU1, jHi_aU5) +
        mesh_aTZ
        ! (i_aU1, jLo_aU3)
        + mesh_aTZ
        ! (iHi_aU2, j_aU4)
        - 4
        * mesh_aTZ
        ! (i_aU1, j_aU4))

residual :: Phi -> Rho -> Indx -> Rho
residual (norecord@mesh_aU6) mesh'_aU7 n_aU8
  = applyOpToMesh (residualOp_aU9 mesh'_aU7) mesh_aU6 n_aU8
  where residualOp_aU9 (norecord@mesh'_aUa) mesh_aUb
          [(norecord@iLo_aUc), i_aUd, (norecord@iHi_aUe), (norecord@jLo_aUf),
           j_aUg, jHi_aUh]
          = mesh'_aUa ! (i_aUd, j_aUg) -
              laplacianOp mesh_aUb
                [iLo_aUc, i_aUd, iHi_aUe, jLo_aUf, j_aUg, jHi_aUh]

relax :: Phi -> Rho -> Indx -> Phi
relax mesh_aUi mesh'_aUj (!n_aUk)
  = applyOpToMesh (relaxOp_aUl mesh'_aUj) mesh_aUi n_aUk
  where relaxOp_aUl mesh'_aUm mesh_aUn
          [(!iLo_aUo), (!i_aUp), iHi_aUq, (!jLo_aUr), j_aUs, jHi_aUt]
          = 0.25 * mesh'_aUm ! (i_aUp, j_aUs) + 0.25 *
              (mesh_aUn ! (iLo_aUo, j_aUs) + mesh_aUn ! (i_aUp, jLo_aUr) +
                 mesh_aUn
                 ! (i_aUp, jHi_aUt)
                 + mesh_aUn
                 ! (iHi_aUq, j_aUs))

correct :: Phi -> Mesh -> Indx -> Indx -> Phi
correct (norecord@phi_aUu) eCoarse_aUv n'_aUw nHalf_aUx
  = array ((0, 0), (n_aUz, n_aUz))
      [((i_aUA, j_aUB),
        phi_aUu ! (i_aUA, j_aUB) + eFine_aUy ! (i_aUA, j_aUB))
       | i_aUA <- [0 .. n_aUz], j_aUB <- [0 .. n_aUz]]
  where eFine_aUy = fineMesh eCoarse_aUv nHalf_aUx
        n_aUz = n'_aUw - 1

==================== Renamer ====================
type PicType.Count = Int
type PicType.Indx = Int
type PicType.Value = Double
type PicType.Mesh = Array (Int, Int) PicType.Value
type PicType.MeshAssoc = ((Int, Int), PicType.Value)
type PicType.Electric = (PicType.Mesh, PicType.Mesh)
type PicType.Phi = PicType.Mesh
type PicType.Rho = PicType.Mesh
type PicType.Position = (PicType.Value, PicType.Value)
type PicType.Range = [PicType.Indx]
type PicType.Velocity = (PicType.Value, PicType.Value)
type PicType.ParticleHeap =
    ([PicType.Position], [PicType.Velocity])


[]
module PicType
       (Count, Indx, Value, Mesh, MeshAssoc, Electric, Phi, Rho, Position,
        Range, Velocity, ParticleHeap)
       where
import Data.Array

type Count = Int

type Indx = Int

type Value = Double

type Mesh = Array (Int, Int) Value

type MeshAssoc = ((Int, Int), Value)

type Electric = (Mesh, Mesh)

type Phi = Mesh

type Rho = Mesh

type Position = (Value, Value)

type Range = [Indx]

type Velocity = (Value, Value)

type ParticleHeap = ([Position], [Velocity])

==================== Renamer ====================
Pic.pic :: Indx -> [Char]
Pic.pic nPart_aoM
  = show dt'_aoQ
  where
      partHeap_aoN = Pic.initParticles nPart_aoM
      dt_aoO = 1.0e-3
      (!phi_aoP) = Pic.initPhi partHeap_aoN
      (dt'_aoQ, (!phi'_aoR), (!partHeap'_aoS))
        = Pic.timeStep partHeap_aoN phi_aoP dt_aoO 0 nStep
Pic.timeStep ::
  ParticleHeap
  -> Phi -> Value -> Indx -> Indx -> (Value, Phi, ParticleHeap)
Pic.timeStep (!partHeap_axj) phi_axk dt_axl (!depth_axm) step_axn
  | step_axn == 0 = (dt_axl, phi_axk, partHeap_axj)
  | otherwise
  = Pic.timeStep
      partHeap'_axt phi'_axp dt'_axu depth'_axv (step_axn - 1)
  where
      rho_axo = chargeDensity partHeap_axj
      phi'_axp = potential phi_axk rho_axo depth_axm 1
      xyElec_axq = elecField phi'_axp
      ((!maxVel_axr), maxAcc_axs, partHeap'_axt)
        = pushParticle partHeap_axj xyElec_axq dt_axl 0 0
      dt'_axu
        = (sqrt (maxVel_axr * maxVel_axr + 2 * maxAcc_axs) - maxVel_axr)
          / maxAcc_axs
      (!depth'_axv) = (depth_axm + 1) `rem` maxDepth
Pic.initParticles :: Indx -> ParticleHeap
Pic.initParticles nPart_aV0
  = (xyPos_aV3, xyVel_aV4)
  where
      nCellD_aV1 = fromIntegral nCell
      (!nPartD_aV2) = fromIntegral (nPart_aV0 + 1)
      xyPos_aV3
        = [(xPos_aV6, yPos_aV7) |
             (!i_aV5) <- [1 .. nPart_aV0],
             xPos_aV6 <- [nCellD_aV1
                          * genRand (fromIntegral i_aV5 / nPartD_aV2)],
             yPos_aV7 <- [nCellD_aV1 * genRand xPos_aV6]]
      (!xyVel_aV4) = [(0.0, 0.0) | i_aV8 <- [1 .. nPart_aV0]]
Pic.initPhi :: ParticleHeap -> Phi
Pic.initPhi (!partHeap_aV9)
  = potential phi0_aVb rho_aVa maxDepth 1
  where
      rho_aVa = chargeDensity partHeap_aV9
      (!phi0_aVb)
        = array
            ((0, 0), (n_aVc, n_aVc))
            [((i_a137, j_a138), 0.0) |
               (!i_a137) <- [0 .. n_aVc], j_a138 <- [0 .. n_aVc]]
      n_aVc = nCell - 1


["nPart_aoM","partHeap_aoN","dt_aoO","phi_aoP","!phi_aoP","(!phi_aoP)","dt'_aoQ","phi'_aoR","!phi'_aoR","(!phi'_aoR)","partHeap'_aoS","!partHeap'_aoS","(!partHeap'_aoS)","(dt'_aoQ, (!phi'_aoR), (!partHeap'_aoS))","partHeap_axj","safebang@!partHeap_axj","(!partHeap_axj)","phi_axk","dt_axl","depth_axm","safebang@!depth_axm","(!depth_axm)","step_axn","rho_axo","phi'_axp","xyElec_axq","maxVel_axr","!maxVel_axr","(!maxVel_axr)","maxAcc_axs","partHeap'_axt","((!maxVel_axr), maxAcc_axs, partHeap'_axt)","dt'_axu","depth'_axv","lazydmd@!depth'_axv","(!depth'_axv)","nPart_aV0","nCellD_aV1","nPartD_aV2","!nPartD_aV2","(!nPartD_aV2)","xyPos_aV3","i_aV5","!i_aV5","(!i_aV5)","xPos_aV6","yPos_aV7","xyVel_aV4","!xyVel_aV4","(!xyVel_aV4)","i_aV8","partHeap_aV9","!partHeap_aV9","(!partHeap_aV9)","rho_aVa","phi0_aVb","!phi0_aVb","(!phi0_aVb)","i_a137","!i_a137","(!i_a137)","j_a138","n_aVc"]
module Pic (pic) where
import PicType
import Consts
import Utils
import ChargeDensity
import Potential
import ElecField
import PushParticle
import Data.Array

pic :: Indx -> [Char]
pic nPart_aoM = show dt'_aoQ
  where partHeap_aoN = initParticles nPart_aoM
        dt_aoO = 1.0e-3
        (norecord@phi_aoP) = initPhi partHeap_aoN
        (dt'_aoQ, (norecord@phi'_aoR), (norecord@partHeap'_aoS))
          = timeStep partHeap_aoN phi_aoP dt_aoO 0 nStep

timeStep ::
         ParticleHeap ->
           Phi -> Value -> Indx -> Indx -> (Value, Phi, ParticleHeap)
timeStep (!partHeap_axj) phi_axk dt_axl (!depth_axm) step_axn
  | step_axn == 0 = (dt_axl, phi_axk, partHeap_axj)
  | otherwise =
    timeStep partHeap'_axt phi'_axp dt'_axu depth'_axv (step_axn - 1)
  where rho_axo = chargeDensity partHeap_axj
        phi'_axp = potential phi_axk rho_axo depth_axm 1
        xyElec_axq = elecField phi'_axp
        ((norecord@maxVel_axr), maxAcc_axs, partHeap'_axt)
          = pushParticle partHeap_axj xyElec_axq dt_axl 0 0
        dt'_axu
          = (sqrt (maxVel_axr * maxVel_axr + 2 * maxAcc_axs) - maxVel_axr) /
              maxAcc_axs
        (lazydmd@depth'_axv) = (depth_axm + 1) `rem` maxDepth

initParticles :: Indx -> ParticleHeap
initParticles nPart_aV0 = (xyPos_aV3, xyVel_aV4)
  where nCellD_aV1 = fromIntegral nCell
        (norecord@nPartD_aV2) = fromIntegral (nPart_aV0 + 1)
        xyPos_aV3
          = [(xPos_aV6, yPos_aV7) | (norecord@i_aV5) <- [1 .. nPart_aV0],
             xPos_aV6 <- [nCellD_aV1 *
                            genRand (fromIntegral i_aV5 / nPartD_aV2)],
             yPos_aV7 <- [nCellD_aV1 * genRand xPos_aV6]]
        (norecord@xyVel_aV4) = [(0.0, 0.0) | i_aV8 <- [1 .. nPart_aV0]]

initPhi :: ParticleHeap -> Phi
initPhi (norecord@partHeap_aV9)
  = potential phi0_aVb rho_aVa maxDepth 1
  where rho_aVa = chargeDensity partHeap_aV9
        (norecord@phi0_aVb)
          = array ((0, 0), (n_aVc, n_aVc))
              [((i_a137, j_a138), 0.0) | (norecord@i_a137) <- [0 .. n_aVc],
               j_a138 <- [0 .. n_aVc]]
        n_aVc = nCell - 1

==================== Renamer ====================
infix 1 Utils.=:

a_anG Utils.=: b_anH = (a_anG, b_anH)
Utils.applyOpToMesh ::
  (Mesh -> Range -> Value) -> Mesh -> Indx -> Mesh
Utils.applyOpToMesh operator_anI (!mesh_anJ) n'_anK
  = array
      ((0, 0), (n_anL, n_anL))
      ([(0, 0) Utils.=: operator_anI mesh_anJ [n_anL, 0, 1, n_anL, 0, 1]]
       ++
         [(0, n_anL)
          Utils.=: operator_anI mesh_anJ [n_anL, 0, 1, n1_anM, n_anL, 0]]
         ++
           [(n_anL, 0)
            Utils.=: operator_anI mesh_anJ [n1_anM, n_anL, 0, n_anL, 0, 1]]
           ++
             [(n_anL, n_anL)
              Utils.=:
                operator_anI mesh_anJ [n1_anM, n_anL, 0, n1_anM, n_anL, 0]]
             ++
               [(0, j_axj)
                Utils.=:
                  operator_anI
                    mesh_anJ [n_anL, 0, n1_anM, (j_axj - 1), j_axj, (j_axj + 1)] |
                  (!j_axj) <- [1 .. n1_anM]]
               ++
                 [(n_anL, j_axk)
                  Utils.=:
                    operator_anI
                      mesh_anJ [n1_anM, n_anL, 0, (j_axk - 1), j_axk, (j_axk + 1)] |
                    (!j_axk) <- [1 .. n1_anM]]
                 ++
                   [(i_axl, 0)
                    Utils.=:
                      operator_anI
                        mesh_anJ [(i_axl - 1), i_axl, (i_axl + 1), n_anL, 0, 1] |
                      i_axl <- [1 .. n1_anM]]
                   ++
                     [(i_axm, n_anL)
                      Utils.=:
                        operator_anI
                          mesh_anJ [(i_axm - 1), i_axm, (i_axm + 1), n1_anM, n_anL, 0] |
                        (!i_axm) <- [1 .. n1_anM]]
                     ++
                       [(i_axn, j_axo)
                        Utils.=:
                          operator_anI
                            mesh_anJ
                            [(i_axn - 1), i_axn, (i_axn + 1), (j_axo - 1), j_axo,
                             (j_axo + 1)] |
                          i_axn <- [1 .. n1_anM], j_axo <- [1 .. n1_anM]])
  where
      (!n_anL) = n'_anK - 1
      n1_anM = n'_anK - 2
Utils.coarseMesh :: Mesh -> Indx -> Mesh
Utils.coarseMesh mesh_axp n_axq
  = array
      ((0, 0), (nHalf_axr, nHalf_axr))
      [(i_aGy, j_aGz) Utils.=: mesh_axp ! (i_aGy * 2, j_aGz * 2) |
         i_aGy <- [0 .. nHalf_axr], (!j_aGz) <- [0 .. nHalf_axr]]
  where
      nHalf_axr = n_axq `div` 2 - 1
Utils.fineMesh :: Mesh -> Indx -> Mesh
Utils.fineMesh mesh_aGA nHalf'_aGB
  = array
      ((0, 0), (n_aGD, n_aGD))
      ([(0, 0) Utils.=: 3]
       ++
         [(0, n_aGD) Utils.=: 3]
         ++
           [(n_aGD, 0) Utils.=: 3]
           ++
             [(n_aGD, n_aGD) Utils.=: 3]
             ++
               [(0, 2 * j_aGE) Utils.=: 4 | j_aGE <- [1 .. nHalf_aGC]]
               ++
                 [(0, 2 * j_aGF - 1) Utils.=: 4 | (!j_aGF) <- [1 .. nHalf_aGC]]
                 ++
                   [(n_aGD, 2 * j_aGG) Utils.=: 4 | j_aGG <- [1 .. nHalf_aGC]]
                   ++
                     [(n_aGD, 2 * j_aGH - 1) Utils.=: 4 | j_aGH <- [1 .. nHalf_aGC]]
                     ++
                       [(2 * i_aGI, 0) Utils.=: 5 | (!i_aGI) <- [1 .. nHalf_aGC]]
                       ++
                         [(2 * i_aGJ - 1, 0) Utils.=: 5 | i_aGJ <- [1 .. nHalf_aGC]]
                         ++
                           [(2 * i_aGK, n_aGD) Utils.=: 5 | (!i_aGK) <- [1 .. nHalf_aGC]]
                           ++
                             [(2 * i_aGL - 1, n_aGD) Utils.=: 5 | i_aGL <- [1 .. nHalf_aGC]]
                             ++
                               [(2 * i_aGM, 2 * j_aGN) Utils.=: 6 |
                                  i_aGM <- [1 .. nHalf_aGC], (!j_aGN) <- [1 .. nHalf_aGC]]
                               ++
                                 [(2 * i_aGO, 2 * j_aGP - 1) Utils.=: 6 |
                                    i_aGO <- [1 .. nHalf_aGC], (!j_aGP) <- [1 .. nHalf_aGC]]
                                 ++
                                   [(2 * i_aGQ - 1, 2 * j_aGR) Utils.=: 6 |
                                      i_aGQ <- [1 .. nHalf_aGC], (!j_aGR) <- [1 .. nHalf_aGC]]
                                   ++
                                     [(2 * i_aGS - 1, 2 * j_aGT - 1) Utils.=: 6 |
                                        (!i_aGS) <- [1 .. nHalf_aGC], j_aGT <- [1 .. nHalf_aGC]])
  where
      nHalf_aGC = nHalf'_aGB - 1
      n_aGD = 2 * nHalf'_aGB - 1
Utils.genRand :: Value -> Value
Utils.genRand seed_aGU
  = r1_aGV / 655357
  where
      r1_aGV = (31453257 * seed_aGU + 271829) `fiRem_aGW` 655357
      fiRem_aGW (!x_aGX) m_aGY
        = x_aGX - fromIntegral ((truncate x_aGX `div` m_aGY) * m_aGY)
Utils.log2 :: Int -> Int
Utils.log2 n_aGZ
  = log2'_aH0 n_aGZ 0
  where
      log2'_aH0 (!n_aH1) (!accum_aH2)
        | n_aH1 > 1 = log2'_aH0 (n_aH1 `div` 2) (accum_aH2 + 1)
        | otherwise = accum_aH2


["a_anG","b_anH","operator_anI","mesh_anJ","!mesh_anJ","(!mesh_anJ)","n'_anK","j_axj","!j_axj","(!j_axj)","j_axk","!j_axk","(!j_axk)","i_axl","i_axm","!i_axm","(!i_axm)","i_axn","j_axo","n_anL","safebang@!n_anL","(!n_anL)","n1_anM","mesh_axp","n_axq","i_aGy","j_aGz","!j_aGz","(!j_aGz)","nHalf_axr","mesh_aGA","nHalf'_aGB","j_aGE","j_aGF","!j_aGF","(!j_aGF)","j_aGG","j_aGH","i_aGI","!i_aGI","(!i_aGI)","i_aGJ","i_aGK","!i_aGK","(!i_aGK)","i_aGL","i_aGM","j_aGN","!j_aGN","(!j_aGN)","i_aGO","j_aGP","!j_aGP","(!j_aGP)","i_aGQ","j_aGR","!j_aGR","(!j_aGR)","i_aGS","!i_aGS","(!i_aGS)","j_aGT","nHalf_aGC","n_aGD","seed_aGU","r1_aGV","x_aGX","!x_aGX","(!x_aGX)","m_aGY","n_aGZ","n_aH1","safebang@!n_aH1","(!n_aH1)","accum_aH2","safebang@!accum_aH2","(!accum_aH2)"]
module Utils (applyOpToMesh, coarseMesh, fineMesh, genRand, log2)
       where
import PicType
import Data.Array

infix 1 =:
a_anG =: b_anH = (a_anG, b_anH)

applyOpToMesh :: (Mesh -> Range -> Value) -> Mesh -> Indx -> Mesh
applyOpToMesh operator_anI (norecord@mesh_anJ) n'_anK
  = array ((0, 0), (n_anL, n_anL))
      ([(0, 0) =: operator_anI mesh_anJ [n_anL, 0, 1, n_anL, 0, 1]] ++
         [(0, n_anL) =:
            operator_anI mesh_anJ [n_anL, 0, 1, n1_anM, n_anL, 0]]
         ++
         [(n_anL, 0) =:
            operator_anI mesh_anJ [n1_anM, n_anL, 0, n_anL, 0, 1]]
         ++
         [(n_anL, n_anL) =:
            operator_anI mesh_anJ [n1_anM, n_anL, 0, n1_anM, n_anL, 0]]
         ++
         [(0, j_axj) =:
            operator_anI mesh_anJ
              [n_anL, 0, n1_anM, (j_axj - 1), j_axj, (j_axj + 1)]
          | (norecord@j_axj) <- [1 .. n1_anM]]
         ++
         [(n_anL, j_axk) =:
            operator_anI mesh_anJ
              [n1_anM, n_anL, 0, (j_axk - 1), j_axk, (j_axk + 1)]
          | (norecord@j_axk) <- [1 .. n1_anM]]
         ++
         [(i_axl, 0) =:
            operator_anI mesh_anJ
              [(i_axl - 1), i_axl, (i_axl + 1), n_anL, 0, 1]
          | i_axl <- [1 .. n1_anM]]
         ++
         [(i_axm, n_anL) =:
            operator_anI mesh_anJ
              [(i_axm - 1), i_axm, (i_axm + 1), n1_anM, n_anL, 0]
          | (norecord@i_axm) <- [1 .. n1_anM]]
         ++
         [(i_axn, j_axo) =:
            operator_anI mesh_anJ
              [(i_axn - 1), i_axn, (i_axn + 1), (j_axo - 1), j_axo, (j_axo + 1)]
          | i_axn <- [1 .. n1_anM], j_axo <- [1 .. n1_anM]])
  where (!n_anL) = n'_anK - 1
        n1_anM = n'_anK - 2

coarseMesh :: Mesh -> Indx -> Mesh
coarseMesh mesh_axp n_axq
  = array ((0, 0), (nHalf_axr, nHalf_axr))
      [(i_aGy, j_aGz) =: mesh_axp ! (i_aGy * 2, j_aGz * 2) |
       i_aGy <- [0 .. nHalf_axr], (norecord@j_aGz) <- [0 .. nHalf_axr]]
  where nHalf_axr = n_axq `div` 2 - 1

fineMesh :: Mesh -> Indx -> Mesh
fineMesh mesh_aGA nHalf'_aGB
  = array ((0, 0), (n_aGD, n_aGD))
      ([(0, 0) =: 3] ++ [(0, n_aGD) =: 3] ++ [(n_aGD, 0) =: 3] ++
         [(n_aGD, n_aGD) =: 3]
         ++ [(0, 2 * j_aGE) =: 4 | j_aGE <- [1 .. nHalf_aGC]]
         ++ [(0, 2 * j_aGF - 1) =: 4 | (norecord@j_aGF) <- [1 .. nHalf_aGC]]
         ++ [(n_aGD, 2 * j_aGG) =: 4 | j_aGG <- [1 .. nHalf_aGC]]
         ++ [(n_aGD, 2 * j_aGH - 1) =: 4 | j_aGH <- [1 .. nHalf_aGC]]
         ++ [(2 * i_aGI, 0) =: 5 | (norecord@i_aGI) <- [1 .. nHalf_aGC]]
         ++ [(2 * i_aGJ - 1, 0) =: 5 | i_aGJ <- [1 .. nHalf_aGC]]
         ++ [(2 * i_aGK, n_aGD) =: 5 | (norecord@i_aGK) <- [1 .. nHalf_aGC]]
         ++ [(2 * i_aGL - 1, n_aGD) =: 5 | i_aGL <- [1 .. nHalf_aGC]]
         ++
         [(2 * i_aGM, 2 * j_aGN) =: 6 | i_aGM <- [1 .. nHalf_aGC],
          (norecord@j_aGN) <- [1 .. nHalf_aGC]]
         ++
         [(2 * i_aGO, 2 * j_aGP - 1) =: 6 | i_aGO <- [1 .. nHalf_aGC],
          (norecord@j_aGP) <- [1 .. nHalf_aGC]]
         ++
         [(2 * i_aGQ - 1, 2 * j_aGR) =: 6 | i_aGQ <- [1 .. nHalf_aGC],
          (norecord@j_aGR) <- [1 .. nHalf_aGC]]
         ++
         [(2 * i_aGS - 1, 2 * j_aGT - 1) =: 6 |
          (norecord@i_aGS) <- [1 .. nHalf_aGC], j_aGT <- [1 .. nHalf_aGC]])
  where nHalf_aGC = nHalf'_aGB - 1
        n_aGD = 2 * nHalf'_aGB - 1

genRand :: Value -> Value
genRand seed_aGU = r1_aGV / 655357
  where r1_aGV = (31453257 * seed_aGU + 271829) `fiRem_aGW` 655357
        fiRem_aGW (norecord@x_aGX) m_aGY
          = x_aGX - fromIntegral ((truncate x_aGX `div` m_aGY) * m_aGY)

log2 :: Int -> Int
log2 n_aGZ = log2'_aH0 n_aGZ 0
  where log2'_aH0 (!n_aH1) (!accum_aH2)
          | n_aH1 > 1 = log2'_aH0 (n_aH1 `div` 2) (accum_aH2 + 1)
          | otherwise = accum_aH2

==================== Renamer ====================
ChargeDensity.chargeDensity :: ParticleHeap -> Rho
ChargeDensity.chargeDensity (xyPos_anG, xyVel_anH)
  = accumArray
      (+)
      0
      ((0, 0), (n_anI, n_anI))
      (ChargeDensity.accumCharge xyPos_anG)
  where
      (!n_anI) = nCell - 1
ChargeDensity.accumCharge :: [Position] -> [MeshAssoc]
ChargeDensity.accumCharge [] = []
ChargeDensity.accumCharge (((!x_axf), (!y_axg)) : (!xys_axh))
  = [((i_axp, j_axr), charge * (1 - dx_axt) * (1 - dy_axu))]
    ++
      [((i'_axq, j_axr), charge * dx_axt * (1 - dy_axu))]
      ++
        [((i_axp, j'_axs), charge * (1 - dx_axt) * dy_axu)]
        ++
          [((i'_axq, j'_axs), charge * dx_axt * dy_axu)]
          ++ ChargeDensity.accumCharge xys_axh
  where
      (!i_axp) = truncate x_axf
      i'_axq = (i_axp + 1) `rem` nCell
      j_axr = truncate y_axg
      j'_axs = (j_axr + 1) `rem` nCell
      dx_axt = x_axf - fromIntegral i_axp
      (!dy_axu) = y_axg - fromIntegral j_axr


["xyPos_anG","xyVel_anH","(xyPos_anG, xyVel_anH)","n_anI","!n_anI","(!n_anI)","[]","x_axf","safebang@!x_axf","(!x_axf)","y_axg","safebang@!y_axg","(!y_axg)","((!x_axf), (!y_axg))","xys_axh","safebang@!xys_axh","(!xys_axh)","((!x_axf), (!y_axg)) : (!xys_axh)","(((!x_axf), (!y_axg)) : (!xys_axh))","i_axp","!i_axp","(!i_axp)","i'_axq","j_axr","j'_axs","dx_axt","dy_axu","!dy_axu","(!dy_axu)"]
module ChargeDensity (chargeDensity) where
import PicType
import Consts
import Data.Array

chargeDensity :: ParticleHeap -> Rho
chargeDensity (xyPos_anG, xyVel_anH)
  = accumArray (+) 0 ((0, 0), (n_anI, n_anI)) (accumCharge xyPos_anG)
  where (norecord@n_anI) = nCell - 1

accumCharge :: [Position] -> [MeshAssoc]
accumCharge [] = []
accumCharge (((!x_axf), (!y_axg)) : (!xys_axh))
  = [((i_axp, j_axr), charge * (1 - dx_axt) * (1 - dy_axu))] ++
      [((i'_axq, j_axr), charge * dx_axt * (1 - dy_axu))]
      ++ [((i_axp, j'_axs), charge * (1 - dx_axt) * dy_axu)]
      ++ [((i'_axq, j'_axs), charge * dx_axt * dy_axu)]
      ++ accumCharge xys_axh
  where (norecord@i_axp) = truncate x_axf
        i'_axq = (i_axp + 1) `rem` nCell
        j_axr = truncate y_axg
        j'_axs = (j_axr + 1) `rem` nCell
        dx_axt = x_axf - fromIntegral i_axp
        (norecord@dy_axu) = y_axg - fromIntegral j_axr

==================== Renamer ====================
PushParticle.pushParticle ::
  ParticleHeap
  -> Electric
     -> Value -> Value -> Value -> (Value, Value, ParticleHeap)
PushParticle.pushParticle
  ([], [])
  (!xyElec_anF)
  dt_anG
  (!maxAcc_anH)
  (!maxVel_anI)
  = (maxAcc_anH, maxVel_anI, ([], []))
PushParticle.pushParticle
  (((!((xPos_anJ, (!yPos_anK)) : xyPos_anL))),
   ((xVel_anT, yVel_anU) : (!xyVel_anV)))
  (xElec_anW, (!yElec_anX))
  dt_anY
  (!maxAcc_anZ)
  maxVel_ao0
  = (maxAcc''_aoj, maxVel''_aok, 
     (((xPos'_aoh, yPos'_aoi) : xyPos'_aol), 
      ((xVel'_aof, yVel'_aog) : xyVel'_aom)))
  where
      (!i_ao1) = truncate xPos_anJ
      j_ao2 = truncate yPos_anK
      i1_ao3 = (i_ao1 + 1) `rem` nCell
      (!j1_ao4) = (j_ao2 + 1) `rem` nCell
      dx_ao5 = xPos_anJ - fromIntegral i_ao1
      (!dy_ao6) = yPos_anK - fromIntegral j_ao2
      xAcc_ao7
        = (charge / mass)
          * (xElec_anW ! (i_ao1, j_ao2) * (1 - dy_ao6)
             + xElec_anW ! (i_ao1, j1_ao4) * dy_ao6)
      (!yAcc_ao8)
        = (charge / mass)
          * (yElec_anX ! (i_ao1, j_ao2) * (1 - dx_ao5)
             + yElec_anX ! (i1_ao3, j_ao2) * dx_ao5)
      (!xTV_ao9) = xAcc_ao7 * dt_anY + xVel_anT
      yTV_aoa = yAcc_ao8 * dt_anY + yVel_anU
      xT_aob = xTV_ao9 * dt_anY + xPos_anJ
      yT_aoc = yTV_aoa * dt_anY + yPos_anK
      maxAcc'_aod = max maxAcc_anZ (max (abs xAcc_ao7) (abs yAcc_ao8))
      maxVel'_aoe = max maxVel_ao0 (max (abs xTV_ao9) (abs yTV_aoa))
      ((!xVel'_aof), yVel'_aog) = (xTV_ao9, yTV_aoa)
      (!xPos'_aoh)
        = if (xT_aob >= fromIntegral nCell) then
              xT_aob - fromIntegral nCell
          else
              if (xT_aob < 0.0) then xT_aob + fromIntegral nCell else xT_aob
      (!yPos'_aoi)
        = if (yT_aoc >= fromIntegral nCell) then
              yT_aoc - fromIntegral nCell
          else
              if (yT_aoc < 0.0) then yT_aoc + fromIntegral nCell else yT_aoc
      (!(maxAcc''_aoj, (!maxVel''_aok), (xyPos'_aol, xyVel'_aom)))
        = PushParticle.pushParticle
            (xyPos_anL, xyVel_anV)
            (xElec_anW, yElec_anX)
            dt_anY
            maxAcc'_aod
            maxVel'_aoe


["[]","[]","([], [])","xyElec_anF","safebang@!xyElec_anF","(!xyElec_anF)","dt_anG","maxAcc_anH","safebang@!maxAcc_anH","(!maxAcc_anH)","maxVel_anI","safebang@!maxVel_anI","(!maxVel_anI)","xPos_anJ","yPos_anK","safebang@!yPos_anK","(!yPos_anK)","(xPos_anJ, (!yPos_anK))","xyPos_anL","(xPos_anJ, (!yPos_anK)) : xyPos_anL","((xPos_anJ, (!yPos_anK)) : xyPos_anL)","!((xPos_anJ, (!yPos_anK)) : xyPos_anL)","(!((xPos_anJ, (!yPos_anK)) : xyPos_anL))","((!((xPos_anJ, (!yPos_anK)) : xyPos_anL)))","xVel_anT","yVel_anU","(xVel_anT, yVel_anU)","xyVel_anV","safebang@!xyVel_anV","(!xyVel_anV)","(xVel_anT, yVel_anU) : (!xyVel_anV)","((xVel_anT, yVel_anU) : (!xyVel_anV))","(((!((xPos_anJ, (!yPos_anK)) : xyPos_anL))),\n ((xVel_anT, yVel_anU) : (!xyVel_anV)))","xElec_anW","yElec_anX","!yElec_anX","(!yElec_anX)","(xElec_anW, (!yElec_anX))","dt_anY","maxAcc_anZ","!maxAcc_anZ","(!maxAcc_anZ)","maxVel_ao0","i_ao1","!i_ao1","(!i_ao1)","j_ao2","i1_ao3","j1_ao4","!j1_ao4","(!j1_ao4)","dx_ao5","dy_ao6","!dy_ao6","(!dy_ao6)","xAcc_ao7","yAcc_ao8","!yAcc_ao8","(!yAcc_ao8)","xTV_ao9","lazydmd@!xTV_ao9","(!xTV_ao9)","yTV_aoa","xT_aob","yT_aoc","maxAcc'_aod","maxVel'_aoe","xVel'_aof","!xVel'_aof","(!xVel'_aof)","yVel'_aog","((!xVel'_aof), yVel'_aog)","xPos'_aoh","!xPos'_aoh","(!xPos'_aoh)","yPos'_aoi","!yPos'_aoi","(!yPos'_aoi)","maxAcc''_aoj","maxVel''_aok","safebang@!maxVel''_aok","(!maxVel''_aok)","xyPos'_aol","xyVel'_aom","(xyPos'_aol, xyVel'_aom)","(maxAcc''_aoj, (!maxVel''_aok), (xyPos'_aol, xyVel'_aom))","!(maxAcc''_aoj, (!maxVel''_aok), (xyPos'_aol, xyVel'_aom))","(!(maxAcc''_aoj, (!maxVel''_aok), (xyPos'_aol, xyVel'_aom)))"]
module PushParticle (pushParticle) where
import PicType
import Consts
import Data.Array

pushParticle ::
             ParticleHeap ->
               Electric -> Value -> Value -> Value -> (Value, Value, ParticleHeap)
pushParticle ([], []) (!xyElec_anF) dt_anG (!maxAcc_anH)
  (!maxVel_anI) = (maxAcc_anH, maxVel_anI, ([], []))
pushParticle
  (((norecord@((xPos_anJ, (!yPos_anK)) : xyPos_anL))),
   ((xVel_anT, yVel_anU) : (!xyVel_anV)))
  (xElec_anW, (norecord@yElec_anX)) dt_anY (norecord@maxAcc_anZ)
  maxVel_ao0
  = (maxAcc''_aoj, maxVel''_aok,
     (((xPos'_aoh, yPos'_aoi) : xyPos'_aol),
      ((xVel'_aof, yVel'_aog) : xyVel'_aom)))
  where (norecord@i_ao1) = truncate xPos_anJ
        j_ao2 = truncate yPos_anK
        i1_ao3 = (i_ao1 + 1) `rem` nCell
        (norecord@j1_ao4) = (j_ao2 + 1) `rem` nCell
        dx_ao5 = xPos_anJ - fromIntegral i_ao1
        (norecord@dy_ao6) = yPos_anK - fromIntegral j_ao2
        xAcc_ao7
          = (charge / mass) *
              (xElec_anW ! (i_ao1, j_ao2) * (1 - dy_ao6) + xElec_anW !
                 (i_ao1, j1_ao4)
                 * dy_ao6)
        (norecord@yAcc_ao8)
          = (charge / mass) *
              (yElec_anX ! (i_ao1, j_ao2) * (1 - dx_ao5) + yElec_anX !
                 (i1_ao3, j_ao2)
                 * dx_ao5)
        (lazydmd@xTV_ao9) = xAcc_ao7 * dt_anY + xVel_anT
        yTV_aoa = yAcc_ao8 * dt_anY + yVel_anU
        xT_aob = xTV_ao9 * dt_anY + xPos_anJ
        yT_aoc = yTV_aoa * dt_anY + yPos_anK
        maxAcc'_aod = max maxAcc_anZ (max (abs xAcc_ao7) (abs yAcc_ao8))
        maxVel'_aoe = max maxVel_ao0 (max (abs xTV_ao9) (abs yTV_aoa))
        ((norecord@xVel'_aof), yVel'_aog) = (xTV_ao9, yTV_aoa)
        (norecord@xPos'_aoh)
          = if (xT_aob >= fromIntegral nCell) then
              xT_aob - fromIntegral nCell else
              if (xT_aob < 0.0) then xT_aob + fromIntegral nCell else xT_aob
        (norecord@yPos'_aoi)
          = if (yT_aoc >= fromIntegral nCell) then
              yT_aoc - fromIntegral nCell else
              if (yT_aoc < 0.0) then yT_aoc + fromIntegral nCell else yT_aoc
        (norecord@(maxAcc''_aoj, (!maxVel''_aok),
                   (xyPos'_aol, xyVel'_aom)))
          = pushParticle (xyPos_anL, xyVel_anV) (xElec_anW, yElec_anX) dt_anY
              maxAcc'_aod
              maxVel'_aoe

==================== Renamer ====================
Main.main
  = do { str_aRj <- getArgs;
         Main.control (map parseLine (Main.condenseArgs str_aRj)) }
Main.control args_aRk
  = do { (!stats_a117) <- if from_aRs == "stdin" then
                              getContents
                          else
                              readFile from_aRs;
         (if into_aRt == "stdout" then putStr else writeFile into_aRt)
           (form_aRl (graph_aRm stats_a117)) }
  where
      form_aRl :: String -> Postscript
      (!form_aRl)
        = if (sizeX_aRp == 0) then
              (if (elem Main.G args_aRk) then gspostscript else postscript)
          else
              ePostscript (sizeX_aRp, sizeY_aRq)
      graph_aRm :: String -> Postscript
      graph_aRm stats_aXx
        = if (elem Main.P args_aRk) then
              poolGraph processors_aRr stats_aXx
          else
              if orderSp_aRo /= [] then
                  sparkGraph orderSp_aRo processors_aRr stats_aXx
              else
                  activityGraph orderAct_aRn processors_aRr stats_aXx
      (Main.A orderAct_aRn)
        = Main.lookUp (Main.A Main.defaultAct) args_aRk
      ((!(Main.S orderSp_aRo))) = Main.lookUp (Main.S []) args_aRk
      (!((!(Main.E (!sizeX_aRp) sizeY_aRq))))
        = Main.lookUp (Main.E 0 0) args_aRk
      (!(Main.PS (!processors_aRr))) = Main.lookUp (Main.PS []) args_aRk
      (!(Main.IO (!((!from_aRs), into_aRt))))
        = Main.lookUp (Main.IO ("stdin", "stdout")) args_aRk
Main.condenseArgs :: [String] -> [String]
Main.condenseArgs [] = []
Main.condenseArgs (!((!arg_a118@(!('-' : _))) : more_a119))
  = arg_a118 : Main.condenseArgs more_a119
Main.condenseArgs [a_a11a, b_a11b] = [a_a11a ++ " " ++ b_a11b]
Main.condenseArgs a_a11c = a_a11c
Main.lookUp :: Main.Args -> [Main.Args] -> Main.Args
Main.lookUp a_a11d (![]) = a_a11d
Main.lookUp a_a11e ((!(b_a11f : (!bs_a11g))))
  | a_a11e == b_a11f = b_a11f
  | otherwise = Main.lookUp a_a11e bs_a11g
Main.defaultAct = [GC, REDN, IDLE, FLUSH]
Main.defaultSp = [RESUMED, USED, CREATED, LOST]
Main.defaultSize = (15 :: Int, 10 :: Int)
Main.defaultPS = [PE "14" 1]

data Main.Args
  = Main.A [Activity] |
    Main.S [Spark] |
    Main.P |
    Main.E Int Int |
    Main.F |
    Main.G |
    Main.PS [PElement] |
    Main.IO (String, String)

instance Parse Main.Args where
  parseType ('-' : (!('A' : (!string_a11h))))
    = (Main.A order_a11i, more_a11k)
    where
        order_a11i
          = if (whiteSpace string_a11h) == "" then
                Main.defaultAct
            else
                x_a11j
        ((!x_a11j), (!more_a11k)) = parse string_a11h
  parseType ((!('-' : (!('S' : (!string_a11l))))))
    = (Main.S order_a11m, more_a11o)
    where
        order_a11m
          = if (whiteSpace string_a11l == "") then Main.defaultSp else x_a11n
        (!(x_a11n, more_a11o)) = parse string_a11l
  parseType ((!('-' : (!('P' : (!string_a11p))))))
    = (Main.P, string_a11p)
  parseType ('-' : ('E' : (!string_a11q)))
    = (Main.E x_a11r y_a11s, "")
    where
        ((!x_a11r), (!y_a11s))
          = if (whiteSpace string_a11q) == "" then
                Main.defaultSize
            else
                (p_a11t, q_a11v)
        (!((!p_a11t), (!((!'x') : (!a_a11u))))) = parse string_a11q
        (q_a11v, more_a11w) = parse a_a11u
  parseType ('-' : (!('F' : (!string_a11x)))) = (Main.F, string_a11x)
  parseType (!((!('-' : (!('G' : (!string_a11y)))))))
    = (Main.G, string_a11y)
  parseType ((!('-' : (!('p' : string_a11z)))))
    = (Main.PS processors_a11B, more_a11C)
    where
        (!order_a11A)
          = if (whiteSpace string_a11z == "") then
                Main.defaultPS
            else
                processors_a11B
        (!(processors_a11B, (!more_a11C))) = parse string_a11z
  parseType (!('-' : string_a11D))
    = error ("Illegal flag to GRIP-graph : -" ++ string_a11D ++ "\n")
  parseType string_a11F
    = (Main.IO files_a11G, "")
    where
        (!files_a11G)
          = if string_a11F == "" then
                ("stdin", "stdout")
            else
                if (whiteSpace more_a11I) == "" then
                    (file1_a11H, file1_a11H ++ ".ps")
                else
                    (file1_a11H, file2_a11J)
        (file1_a11H, more_a11I)
          = span (\ x_a156 -> x_a156 /= ' ') string_a11F
        (!((!file2_a11J), (!_)))
          = span
              (\ (!x_a157) -> x_a157 /= ' ') (whiteSpace (more_a11I ++ " "))
instance Eq Main.Args where
  (Main.A (!_)) == (!(Main.A _)) = True
  ((!(Main.S (!_)))) == (Main.S _) = True
  (!Main.P) == Main.P = True
  (Main.E _ _) == (Main.E (!_) _) = True
  (!Main.F) == (!Main.F) = True
  Main.G == (!Main.G) = True
  (!((!(Main.PS _)))) == (!((!(Main.PS (!_))))) = True
  (!(Main.IO (!_))) == (Main.IO (!_)) = True
  (!_) == _ = False


["main","str_aRj","args_aRk","stats_a117","!stats_a117","(!stats_a117)","form_aRl","lazydmd@!form_aRl","(!form_aRl)","stats_aXx","orderAct_aRn","A orderAct_aRn","(A orderAct_aRn)","orderSp_aRo","S orderSp_aRo","(S orderSp_aRo)","!(S orderSp_aRo)","(!(S orderSp_aRo))","((!(S orderSp_aRo)))","sizeX_aRp","!sizeX_aRp","(!sizeX_aRp)","sizeY_aRq","E (!sizeX_aRp) sizeY_aRq","(E (!sizeX_aRp) sizeY_aRq)","!(E (!sizeX_aRp) sizeY_aRq)","(!(E (!sizeX_aRp) sizeY_aRq))","((!(E (!sizeX_aRp) sizeY_aRq)))","!((!(E (!sizeX_aRp) sizeY_aRq)))","(!((!(E (!sizeX_aRp) sizeY_aRq))))","processors_aRr","safebang@!processors_aRr","(!processors_aRr)","PS (!processors_aRr)","(PS (!processors_aRr))","!(PS (!processors_aRr))","(!(PS (!processors_aRr)))","from_aRs","safebang@!from_aRs","(!from_aRs)","into_aRt","((!from_aRs), into_aRt)","!((!from_aRs), into_aRt)","(!((!from_aRs), into_aRt))","IO (!((!from_aRs), into_aRt))","(IO (!((!from_aRs), into_aRt)))","!(IO (!((!from_aRs), into_aRt)))","(!(IO (!((!from_aRs), into_aRt))))","[]","'-'","_","'-' : _","('-' : _)","!('-' : _)","(!('-' : _))","arg_a118@(!('-' : _))","!arg_a118@(!('-' : _))","(!arg_a118@(!('-' : _)))","more_a119","(!arg_a118@(!('-' : _))) : more_a119","((!arg_a118@(!('-' : _))) : more_a119)","!((!arg_a118@(!('-' : _))) : more_a119)","(!((!arg_a118@(!('-' : _))) : more_a119))","a_a11a","b_a11b","[a_a11a, b_a11b]","a_a11c","a_a11d","[]","![]","(![])","a_a11e","b_a11f","bs_a11g","safebang@!bs_a11g","(!bs_a11g)","b_a11f : (!bs_a11g)","(b_a11f : (!bs_a11g))","!(b_a11f : (!bs_a11g))","(!(b_a11f : (!bs_a11g)))","((!(b_a11f : (!bs_a11g))))","defaultAct","defaultSp","defaultSize","defaultPS","'-'","'A'","string_a11h","lazydmd@!string_a11h","(!string_a11h)","'A' : (!string_a11h)","('A' : (!string_a11h))","!('A' : (!string_a11h))","(!('A' : (!string_a11h)))","'-' : (!('A' : (!string_a11h)))","('-' : (!('A' : (!string_a11h))))","order_a11i","x_a11j","!x_a11j","(!x_a11j)","more_a11k","!more_a11k","(!more_a11k)","((!x_a11j), (!more_a11k))","'-'","'S'","string_a11l","!string_a11l","(!string_a11l)","'S' : (!string_a11l)","('S' : (!string_a11l))","!('S' : (!string_a11l))","(!('S' : (!string_a11l)))","'-' : (!('S' : (!string_a11l)))","('-' : (!('S' : (!string_a11l))))","!('-' : (!('S' : (!string_a11l))))","(!('-' : (!('S' : (!string_a11l)))))","((!('-' : (!('S' : (!string_a11l))))))","order_a11m","x_a11n","more_a11o","(x_a11n, more_a11o)","!(x_a11n, more_a11o)","(!(x_a11n, more_a11o))","'-'","'P'","string_a11p","!string_a11p","(!string_a11p)","'P' : (!string_a11p)","('P' : (!string_a11p))","!('P' : (!string_a11p))","(!('P' : (!string_a11p)))","'-' : (!('P' : (!string_a11p)))","('-' : (!('P' : (!string_a11p))))","!('-' : (!('P' : (!string_a11p))))","(!('-' : (!('P' : (!string_a11p)))))","((!('-' : (!('P' : (!string_a11p))))))","'-'","'E'","string_a11q","!string_a11q","(!string_a11q)","'E' : (!string_a11q)","('E' : (!string_a11q))","'-' : ('E' : (!string_a11q))","('-' : ('E' : (!string_a11q)))","x_a11r","!x_a11r","(!x_a11r)","y_a11s","!y_a11s","(!y_a11s)","((!x_a11r), (!y_a11s))","p_a11t","!p_a11t","(!p_a11t)","'x'","!'x'","(!'x')","a_a11u","safebang@!a_a11u","(!a_a11u)","(!'x') : (!a_a11u)","((!'x') : (!a_a11u))","!((!'x') : (!a_a11u))","(!((!'x') : (!a_a11u)))","((!p_a11t), (!((!'x') : (!a_a11u))))","!((!p_a11t), (!((!'x') : (!a_a11u))))","(!((!p_a11t), (!((!'x') : (!a_a11u)))))","q_a11v","more_a11w","(q_a11v, more_a11w)","'-'","'F'","string_a11x","!string_a11x","(!string_a11x)","'F' : (!string_a11x)","('F' : (!string_a11x))","!('F' : (!string_a11x))","(!('F' : (!string_a11x)))","'-' : (!('F' : (!string_a11x)))","('-' : (!('F' : (!string_a11x))))","'-'","'G'","string_a11y","lazydmd@!string_a11y","(!string_a11y)","'G' : (!string_a11y)","('G' : (!string_a11y))","!('G' : (!string_a11y))","(!('G' : (!string_a11y)))","'-' : (!('G' : (!string_a11y)))","('-' : (!('G' : (!string_a11y))))","!('-' : (!('G' : (!string_a11y))))","(!('-' : (!('G' : (!string_a11y)))))","((!('-' : (!('G' : (!string_a11y))))))","!((!('-' : (!('G' : (!string_a11y))))))","(!((!('-' : (!('G' : (!string_a11y)))))))","'-'","'p'","string_a11z","'p' : string_a11z","('p' : string_a11z)","!('p' : string_a11z)","(!('p' : string_a11z))","'-' : (!('p' : string_a11z))","('-' : (!('p' : string_a11z)))","!('-' : (!('p' : string_a11z)))","(!('-' : (!('p' : string_a11z))))","((!('-' : (!('p' : string_a11z)))))","order_a11A","!order_a11A","(!order_a11A)","processors_a11B","more_a11C","!more_a11C","(!more_a11C)","(processors_a11B, (!more_a11C))","!(processors_a11B, (!more_a11C))","(!(processors_a11B, (!more_a11C)))","'-'","string_a11D","'-' : string_a11D","('-' : string_a11D)","!('-' : string_a11D)","(!('-' : string_a11D))","string_a11F","files_a11G","!files_a11G","(!files_a11G)","file1_a11H","more_a11I","(file1_a11H, more_a11I)","x_a156","file2_a11J","!file2_a11J","(!file2_a11J)","_","!_","(!_)","((!file2_a11J), (!_))","!((!file2_a11J), (!_))","(!((!file2_a11J), (!_)))","x_a157","!x_a157","(!x_a157)","_","!_","(!_)","A (!_)","(A (!_))","_","A _","(A _)","!(A _)","(!(A _))","_","!_","(!_)","S (!_)","(S (!_))","!(S (!_))","(!(S (!_)))","((!(S (!_))))","_","S _","(S _)","P","!P","(!P)","P","_","_","E _ _","(E _ _)","_","!_","(!_)","_","E (!_) _","(E (!_) _)","F","!F","(!F)","F","!F","(!F)","G","G","!G","(!G)","_","PS _","(PS _)","!(PS _)","(!(PS _))","((!(PS _)))","!((!(PS _)))","(!((!(PS _))))","_","!_","(!_)","PS (!_)","(PS (!_))","!(PS (!_))","(!(PS (!_)))","((!(PS (!_))))","!((!(PS (!_))))","(!((!(PS (!_)))))","_","!_","(!_)","IO (!_)","(IO (!_))","!(IO (!_))","(!(IO (!_)))","_","!_","(!_)","IO (!_)","(IO (!_))","_","!_","(!_)","_"]
module Main where
import GRIP
import PSlib
import Graph
import Parse
import Pool
import Activity
import Spark
import System.Environment
main
  = do str_aRj <- getArgs
       control (map parseLine (condenseArgs str_aRj))
control args_aRk
  = do (norecord@stats_a117) <- if from_aRs == "stdin" then
                                  getContents else readFile from_aRs
       (if into_aRt == "stdout" then putStr else writeFile into_aRt)
         (form_aRl (graph_aRm stats_a117))
  where form_aRl :: String -> Postscript
        (lazydmd@form_aRl)
          = if (sizeX_aRp == 0) then
              (if (elem G args_aRk) then gspostscript else postscript) else
              ePostscript (sizeX_aRp, sizeY_aRq)
        
        graph_aRm :: String -> Postscript
        graph_aRm stats_aXx
          = if (elem P args_aRk) then poolGraph processors_aRr stats_aXx else
              if orderSp_aRo /= [] then
                sparkGraph orderSp_aRo processors_aRr stats_aXx else
                activityGraph orderAct_aRn processors_aRr stats_aXx
        (A orderAct_aRn) = lookUp (A defaultAct) args_aRk
        ((norecord@(S orderSp_aRo))) = lookUp (S []) args_aRk
        (norecord@((norecord@(E (norecord@sizeX_aRp) sizeY_aRq))))
          = lookUp (E 0 0) args_aRk
        (norecord@(PS (!processors_aRr))) = lookUp (PS []) args_aRk
        (norecord@(IO (norecord@((!from_aRs), into_aRt))))
          = lookUp (IO ("stdin", "stdout")) args_aRk

condenseArgs :: [String] -> [String]
condenseArgs [] = []
condenseArgs
  (norecord@((norecord@arg_a118@(norecord@('-' : _))) : more_a119))
  = arg_a118 : condenseArgs more_a119
condenseArgs [a_a11a, b_a11b] = [a_a11a ++ " " ++ b_a11b]
condenseArgs a_a11c = a_a11c

lookUp :: Args -> [Args] -> Args
lookUp a_a11d (norecord@[]) = a_a11d
lookUp a_a11e ((norecord@(b_a11f : (!bs_a11g))))
  | a_a11e == b_a11f = b_a11f
  | otherwise = lookUp a_a11e bs_a11g
defaultAct = [GC, REDN, IDLE, FLUSH]
defaultSp = [RESUMED, USED, CREATED, LOST]
defaultSize = (15 :: Int, 10 :: Int)
defaultPS = [PE "14" 1]

data Args = A [Activity]
          | S [Spark]
          | P
          | E Int Int
          | F
          | G
          | PS [PElement]
          | IO (String, String)

instance Parse Args where
        parseType ('-' : (norecord@('A' : (lazydmd@string_a11h))))
          = (A order_a11i, more_a11k)
          where order_a11i
                  = if (whiteSpace string_a11h) == "" then defaultAct else x_a11j
                ((norecord@x_a11j), (norecord@more_a11k)) = parse string_a11h
        parseType
          ((norecord@('-' : (norecord@('S' : (norecord@string_a11l))))))
          = (S order_a11m, more_a11o)
          where order_a11m
                  = if (whiteSpace string_a11l == "") then defaultSp else x_a11n
                (norecord@(x_a11n, more_a11o)) = parse string_a11l
        parseType
          ((norecord@('-' : (norecord@('P' : (norecord@string_a11p))))))
          = (P, string_a11p)
        parseType ('-' : ('E' : (norecord@string_a11q)))
          = (E x_a11r y_a11s, "")
          where ((norecord@x_a11r), (norecord@y_a11s))
                  = if (whiteSpace string_a11q) == "" then defaultSize else
                      (p_a11t, q_a11v)
                (norecord@((norecord@p_a11t),
                           (norecord@((norecord@'x') : (!a_a11u)))))
                  = parse string_a11q
                (q_a11v, more_a11w) = parse a_a11u
        parseType ('-' : (norecord@('F' : (norecord@string_a11x))))
          = (F, string_a11x)
        parseType
          (norecord@((norecord@('-' :
                                  (norecord@('G' : (lazydmd@string_a11y)))))))
          = (G, string_a11y)
        parseType ((norecord@('-' : (norecord@('p' : string_a11z)))))
          = (PS processors_a11B, more_a11C)
          where (norecord@order_a11A)
                  = if (whiteSpace string_a11z == "") then defaultPS else
                      processors_a11B
                (norecord@(processors_a11B, (norecord@more_a11C)))
                  = parse string_a11z
        parseType (norecord@('-' : string_a11D))
          = error ("Illegal flag to GRIP-graph : -" ++ string_a11D ++ "\n")
        parseType string_a11F = (IO files_a11G, "")
          where (norecord@files_a11G)
                  = if string_a11F == "" then ("stdin", "stdout") else
                      if (whiteSpace more_a11I) == "" then
                        (file1_a11H, file1_a11H ++ ".ps") else (file1_a11H, file2_a11J)
                (file1_a11H, more_a11I)
                  = span (\ x_a156 -> x_a156 /= ' ') string_a11F
                (norecord@((norecord@file2_a11J), (norecord@_)))
                  = span (\ (norecord@x_a157) -> x_a157 /= ' ')
                      (whiteSpace (more_a11I ++ " "))

instance Eq Args where
        (A (norecord@_)) == (norecord@(A _)) = True
        ((norecord@(S (norecord@_)))) == (S _) = True
        (norecord@P) == P = True
        (E _ _) == (E (norecord@_) _) = True
        (norecord@F) == (norecord@F) = True
        G == (norecord@G) = True
        (norecord@((norecord@(PS _)))) ==
          (norecord@((norecord@(PS (norecord@_))))) = True
        (norecord@(IO (norecord@_))) == (IO (norecord@_)) = True
        (norecord@_) == _ = False

==================== Renamer ====================
PSlib.initialise header_aJr
  = header_aJr
    ++
      "/SMALL /Helvetica findfont 4 scalefont def\n"
      ++
        "/SMALLBOLD /Helvetica-Bold findfont 4 scalefont def\n"
        ++
          "/SMALLITALIC /Helvetica-Oblique findfont 4 scalefont def\n"
          ++
            "/NORM /Helvetica findfont 5 scalefont def\n"
            ++
              "/BOLD /Helvetica-Bold findfont 5 scalefont def\n"
              ++
                "/LARGE /Helvetica-Bold findfont 11 scalefont def\n"
                ++
                  "NORM setfont\n"
                  ++ PSlib.setcms ++ PSlib.stdProcedures ++ PSlib.thinlines
PSlib.setfont str_aJs = str_aJs ++ " setfont\n"
PSlib.stdheader :: PSlib.Postscript
PSlib.stdheader
  = "%!PS-Adobe-2.0\n\
    \%%Created by Haskell Graph Package\n"
PSlib.gslandscape = ""
PSlib.landscape
  = PSlib.translate 8 290
    ++ PSlib.rotate 270 ++ PSlib.translate 20 10 ++ "0.9 0.9 scale\n"
PSlib.portrait = ""
PSlib.stdProcedures = PSlib.rightshow ++ PSlib.centreshow
PSlib.drawObject :: [PSlib.Point] -> PSlib.Postscript
PSlib.drawObject (pts_aJt)
  = PSlib.newpath
    ++
      PSlib.moveto (PSlib.Pt 0 0)
      ++
        concat (map PSlib.lineto pts_aJt)
        ++ PSlib.thinlines ++ PSlib.stroke
PSlib.fillObject :: [PSlib.Point] -> PSlib.Postscript
PSlib.fillObject (!(pts_aPB))
  = PSlib.newpath
    ++
      PSlib.moveto (PSlib.Pt 0 0)
      ++
        concat (map PSlib.lineto pts_aPB)
        ++ PSlib.closepath ++ PSlib.fill ++ PSlib.stroke
PSlib.fillBox ::
  PSlib.Point -> Int -> Int -> Int -> PSlib.Postscript
PSlib.fillBox pt_aPC (!dx_aPD) dy_aPE (!c_aPF)
  = PSlib.newpath
    ++
      PSlib.moveto pt_aPC
      ++
        PSlib.rlineto 0 dy_aPE
        ++
          PSlib.rlineto dx_aPD 0
          ++
            PSlib.rlineto 0 (- dy_aPE)
            ++ PSlib.closepath ++ PSlib.setgray c_aPF ++ PSlib.fill
PSlib.drawBox :: PSlib.Point -> Int -> Int -> PSlib.Postscript
PSlib.drawBox (!pt_aPG) (!dx_aPH) dy_aPI
  = PSlib.thinlines
    ++
      PSlib.newpath
      ++
        PSlib.moveto pt_aPG
        ++
          PSlib.rlineto 0 dy_aPI
          ++
            PSlib.rlineto dx_aPH 0
            ++ PSlib.rlineto 0 (- dy_aPI) ++ PSlib.closepath ++ PSlib.stroke
PSlib.rjustify (!str_aPJ) = "(" ++ str_aPJ ++ ") rightshow\n"
PSlib.cjustify (!str_aPK) = "(" ++ str_aPK ++ ") centreshow\n"
PSlib.rightshow
  = "/rightshow\n\
    \{dup stringwidth pop\n\
    \0 exch sub\n\
    \0 rmoveto\n\
    \show } def \n"
PSlib.centreshow
  = "/centreshow\n\
    \{dup stringwidth pop\n\
    \0 exch sub\n\
    \2 div\n\
    \0 rmoveto\n\
    \show } def \n"
PSlib.fill = "fill\n"
PSlib.stroke = "stroke\n"
PSlib.closepath = "closepath\n"
PSlib.newpath = "newpath\n"
PSlib.showpage
  = "showpage\n\
    \\n"
PSlib.gsave = "gsave\n"
PSlib.grestore = "grestore\n"
PSlib.text (!t_aPL) = PSlib.setgray 0 ++ "(" ++ t_aPL ++ ") show\n"
PSlib.setgray 0 = "0 setgray\n"
PSlib.setgray 10 = "1 setgray\n"
PSlib.setgray (!n_aPM) = "." ++ show n_aPM ++ " setgray\n"
PSlib.moveto (PSlib.Pt x_aPN y_aPO)
  = PSlib.psCommand "moveto" [x_aPN, y_aPO]
PSlib.rmoveto x_aPP (!y_aPQ)
  = PSlib.psCommand "rmoveto" [x_aPP, y_aPQ]
PSlib.lineto :: PSlib.Point -> PSlib.Postscript
PSlib.lineto (!((!(PSlib.Pt x_aPR y_aPS))))
  = PSlib.psCommand "lineto" [x_aPR, y_aPS]
PSlib.rlineto x_aPT (!y_aPU)
  = PSlib.psCommand "rlineto" [x_aPT, y_aPU]
PSlib.setlinewidth n_aPV = PSlib.psCommand "setlinewidth" [n_aPV]
PSlib.thinlines = "0.2 setlinewidth\n"
PSlib.rotate n_aPW = PSlib.psCommand "rotate" [n_aPW]
PSlib.psCommand c_aPX (!args_aPY)
  = concat (map f_aPZ args_aPY) ++ c_aPX ++ "\n"
  where
      f_aPZ (!x_aQ0) = show x_aQ0 ++ " "
PSlib.translate (!x_aQ1) y_aQ2
  = PSlib.psCommand "translate" [x_aQ1, y_aQ2]
PSlib.scale x_aQ3 y_aQ4 = PSlib.psCommand "scale" [x_aQ3, y_aQ4]
PSlib.setcms = "2.84584 2.84584 scale\n"

type PSlib.Postscript = String
data PSlib.Point
  = PSlib.Pt Int Int
  deriving (Eq, Show)


["header_aJr","str_aJs","stdheader","gslandscape","landscape","portrait","stdProcedures","pts_aJt","(pts_aJt)","pts_aPB","(pts_aPB)","!(pts_aPB)","(!(pts_aPB))","pt_aPC","dx_aPD","safebang@!dx_aPD","(!dx_aPD)","dy_aPE","c_aPF","safebang@!c_aPF","(!c_aPF)","pt_aPG","safebang@!pt_aPG","(!pt_aPG)","dx_aPH","safebang@!dx_aPH","(!dx_aPH)","dy_aPI","str_aPJ","safebang@!str_aPJ","(!str_aPJ)","str_aPK","safebang@!str_aPK","(!str_aPK)","rightshow","centreshow","fill","stroke","closepath","newpath","showpage","gsave","grestore","t_aPL","safebang@!t_aPL","(!t_aPL)","0","10","n_aPM","!n_aPM","(!n_aPM)","x_aPN","y_aPO","Pt x_aPN y_aPO","(Pt x_aPN y_aPO)","x_aPP","y_aPQ","safebang@!y_aPQ","(!y_aPQ)","x_aPR","y_aPS","Pt x_aPR y_aPS","(Pt x_aPR y_aPS)","!(Pt x_aPR y_aPS)","(!(Pt x_aPR y_aPS))","((!(Pt x_aPR y_aPS)))","!((!(Pt x_aPR y_aPS)))","(!((!(Pt x_aPR y_aPS))))","x_aPT","y_aPU","safebang@!y_aPU","(!y_aPU)","n_aPV","thinlines","n_aPW","c_aPX","args_aPY","safebang@!args_aPY","(!args_aPY)","x_aQ0","!x_aQ0","(!x_aQ0)","x_aQ1","safebang@!x_aQ1","(!x_aQ1)","y_aQ2","x_aQ3","y_aQ4","setcms"]
module PSlib where
initialise header_aJr
  = header_aJr ++ "/SMALL /Helvetica findfont 4 scalefont def\n" ++
      "/SMALLBOLD /Helvetica-Bold findfont 4 scalefont def\n"
      ++ "/SMALLITALIC /Helvetica-Oblique findfont 4 scalefont def\n"
      ++ "/NORM /Helvetica findfont 5 scalefont def\n"
      ++ "/BOLD /Helvetica-Bold findfont 5 scalefont def\n"
      ++ "/LARGE /Helvetica-Bold findfont 11 scalefont def\n"
      ++ "NORM setfont\n"
      ++ setcms
      ++ stdProcedures
      ++ thinlines
setfont str_aJs = str_aJs ++ " setfont\n"

stdheader :: Postscript
stdheader = "%!PS-Adobe-2.0\n%%Created by Haskell Graph Package\n"
gslandscape = ""
landscape
  = translate 8 290 ++ rotate 270 ++ translate 20 10 ++
      "0.9 0.9 scale\n"
portrait = ""
stdProcedures = rightshow ++ centreshow

drawObject :: [Point] -> Postscript
drawObject (pts_aJt)
  = newpath ++ moveto (Pt 0 0) ++ concat (map lineto pts_aJt) ++
      thinlines
      ++ stroke

fillObject :: [Point] -> Postscript
fillObject (norecord@(pts_aPB))
  = newpath ++ moveto (Pt 0 0) ++ concat (map lineto pts_aPB) ++
      closepath
      ++ fill
      ++ stroke

fillBox :: Point -> Int -> Int -> Int -> Postscript
fillBox pt_aPC (!dx_aPD) dy_aPE (!c_aPF)
  = newpath ++ moveto pt_aPC ++ rlineto 0 dy_aPE ++ rlineto dx_aPD 0
      ++ rlineto 0 (-dy_aPE)
      ++ closepath
      ++ setgray c_aPF
      ++ fill

drawBox :: Point -> Int -> Int -> Postscript
drawBox (!pt_aPG) (!dx_aPH) dy_aPI
  = thinlines ++ newpath ++ moveto pt_aPG ++ rlineto 0 dy_aPI ++
      rlineto dx_aPH 0
      ++ rlineto 0 (-dy_aPI)
      ++ closepath
      ++ stroke
rjustify (!str_aPJ) = "(" ++ str_aPJ ++ ") rightshow\n"
cjustify (!str_aPK) = "(" ++ str_aPK ++ ") centreshow\n"
rightshow
  = "/rightshow\n{dup stringwidth pop\n0 exch sub\n0 rmoveto\nshow } def \n"
centreshow
  = "/centreshow\n{dup stringwidth pop\n0 exch sub\n2 div\n0 rmoveto\nshow } def \n"
fill = "fill\n"
stroke = "stroke\n"
closepath = "closepath\n"
newpath = "newpath\n"
showpage = "showpage\n\n"
gsave = "gsave\n"
grestore = "grestore\n"
text (!t_aPL) = setgray 0 ++ "(" ++ t_aPL ++ ") show\n"
setgray 0 = "0 setgray\n"
setgray 10 = "1 setgray\n"
setgray (norecord@n_aPM) = "." ++ show n_aPM ++ " setgray\n"
moveto (Pt x_aPN y_aPO) = psCommand "moveto" [x_aPN, y_aPO]
rmoveto x_aPP (!y_aPQ) = psCommand "rmoveto" [x_aPP, y_aPQ]

lineto :: Point -> Postscript
lineto (norecord@((norecord@(Pt x_aPR y_aPS))))
  = psCommand "lineto" [x_aPR, y_aPS]
rlineto x_aPT (!y_aPU) = psCommand "rlineto" [x_aPT, y_aPU]
setlinewidth n_aPV = psCommand "setlinewidth" [n_aPV]
thinlines = "0.2 setlinewidth\n"
rotate n_aPW = psCommand "rotate" [n_aPW]
psCommand c_aPX (!args_aPY)
  = concat (map f_aPZ args_aPY) ++ c_aPX ++ "\n"
  where f_aPZ (norecord@x_aQ0) = show x_aQ0 ++ " "
translate (!x_aQ1) y_aQ2 = psCommand "translate" [x_aQ1, y_aQ2]
scale x_aQ3 y_aQ4 = psCommand "scale" [x_aQ3, y_aQ4]
setcms = "2.84584 2.84584 scale\n"

type Postscript = String

data Point = Pt Int Int
           deriving (Eq, Show)

==================== Renamer ====================
Graph.paperX = 280 :: Int
Graph.paperY = 190 :: Int
Graph.my_fromInt :: Num a_ax0 => Int -> a_ax0
Graph.my_fromInt = fromInteger . toInteger
Graph.gspostscript (!str_aH4)
  = initialise stdheader ++ portrait ++ str_aH4 ++ "showpage\n"
Graph.postscript (!str_aH5)
  = initialise stdheader ++ landscape ++ str_aH5 ++ "showpage\n"
Graph.ePostscript (reqdx_aH6, reqdy_aH7) str_aH8
  = initialise
      (stdheader
       ++
         "%%BoundingBox: 0 0 "
         ++
           show (Graph.cms2pts reqdx_aH6)
           ++
             " " ++ show (Graph.cms2pts reqdy_aH7) ++ "\n" ++ "%%EndComments\n")
    ++
      scale
        (Graph.my_fromInt reqdx_aH6 * 10 / Graph.my_fromInt Graph.paperX)
        (Graph.my_fromInt reqdy_aH7 * 10 / Graph.my_fromInt Graph.paperY)
      ++ str_aH8 ++ showpage
Graph.initGraph
  title_aPt
  (!pedata_aPu)
  (topX_aPv, (!topY_aPw))
  (!((!xlabel_aPx), (!ylabel_aPy)))
  keys_aPz
  = drawBox (Pt 0 0) Graph.paperX Graph.paperY
    ++
      drawBox (Pt 1 1) (Graph.paperX - 2) 5
      ++
        drawBox (Pt 1 (Graph.paperY - 7)) (Graph.paperX - 2) 6
        ++
          setfont "BOLD"
          ++
            moveto (Pt (Graph.paperX `div` 2) (Graph.paperY - 6))
            ++
              cjustify (title_aPt)
              ++
                setfont "NORM"
                ++
                  Graph.placePEs pedata_aPu
                  ++
                    translate 20 25
                    ++
                      newpath
                      ++
                        moveto (Pt 0 (- 5))
                        ++
                          lineto (Pt 0 Graph.dimY)
                          ++
                            moveto (Pt (- 5) 0)
                            ++
                              lineto (Pt Graph.dimX 0)
                              ++
                                stroke
                                ++
                                  setfont "SMALL"
                                  ++
                                    Graph.markXAxis Graph.dimX topX_aPv
                                    ++
                                      Graph.markYAxis Graph.dimY topY_aPw
                                      ++
                                        moveto (Pt 0 (Graph.dimY + 4))
                                        ++
                                          rjustify ylabel_aPy
                                          ++
                                            stroke
                                            ++
                                              moveto (Pt Graph.dimX (- 8))
                                              ++
                                                rjustify xlabel_aPx
                                                ++
                                                  stroke
                                                  ++
                                                    setfont "NORM"
                                                    ++ Graph.dokeys Graph.dimX keys_aPz
Graph.placePEs ((!pes_aPA), (!on_aPB))
  | Graph.checkPEs (tail pes_aPA) on_aPB
  = Graph.showActive (length pes_aPA) (length used_aPC)
    ++ Graph.showUsed pes_aPA used_aPC ++ setfont "NORM"
  where
      (!used_aPC) = if on_aPB == [] then tail pes_aPA else on_aPB
Graph.cms2pts :: Int -> Int
Graph.cms2pts x_a1cr = round (28.4584 * Graph.my_fromInt x_a1cr)
Graph.plotCurve :: Int -> [Point] -> Postscript
Graph.plotCurve (!x_a1cs) pts_a1ct
  = setgray x_a1cs ++ fillObject pts_a1ct
Graph.plot :: [Point] -> Postscript
Graph.plot points_a1cu = Graph.plotCurve 5 (Pt 0 0 : points_a1cu)
Graph.dokeys left_a1cv keys_a1cw
  = concat (map2 format_a1cx (places_a1cz 0) keys_a1cw)
  where
      format_a1cx
        (!pt_a1cA@(Pt (!x_a1cB) (!y_a1cC)))
        (col_a1cD, tex_a1cE, pc_a1cF)
        = fillBox pt_a1cA 16 9 col_a1cD
          ++
            stroke
            ++
              moveto (Pt (x_a1cB + 17) (y_a1cC + 3))
              ++
                text tex_a1cE
                ++
                  stroke
                  ++
                    moveto (Pt (x_a1cB + 8) (y_a1cC + 3))
                    ++
                      Graph.inv col_a1cD
                      ++
                        setfont "BOLD"
                        ++ cjustify (pc_a1cF) ++ stroke ++ setfont "NORM" ++ setgray 10
      no_a1cy = left_a1cv `div` length keys_a1cw
      places_a1cz (!n_a1cG) | n_a1cG == no_a1cy = []
      places_a1cz n_a1cH
        = (Pt (n_a1cH * no_a1cy) (- 17)) : places_a1cz (n_a1cH + 1)
Graph.showActive t_a1cI (!f_a1cJ)
  = setfont "LARGE"
    ++
      moveto (Pt 10 16)
      ++
        cjustify (show f_a1cJ)
        ++
          setfont "SMALL"
          ++
            moveto (Pt 10 12)
            ++
              cjustify "PE(s)"
              ++
                stroke
                ++
                  setfont "SMALL"
                  ++
                    moveto (Pt 10 8)
                    ++ cjustify "displayed" ++ stroke ++ setfont "NORM"
Graph.showUsed ((!((!m_a1cK) : pes_a1cL))) on_a1cM
  = moveto (Pt 2 2)
    ++
      setfont "SMALL"
      ++
        text "Configuration:"
        ++
          Graph.dopes
            (Graph.paperX - 27)
            (("SMALLITALIC", Graph.showPE m_a1cK) : map f_a1cN pes_a1cL)
          ++ stroke
  where
      f_a1cN pe_a1cO
        | elem pe_a1cO on_a1cM = ("SMALLBOLD", Graph.showPE pe_a1cO)
        | otherwise = ("SMALL", Graph.showPE pe_a1cO)
Graph.dopes left_a1cP (!pes_a1cQ)
  = concat (map2 format_a1cR (places_a1cU 0) pes_a1cQ)
  where
      format_a1cR
        pt_a1cV@(Pt (!x_a1cW) (!y_a1cX))
        (font_a1cY, (!tex_a1cZ))
        = setfont font_a1cY ++ moveto pt_a1cV ++ text tex_a1cZ ++ stroke
      no_a1cS = left_a1cP `div` ((length pes_a1cQ * 2) + 1)
      f_a1cT x_a1d0 = (no_a1cS * ((x_a1d0 * 2) + 1)) + 27
      places_a1cU n_a1d1 | n_a1d1 > 2 * no_a1cS = []
      places_a1cU n_a1d2
        = (Pt (f_a1cT n_a1d2) 2) : places_a1cU (n_a1d2 + 1)
Graph.checkPEs (!pes_a1d3) [] = True
Graph.checkPEs pes_a1d4 ((!(p_a1d5 : (!ps_a1d6))))
  | elem p_a1d5 pes_a1d4 = Graph.checkPEs pes_a1d4 ps_a1d6
  | otherwise
  = error
      ("Attempt to gather information from inactive PE - "
       ++ Graph.showPE p_a1d5)
Graph.showPE :: PElement -> String
Graph.showPE (!((!(PE (!str_a1d8) no_a1d9))))
  = str_a1d8 ++ "." ++ show no_a1d9
Graph.inv (!x_a1da)
  | x_a1da >= 5 = setgray 0
  | otherwise = setgray 10
Graph.dimX = Graph.paperX - 30
Graph.dimY = Graph.paperY - 40
Graph.markXAxis :: Int -> Int -> Postscript
Graph.markXAxis (!dimX_a1db) maxX_a1dc
  = label_a1dd 10 ++ Graph.markOnX 100
  where
      label_a1dd (!0) = ""
      label_a1dd (!x_a1dg)
        = newpath
          ++
            moveto (Pt (notch_a1df x_a1dg) 0)
            ++
              rlineto 0 (- 2)
              ++
                moveto (Pt (notch_a1df x_a1dg) (- 5))
                ++
                  cjustify (Graph.printFloat (t_a1de x_a1dg))
                  ++ stroke ++ label_a1dd (x_a1dg - 1)
      t_a1de x_a1dh
        = Graph.my_fromInt x_a1dh
          * (Graph.my_fromInt maxX_a1dc / Graph.my_fromInt 10)
      notch_a1df x_a1di = x_a1di * (dimX_a1db `div` 10)
Graph.markOnX (!n_a1dj)
  = mapcat notches_a1dk [1 .. n_a1dj] ++ stroke
  where
      notches_a1dk n_a1dm
        = Graph.movetofloat (m_a1dl * Graph.my_fromInt n_a1dm) 0
          ++ (rlineto 0 (- 1)) ++ stroke
      (!m_a1dl) = Graph.my_fromInt Graph.dimX / Graph.my_fromInt n_a1dj
Graph.markYAxis :: Int -> Int -> Postscript
Graph.markYAxis dimY_a1dn maxY_a1do
  = label_a1dp 10 ++ Graph.markOnY (Graph.calibrate maxY_a1do)
  where
      label_a1dp (!0) = ""
      label_a1dp x_a1ds
        = newpath
          ++
            moveto (Pt 0 (notch_a1dr x_a1ds))
            ++
              rlineto (- 2) 0
              ++
                moveto (Pt (- 3) (notch_a1dr x_a1ds))
                ++
                  rjustify (Graph.printFloat (t_a1dq x_a1ds))
                  ++ stroke ++ label_a1dp (x_a1ds - 1)
      t_a1dq x_a1dt
        = Graph.my_fromInt x_a1dt
          * (Graph.my_fromInt maxY_a1do / Graph.my_fromInt 10)
      notch_a1dr (!x_a1du) = x_a1du * (dimY_a1dn `div` 10)
Graph.calibrate (!x_a1dv)
  | x_a1dv <= 1 = 1
  | x_a1dv <= 100 = x_a1dv
  | otherwise = Graph.calibrate (x_a1dv `div` 10)
Graph.markOnY n_a1dw
  = mapcat notches_a1dx [1 .. n_a1dw] ++ stroke
  where
      notches_a1dx n_a1dz
        = Graph.movetofloat 0 (m_a1dy * Graph.my_fromInt n_a1dz)
          ++ (rlineto (- 1) 0)
      m_a1dy = Graph.my_fromInt Graph.dimY / Graph.my_fromInt n_a1dw
Graph.movetofloat (!x_a1dA) (!y_a1dB)
  = show x_a1dA ++ " " ++ show y_a1dB ++ " moveto\n"
Graph.determineScale :: [Point] -> (Int, Int)
Graph.determineScale pts_a1dC
  = (Graph.axisScale x_a1dE, Graph.axisScale y_a1dF)
  where
      (!(min_a1dD, (!(Pt x_a1dE (!y_a1dF))))) = Graph.minandmax pts_a1dC
Graph.axisScale :: Int -> Int
Graph.axisScale x_a1dG = Graph.axisScale' x_a1dG 1
Graph.axisScale' x_a1dH m_a1dI
  | x_a1dH <= m_a1dI = m_a1dI
  | x_a1dH <= m_a1dI * 2 = m_a1dI * 2
  | x_a1dH <= m_a1dI * 5 = m_a1dI * 5
  | x_a1dH <= m_a1dI * 10 = m_a1dI * 10
  | otherwise = Graph.axisScale' x_a1dH (m_a1dI * 10)
Graph.minandmax :: [Point] -> (Point, Point)
Graph.minandmax [] = error "No points"
Graph.minandmax (!((!p_a1dJ) : ps_a1dK))
  = f_a1dL (p_a1dJ, p_a1dJ) ps_a1dK
  where
      f_a1dL (!p_a1dM) (![]) = p_a1dM
      f_a1dL
        (Pt minx_a1dN miny_a1dO, Pt (!maxx_a1dP) maxy_a1dQ)
        (!((!(Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT)))))
        = f_a1dL
            (Pt minx'_a1dU miny'_a1dV, Pt maxx'_a1dW maxy'_a1dX) ps_a1dT
        where
            (!minx'_a1dU) = min x_a1dR minx_a1dN
            (!miny'_a1dV) = min y_a1dS miny_a1dO
            maxx'_a1dW = max x_a1dR maxx_a1dP
            maxy'_a1dX = max y_a1dS maxy_a1dQ
Graph.printFloat :: Float -> String
Graph.printFloat x_a1dY
  = f_a1dZ (show (round (x_a1dY * 10)))
  where
      f_a1dZ "0" = "0"
      f_a1dZ r_a1e0 | x_a1dY < 1 = "0." ++ r_a1e0
      f_a1dZ ((!r_a1e1) : (!"0")) | x_a1dY < 10 = [r_a1e1]
      f_a1dZ (!((!(r_a1e2 : m_a1e3))))
        | x_a1dY < 10 = r_a1e2 : '.' : m_a1e3
      f_a1dZ (!_) = show (round x_a1dY)


["paperX","paperY","my_fromInt","str_aH4","safebang@!str_aH4","(!str_aH4)","str_aH5","safebang@!str_aH5","(!str_aH5)","reqdx_aH6","reqdy_aH7","(reqdx_aH6, reqdy_aH7)","str_aH8","title_aPt","pedata_aPu","safebang@!pedata_aPu","(!pedata_aPu)","topX_aPv","topY_aPw","safebang@!topY_aPw","(!topY_aPw)","(topX_aPv, (!topY_aPw))","xlabel_aPx","safebang@!xlabel_aPx","(!xlabel_aPx)","ylabel_aPy","safebang@!ylabel_aPy","(!ylabel_aPy)","((!xlabel_aPx), (!ylabel_aPy))","!((!xlabel_aPx), (!ylabel_aPy))","(!((!xlabel_aPx), (!ylabel_aPy)))","keys_aPz","pes_aPA","safebang@!pes_aPA","(!pes_aPA)","on_aPB","safebang@!on_aPB","(!on_aPB)","((!pes_aPA), (!on_aPB))","used_aPC","safebang@!used_aPC","(!used_aPC)","x_a1cr","x_a1cs","!x_a1cs","(!x_a1cs)","pts_a1ct","points_a1cu","left_a1cv","keys_a1cw","x_a1cB","safebang@!x_a1cB","(!x_a1cB)","y_a1cC","safebang@!y_a1cC","(!y_a1cC)","Pt (!x_a1cB) (!y_a1cC)","(Pt (!x_a1cB) (!y_a1cC))","pt_a1cA@(Pt (!x_a1cB) (!y_a1cC))","!pt_a1cA@(Pt (!x_a1cB) (!y_a1cC))","(!pt_a1cA@(Pt (!x_a1cB) (!y_a1cC)))","col_a1cD","tex_a1cE","pc_a1cF","(col_a1cD, tex_a1cE, pc_a1cF)","no_a1cy","n_a1cG","safebang@!n_a1cG","(!n_a1cG)","n_a1cH","t_a1cI","f_a1cJ","safebang@!f_a1cJ","(!f_a1cJ)","m_a1cK","safebang@!m_a1cK","(!m_a1cK)","pes_a1cL","(!m_a1cK) : pes_a1cL","((!m_a1cK) : pes_a1cL)","!((!m_a1cK) : pes_a1cL)","(!((!m_a1cK) : pes_a1cL))","((!((!m_a1cK) : pes_a1cL)))","on_a1cM","pe_a1cO","left_a1cP","pes_a1cQ","safebang@!pes_a1cQ","(!pes_a1cQ)","x_a1cW","safebang@!x_a1cW","(!x_a1cW)","y_a1cX","safebang@!y_a1cX","(!y_a1cX)","Pt (!x_a1cW) (!y_a1cX)","(Pt (!x_a1cW) (!y_a1cX))","pt_a1cV@(Pt (!x_a1cW) (!y_a1cX))","font_a1cY","tex_a1cZ","safebang@!tex_a1cZ","(!tex_a1cZ)","(font_a1cY, (!tex_a1cZ))","no_a1cS","x_a1d0","n_a1d1","n_a1d2","pes_a1d3","safebang@!pes_a1d3","(!pes_a1d3)","[]","pes_a1d4","p_a1d5","ps_a1d6","!ps_a1d6","(!ps_a1d6)","p_a1d5 : (!ps_a1d6)","(p_a1d5 : (!ps_a1d6))","!(p_a1d5 : (!ps_a1d6))","(!(p_a1d5 : (!ps_a1d6)))","((!(p_a1d5 : (!ps_a1d6))))","str_a1d8","!str_a1d8","(!str_a1d8)","no_a1d9","PE (!str_a1d8) no_a1d9","(PE (!str_a1d8) no_a1d9)","!(PE (!str_a1d8) no_a1d9)","(!(PE (!str_a1d8) no_a1d9))","((!(PE (!str_a1d8) no_a1d9)))","!((!(PE (!str_a1d8) no_a1d9)))","(!((!(PE (!str_a1d8) no_a1d9))))","x_a1da","safebang@!x_a1da","(!x_a1da)","dimX","dimY","dimX_a1db","safebang@!dimX_a1db","(!dimX_a1db)","maxX_a1dc","0","!0","(!0)","x_a1dg","!x_a1dg","(!x_a1dg)","x_a1dh","x_a1di","n_a1dj","safebang@!n_a1dj","(!n_a1dj)","n_a1dm","m_a1dl","!m_a1dl","(!m_a1dl)","dimY_a1dn","maxY_a1do","0","!0","(!0)","x_a1ds","x_a1dt","x_a1du","!x_a1du","(!x_a1du)","x_a1dv","safebang@!x_a1dv","(!x_a1dv)","n_a1dw","n_a1dz","m_a1dy","x_a1dA","safebang@!x_a1dA","(!x_a1dA)","y_a1dB","safebang@!y_a1dB","(!y_a1dB)","pts_a1dC","min_a1dD","x_a1dE","y_a1dF","safebang@!y_a1dF","(!y_a1dF)","Pt x_a1dE (!y_a1dF)","(Pt x_a1dE (!y_a1dF))","!(Pt x_a1dE (!y_a1dF))","(!(Pt x_a1dE (!y_a1dF)))","(min_a1dD, (!(Pt x_a1dE (!y_a1dF))))","!(min_a1dD, (!(Pt x_a1dE (!y_a1dF))))","(!(min_a1dD, (!(Pt x_a1dE (!y_a1dF)))))","x_a1dG","x_a1dH","m_a1dI","[]","p_a1dJ","safebang@!p_a1dJ","(!p_a1dJ)","ps_a1dK","(!p_a1dJ) : ps_a1dK","((!p_a1dJ) : ps_a1dK)","!((!p_a1dJ) : ps_a1dK)","(!((!p_a1dJ) : ps_a1dK))","p_a1dM","safebang@!p_a1dM","(!p_a1dM)","[]","![]","(![])","minx_a1dN","miny_a1dO","Pt minx_a1dN miny_a1dO","maxx_a1dP","safebang@!maxx_a1dP","(!maxx_a1dP)","maxy_a1dQ","Pt (!maxx_a1dP) maxy_a1dQ","(Pt minx_a1dN miny_a1dO, Pt (!maxx_a1dP) maxy_a1dQ)","x_a1dR","safebang@!x_a1dR","(!x_a1dR)","y_a1dS","safebang@!y_a1dS","(!y_a1dS)","Pt (!x_a1dR) (!y_a1dS)","ps_a1dT","!ps_a1dT","(!ps_a1dT)","Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT)","(Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT))","!(Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT))","(!(Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT)))","((!(Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT))))","!((!(Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT))))","(!((!(Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT)))))","minx'_a1dU","lazydmd@!minx'_a1dU","(!minx'_a1dU)","miny'_a1dV","lazydmd@!miny'_a1dV","(!miny'_a1dV)","maxx'_a1dW","maxy'_a1dX","x_a1dY","\"0\"","r_a1e0","r_a1e1","safebang@!r_a1e1","(!r_a1e1)","\"0\"","!\"0\"","(!\"0\")","(!r_a1e1) : (!\"0\")","((!r_a1e1) : (!\"0\"))","r_a1e2","m_a1e3","r_a1e2 : m_a1e3","(r_a1e2 : m_a1e3)","!(r_a1e2 : m_a1e3)","(!(r_a1e2 : m_a1e3))","((!(r_a1e2 : m_a1e3)))","!((!(r_a1e2 : m_a1e3)))","(!((!(r_a1e2 : m_a1e3))))","_","!_","(!_)"]
module Graph where
import Parse
import StdLib
import PSlib
import GRIP
paperX = 280 :: Int
paperY = 190 :: Int

my_fromInt :: Num a_ax0 => Int -> a_ax0
my_fromInt = fromInteger . toInteger
gspostscript (!str_aH4)
  = initialise stdheader ++ portrait ++ str_aH4 ++ "showpage\n"
postscript (!str_aH5)
  = initialise stdheader ++ landscape ++ str_aH5 ++ "showpage\n"
ePostscript (reqdx_aH6, reqdy_aH7) str_aH8
  = initialise
      (stdheader ++ "%%BoundingBox: 0 0 " ++ show (cms2pts reqdx_aH6) ++
         " "
         ++ show (cms2pts reqdy_aH7)
         ++ "\n"
         ++ "%%EndComments\n")
      ++
      scale (my_fromInt reqdx_aH6 * 10 / my_fromInt paperX)
        (my_fromInt reqdy_aH7 * 10 / my_fromInt paperY)
      ++ str_aH8
      ++ showpage
initGraph title_aPt (!pedata_aPu) (topX_aPv, (!topY_aPw))
  (norecord@((!xlabel_aPx), (!ylabel_aPy))) keys_aPz
  = drawBox (Pt 0 0) paperX paperY ++ drawBox (Pt 1 1) (paperX - 2) 5
      ++ drawBox (Pt 1 (paperY - 7)) (paperX - 2) 6
      ++ setfont "BOLD"
      ++ moveto (Pt (paperX `div` 2) (paperY - 6))
      ++ cjustify (title_aPt)
      ++ setfont "NORM"
      ++ placePEs pedata_aPu
      ++ translate 20 25
      ++ newpath
      ++ moveto (Pt 0 (-5))
      ++ lineto (Pt 0 dimY)
      ++ moveto (Pt (-5) 0)
      ++ lineto (Pt dimX 0)
      ++ stroke
      ++ setfont "SMALL"
      ++ markXAxis dimX topX_aPv
      ++ markYAxis dimY topY_aPw
      ++ moveto (Pt 0 (dimY + 4))
      ++ rjustify ylabel_aPy
      ++ stroke
      ++ moveto (Pt dimX (-8))
      ++ rjustify xlabel_aPx
      ++ stroke
      ++ setfont "NORM"
      ++ dokeys dimX keys_aPz
placePEs ((!pes_aPA), (!on_aPB))
  | checkPEs (tail pes_aPA) on_aPB =
    showActive (length pes_aPA) (length used_aPC) ++
      showUsed pes_aPA used_aPC
      ++ setfont "NORM"
  where (!used_aPC) = if on_aPB == [] then tail pes_aPA else on_aPB

cms2pts :: Int -> Int
cms2pts x_a1cr = round (28.4584 * my_fromInt x_a1cr)

plotCurve :: Int -> [Point] -> Postscript
plotCurve (norecord@x_a1cs) pts_a1ct
  = setgray x_a1cs ++ fillObject pts_a1ct

plot :: [Point] -> Postscript
plot points_a1cu = plotCurve 5 (Pt 0 0 : points_a1cu)
dokeys left_a1cv keys_a1cw
  = concat (map2 format_a1cx (places_a1cz 0) keys_a1cw)
  where format_a1cx (norecord@pt_a1cA@(Pt (!x_a1cB) (!y_a1cC)))
          (col_a1cD, tex_a1cE, pc_a1cF)
          = fillBox pt_a1cA 16 9 col_a1cD ++ stroke ++
              moveto (Pt (x_a1cB + 17) (y_a1cC + 3))
              ++ text tex_a1cE
              ++ stroke
              ++ moveto (Pt (x_a1cB + 8) (y_a1cC + 3))
              ++ inv col_a1cD
              ++ setfont "BOLD"
              ++ cjustify (pc_a1cF)
              ++ stroke
              ++ setfont "NORM"
              ++ setgray 10
        no_a1cy = left_a1cv `div` length keys_a1cw
        places_a1cz (!n_a1cG) | n_a1cG == no_a1cy = []
        places_a1cz n_a1cH
          = (Pt (n_a1cH * no_a1cy) (-17)) : places_a1cz (n_a1cH + 1)
showActive t_a1cI (!f_a1cJ)
  = setfont "LARGE" ++ moveto (Pt 10 16) ++ cjustify (show f_a1cJ) ++
      setfont "SMALL"
      ++ moveto (Pt 10 12)
      ++ cjustify "PE(s)"
      ++ stroke
      ++ setfont "SMALL"
      ++ moveto (Pt 10 8)
      ++ cjustify "displayed"
      ++ stroke
      ++ setfont "NORM"
showUsed ((norecord@((!m_a1cK) : pes_a1cL))) on_a1cM
  = moveto (Pt 2 2) ++ setfont "SMALL" ++ text "Configuration:" ++
      dopes (paperX - 27)
        (("SMALLITALIC", showPE m_a1cK) : map f_a1cN pes_a1cL)
      ++ stroke
  where f_a1cN pe_a1cO
          | elem pe_a1cO on_a1cM = ("SMALLBOLD", showPE pe_a1cO)
          | otherwise = ("SMALL", showPE pe_a1cO)
dopes left_a1cP (!pes_a1cQ)
  = concat (map2 format_a1cR (places_a1cU 0) pes_a1cQ)
  where format_a1cR pt_a1cV@(Pt (!x_a1cW) (!y_a1cX))
          (font_a1cY, (!tex_a1cZ))
          = setfont font_a1cY ++ moveto pt_a1cV ++ text tex_a1cZ ++ stroke
        no_a1cS = left_a1cP `div` ((length pes_a1cQ * 2) + 1)
        f_a1cT x_a1d0 = (no_a1cS * ((x_a1d0 * 2) + 1)) + 27
        places_a1cU n_a1d1 | n_a1d1 > 2 * no_a1cS = []
        places_a1cU n_a1d2
          = (Pt (f_a1cT n_a1d2) 2) : places_a1cU (n_a1d2 + 1)
checkPEs (!pes_a1d3) [] = True
checkPEs pes_a1d4 ((norecord@(p_a1d5 : (norecord@ps_a1d6))))
  | elem p_a1d5 pes_a1d4 = checkPEs pes_a1d4 ps_a1d6
  | otherwise =
    error
      ("Attempt to gather information from inactive PE - " ++
         showPE p_a1d5)

showPE :: PElement -> String
showPE (norecord@((norecord@(PE (norecord@str_a1d8) no_a1d9))))
  = str_a1d8 ++ "." ++ show no_a1d9
inv (!x_a1da)
  | x_a1da >= 5 = setgray 0
  | otherwise = setgray 10
dimX = paperX - 30
dimY = paperY - 40

markXAxis :: Int -> Int -> Postscript
markXAxis (!dimX_a1db) maxX_a1dc = label_a1dd 10 ++ markOnX 100
  where label_a1dd (norecord@0) = ""
        label_a1dd (norecord@x_a1dg)
          = newpath ++ moveto (Pt (notch_a1df x_a1dg) 0) ++ rlineto 0 (-2) ++
              moveto (Pt (notch_a1df x_a1dg) (-5))
              ++ cjustify (printFloat (t_a1de x_a1dg))
              ++ stroke
              ++ label_a1dd (x_a1dg - 1)
        t_a1de x_a1dh
          = my_fromInt x_a1dh * (my_fromInt maxX_a1dc / my_fromInt 10)
        notch_a1df x_a1di = x_a1di * (dimX_a1db `div` 10)
markOnX (!n_a1dj) = mapcat notches_a1dk [1 .. n_a1dj] ++ stroke
  where notches_a1dk n_a1dm
          = movetofloat (m_a1dl * my_fromInt n_a1dm) 0 ++ (rlineto 0 (-1)) ++
              stroke
        (norecord@m_a1dl) = my_fromInt dimX / my_fromInt n_a1dj

markYAxis :: Int -> Int -> Postscript
markYAxis dimY_a1dn maxY_a1do
  = label_a1dp 10 ++ markOnY (calibrate maxY_a1do)
  where label_a1dp (norecord@0) = ""
        label_a1dp x_a1ds
          = newpath ++ moveto (Pt 0 (notch_a1dr x_a1ds)) ++ rlineto (-2) 0 ++
              moveto (Pt (-3) (notch_a1dr x_a1ds))
              ++ rjustify (printFloat (t_a1dq x_a1ds))
              ++ stroke
              ++ label_a1dp (x_a1ds - 1)
        t_a1dq x_a1dt
          = my_fromInt x_a1dt * (my_fromInt maxY_a1do / my_fromInt 10)
        notch_a1dr (norecord@x_a1du) = x_a1du * (dimY_a1dn `div` 10)
calibrate (!x_a1dv)
  | x_a1dv <= 1 = 1
  | x_a1dv <= 100 = x_a1dv
  | otherwise = calibrate (x_a1dv `div` 10)
markOnY n_a1dw = mapcat notches_a1dx [1 .. n_a1dw] ++ stroke
  where notches_a1dx n_a1dz
          = movetofloat 0 (m_a1dy * my_fromInt n_a1dz) ++ (rlineto (-1) 0)
        m_a1dy = my_fromInt dimY / my_fromInt n_a1dw
movetofloat (!x_a1dA) (!y_a1dB)
  = show x_a1dA ++ " " ++ show y_a1dB ++ " moveto\n"

determineScale :: [Point] -> (Int, Int)
determineScale pts_a1dC = (axisScale x_a1dE, axisScale y_a1dF)
  where (norecord@(min_a1dD, (norecord@(Pt x_a1dE (!y_a1dF)))))
          = minandmax pts_a1dC

axisScale :: Int -> Int
axisScale x_a1dG = axisScale' x_a1dG 1
axisScale' x_a1dH m_a1dI
  | x_a1dH <= m_a1dI = m_a1dI
  | x_a1dH <= m_a1dI * 2 = m_a1dI * 2
  | x_a1dH <= m_a1dI * 5 = m_a1dI * 5
  | x_a1dH <= m_a1dI * 10 = m_a1dI * 10
  | otherwise = axisScale' x_a1dH (m_a1dI * 10)

minandmax :: [Point] -> (Point, Point)
minandmax [] = error "No points"
minandmax (norecord@((!p_a1dJ) : ps_a1dK))
  = f_a1dL (p_a1dJ, p_a1dJ) ps_a1dK
  where f_a1dL (!p_a1dM) (norecord@[]) = p_a1dM
        f_a1dL (Pt minx_a1dN miny_a1dO, Pt (!maxx_a1dP) maxy_a1dQ)
          (norecord@((norecord@(Pt (!x_a1dR) (!y_a1dS) :
                                  (norecord@ps_a1dT)))))
          = f_a1dL (Pt minx'_a1dU miny'_a1dV, Pt maxx'_a1dW maxy'_a1dX)
              ps_a1dT
          where (lazydmd@minx'_a1dU) = min x_a1dR minx_a1dN
                (lazydmd@miny'_a1dV) = min y_a1dS miny_a1dO
                maxx'_a1dW = max x_a1dR maxx_a1dP
                maxy'_a1dX = max y_a1dS maxy_a1dQ

printFloat :: Float -> String
printFloat x_a1dY = f_a1dZ (show (round (x_a1dY * 10)))
  where f_a1dZ "0" = "0"
        f_a1dZ r_a1e0 | x_a1dY < 1 = "0." ++ r_a1e0
        f_a1dZ ((!r_a1e1) : (norecord@"0")) | x_a1dY < 10 = [r_a1e1]
        f_a1dZ (norecord@((norecord@(r_a1e2 : m_a1e3))))
          | x_a1dY < 10 = r_a1e2 : '.' : m_a1e3
        f_a1dZ (norecord@_) = show (round x_a1dY)

==================== Renamer ====================
Pool.poolGraph selectpes_aJj statFile_aJk
  = initGraph
      "Spark Pool Profile Graph"
      (pes_aJn, selectpes_aJj)
      (100 * ticks_aJo, height_aJq)
      ("Time (ms)", "Sparks")
      [(5, "Spark Residency", ""), (0, "Sparks Used", "")]
    ++
      scale
        (my_fromInt dimX / my_fromInt 200)
        (my_fromInt dimY / my_fromInt height_aJq)
      ++ plotCurve 0 usedGraph_aJm ++ plotCurve 5 sparkGraph_aJl
  where
      (!(sparkGraph_aJl, (!usedGraph_aJm)))
        = Pool.outlineGraphs (traces_aJs ++ [Pool.T width_aJx [0, 0, 0]])
      (pes_aJn, ticks_aJo, orderedStats_aJp) = getParameters stats_aJr
      height_aJq = axisScale h_aJw
      (!stats_aJr) = parseFile statFile_aJk
      (traces_aJs,
       (!((!((!sparks_aJt), used_aJu, (!resumed_aJv))),
          (!_),
          h_aJw,
          (!width_aJx))))
        = akkumulate
            Pool.processSparks
            Pool.nullstate
            (Pool.gatherSp
               (Sp 0 0 0 0 0) (getSp selectpes_aJj orderedStats_aJp))
Pool.processSparks
  (!(((!c''_aTz), u''_aTA, (!r''_aTB)), l''_aTC, m_aTD, _))
  (Sp (!n_aTE) c_aTF u_aTG (!r_aTH) l_aTI)
  = (Pool.T n_aTE [p'_aTJ, u'_aTK, l'_aTL], 
     ((c''_aTz + c_aTF, u''_aTA + u_aTG, r''_aTB + r_aTH), l'_aTL, 
      max m_aTD p'_aTJ, n_aTE))
  where
      p'_aTJ = l''_aTC + c_aTF
      u'_aTK = p'_aTJ - l_aTI
      (!l'_aTL) = p'_aTJ - u_aTG - l_aTI
Pool.gatherSp t_a17a [] = [t_a17a]
Pool.gatherSp (!t_a17b) l_a17c@((!((!a_a17d) : as_a17e)))
  | numberSp t_a17b == numberSp a_a17d
  = Pool.gatherSp (Pool.addSparks t_a17b a_a17d) as_a17e
  | otherwise
  = t_a17b : Pool.gatherSp (Sp (n_a17f + 1) 0 0 0 0) l_a17c
  where
      n_a17f = numberSp t_a17b
Pool.addSparks
  (Sp _ (!a_a17g) (!b_a17h) (!c_a17i) d_a17j)
  (Sp n_a17k (!a'_a17l) b'_a17m c'_a17n d'_a17o)
  = Sp
      n_a17k
      (a_a17g + a'_a17l)
      (b_a17h + b'_a17m)
      (c_a17i + c'_a17n)
      (d_a17j + d'_a17o)
Pool.nullstate = ((0, 0, 0), 0, 0, 0)
Pool.outlineGraphs :: [Pool.Trace] -> ([Point], [Point])
Pool.outlineGraphs traces_a17p
  = aux_a17q traces_a17p
  where
      aux_a17q [] = ([], [])
      aux_a17q
        (!((!(Pool.T n_a17r
                     (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v)))))
        = (Pt t_a17y p_a17s
           : Pt t_a17y l_a17u : Pt t'_a17z l_a17u : pas_a17w, 
           Pt t_a17y u_a17t : Pt t'_a17z l_a17u : pbs_a17x)
        where
            (!((!pas_a17w), (!pbs_a17x))) = aux_a17q ts_a17v
            t_a17y = n_a17r * 2
            (!t'_a17z) = n_a17r * 2 + 1

data Pool.Trace
  = Pool.T Int [Int]
  deriving (Show)
type Pool.Object = [Point]


["selectpes_aJj","statFile_aJk","sparkGraph_aJl","usedGraph_aJm","safebang@!usedGraph_aJm","(!usedGraph_aJm)","(sparkGraph_aJl, (!usedGraph_aJm))","!(sparkGraph_aJl, (!usedGraph_aJm))","(!(sparkGraph_aJl, (!usedGraph_aJm)))","pes_aJn","ticks_aJo","orderedStats_aJp","(pes_aJn, ticks_aJo, orderedStats_aJp)","height_aJq","stats_aJr","safebang@!stats_aJr","(!stats_aJr)","traces_aJs","sparks_aJt","!sparks_aJt","(!sparks_aJt)","used_aJu","resumed_aJv","!resumed_aJv","(!resumed_aJv)","((!sparks_aJt), used_aJu, (!resumed_aJv))","!((!sparks_aJt), used_aJu, (!resumed_aJv))","(!((!sparks_aJt), used_aJu, (!resumed_aJv)))","_","!_","(!_)","h_aJw","width_aJx","!width_aJx","(!width_aJx)","((!((!sparks_aJt), used_aJu, (!resumed_aJv))), (!_), h_aJw,\n (!width_aJx))","!((!((!sparks_aJt), used_aJu, (!resumed_aJv))), (!_), h_aJw,\n  (!width_aJx))","(!((!((!sparks_aJt), used_aJu, (!resumed_aJv))), (!_), h_aJw,\n   (!width_aJx)))","(traces_aJs,\n (!((!((!sparks_aJt), used_aJu, (!resumed_aJv))), (!_), h_aJw,\n    (!width_aJx))))","c''_aTz","safebang@!c''_aTz","(!c''_aTz)","u''_aTA","r''_aTB","safebang@!r''_aTB","(!r''_aTB)","((!c''_aTz), u''_aTA, (!r''_aTB))","l''_aTC","m_aTD","_","(((!c''_aTz), u''_aTA, (!r''_aTB)), l''_aTC, m_aTD, _)","!(((!c''_aTz), u''_aTA, (!r''_aTB)), l''_aTC, m_aTD, _)","(!(((!c''_aTz), u''_aTA, (!r''_aTB)), l''_aTC, m_aTD, _))","n_aTE","safebang@!n_aTE","(!n_aTE)","c_aTF","u_aTG","r_aTH","safebang@!r_aTH","(!r_aTH)","l_aTI","Sp (!n_aTE) c_aTF u_aTG (!r_aTH) l_aTI","(Sp (!n_aTE) c_aTF u_aTG (!r_aTH) l_aTI)","p'_aTJ","u'_aTK","l'_aTL","!l'_aTL","(!l'_aTL)","t_a17a","[]","t_a17b","!t_a17b","(!t_a17b)","a_a17d","!a_a17d","(!a_a17d)","as_a17e","(!a_a17d) : as_a17e","((!a_a17d) : as_a17e)","!((!a_a17d) : as_a17e)","(!((!a_a17d) : as_a17e))","((!((!a_a17d) : as_a17e)))","l_a17c@((!((!a_a17d) : as_a17e)))","n_a17f","_","a_a17g","!a_a17g","(!a_a17g)","b_a17h","!b_a17h","(!b_a17h)","c_a17i","!c_a17i","(!c_a17i)","d_a17j","Sp _ (!a_a17g) (!b_a17h) (!c_a17i) d_a17j","(Sp _ (!a_a17g) (!b_a17h) (!c_a17i) d_a17j)","n_a17k","a'_a17l","!a'_a17l","(!a'_a17l)","b'_a17m","c'_a17n","d'_a17o","Sp n_a17k (!a'_a17l) b'_a17m c'_a17n d'_a17o","(Sp n_a17k (!a'_a17l) b'_a17m c'_a17n d'_a17o)","nullstate","traces_a17p","[]","n_a17r","p_a17s","safebang@!p_a17s","(!p_a17s)","u_a17t","safebang@!u_a17t","(!u_a17t)","l_a17u","[(!p_a17s), (!u_a17t), l_a17u]","![(!p_a17s), (!u_a17t), l_a17u]","(![(!p_a17s), (!u_a17t), l_a17u])","T n_a17r (![(!p_a17s), (!u_a17t), l_a17u])","ts_a17v","!ts_a17v","(!ts_a17v)","T n_a17r (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v)","(T n_a17r (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v))","!(T n_a17r (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v))","(!(T n_a17r (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v)))","((!(T n_a17r (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v))))","!((!(T n_a17r (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v))))","(!((!(T n_a17r (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v)))))","pas_a17w","safebang@!pas_a17w","(!pas_a17w)","pbs_a17x","safebang@!pbs_a17x","(!pbs_a17x)","((!pas_a17w), (!pbs_a17x))","!((!pas_a17w), (!pbs_a17x))","(!((!pas_a17w), (!pbs_a17x)))","t_a17y","t'_a17z","!t'_a17z","(!t'_a17z)"]
module Pool (poolGraph) where
import StdLib
import GRIP
import PSlib
import Graph
import Parse
poolGraph selectpes_aJj statFile_aJk
  = initGraph "Spark Pool Profile Graph" (pes_aJn, selectpes_aJj)
      (100 * ticks_aJo, height_aJq)
      ("Time (ms)", "Sparks")
      [(5, "Spark Residency", ""), (0, "Sparks Used", "")]
      ++
      scale (my_fromInt dimX / my_fromInt 200)
        (my_fromInt dimY / my_fromInt height_aJq)
      ++ plotCurve 0 usedGraph_aJm
      ++ plotCurve 5 sparkGraph_aJl
  where (norecord@(sparkGraph_aJl, (!usedGraph_aJm)))
          = outlineGraphs (traces_aJs ++ [T width_aJx [0, 0, 0]])
        (pes_aJn, ticks_aJo, orderedStats_aJp) = getParameters stats_aJr
        height_aJq = axisScale h_aJw
        (!stats_aJr) = parseFile statFile_aJk
        (traces_aJs,
         (norecord@((norecord@((norecord@sparks_aJt), used_aJu,
                               (norecord@resumed_aJv))),
                    (norecord@_), h_aJw, (norecord@width_aJx))))
          = akkumulate processSparks nullstate
              (gatherSp (Sp 0 0 0 0 0) (getSp selectpes_aJj orderedStats_aJp))
processSparks
  (norecord@(((!c''_aTz), u''_aTA, (!r''_aTB)), l''_aTC, m_aTD, _))
  (Sp (!n_aTE) c_aTF u_aTG (!r_aTH) l_aTI)
  = (T n_aTE [p'_aTJ, u'_aTK, l'_aTL],
     ((c''_aTz + c_aTF, u''_aTA + u_aTG, r''_aTB + r_aTH), l'_aTL,
      max m_aTD p'_aTJ, n_aTE))
  where p'_aTJ = l''_aTC + c_aTF
        u'_aTK = p'_aTJ - l_aTI
        (norecord@l'_aTL) = p'_aTJ - u_aTG - l_aTI
gatherSp t_a17a [] = [t_a17a]
gatherSp (norecord@t_a17b)
  l_a17c@((norecord@((norecord@a_a17d) : as_a17e)))
  | numberSp t_a17b == numberSp a_a17d =
    gatherSp (addSparks t_a17b a_a17d) as_a17e
  | otherwise = t_a17b : gatherSp (Sp (n_a17f + 1) 0 0 0 0) l_a17c
  where n_a17f = numberSp t_a17b
addSparks
  (Sp _ (norecord@a_a17g) (norecord@b_a17h) (norecord@c_a17i) d_a17j)
  (Sp n_a17k (norecord@a'_a17l) b'_a17m c'_a17n d'_a17o)
  = Sp n_a17k (a_a17g + a'_a17l) (b_a17h + b'_a17m)
      (c_a17i + c'_a17n)
      (d_a17j + d'_a17o)
nullstate = ((0, 0, 0), 0, 0, 0)

outlineGraphs :: [Trace] -> ([Point], [Point])
outlineGraphs traces_a17p = aux_a17q traces_a17p
  where aux_a17q [] = ([], [])
        aux_a17q
          (norecord@((norecord@(T n_a17r
                                  (norecord@[(!p_a17s), (!u_a17t), l_a17u])
                                  : (norecord@ts_a17v)))))
          = (Pt t_a17y p_a17s : Pt t_a17y l_a17u : Pt t'_a17z l_a17u :
               pas_a17w,
             Pt t_a17y u_a17t : Pt t'_a17z l_a17u : pbs_a17x)
          where (norecord@((!pas_a17w), (!pbs_a17x))) = aux_a17q ts_a17v
                t_a17y = n_a17r * 2
                (norecord@t'_a17z) = n_a17r * 2 + 1

data Trace = T Int [Int]
           deriving Show

type Object = [Point]

==================== Renamer ====================
Activity.activityGraph ordering_aOB selectpes_aOC statFile_aOD
  = initGraph
      "Processor Activity Graph"
      (pes_aOH, selectpes_aOC)
      (ticks_aOI * 100, 100)
      ("Time (ms)", "% Activity")
      (map f_aOE ordering_aOB)
    ++
      scale
        (my_fromInt dimX / my_fromInt 100)
        (my_fromInt dimY / my_fromInt (maxticks_aOG))
      ++
        concat
          (map2
             plotCurve
             (map Activity.colour order_aOM)
             (Activity.outlinesTrace traces_aOK))
  where
      f_aOE (!a_aOO)
        = (Activity.colour a_aOO, Activity.display a_aOO, 
           Activity.aggr a_aOO aggs_aOL)
      (!active_aOF)
        = if selectpes_aOC == [] then
              length pes_aOH - 1
          else
              length selectpes_aOC
      maxticks_aOG = active_aOF * ticks_aOI
      (pes_aOH, ticks_aOI, orderedStats_aOJ) = getParameters stats_aON
      (!((!traces_aOK), aggs_aOL))
        = (akkumulate
             (Activity.processAct (map Activity.extractor order_aOM))
             Activity.nullstate
           . Activity.gatherAct (Act 0 0 0 0 0 0)
             . map (scaleAct ticks_aOI) . getAct selectpes_aOC)
            orderedStats_aOJ
      order_aOM = reverse ordering_aOB
      (!stats_aON) = parseFile statFile_aOD
Activity.processAct ::
  [Activities -> Int]
  -> Activity.State -> Activities -> (Activity.Trace, Activity.State)
Activity.processAct
  (!extractors_a18e)
  (!((!i_a18f), r_a18g, (!g_a18h), (!f_a18i), t_a18j))
  a_a18k@(!((!(Act n_a18l
                   (!i'_a18m)
                   r'_a18n
                   g'_a18o
                   f'_a18p
                   t'_a18q))))
  = (trace_a18r, 
     (i'_a18m + i_a18f, r'_a18n + r_a18g, g'_a18o + g_a18h, 
      f'_a18p + f_a18i, t_a18j + t'_a18q))
  where
      (!trace_a18r@(Activity.T _ ((!m_a18s) : _)))
        = Activity.makeTrace extractors_a18e n_a18l a_a18k
Activity.makeTrace fs_a18t n_a18u (!s_a18v)
  = Activity.T n_a18u (f_a18w fs_a18t)
  where
      f_a18w (![]) = []
      f_a18w ex_a18x@(e_a18y : (!es_a18z))
        = sum (Activity.pam ex_a18x s_a18v) : f_a18w es_a18z
Activity.nullstate = (0, 0, 0, 0, 0)
Activity.outlinesTrace :: [Activity.Trace] -> [[Point]]
Activity.outlinesTrace [(!(Activity.T (!n_a18A) (!a_a18B)))]
  = map (\ x_a18C -> [Pt n_a18A x_a18C]) a_a18B
Activity.outlinesTrace ((!(Activity.T n_a18D a_a18E)) : more_a18F)
  = map2
      (:)
      (map (\ x_a18G -> Pt n_a18D x_a18G) a_a18E)
      (Activity.outlinesTrace more_a18F)
Activity.aggr Activity.IDLE (!((!i_a18H), _, _, _, (!t_a18I)))
  = printFloat (Activity.percentage i_a18H t_a18I) ++ "%"
Activity.aggr
  Activity.REDN
  (!((!_), r_a18J, (!_), (!_), (!t_a18K)))
  = printFloat (Activity.percentage r_a18J t_a18K) ++ "%"
Activity.aggr (!Activity.GC) ((!_), _, (!g_a18L), (!_), t_a18M)
  = printFloat (Activity.percentage g_a18L t_a18M) ++ "%"
Activity.aggr (!Activity.FLUSH) (_, (!_), _, f_a18N, (!t_a18O))
  = printFloat (Activity.percentage f_a18N t_a18O) ++ "%"
Activity.percentage x_a18P (!y_a18Q)
  = my_fromInt x_a18P * 100 / my_fromInt y_a18Q
Activity.gatherAct :: Activities -> [Activities] -> [Activities]
Activity.gatherAct (!t_a18R) []
  = [t_a18R, (Act (numberAct t_a18R + 1) 0 0 0 0 0)]
Activity.gatherAct t_a18S l_a18T@((!(a_a18U : (!as_a18V))))
  | numberAct t_a18S == numberAct a_a18U
  = Activity.gatherAct (Activity.addAct t_a18S a_a18U) as_a18V
  | otherwise
  = t_a18S : Activity.gatherAct (Act (n_a18W + 1) 0 0 0 0 0) l_a18T
  where
      n_a18W = numberAct t_a18S
Activity.pam (![]) (!_) = []
Activity.pam ((!f_a18X) : fs_a18Y) a_a18Z
  = f_a18X a_a18Z : Activity.pam fs_a18Y a_a18Z
Activity.extractor (!Activity.REDN) = reduction
Activity.extractor Activity.IDLE = idle
Activity.extractor Activity.GC = gc
Activity.extractor (!Activity.FLUSH) = flush
Activity.colour (!Activity.REDN) = 0
Activity.colour (!Activity.IDLE) = 8
Activity.colour Activity.FLUSH = 5
Activity.colour Activity.GC = 2
Activity.display (!Activity.REDN) = "Reduction"
Activity.display (!Activity.GC) = "Garbage Collection"
Activity.display Activity.FLUSH = "Flush Read/Write"
Activity.display Activity.IDLE = "Idle"
Activity.addAct
  (Act _ a_a190 (!b_a191) (!c_a192) (!d_a193) (!t1_a194))
  (!((!(Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a))))
  = Act
      n_a195
      (a_a190 + e_a196)
      (b_a191 + f_a197)
      (c_a192 + g_a198)
      (d_a193 + h_a199)
      (t1_a194 + t2_a19a)

type Activity.State = (Int, Int, Int, Int, Int)
data Activity.Trace = Activity.T Int [Int]
data Activity.Activity
  = Activity.REDN | Activity.IDLE | Activity.FLUSH | Activity.GC
  deriving (Eq)

instance Parse Activity.Activity where
  parseType ('R' : (!string_a19b)) = (Activity.REDN, string_a19b)
  parseType ((!('G' : (!string_a19c)))) = (Activity.GC, string_a19c)
  parseType (!((!((!'F') : (!string_a19d)))))
    = (Activity.FLUSH, string_a19d)
  parseType ((!'I') : string_a19e) = (Activity.IDLE, string_a19e)
  parseType (string_a19f)
    = error ("No such Activity : " ++ show string_a19f ++ "\n")


["ordering_aOB","selectpes_aOC","statFile_aOD","a_aOO","!a_aOO","(!a_aOO)","active_aOF","!active_aOF","(!active_aOF)","maxticks_aOG","pes_aOH","ticks_aOI","orderedStats_aOJ","(pes_aOH, ticks_aOI, orderedStats_aOJ)","traces_aOK","!traces_aOK","(!traces_aOK)","aggs_aOL","((!traces_aOK), aggs_aOL)","!((!traces_aOK), aggs_aOL)","(!((!traces_aOK), aggs_aOL))","order_aOM","stats_aON","safebang@!stats_aON","(!stats_aON)","extractors_a18e","!extractors_a18e","(!extractors_a18e)","i_a18f","safebang@!i_a18f","(!i_a18f)","r_a18g","g_a18h","safebang@!g_a18h","(!g_a18h)","f_a18i","safebang@!f_a18i","(!f_a18i)","t_a18j","((!i_a18f), r_a18g, (!g_a18h), (!f_a18i), t_a18j)","!((!i_a18f), r_a18g, (!g_a18h), (!f_a18i), t_a18j)","(!((!i_a18f), r_a18g, (!g_a18h), (!f_a18i), t_a18j))","n_a18l","i'_a18m","!i'_a18m","(!i'_a18m)","r'_a18n","g'_a18o","f'_a18p","t'_a18q","Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p t'_a18q","(Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p t'_a18q)","!(Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p t'_a18q)","(!(Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p t'_a18q))","((!(Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p t'_a18q)))","!((!(Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p t'_a18q)))","(!((!(Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p t'_a18q))))","a_a18k@(!((!(Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p\n               t'_a18q))))","_","m_a18s","safebang@!m_a18s","(!m_a18s)","_","(!m_a18s) : _","((!m_a18s) : _)","T _ ((!m_a18s) : _)","(T _ ((!m_a18s) : _))","trace_a18r@(T _ ((!m_a18s) : _))","!trace_a18r@(T _ ((!m_a18s) : _))","(!trace_a18r@(T _ ((!m_a18s) : _)))","fs_a18t","n_a18u","s_a18v","!s_a18v","(!s_a18v)","[]","![]","(![])","e_a18y","es_a18z","safebang@!es_a18z","(!es_a18z)","e_a18y : (!es_a18z)","(e_a18y : (!es_a18z))","ex_a18x@(e_a18y : (!es_a18z))","nullstate","n_a18A","safebang@!n_a18A","(!n_a18A)","a_a18B","safebang@!a_a18B","(!a_a18B)","T (!n_a18A) (!a_a18B)","(T (!n_a18A) (!a_a18B))","!(T (!n_a18A) (!a_a18B))","(!(T (!n_a18A) (!a_a18B)))","[(!(T (!n_a18A) (!a_a18B)))]","x_a18C","n_a18D","a_a18E","T n_a18D a_a18E","(T n_a18D a_a18E)","!(T n_a18D a_a18E)","(!(T n_a18D a_a18E))","more_a18F","(!(T n_a18D a_a18E)) : more_a18F","((!(T n_a18D a_a18E)) : more_a18F)","x_a18G","IDLE","i_a18H","safebang@!i_a18H","(!i_a18H)","_","_","_","t_a18I","safebang@!t_a18I","(!t_a18I)","((!i_a18H), _, _, _, (!t_a18I))","!((!i_a18H), _, _, _, (!t_a18I))","(!((!i_a18H), _, _, _, (!t_a18I)))","REDN","_","!_","(!_)","r_a18J","_","!_","(!_)","_","!_","(!_)","t_a18K","safebang@!t_a18K","(!t_a18K)","((!_), r_a18J, (!_), (!_), (!t_a18K))","!((!_), r_a18J, (!_), (!_), (!t_a18K))","(!((!_), r_a18J, (!_), (!_), (!t_a18K)))","GC","!GC","(!GC)","_","!_","(!_)","_","g_a18L","safebang@!g_a18L","(!g_a18L)","_","!_","(!_)","t_a18M","((!_), _, (!g_a18L), (!_), t_a18M)","FLUSH","!FLUSH","(!FLUSH)","_","_","!_","(!_)","_","f_a18N","t_a18O","safebang@!t_a18O","(!t_a18O)","(_, (!_), _, f_a18N, (!t_a18O))","x_a18P","y_a18Q","!y_a18Q","(!y_a18Q)","t_a18R","safebang@!t_a18R","(!t_a18R)","[]","t_a18S","a_a18U","as_a18V","!as_a18V","(!as_a18V)","a_a18U : (!as_a18V)","(a_a18U : (!as_a18V))","!(a_a18U : (!as_a18V))","(!(a_a18U : (!as_a18V)))","((!(a_a18U : (!as_a18V))))","l_a18T@((!(a_a18U : (!as_a18V))))","n_a18W","[]","![]","(![])","_","!_","(!_)","f_a18X","safebang@!f_a18X","(!f_a18X)","fs_a18Y","(!f_a18X) : fs_a18Y","((!f_a18X) : fs_a18Y)","a_a18Z","REDN","!REDN","(!REDN)","IDLE","GC","FLUSH","!FLUSH","(!FLUSH)","REDN","!REDN","(!REDN)","IDLE","!IDLE","(!IDLE)","FLUSH","GC","REDN","!REDN","(!REDN)","GC","!GC","(!GC)","FLUSH","IDLE","_","a_a190","b_a191","!b_a191","(!b_a191)","c_a192","!c_a192","(!c_a192)","d_a193","!d_a193","(!d_a193)","t1_a194","!t1_a194","(!t1_a194)","Act _ a_a190 (!b_a191) (!c_a192) (!d_a193) (!t1_a194)","(Act _ a_a190 (!b_a191) (!c_a192) (!d_a193) (!t1_a194))","n_a195","e_a196","!e_a196","(!e_a196)","f_a197","!f_a197","(!f_a197)","g_a198","h_a199","!h_a199","(!h_a199)","t2_a19a","Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a","(Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a)","!(Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a)","(!(Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a))","((!(Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a)))","!((!(Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a)))","(!((!(Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a))))","'R'","string_a19b","lazydmd@!string_a19b","(!string_a19b)","'R' : (!string_a19b)","('R' : (!string_a19b))","'G'","string_a19c","!string_a19c","(!string_a19c)","'G' : (!string_a19c)","('G' : (!string_a19c))","!('G' : (!string_a19c))","(!('G' : (!string_a19c)))","((!('G' : (!string_a19c))))","'F'","!'F'","(!'F')","string_a19d","lazydmd@!string_a19d","(!string_a19d)","(!'F') : (!string_a19d)","((!'F') : (!string_a19d))","!((!'F') : (!string_a19d))","(!((!'F') : (!string_a19d)))","((!((!'F') : (!string_a19d))))","!((!((!'F') : (!string_a19d))))","(!((!((!'F') : (!string_a19d)))))","'I'","!'I'","(!'I')","string_a19e","(!'I') : string_a19e","((!'I') : string_a19e)","string_a19f","(string_a19f)"]
module Activity (activityGraph, Activity(..)) where
import GRIP
import StdLib
import PSlib
import Graph
import Parse
activityGraph ordering_aOB selectpes_aOC statFile_aOD
  = initGraph "Processor Activity Graph" (pes_aOH, selectpes_aOC)
      (ticks_aOI * 100, 100)
      ("Time (ms)", "% Activity")
      (map f_aOE ordering_aOB)
      ++
      scale (my_fromInt dimX / my_fromInt 100)
        (my_fromInt dimY / my_fromInt (maxticks_aOG))
      ++
      concat
        (map2 plotCurve (map colour order_aOM) (outlinesTrace traces_aOK))
  where f_aOE (norecord@a_aOO)
          = (colour a_aOO, display a_aOO, aggr a_aOO aggs_aOL)
        (norecord@active_aOF)
          = if selectpes_aOC == [] then length pes_aOH - 1 else
              length selectpes_aOC
        maxticks_aOG = active_aOF * ticks_aOI
        (pes_aOH, ticks_aOI, orderedStats_aOJ) = getParameters stats_aON
        (norecord@((norecord@traces_aOK), aggs_aOL))
          = (akkumulate (processAct (map extractor order_aOM)) nullstate .
               gatherAct (Act 0 0 0 0 0 0)
               . map (scaleAct ticks_aOI)
               . getAct selectpes_aOC)
              orderedStats_aOJ
        order_aOM = reverse ordering_aOB
        (!stats_aON) = parseFile statFile_aOD

processAct ::
           [Activities -> Int] -> State -> Activities -> (Trace, State)
processAct (norecord@extractors_a18e)
  (norecord@((!i_a18f), r_a18g, (!g_a18h), (!f_a18i), t_a18j))
  a_a18k@(norecord@((norecord@(Act n_a18l (norecord@i'_a18m) r'_a18n
                                 g'_a18o f'_a18p t'_a18q))))
  = (trace_a18r,
     (i'_a18m + i_a18f, r'_a18n + r_a18g, g'_a18o + g_a18h,
      f'_a18p + f_a18i, t_a18j + t'_a18q))
  where (norecord@trace_a18r@(T _ ((!m_a18s) : _)))
          = makeTrace extractors_a18e n_a18l a_a18k
makeTrace fs_a18t n_a18u (norecord@s_a18v)
  = T n_a18u (f_a18w fs_a18t)
  where f_a18w (norecord@[]) = []
        f_a18w ex_a18x@(e_a18y : (!es_a18z))
          = sum (pam ex_a18x s_a18v) : f_a18w es_a18z
nullstate = (0, 0, 0, 0, 0)

outlinesTrace :: [Trace] -> [[Point]]
outlinesTrace [(norecord@(T (!n_a18A) (!a_a18B)))]
  = map (\ x_a18C -> [Pt n_a18A x_a18C]) a_a18B
outlinesTrace ((norecord@(T n_a18D a_a18E)) : more_a18F)
  = map2 (:) (map (\ x_a18G -> Pt n_a18D x_a18G) a_a18E)
      (outlinesTrace more_a18F)
aggr IDLE (norecord@((!i_a18H), _, _, _, (!t_a18I)))
  = printFloat (percentage i_a18H t_a18I) ++ "%"
aggr REDN
  (norecord@((norecord@_), r_a18J, (norecord@_), (norecord@_),
             (!t_a18K)))
  = printFloat (percentage r_a18J t_a18K) ++ "%"
aggr (norecord@GC)
  ((norecord@_), _, (!g_a18L), (norecord@_), t_a18M)
  = printFloat (percentage g_a18L t_a18M) ++ "%"
aggr (norecord@FLUSH) (_, (norecord@_), _, f_a18N, (!t_a18O))
  = printFloat (percentage f_a18N t_a18O) ++ "%"
percentage x_a18P (norecord@y_a18Q)
  = my_fromInt x_a18P * 100 / my_fromInt y_a18Q

gatherAct :: Activities -> [Activities] -> [Activities]
gatherAct (!t_a18R) []
  = [t_a18R, (Act (numberAct t_a18R + 1) 0 0 0 0 0)]
gatherAct t_a18S l_a18T@((norecord@(a_a18U : (norecord@as_a18V))))
  | numberAct t_a18S == numberAct a_a18U =
    gatherAct (addAct t_a18S a_a18U) as_a18V
  | otherwise =
    t_a18S : gatherAct (Act (n_a18W + 1) 0 0 0 0 0) l_a18T
  where n_a18W = numberAct t_a18S
pam (norecord@[]) (norecord@_) = []
pam ((!f_a18X) : fs_a18Y) a_a18Z
  = f_a18X a_a18Z : pam fs_a18Y a_a18Z
extractor (norecord@REDN) = reduction
extractor IDLE = idle
extractor GC = gc
extractor (norecord@FLUSH) = flush
colour (norecord@REDN) = 0
colour (norecord@IDLE) = 8
colour FLUSH = 5
colour GC = 2
display (norecord@REDN) = "Reduction"
display (norecord@GC) = "Garbage Collection"
display FLUSH = "Flush Read/Write"
display IDLE = "Idle"
addAct
  (Act _ a_a190 (norecord@b_a191) (norecord@c_a192) (norecord@d_a193)
     (norecord@t1_a194))
  (norecord@((norecord@(Act n_a195 (norecord@e_a196)
                          (norecord@f_a197) g_a198 (norecord@h_a199) t2_a19a))))
  = Act n_a195 (a_a190 + e_a196) (b_a191 + f_a197) (c_a192 + g_a198)
      (d_a193 + h_a199)
      (t1_a194 + t2_a19a)

type State = (Int, Int, Int, Int, Int)

data Trace = T Int [Int]

data Activity = REDN
              | IDLE
              | FLUSH
              | GC
              deriving Eq

instance Parse Activity where
        parseType ('R' : (lazydmd@string_a19b)) = (REDN, string_a19b)
        parseType ((norecord@('G' : (norecord@string_a19c))))
          = (GC, string_a19c)
        parseType
          (norecord@((norecord@((norecord@'F') : (lazydmd@string_a19d)))))
          = (FLUSH, string_a19d)
        parseType ((norecord@'I') : string_a19e) = (IDLE, string_a19e)
        parseType (string_a19f)
          = error ("No such Activity : " ++ show string_a19f ++ "\n")

==================== Renamer ====================
Parse.seperatedBy :: Char -> String -> [String]
Parse.seperatedBy ch_aBK [] = []
Parse.seperatedBy (!ch_aBL) (!xs_aBM)
  = twaddle_aBN ch_aBL (span' (\ x_aBR -> x_aBR /= ch_aBL) xs_aBM)
  where
      twaddle_aBN ch_aBO ((!l_aBP), _ : r_aBQ)
        = l_aBP : Parse.seperatedBy ch_aBO r_aBQ
Parse.whiteSpace :: String -> String
Parse.whiteSpace = dropWhile isSpace

class Parse.Parse a_avq where
  Parse.parseFile :: String -> [a_avq]
  Parse.parseLine :: String -> a_avq
  Parse.parse :: String -> (a_avq, String)
  Parse.parseType :: String -> (a_avq, String)
  Parse.forced :: a_avq -> Bool
  Parse.parseFile string_avy
    | all Parse.forced x_avz = x_avz
    where
        x_avz = map Parse.parseLine (lines' string_avy)
  Parse.parseLine
    = pl_aBH . Parse.parse
    where
        pl_aBH ((!a_aBI), (!_)) = a_aBI
  Parse.parse = Parse.parseType . Parse.whiteSpace
  Parse.forced x_aBJ = True

instance (Parse.Parse a_aT5) => Parse.Parse [a_aT5] where
  Parse.parseType (!more_aT6)
    = (map Parse.parseLine (Parse.seperatedBy ',' (l_aT7 ++ ",")), 
       out_aT8)
    where
        (!((!l_aT7), ']' : (!out_aT8)))
          = span' (\ x_aT9 -> x_aT9 /= ']') (tail more_aT6)
  Parse.forced = all Parse.forced
instance Parse.Parse Char where
  Parse.parseType (!((!(ch_aTa : (!str_aTb))))) = (ch_aTa, str_aTb)
  Parse.forced n_aTc = True
instance Parse.Parse Int where
  Parse.parseType str_aTd
    = pl_aTe (span' isDigit str_aTd)
    where
        pl_aTe (l_aTf, (!r_aTg)) = (strToInt l_aTf, r_aTg)
  Parse.forced (!n_aTh) | n_aTh >= 0 = True


["ch_aBK","[]","ch_aBL","!ch_aBL","(!ch_aBL)","xs_aBM","!xs_aBM","(!xs_aBM)","x_aBR","ch_aBO","l_aBP","!l_aBP","(!l_aBP)","_","r_aBQ","_ : r_aBQ","((!l_aBP), _ : r_aBQ)","whiteSpace","string_avy","x_avz","parseLine","a_aBI","safebang@!a_aBI","(!a_aBI)","_","!_","(!_)","((!a_aBI), (!_))","parse","x_aBJ","more_aT6","safebang@!more_aT6","(!more_aT6)","l_aT7","!l_aT7","(!l_aT7)","']'","out_aT8","safebang@!out_aT8","(!out_aT8)","']' : (!out_aT8)","((!l_aT7), ']' : (!out_aT8))","!((!l_aT7), ']' : (!out_aT8))","(!((!l_aT7), ']' : (!out_aT8)))","x_aT9","forced","ch_aTa","str_aTb","safebang@!str_aTb","(!str_aTb)","ch_aTa : (!str_aTb)","(ch_aTa : (!str_aTb))","!(ch_aTa : (!str_aTb))","(!(ch_aTa : (!str_aTb)))","((!(ch_aTa : (!str_aTb))))","!((!(ch_aTa : (!str_aTb))))","(!((!(ch_aTa : (!str_aTb)))))","n_aTc","str_aTd","l_aTf","r_aTg","!r_aTg","(!r_aTg)","(l_aTf, (!r_aTg))","n_aTh","safebang@!n_aTh","(!n_aTh)"]
module Parse (Parse(..), whiteSpace, seperatedBy) where
import Data.Char
import StdLib

seperatedBy :: Char -> String -> [String]
seperatedBy ch_aBK [] = []
seperatedBy (norecord@ch_aBL) (norecord@xs_aBM)
  = twaddle_aBN ch_aBL (span' (\ x_aBR -> x_aBR /= ch_aBL) xs_aBM)
  where twaddle_aBN ch_aBO ((norecord@l_aBP), _ : r_aBQ)
          = l_aBP : seperatedBy ch_aBO r_aBQ

whiteSpace :: String -> String
whiteSpace = dropWhile isSpace

class Parse a_avq where
        parseFile :: String -> [a_avq]
        
        parseLine :: String -> a_avq
        
        parse :: String -> (a_avq, String)
        
        parseType :: String -> (a_avq, String)
        
        forced :: a_avq -> Bool
        parseFile string_avy | all forced x_avz = x_avz
          where x_avz = map parseLine (lines' string_avy)
        parseLine = pl_aBH . parse
          where pl_aBH ((!a_aBI), (norecord@_)) = a_aBI
        parse = parseType . whiteSpace
        forced x_aBJ = True

instance (Parse a_aT5) => Parse [a_aT5] where
        parseType (!more_aT6)
          = (map parseLine (seperatedBy ',' (l_aT7 ++ ",")), out_aT8)
          where (norecord@((norecord@l_aT7), ']' : (!out_aT8)))
                  = span' (\ x_aT9 -> x_aT9 /= ']') (tail more_aT6)
        forced = all forced

instance Parse Char where
        parseType (norecord@((norecord@(ch_aTa : (!str_aTb)))))
          = (ch_aTa, str_aTb)
        forced n_aTc = True

instance Parse Int where
        parseType str_aTd = pl_aTe (span' isDigit str_aTd)
          where pl_aTe (l_aTf, (norecord@r_aTg)) = (strToInt l_aTf, r_aTg)
        forced (!n_aTh) | n_aTh >= 0 = True

==================== Renamer ====================
StdLib.pair :: a_aAS -> b_aAT -> (a_aAS, b_aAT)
StdLib.pair a_aAU b_aAV = (a_aAU, b_aAV)
StdLib.fstcons :: a_aAQ -> ([a_aAQ], b_aAR) -> ([a_aAQ], b_aAR)
StdLib.fstcons a_aAW ((!as_aAX), (!b_aAY))
  = (a_aAW : as_aAX, b_aAY)
StdLib.sndcons :: b_aAO -> (a_aAP, [b_aAO]) -> (a_aAP, [b_aAO])
StdLib.sndcons b_aAZ (a_aB0, bs_aB1) = (a_aB0, b_aAZ : bs_aB1)
StdLib.map2 (!f_aB2) [] (!_) = []
StdLib.map2 f_aB3 (!_) (![]) = []
StdLib.map2
  (!f_aB4)
  ((!(a_aB5 : (!l_aB6))))
  ((!((!b_aB7) : k_aB8)))
  = f_aB4 a_aB5 b_aB7 : StdLib.map2 f_aB4 l_aB6 k_aB8
StdLib.mapcat :: (a_aAM -> [b_aAN]) -> [a_aAM] -> [b_aAN]
StdLib.mapcat f_aB9 [] = []
StdLib.mapcat f_aBa ((!a_aBb) : (!l_aBc))
  = f_aBa a_aBb ++ StdLib.mapcat f_aBa l_aBc
StdLib.sort :: Ord a_aAL => [a_aAL] -> [a_aAL]
StdLib.sort (![]) = []
StdLib.sort (a_aBd : l_aBe)
  = (StdLib.sort low_aBf) ++ [a_aBd] ++ (StdLib.sort high_aBg)
  where
      (low_aBf, (!high_aBg)) = StdLib.group a_aBd l_aBe
StdLib.group :: Ord a_aAK => a_aAK -> [a_aAK] -> ([a_aAK], [a_aAK])
StdLib.group _ (![]) = ([], [])
StdLib.group (!i_aBh) (a_aBi : (!l_aBj))
  = f_aBk (StdLib.group i_aBh l_aBj)
  where
      f_aBk (!(low_aBl, high_aBm))
        | a_aBi < i_aBh = (a_aBi : low_aBl, high_aBm)
        | otherwise = (low_aBl, a_aBi : high_aBm)
StdLib.insert :: Ord a_aAJ => a_aAJ -> [a_aAJ] -> [a_aAJ]
StdLib.insert (!a_aBn) (![]) = [a_aBn]
StdLib.insert a_aBo as_aBp@(!(x_aBq : xs_aBr))
  | x_aBq > a_aBo = a_aBo : as_aBp
  | otherwise = x_aBq : StdLib.insert a_aBo xs_aBr
StdLib.replace :: Eq a_aAI => a_aAI -> [a_aAI] -> [a_aAI]
StdLib.replace a_aBs [] = []
StdLib.replace a_aBt (x_aBu : (!xs_aBv))
  | a_aBt == x_aBu = a_aBt : xs_aBv
  | otherwise = x_aBu : StdLib.replace a_aBt xs_aBv
StdLib.remove :: Eq a_aAH => a_aAH -> [a_aAH] -> [a_aAH]
StdLib.remove a_aBw (![]) = []
StdLib.remove (!a_aBx) (!(x_aBy : (!xs_aBz)))
  | a_aBx == x_aBy = xs_aBz
  | otherwise = x_aBy : StdLib.remove a_aBx xs_aBz
StdLib.collect ::
  Ord a_ane => (b_and -> a_ane) -> [a_ane] -> [b_and] -> [b_and]
StdLib.collect (!_) (![]) (!_) = []
StdLib.collect (!_) (!_) [] = []
StdLib.collect
  (!p_aBA)
  as_aBB@(!((!a_aBC) : l_aBD))
  bs_aBE@(!((!b_aBF) : k_aBG))
  | a_aBC == p_aBA b_aBF = b_aBF : StdLib.collect p_aBA l_aBD k_aBG
  | p_aBA b_aBF > a_aBC = StdLib.collect p_aBA l_aBD bs_aBE
  | otherwise = StdLib.collect p_aBA as_aBB k_aBG
StdLib.span' :: (a_anc -> Bool) -> [a_anc] -> ([a_anc], [a_anc])
StdLib.span' p_aBH (![]) = ([], [])
StdLib.span' (!p_aBI) (!(x_aBJ : xs'_aBK))
  | p_aBI x_aBJ = fixLeak_aBL x_aBJ (StdLib.span' p_aBI xs'_aBK)
  where
      fixLeak_aBL (!x_aBM) (xs_aBN, ys_aBO) = (x_aBM : xs_aBN, ys_aBO)
StdLib.span' (!_) (!xs_aBP) = ([], xs_aBP)
StdLib.lines' :: [Char] -> [[Char]]
StdLib.lines' (!"") = []
StdLib.lines' s_aBQ
  = plumb_aBR (StdLib.span' ((/=) '\n') s_aBQ)
  where
      plumb_aBR (l_aBS, s'_aBT)
        = l_aBS : if null s'_aBT then [] else StdLib.lines' (tail s'_aBT)
StdLib.strToInt :: String -> Int
StdLib.strToInt (!x_aLr)
  = strToInt'_aLs (length x_aLr - 1) x_aLr
  where
      strToInt'_aLs _ [] = 0
      strToInt'_aLs (!x_aLt) ((!a_aLu) : (!l_aLv))
        = (StdLib.charToInt a_aLu) * (10 ^ x_aLt)
          + (strToInt'_aLs (x_aLt - 1) l_aLv)
StdLib.charToInt :: Char -> Int
StdLib.charToInt x_aVA = (fromEnum x_aVA - fromEnum '0')


["a_aAU","b_aAV","a_aAW","as_aAX","safebang@!as_aAX","(!as_aAX)","b_aAY","safebang@!b_aAY","(!b_aAY)","((!as_aAX), (!b_aAY))","b_aAZ","a_aB0","bs_aB1","(a_aB0, bs_aB1)","f_aB2","safebang@!f_aB2","(!f_aB2)","[]","_","!_","(!_)","f_aB3","_","!_","(!_)","[]","![]","(![])","f_aB4","!f_aB4","(!f_aB4)","a_aB5","l_aB6","!l_aB6","(!l_aB6)","a_aB5 : (!l_aB6)","(a_aB5 : (!l_aB6))","!(a_aB5 : (!l_aB6))","(!(a_aB5 : (!l_aB6)))","((!(a_aB5 : (!l_aB6))))","b_aB7","!b_aB7","(!b_aB7)","k_aB8","(!b_aB7) : k_aB8","((!b_aB7) : k_aB8)","!((!b_aB7) : k_aB8)","(!((!b_aB7) : k_aB8))","((!((!b_aB7) : k_aB8)))","f_aB9","[]","f_aBa","a_aBb","safebang@!a_aBb","(!a_aBb)","l_aBc","safebang@!l_aBc","(!l_aBc)","(!a_aBb) : (!l_aBc)","((!a_aBb) : (!l_aBc))","[]","![]","(![])","a_aBd","l_aBe","a_aBd : l_aBe","(a_aBd : l_aBe)","low_aBf","high_aBg","!high_aBg","(!high_aBg)","(low_aBf, (!high_aBg))","_","[]","![]","(![])","i_aBh","!i_aBh","(!i_aBh)","a_aBi","l_aBj","!l_aBj","(!l_aBj)","a_aBi : (!l_aBj)","(a_aBi : (!l_aBj))","low_aBl","high_aBm","(low_aBl, high_aBm)","!(low_aBl, high_aBm)","(!(low_aBl, high_aBm))","a_aBn","safebang@!a_aBn","(!a_aBn)","[]","![]","(![])","a_aBo","x_aBq","xs_aBr","x_aBq : xs_aBr","(x_aBq : xs_aBr)","!(x_aBq : xs_aBr)","(!(x_aBq : xs_aBr))","as_aBp@(!(x_aBq : xs_aBr))","a_aBs","[]","a_aBt","x_aBu","xs_aBv","safebang@!xs_aBv","(!xs_aBv)","x_aBu : (!xs_aBv)","(x_aBu : (!xs_aBv))","a_aBw","[]","![]","(![])","a_aBx","!a_aBx","(!a_aBx)","x_aBy","xs_aBz","!xs_aBz","(!xs_aBz)","x_aBy : (!xs_aBz)","(x_aBy : (!xs_aBz))","!(x_aBy : (!xs_aBz))","(!(x_aBy : (!xs_aBz)))","_","!_","(!_)","[]","![]","(![])","_","!_","(!_)","_","!_","(!_)","_","!_","(!_)","[]","p_aBA","!p_aBA","(!p_aBA)","a_aBC","!a_aBC","(!a_aBC)","l_aBD","(!a_aBC) : l_aBD","((!a_aBC) : l_aBD)","!((!a_aBC) : l_aBD)","(!((!a_aBC) : l_aBD))","as_aBB@(!((!a_aBC) : l_aBD))","b_aBF","!b_aBF","(!b_aBF)","k_aBG","(!b_aBF) : k_aBG","((!b_aBF) : k_aBG)","!((!b_aBF) : k_aBG)","(!((!b_aBF) : k_aBG))","bs_aBE@(!((!b_aBF) : k_aBG))","p_aBH","[]","![]","(![])","p_aBI","!p_aBI","(!p_aBI)","x_aBJ","xs'_aBK","x_aBJ : xs'_aBK","(x_aBJ : xs'_aBK)","!(x_aBJ : xs'_aBK)","(!(x_aBJ : xs'_aBK))","x_aBM","!x_aBM","(!x_aBM)","xs_aBN","ys_aBO","(xs_aBN, ys_aBO)","_","!_","(!_)","xs_aBP","!xs_aBP","(!xs_aBP)","\"\"","!\"\"","(!\"\")","s_aBQ","l_aBS","s'_aBT","(l_aBS, s'_aBT)","x_aLr","safebang@!x_aLr","(!x_aLr)","_","[]","x_aLt","!x_aLt","(!x_aLt)","a_aLu","!a_aLu","(!a_aLu)","l_aLv","!l_aLv","(!l_aLv)","(!a_aLu) : (!l_aLv)","((!a_aLu) : (!l_aLv))","x_aVA"]
module StdLib where

pair :: a_aAS -> b_aAT -> (a_aAS, b_aAT)
pair a_aAU b_aAV = (a_aAU, b_aAV)

fstcons :: a_aAQ -> ([a_aAQ], b_aAR) -> ([a_aAQ], b_aAR)
fstcons a_aAW ((!as_aAX), (!b_aAY)) = (a_aAW : as_aAX, b_aAY)

sndcons :: b_aAO -> (a_aAP, [b_aAO]) -> (a_aAP, [b_aAO])
sndcons b_aAZ (a_aB0, bs_aB1) = (a_aB0, b_aAZ : bs_aB1)
map2 (!f_aB2) [] (norecord@_) = []
map2 f_aB3 (norecord@_) (norecord@[]) = []
map2 (norecord@f_aB4) ((norecord@(a_aB5 : (norecord@l_aB6))))
  ((norecord@((norecord@b_aB7) : k_aB8)))
  = f_aB4 a_aB5 b_aB7 : map2 f_aB4 l_aB6 k_aB8

mapcat :: (a_aAM -> [b_aAN]) -> [a_aAM] -> [b_aAN]
mapcat f_aB9 [] = []
mapcat f_aBa ((!a_aBb) : (!l_aBc))
  = f_aBa a_aBb ++ mapcat f_aBa l_aBc

sort :: Ord a_aAL => [a_aAL] -> [a_aAL]
sort (norecord@[]) = []
sort (a_aBd : l_aBe) = (sort low_aBf) ++ [a_aBd] ++ (sort high_aBg)
  where (low_aBf, (norecord@high_aBg)) = group a_aBd l_aBe

group :: Ord a_aAK => a_aAK -> [a_aAK] -> ([a_aAK], [a_aAK])
group _ (norecord@[]) = ([], [])
group (norecord@i_aBh) (a_aBi : (norecord@l_aBj))
  = f_aBk (group i_aBh l_aBj)
  where f_aBk (norecord@(low_aBl, high_aBm))
          | a_aBi < i_aBh = (a_aBi : low_aBl, high_aBm)
          | otherwise = (low_aBl, a_aBi : high_aBm)

insert :: Ord a_aAJ => a_aAJ -> [a_aAJ] -> [a_aAJ]
insert (!a_aBn) (norecord@[]) = [a_aBn]
insert a_aBo as_aBp@(norecord@(x_aBq : xs_aBr))
  | x_aBq > a_aBo = a_aBo : as_aBp
  | otherwise = x_aBq : insert a_aBo xs_aBr

replace :: Eq a_aAI => a_aAI -> [a_aAI] -> [a_aAI]
replace a_aBs [] = []
replace a_aBt (x_aBu : (!xs_aBv))
  | a_aBt == x_aBu = a_aBt : xs_aBv
  | otherwise = x_aBu : replace a_aBt xs_aBv

remove :: Eq a_aAH => a_aAH -> [a_aAH] -> [a_aAH]
remove a_aBw (norecord@[]) = []
remove (norecord@a_aBx) (norecord@(x_aBy : (norecord@xs_aBz)))
  | a_aBx == x_aBy = xs_aBz
  | otherwise = x_aBy : remove a_aBx xs_aBz

collect ::
          Ord a_ane => (b_and -> a_ane) -> [a_ane] -> [b_and] -> [b_and]
collect (norecord@_) (norecord@[]) (norecord@_) = []
collect (norecord@_) (norecord@_) [] = []
collect (norecord@p_aBA)
  as_aBB@(norecord@((norecord@a_aBC) : l_aBD))
  bs_aBE@(norecord@((norecord@b_aBF) : k_aBG))
  | a_aBC == p_aBA b_aBF = b_aBF : collect p_aBA l_aBD k_aBG
  | p_aBA b_aBF > a_aBC = collect p_aBA l_aBD bs_aBE
  | otherwise = collect p_aBA as_aBB k_aBG

span' :: (a_anc -> Bool) -> [a_anc] -> ([a_anc], [a_anc])
span' p_aBH (norecord@[]) = ([], [])
span' (norecord@p_aBI) (norecord@(x_aBJ : xs'_aBK))
  | p_aBI x_aBJ = fixLeak_aBL x_aBJ (span' p_aBI xs'_aBK)
  where fixLeak_aBL (norecord@x_aBM) (xs_aBN, ys_aBO)
          = (x_aBM : xs_aBN, ys_aBO)
span' (norecord@_) (norecord@xs_aBP) = ([], xs_aBP)

lines' :: [Char] -> [[Char]]
lines' (norecord@"") = []
lines' s_aBQ = plumb_aBR (span' ((/=) '\n') s_aBQ)
  where plumb_aBR (l_aBS, s'_aBT)
          = l_aBS : if null s'_aBT then [] else lines' (tail s'_aBT)

strToInt :: String -> Int
strToInt (!x_aLr) = strToInt'_aLs (length x_aLr - 1) x_aLr
  where strToInt'_aLs _ [] = 0
        strToInt'_aLs (norecord@x_aLt)
          ((norecord@a_aLu) : (norecord@l_aLv))
          = (charToInt a_aLu) * (10 ^ x_aLt) +
              (strToInt'_aLs (x_aLt - 1) l_aLv)

charToInt :: Char -> Int
charToInt x_aVA = (fromEnum x_aVA - fromEnum '0')

==================== Renamer ====================
GRIP.akkumulate ::
  (state_aP8 -> a_aP9 -> (b_aPa, state_aP8))
  -> state_aP8 -> [a_aP9] -> ([b_aPa], state_aP8)
GRIP.akkumulate f_aPb st_aPc [] = ([], st_aPc)
GRIP.akkumulate (!f_aPd) (!st_aPe) (a_aPf : as_aPg)
  = (b_aPh : bs_aPj, st''_aPk)
  where
      (b_aPh, (!st'_aPi)) = f_aPd st_aPe a_aPf
      (!((!bs_aPj), st''_aPk)) = GRIP.akkumulate f_aPd st'_aPi as_aPg
GRIP.getParameters ::
  [GRIP.Line] -> ([GRIP.PElement], Int, [GRIP.Line])
GRIP.getParameters (!lines_aPl)
  = (pe_aPm, ticks_aPn, lines'_aPo)
  where
      (!((!pe_aPm), ticks_aPn, (!lines'_aPo))) = f_aPp [] 0 lines_aPl
      f_aPp l_aPq (!m_aPr) [] = ([], m_aPr, l_aPq)
      f_aPp
        (!l_aPs)
        m_aPt
        (l'_aPu@(GRIP.Ln _
                         ((!(GRIP.Act _ _ (!_) (!_) _ t_aPv)))
                         _) : (!more_aPw))
        = f_aPp (insert l'_aPu l_aPs) (max m_aPt t_aPv) more_aPw
      f_aPp (!l_aPx) (!m_aPy) ((!(GRIP.PEs x_aPz)) : more_aPA)
        = (x_aPz : xs_aPB, t_aPC, l'_aPD)
        where
            (!(xs_aPB, (!t_aPC), (!l'_aPD))) = f_aPp l_aPx m_aPy more_aPA
      f_aPp l_aPE m_aPF ((!(_ : more_aPG))) = f_aPp l_aPE m_aPF more_aPG
GRIP.getAct :: [GRIP.PElement] -> [GRIP.Line] -> [GRIP.Activities]
GRIP.getAct [] = GRIP.aux (\ x_aPH -> True)
GRIP.getAct pes_aPI = GRIP.aux (\ x_aPJ -> elem x_aPJ pes_aPI)
GRIP.aux (!_) [] = []
GRIP.aux
  f_aVO
  (!((!((!(GRIP.Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS))))
  | f_aVO pe_aVP = a_aVQ : GRIP.aux f_aVO more_aVS
  | otherwise = GRIP.aux f_aVO more_aVS
GRIP.aux (!f_aVT) ((!((!_) : (!more_aVU))))
  = GRIP.aux f_aVT more_aVU
GRIP.getSp :: [GRIP.PElement] -> [GRIP.Line] -> [GRIP.Sparks]
GRIP.getSp (![]) = GRIP.aux' (\ (!x_aVV) -> True)
GRIP.getSp pes_aVW = GRIP.aux' (\ x_aVX -> elem x_aVX pes_aVW)
GRIP.aux' (!_) [] = []
GRIP.aux'
  (!f_aVY)
  ((!((GRIP.Ln pe_aVZ a_aW0 (!s_aW1)) : (!more_aW2))))
  | f_aVY pe_aVZ = s_aW1 : GRIP.aux' f_aVY more_aW2
  | otherwise = GRIP.aux' f_aVY more_aW2
GRIP.aux' f_aW3 ((!(_ : (!more_aW4)))) = GRIP.aux' f_aW3 more_aW4
GRIP.scaleAct
  m_aW5
  (!a_aW6@(GRIP.Act n_aW7 (!i_aW8) (!r_aW9) (!g_aWa) f_aWb t_aWc))
  | m_aW5 == t_aWc = a_aW6
  | otherwise
  = GRIP.Act
      n_aW7
      (i_aW8 * c_aWd)
      (r_aW9 * c_aWd)
      (g_aWa * c_aWd)
      (f_aWb * c_aWd)
      (t_aWc * c_aWd)
  where
      c_aWd = m_aW5 `div` t_aWc
GRIP.numberSp (GRIP.Sp n_a16e (!_) (!_) (!_) _) = n_a16e
GRIP.created ((!(GRIP.Sp (!_) s_a16f _ _ (!_)))) = s_a16f
GRIP.used (GRIP.Sp (!_) (!_) (!u_a16g) (!_) (!_)) = u_a16g
GRIP.resumed (GRIP.Sp _ _ _ (!r_a16h) (!_)) = r_a16h
GRIP.lost ((!(GRIP.Sp _ _ (!_) (!_) (!l_a16i)))) = l_a16i
GRIP.numberAct (!(GRIP.Act b_a16j _ (!_) (!_) _ (!_))) = b_a16j
GRIP.idle ((!(GRIP.Act (!_) i_a16k _ _ (!_) _))) = i_a16k
GRIP.reduction ((!(GRIP.Act _ _ r_a16l (!_) (!_) (!_)))) = r_a16l
GRIP.gc (!(GRIP.Act _ (!_) (!_) (!g_a16m) _ (!_))) = g_a16m
GRIP.flush (GRIP.Act (!_) _ _ _ f_a16n _) = f_a16n
GRIP.total (GRIP.Act (!_) (!_) _ _ _ t_a16o) = t_a16o

data GRIP.Sparks
  = GRIP.Sp Int Int Int Int Int
  deriving (Show, Eq)
data GRIP.Activities
  = GRIP.Act Int Int Int Int Int Int
  deriving (Show, Eq)
data GRIP.PElement
  = GRIP.PE String Int
  deriving (Eq, Show)
data GRIP.Line
  = GRIP.Ln GRIP.PElement GRIP.Activities GRIP.Sparks |
    GRIP.PEs GRIP.PElement |
    GRIP.BucketFull Int |
    GRIP.Null
  deriving (Show, Eq)

instance Parse GRIP.PElement where
  parseType (!string_a16p)
    = (GRIP.PE name_a16q no_a16s, more_a16t)
    where
        (!(name_a16q, (!('.' : a_a16r)))) = span ((/=) '.') string_a16p
        (!((!no_a16s), more_a16t)) = parse a_a16r
instance Ord GRIP.Line where
  (!x_a19R@(!(GRIP.Ln (!_)
                      (!((!(GRIP.Act (!b_a19S) _ (!_) _ _ _))))
                      _))) <= y_a19T@(GRIP.Ln _ (!(GRIP.Act b'_a19U _ _ _ (!_) (!_))) _)
    = b_a19S <= b'_a19U
instance Parse GRIP.Line where
  parseType ((!'B') : (!string_a19V))
    = ((GRIP.Ln
          pe_a19W
          (GRIP.Act
             bucket_a19Y
             idle_a1a0
             redn_a1a2
             gc_a1a4
             (flush_a1a6 + read_a1a8)
             (idle_a1a0 + redn_a1a2 + gc_a1a4 + flush_a1a6 + read_a1a8
              + io_a1aj))
          (GRIP.Sp bucket_a19Y sprkd_a1ab sused_a1ad resum_a1af lost_a1ah)), 
       more_a1ak)
    where
        (!((!pe_a19W), (!(':' : p_a19X)))) = parse string_a19V
        (bucket_a19Y, (!((!':') : (!a_a19Z)))) = parse p_a19X
        ((!idle_a1a0), b_a1a1) = parse a_a19Z
        ((!redn_a1a2), c_a1a3) = parse b_a1a1
        ((!gc_a1a4), d_a1a5) = parse c_a1a3
        (!((!flush_a1a6), (!e_a1a7))) = parse d_a1a5
        (!((!read_a1a8), (!k_a1a9))) = parse e_a1a7
        ((!_), (!f_a1aa)) = span ((/=) ' ') (whiteSpace k_a1a9)
        (!((!sprkd_a1ab), g_a1ac)) = parse f_a1aa
        (!((!sused_a1ad), (!h_a1ae))) = parse g_a1ac
        (!((!resum_a1af), i_a1ag)) = parse h_a1ae
        ((!lost_a1ah), j_a1ai) = parse i_a1ag
        (!((!io_a1aj), (!more_a1ak))) = parse j_a1ai
  parseType ('P' : (!((!'S') : (!string_a1al))))
    = (GRIP.PEs pe_a1am, more_a1an)
    where
        (!((!pe_a1am), more_a1an))
          = parse (tail (dropWhile ((/=) 'r') string_a1al))
  parseType (!string_a1ao) = (GRIP.Null, string_a1ao)


["f_aPb","st_aPc","[]","f_aPd","!f_aPd","(!f_aPd)","st_aPe","!st_aPe","(!st_aPe)","a_aPf","as_aPg","a_aPf : as_aPg","(a_aPf : as_aPg)","b_aPh","st'_aPi","!st'_aPi","(!st'_aPi)","(b_aPh, (!st'_aPi))","bs_aPj","safebang@!bs_aPj","(!bs_aPj)","st''_aPk","((!bs_aPj), st''_aPk)","!((!bs_aPj), st''_aPk)","(!((!bs_aPj), st''_aPk))","lines_aPl","safebang@!lines_aPl","(!lines_aPl)","pe_aPm","safebang@!pe_aPm","(!pe_aPm)","ticks_aPn","lines'_aPo","safebang@!lines'_aPo","(!lines'_aPo)","((!pe_aPm), ticks_aPn, (!lines'_aPo))","!((!pe_aPm), ticks_aPn, (!lines'_aPo))","(!((!pe_aPm), ticks_aPn, (!lines'_aPo)))","l_aPq","m_aPr","safebang@!m_aPr","(!m_aPr)","[]","l_aPs","!l_aPs","(!l_aPs)","m_aPt","_","_","_","_","!_","(!_)","_","!_","(!_)","_","t_aPv","Act _ _ (!_) (!_) _ t_aPv","(Act _ _ (!_) (!_) _ t_aPv)","!(Act _ _ (!_) (!_) _ t_aPv)","(!(Act _ _ (!_) (!_) _ t_aPv))","((!(Act _ _ (!_) (!_) _ t_aPv)))","_","Ln _ ((!(Act _ _ (!_) (!_) _ t_aPv))) _","(Ln _ ((!(Act _ _ (!_) (!_) _ t_aPv))) _)","l'_aPu@(Ln _ ((!(Act _ _ (!_) (!_) _ t_aPv))) _)","more_aPw","!more_aPw","(!more_aPw)","l'_aPu@(Ln _ ((!(Act _ _ (!_) (!_) _ t_aPv))) _) : (!more_aPw)","(l'_aPu@(Ln _ ((!(Act _ _ (!_) (!_) _ t_aPv))) _) : (!more_aPw))","l_aPx","!l_aPx","(!l_aPx)","m_aPy","!m_aPy","(!m_aPy)","x_aPz","PEs x_aPz","(PEs x_aPz)","!(PEs x_aPz)","(!(PEs x_aPz))","more_aPA","(!(PEs x_aPz)) : more_aPA","((!(PEs x_aPz)) : more_aPA)","xs_aPB","t_aPC","safebang@!t_aPC","(!t_aPC)","l'_aPD","safebang@!l'_aPD","(!l'_aPD)","(xs_aPB, (!t_aPC), (!l'_aPD))","!(xs_aPB, (!t_aPC), (!l'_aPD))","(!(xs_aPB, (!t_aPC), (!l'_aPD)))","l_aPE","m_aPF","_","more_aPG","_ : more_aPG","(_ : more_aPG)","!(_ : more_aPG)","(!(_ : more_aPG))","((!(_ : more_aPG)))","[]","x_aPH","pes_aPI","x_aPJ","_","!_","(!_)","[]","f_aVO","pe_aVP","a_aVQ","safebang@!a_aVQ","(!a_aVQ)","s_aVR","safebang@!s_aVR","(!s_aVR)","Ln pe_aVP (!a_aVQ) (!s_aVR)","(Ln pe_aVP (!a_aVQ) (!s_aVR))","!(Ln pe_aVP (!a_aVQ) (!s_aVR))","(!(Ln pe_aVP (!a_aVQ) (!s_aVR)))","more_aVS","(!(Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS","((!(Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS)","!((!(Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS)","(!((!(Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS))","((!((!(Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS)))","!((!((!(Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS)))","(!((!((!(Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS))))","f_aVT","!f_aVT","(!f_aVT)","_","!_","(!_)","more_aVU","!more_aVU","(!more_aVU)","(!_) : (!more_aVU)","((!_) : (!more_aVU))","!((!_) : (!more_aVU))","(!((!_) : (!more_aVU)))","((!((!_) : (!more_aVU))))","[]","![]","(![])","x_aVV","safebang@!x_aVV","(!x_aVV)","pes_aVW","x_aVX","_","!_","(!_)","[]","f_aVY","!f_aVY","(!f_aVY)","pe_aVZ","a_aW0","s_aW1","safebang@!s_aW1","(!s_aW1)","Ln pe_aVZ a_aW0 (!s_aW1)","(Ln pe_aVZ a_aW0 (!s_aW1))","more_aW2","safebang@!more_aW2","(!more_aW2)","(Ln pe_aVZ a_aW0 (!s_aW1)) : (!more_aW2)","((Ln pe_aVZ a_aW0 (!s_aW1)) : (!more_aW2))","!((Ln pe_aVZ a_aW0 (!s_aW1)) : (!more_aW2))","(!((Ln pe_aVZ a_aW0 (!s_aW1)) : (!more_aW2)))","((!((Ln pe_aVZ a_aW0 (!s_aW1)) : (!more_aW2))))","f_aW3","_","more_aW4","!more_aW4","(!more_aW4)","_ : (!more_aW4)","(_ : (!more_aW4))","!(_ : (!more_aW4))","(!(_ : (!more_aW4)))","((!(_ : (!more_aW4))))","m_aW5","n_aW7","i_aW8","safebang@!i_aW8","(!i_aW8)","r_aW9","safebang@!r_aW9","(!r_aW9)","g_aWa","safebang@!g_aWa","(!g_aWa)","f_aWb","t_aWc","Act n_aW7 (!i_aW8) (!r_aW9) (!g_aWa) f_aWb t_aWc","(Act n_aW7 (!i_aW8) (!r_aW9) (!g_aWa) f_aWb t_aWc)","a_aW6@(Act n_aW7 (!i_aW8) (!r_aW9) (!g_aWa) f_aWb t_aWc)","!a_aW6@(Act n_aW7 (!i_aW8) (!r_aW9) (!g_aWa) f_aWb t_aWc)","(!a_aW6@(Act n_aW7 (!i_aW8) (!r_aW9) (!g_aWa) f_aWb t_aWc))","c_aWd","n_a16e","_","!_","(!_)","_","!_","(!_)","_","!_","(!_)","_","Sp n_a16e (!_) (!_) (!_) _","(Sp n_a16e (!_) (!_) (!_) _)","_","!_","(!_)","s_a16f","_","_","_","!_","(!_)","Sp (!_) s_a16f _ _ (!_)","(Sp (!_) s_a16f _ _ (!_))","!(Sp (!_) s_a16f _ _ (!_))","(!(Sp (!_) s_a16f _ _ (!_)))","((!(Sp (!_) s_a16f _ _ (!_))))","_","!_","(!_)","_","!_","(!_)","u_a16g","safebang@!u_a16g","(!u_a16g)","_","!_","(!_)","_","!_","(!_)","Sp (!_) (!_) (!u_a16g) (!_) (!_)","(Sp (!_) (!_) (!u_a16g) (!_) (!_))","_","_","_","r_a16h","safebang@!r_a16h","(!r_a16h)","_","!_","(!_)","Sp _ _ _ (!r_a16h) (!_)","(Sp _ _ _ (!r_a16h) (!_))","_","_","_","!_","(!_)","_","!_","(!_)","l_a16i","safebang@!l_a16i","(!l_a16i)","Sp _ _ (!_) (!_) (!l_a16i)","(Sp _ _ (!_) (!_) (!l_a16i))","!(Sp _ _ (!_) (!_) (!l_a16i))","(!(Sp _ _ (!_) (!_) (!l_a16i)))","((!(Sp _ _ (!_) (!_) (!l_a16i))))","b_a16j","_","_","!_","(!_)","_","!_","(!_)","_","_","!_","(!_)","Act b_a16j _ (!_) (!_) _ (!_)","(Act b_a16j _ (!_) (!_) _ (!_))","!(Act b_a16j _ (!_) (!_) _ (!_))","(!(Act b_a16j _ (!_) (!_) _ (!_)))","_","!_","(!_)","i_a16k","_","_","_","!_","(!_)","_","Act (!_) i_a16k _ _ (!_) _","(Act (!_) i_a16k _ _ (!_) _)","!(Act (!_) i_a16k _ _ (!_) _)","(!(Act (!_) i_a16k _ _ (!_) _))","((!(Act (!_) i_a16k _ _ (!_) _)))","_","_","r_a16l","_","!_","(!_)","_","!_","(!_)","_","!_","(!_)","Act _ _ r_a16l (!_) (!_) (!_)","(Act _ _ r_a16l (!_) (!_) (!_))","!(Act _ _ r_a16l (!_) (!_) (!_))","(!(Act _ _ r_a16l (!_) (!_) (!_)))","((!(Act _ _ r_a16l (!_) (!_) (!_))))","_","_","!_","(!_)","_","!_","(!_)","g_a16m","safebang@!g_a16m","(!g_a16m)","_","_","!_","(!_)","Act _ (!_) (!_) (!g_a16m) _ (!_)","(Act _ (!_) (!_) (!g_a16m) _ (!_))","!(Act _ (!_) (!_) (!g_a16m) _ (!_))","(!(Act _ (!_) (!_) (!g_a16m) _ (!_)))","_","!_","(!_)","_","_","_","f_a16n","_","Act (!_) _ _ _ f_a16n _","(Act (!_) _ _ _ f_a16n _)","_","!_","(!_)","_","!_","(!_)","_","_","_","t_a16o","Act (!_) (!_) _ _ _ t_a16o","(Act (!_) (!_) _ _ _ t_a16o)","string_a16p","safebang@!string_a16p","(!string_a16p)","name_a16q","'.'","a_a16r","'.' : a_a16r","('.' : a_a16r)","!('.' : a_a16r)","(!('.' : a_a16r))","(name_a16q, (!('.' : a_a16r)))","!(name_a16q, (!('.' : a_a16r)))","(!(name_a16q, (!('.' : a_a16r))))","no_a16s","!no_a16s","(!no_a16s)","more_a16t","((!no_a16s), more_a16t)","!((!no_a16s), more_a16t)","(!((!no_a16s), more_a16t))","_","!_","(!_)","b_a19S","!b_a19S","(!b_a19S)","_","_","!_","(!_)","_","_","_","Act (!b_a19S) _ (!_) _ _ _","(Act (!b_a19S) _ (!_) _ _ _)","!(Act (!b_a19S) _ (!_) _ _ _)","(!(Act (!b_a19S) _ (!_) _ _ _))","((!(Act (!b_a19S) _ (!_) _ _ _)))","!((!(Act (!b_a19S) _ (!_) _ _ _)))","(!((!(Act (!b_a19S) _ (!_) _ _ _))))","_","Ln (!_) (!((!(Act (!b_a19S) _ (!_) _ _ _)))) _","(Ln (!_) (!((!(Act (!b_a19S) _ (!_) _ _ _)))) _)","!(Ln (!_) (!((!(Act (!b_a19S) _ (!_) _ _ _)))) _)","(!(Ln (!_) (!((!(Act (!b_a19S) _ (!_) _ _ _)))) _))","x_a19R@(!(Ln (!_) (!((!(Act (!b_a19S) _ (!_) _ _ _)))) _))","!x_a19R@(!(Ln (!_) (!((!(Act (!b_a19S) _ (!_) _ _ _)))) _))","(!x_a19R@(!(Ln (!_) (!((!(Act (!b_a19S) _ (!_) _ _ _)))) _)))","_","b'_a19U","_","_","_","_","!_","(!_)","_","!_","(!_)","Act b'_a19U _ _ _ (!_) (!_)","(Act b'_a19U _ _ _ (!_) (!_))","!(Act b'_a19U _ _ _ (!_) (!_))","(!(Act b'_a19U _ _ _ (!_) (!_)))","_","Ln _ (!(Act b'_a19U _ _ _ (!_) (!_))) _","(Ln _ (!(Act b'_a19U _ _ _ (!_) (!_))) _)","y_a19T@(Ln _ (!(Act b'_a19U _ _ _ (!_) (!_))) _)","'B'","!'B'","(!'B')","string_a19V","!string_a19V","(!string_a19V)","(!'B') : (!string_a19V)","((!'B') : (!string_a19V))","pe_a19W","safebang@!pe_a19W","(!pe_a19W)","':'","p_a19X","':' : p_a19X","(':' : p_a19X)","!(':' : p_a19X)","(!(':' : p_a19X))","((!pe_a19W), (!(':' : p_a19X)))","!((!pe_a19W), (!(':' : p_a19X)))","(!((!pe_a19W), (!(':' : p_a19X))))","bucket_a19Y","':'","!':'","(!':')","a_a19Z","!a_a19Z","(!a_a19Z)","(!':') : (!a_a19Z)","((!':') : (!a_a19Z))","!((!':') : (!a_a19Z))","(!((!':') : (!a_a19Z)))","(bucket_a19Y, (!((!':') : (!a_a19Z))))","idle_a1a0","!idle_a1a0","(!idle_a1a0)","b_a1a1","((!idle_a1a0), b_a1a1)","redn_a1a2","!redn_a1a2","(!redn_a1a2)","c_a1a3","((!redn_a1a2), c_a1a3)","gc_a1a4","!gc_a1a4","(!gc_a1a4)","d_a1a5","((!gc_a1a4), d_a1a5)","flush_a1a6","!flush_a1a6","(!flush_a1a6)","e_a1a7","!e_a1a7","(!e_a1a7)","((!flush_a1a6), (!e_a1a7))","!((!flush_a1a6), (!e_a1a7))","(!((!flush_a1a6), (!e_a1a7)))","read_a1a8","!read_a1a8","(!read_a1a8)","k_a1a9","!k_a1a9","(!k_a1a9)","((!read_a1a8), (!k_a1a9))","!((!read_a1a8), (!k_a1a9))","(!((!read_a1a8), (!k_a1a9)))","_","!_","(!_)","f_a1aa","!f_a1aa","(!f_a1aa)","((!_), (!f_a1aa))","sprkd_a1ab","!sprkd_a1ab","(!sprkd_a1ab)","g_a1ac","((!sprkd_a1ab), g_a1ac)","!((!sprkd_a1ab), g_a1ac)","(!((!sprkd_a1ab), g_a1ac))","sused_a1ad","!sused_a1ad","(!sused_a1ad)","h_a1ae","!h_a1ae","(!h_a1ae)","((!sused_a1ad), (!h_a1ae))","!((!sused_a1ad), (!h_a1ae))","(!((!sused_a1ad), (!h_a1ae)))","resum_a1af","!resum_a1af","(!resum_a1af)","i_a1ag","((!resum_a1af), i_a1ag)","!((!resum_a1af), i_a1ag)","(!((!resum_a1af), i_a1ag))","lost_a1ah","!lost_a1ah","(!lost_a1ah)","j_a1ai","((!lost_a1ah), j_a1ai)","io_a1aj","!io_a1aj","(!io_a1aj)","more_a1ak","!more_a1ak","(!more_a1ak)","((!io_a1aj), (!more_a1ak))","!((!io_a1aj), (!more_a1ak))","(!((!io_a1aj), (!more_a1ak)))","'P'","'S'","!'S'","(!'S')","string_a1al","lazydmd@!string_a1al","(!string_a1al)","(!'S') : (!string_a1al)","((!'S') : (!string_a1al))","!((!'S') : (!string_a1al))","(!((!'S') : (!string_a1al)))","'P' : (!((!'S') : (!string_a1al)))","('P' : (!((!'S') : (!string_a1al))))","pe_a1am","safebang@!pe_a1am","(!pe_a1am)","more_a1an","((!pe_a1am), more_a1an)","!((!pe_a1am), more_a1an)","(!((!pe_a1am), more_a1an))","string_a1ao","!string_a1ao","(!string_a1ao)"]
module GRIP where
import PSlib
import StdLib
import Parse

akkumulate ::
           (state_aP8 -> a_aP9 -> (b_aPa, state_aP8)) ->
             state_aP8 -> [a_aP9] -> ([b_aPa], state_aP8)
akkumulate f_aPb st_aPc [] = ([], st_aPc)
akkumulate (norecord@f_aPd) (norecord@st_aPe) (a_aPf : as_aPg)
  = (b_aPh : bs_aPj, st''_aPk)
  where (b_aPh, (norecord@st'_aPi)) = f_aPd st_aPe a_aPf
        (norecord@((!bs_aPj), st''_aPk)) = akkumulate f_aPd st'_aPi as_aPg

getParameters :: [Line] -> ([PElement], Int, [Line])
getParameters (!lines_aPl) = (pe_aPm, ticks_aPn, lines'_aPo)
  where (norecord@((!pe_aPm), ticks_aPn, (!lines'_aPo)))
          = f_aPp [] 0 lines_aPl
        f_aPp l_aPq (!m_aPr) [] = ([], m_aPr, l_aPq)
        f_aPp (norecord@l_aPs) m_aPt
          (l'_aPu@(Ln _
                     ((norecord@(Act _ _ (norecord@_) (norecord@_) _ t_aPv))) _)
             : (norecord@more_aPw))
          = f_aPp (insert l'_aPu l_aPs) (max m_aPt t_aPv) more_aPw
        f_aPp (norecord@l_aPx) (norecord@m_aPy)
          ((norecord@(PEs x_aPz)) : more_aPA)
          = (x_aPz : xs_aPB, t_aPC, l'_aPD)
          where (norecord@(xs_aPB, (!t_aPC), (!l'_aPD)))
                  = f_aPp l_aPx m_aPy more_aPA
        f_aPp l_aPE m_aPF ((norecord@(_ : more_aPG)))
          = f_aPp l_aPE m_aPF more_aPG

getAct :: [PElement] -> [Line] -> [Activities]
getAct [] = aux (\ x_aPH -> True)
getAct pes_aPI = aux (\ x_aPJ -> elem x_aPJ pes_aPI)
aux (norecord@_) [] = []
aux f_aVO
  (norecord@((norecord@((norecord@(Ln pe_aVP (!a_aVQ) (!s_aVR))) :
                          more_aVS))))
  | f_aVO pe_aVP = a_aVQ : aux f_aVO more_aVS
  | otherwise = aux f_aVO more_aVS
aux (norecord@f_aVT)
  ((norecord@((norecord@_) : (norecord@more_aVU))))
  = aux f_aVT more_aVU

getSp :: [PElement] -> [Line] -> [Sparks]
getSp (norecord@[]) = aux' (\ (!x_aVV) -> True)
getSp pes_aVW = aux' (\ x_aVX -> elem x_aVX pes_aVW)
aux' (norecord@_) [] = []
aux' (norecord@f_aVY)
  ((norecord@((Ln pe_aVZ a_aW0 (!s_aW1)) : (!more_aW2))))
  | f_aVY pe_aVZ = s_aW1 : aux' f_aVY more_aW2
  | otherwise = aux' f_aVY more_aW2
aux' f_aW3 ((norecord@(_ : (norecord@more_aW4))))
  = aux' f_aW3 more_aW4
scaleAct m_aW5
  (norecord@a_aW6@(Act n_aW7 (!i_aW8) (!r_aW9) (!g_aWa) f_aWb t_aWc))
  | m_aW5 == t_aWc = a_aW6
  | otherwise =
    Act n_aW7 (i_aW8 * c_aWd) (r_aW9 * c_aWd) (g_aWa * c_aWd)
      (f_aWb * c_aWd)
      (t_aWc * c_aWd)
  where c_aWd = m_aW5 `div` t_aWc
numberSp (Sp n_a16e (norecord@_) (norecord@_) (norecord@_) _)
  = n_a16e
created ((norecord@(Sp (norecord@_) s_a16f _ _ (norecord@_))))
  = s_a16f
used
  (Sp (norecord@_) (norecord@_) (!u_a16g) (norecord@_) (norecord@_))
  = u_a16g
resumed (Sp _ _ _ (!r_a16h) (norecord@_)) = r_a16h
lost ((norecord@(Sp _ _ (norecord@_) (norecord@_) (!l_a16i))))
  = l_a16i
numberAct
  (norecord@(Act b_a16j _ (norecord@_) (norecord@_) _ (norecord@_)))
  = b_a16j
idle ((norecord@(Act (norecord@_) i_a16k _ _ (norecord@_) _)))
  = i_a16k
reduction
  ((norecord@(Act _ _ r_a16l (norecord@_) (norecord@_)
                (norecord@_))))
  = r_a16l
gc
  (norecord@(Act _ (norecord@_) (norecord@_) (!g_a16m) _
               (norecord@_)))
  = g_a16m
flush (Act (norecord@_) _ _ _ f_a16n _) = f_a16n
total (Act (norecord@_) (norecord@_) _ _ _ t_a16o) = t_a16o

data Sparks = Sp Int Int Int Int Int
            deriving (Show, Eq)

data Activities = Act Int Int Int Int Int Int
                deriving (Show, Eq)

data PElement = PE String Int
              deriving (Eq, Show)

data Line = Ln PElement Activities Sparks
          | PEs PElement
          | BucketFull Int
          | Null
          deriving (Show, Eq)

instance Parse PElement where
        parseType (!string_a16p) = (PE name_a16q no_a16s, more_a16t)
          where (norecord@(name_a16q, (norecord@('.' : a_a16r))))
                  = span ((/=) '.') string_a16p
                (norecord@((norecord@no_a16s), more_a16t)) = parse a_a16r

instance Ord Line where
        (norecord@x_a19R@(norecord@(Ln (norecord@_)
                                      (norecord@((norecord@(Act (norecord@b_a19S) _ (norecord@_) _ _
                                                              _))))
                                      _)))
          <=
          y_a19T@(Ln _
                    (norecord@(Act b'_a19U _ _ _ (norecord@_) (norecord@_))) _)
          = b_a19S <= b'_a19U

instance Parse Line where
        parseType ((norecord@'B') : (norecord@string_a19V))
          = ((Ln pe_a19W
                (Act bucket_a19Y idle_a1a0 redn_a1a2 gc_a1a4
                   (flush_a1a6 + read_a1a8)
                   (idle_a1a0 + redn_a1a2 + gc_a1a4 + flush_a1a6 + read_a1a8 +
                      io_a1aj))
                (Sp bucket_a19Y sprkd_a1ab sused_a1ad resum_a1af lost_a1ah)),
             more_a1ak)
          where (norecord@((!pe_a19W), (norecord@(':' : p_a19X))))
                  = parse string_a19V
                (bucket_a19Y, (norecord@((norecord@':') : (norecord@a_a19Z))))
                  = parse p_a19X
                ((norecord@idle_a1a0), b_a1a1) = parse a_a19Z
                ((norecord@redn_a1a2), c_a1a3) = parse b_a1a1
                ((norecord@gc_a1a4), d_a1a5) = parse c_a1a3
                (norecord@((norecord@flush_a1a6), (norecord@e_a1a7)))
                  = parse d_a1a5
                (norecord@((norecord@read_a1a8), (norecord@k_a1a9))) = parse e_a1a7
                ((norecord@_), (norecord@f_a1aa))
                  = span ((/=) ' ') (whiteSpace k_a1a9)
                (norecord@((norecord@sprkd_a1ab), g_a1ac)) = parse f_a1aa
                (norecord@((norecord@sused_a1ad), (norecord@h_a1ae)))
                  = parse g_a1ac
                (norecord@((norecord@resum_a1af), i_a1ag)) = parse h_a1ae
                ((norecord@lost_a1ah), j_a1ai) = parse i_a1ag
                (norecord@((norecord@io_a1aj), (norecord@more_a1ak)))
                  = parse j_a1ai
        parseType
          ('P' : (norecord@((norecord@'S') : (lazydmd@string_a1al))))
          = (PEs pe_a1am, more_a1an)
          where (norecord@((!pe_a1am), more_a1an))
                  = parse (tail (dropWhile ((/=) 'r') string_a1al))
        parseType (norecord@string_a1ao) = (Null, string_a1ao)

==================== Renamer ====================
Spark.sparkGraph ordering_aOA selectpes_aOB statFile_aOC
  = initGraph
      "Spark Activity Graph"
      (pes_aOE, selectpes_aOB)
      (100 * ticks_aOF, height_aOH)
      ("Time (ms)", "Sparks")
      (map f_aOD ordering_aOA)
    ++
      scale
        (my_fromInt dimX / my_fromInt 100)
        (my_fromInt dimY / my_fromInt height_aOH)
      ++
        concat
          (map2
             plotCurve
             (map Spark.colourSpark order_aOM)
             (Spark.outlinesTrace traces_aOI))
  where
      f_aOD (!a_aOO)
        = (Spark.colourSpark a_aOO, Spark.displaySpark a_aOO, 
           Spark.aggr a_aOO aggs_aOJ)
      ((!pes_aOE), ticks_aOF, orderedStats_aOG) = getParameters stats_aON
      height_aOH = axisScale h_aOK
      (!(traces_aOI, ((!aggs_aOJ), h_aOK, (!w_aOL))))
        = akkumulate
            (Spark.processSparks (map Spark.extractor order_aOM))
            Spark.nullstate
            (Spark.gatherSp
               (Sp 0 0 0 0 0) (getSp selectpes_aOB orderedStats_aOG))
      (!order_aOM) = reverse ordering_aOA
      (!stats_aON) = parseFile statFile_aOC
Spark.processSparks ::
  [Sparks -> Int]
  -> Spark.State -> Sparks -> (Spark.Trace, Spark.State)
Spark.processSparks
  extractors_a18e
  (((!c_a18f), (!u_a18g), r_a18h, (!l_a18i)), (!graphmax_a18j), _)
  s_a18k@(!(Sp n_a18l c'_a18m (!u'_a18n) (!r'_a18o) l'_a18p))
  = (trace_a18q, 
     ((c'_a18m + c_a18f, u'_a18n + u_a18g, r'_a18o + r_a18h, 
       l'_a18p + l_a18i), 
      max graphmax_a18j m_a18r, n_a18l))
  where
      (!trace_a18q@(Spark.T _ (!(m_a18r : _))))
        = Spark.makeTrace extractors_a18e n_a18l s_a18k
Spark.makeTrace (!fs_a18s) n_a18t (!s_a18u)
  = Spark.T n_a18t (f_a18v fs_a18s)
  where
      f_a18v [] = []
      f_a18v (!ex_a18w@(!(e_a18x : es_a18y)))
        = sum (Spark.pam ex_a18w s_a18u) : f_a18v es_a18y
Spark.nullstate = ((0, 0, 0, 0), 0, 0)
Spark.outlinesTrace :: [Spark.Trace] -> [[Point]]
Spark.outlinesTrace [Spark.T n_a18z a_a18A]
  = map (\ (!x_a18B) -> [Pt n_a18z x_a18B]) a_a18A
Spark.outlinesTrace (!(Spark.T n_a18C a_a18D : more_a18E))
  = map2
      (:)
      (map (\ x_a18F -> Pt n_a18C x_a18F) a_a18D)
      (Spark.outlinesTrace more_a18E)
Spark.pam [] _ = []
Spark.pam (!((!f_a18G) : (!fs_a18H))) a_a18I
  = f_a18G a_a18I : Spark.pam fs_a18H a_a18I
Spark.gatherSp (!t_a18J) (![])
  = [t_a18J, (Sp (numberSp t_a18J + 1) 0 0 0 0)]
Spark.gatherSp (!t_a18K) (!l_a18L@((!((!a_a18M) : (!as_a18N)))))
  | numberSp t_a18K == numberSp a_a18M
  = Spark.gatherSp (Spark.addSparks t_a18K a_a18M) as_a18N
  | otherwise
  = t_a18K : Spark.gatherSp (Sp (n_a18O + 1) 0 0 0 0) l_a18L
  where
      (!n_a18O) = numberSp t_a18K
Spark.addSparks
  (Sp n_a18P a_a18Q (!b_a18R) c_a18S (!d_a18T))
  (Sp (!_) e_a18U f_a18V (!g_a18W) (!h_a18X))
  = Sp
      n_a18P
      (a_a18Q + e_a18U)
      (b_a18R + f_a18V)
      (c_a18S + g_a18W)
      (d_a18T + h_a18X)
Spark.aggr :: Spark.Spark -> (Int, Int, Int, Int) -> String
Spark.aggr Spark.CREATED ((!i_a18Y), (!_), _, _) = show i_a18Y
Spark.aggr (!Spark.USED) ((!_), (!r_a1hi), _, _) = show r_a1hi
Spark.aggr Spark.RESUMED (!((!_), _, g_a1hj, (!_))) = show g_a1hj
Spark.aggr (!Spark.LOST) (_, _, _, (!f_a1hk)) = show f_a1hk
Spark.extractor Spark.LOST = lost
Spark.extractor Spark.CREATED = created
Spark.extractor (!Spark.RESUMED) = resumed
Spark.extractor (!Spark.USED) = used
Spark.colourSpark :: Spark.Spark -> Int
Spark.colourSpark Spark.LOST = 8
Spark.colourSpark (!Spark.CREATED) = 5
Spark.colourSpark (!Spark.RESUMED) = 2
Spark.colourSpark (!Spark.USED) = 0
Spark.displaySpark :: Spark.Spark -> String
Spark.displaySpark (!Spark.LOST) = "Sparks Lost"
Spark.displaySpark (!Spark.CREATED) = "Sparks Created"
Spark.displaySpark Spark.RESUMED = "Resumed Sparks"
Spark.displaySpark Spark.USED = "Used Sparks"

type Spark.State = ((Int, Int, Int, Int), Int, Int)
data Spark.Trace = Spark.T Int [Int]
data Spark.Spark
  = Spark.USED | Spark.RESUMED | Spark.CREATED | Spark.LOST
  deriving (Eq)

instance Parse Spark.Spark where
  parseType (!('L' : string_a1hl)) = (Spark.LOST, string_a1hl)
  parseType ((!'C') : string_a1hm) = (Spark.CREATED, string_a1hm)
  parseType (!((!('R' : (!string_a1hn)))))
    = (Spark.RESUMED, string_a1hn)
  parseType ((!'U') : string_a1ho) = (Spark.USED, string_a1ho)
  parseType (!((!string_a1hp)))
    = error ("No such Activity : " ++ show string_a1hp ++ "\n")


["ordering_aOA","selectpes_aOB","statFile_aOC","a_aOO","!a_aOO","(!a_aOO)","pes_aOE","!pes_aOE","(!pes_aOE)","ticks_aOF","orderedStats_aOG","((!pes_aOE), ticks_aOF, orderedStats_aOG)","height_aOH","traces_aOI","aggs_aOJ","safebang@!aggs_aOJ","(!aggs_aOJ)","h_aOK","w_aOL","safebang@!w_aOL","(!w_aOL)","((!aggs_aOJ), h_aOK, (!w_aOL))","(traces_aOI, ((!aggs_aOJ), h_aOK, (!w_aOL)))","!(traces_aOI, ((!aggs_aOJ), h_aOK, (!w_aOL)))","(!(traces_aOI, ((!aggs_aOJ), h_aOK, (!w_aOL))))","order_aOM","!order_aOM","(!order_aOM)","stats_aON","safebang@!stats_aON","(!stats_aON)","extractors_a18e","c_a18f","safebang@!c_a18f","(!c_a18f)","u_a18g","safebang@!u_a18g","(!u_a18g)","r_a18h","l_a18i","safebang@!l_a18i","(!l_a18i)","((!c_a18f), (!u_a18g), r_a18h, (!l_a18i))","graphmax_a18j","safebang@!graphmax_a18j","(!graphmax_a18j)","_","(((!c_a18f), (!u_a18g), r_a18h, (!l_a18i)), (!graphmax_a18j), _)","n_a18l","c'_a18m","u'_a18n","safebang@!u'_a18n","(!u'_a18n)","r'_a18o","safebang@!r'_a18o","(!r'_a18o)","l'_a18p","Sp n_a18l c'_a18m (!u'_a18n) (!r'_a18o) l'_a18p","(Sp n_a18l c'_a18m (!u'_a18n) (!r'_a18o) l'_a18p)","!(Sp n_a18l c'_a18m (!u'_a18n) (!r'_a18o) l'_a18p)","(!(Sp n_a18l c'_a18m (!u'_a18n) (!r'_a18o) l'_a18p))","s_a18k@(!(Sp n_a18l c'_a18m (!u'_a18n) (!r'_a18o) l'_a18p))","_","m_a18r","_","m_a18r : _","(m_a18r : _)","!(m_a18r : _)","(!(m_a18r : _))","T _ (!(m_a18r : _))","(T _ (!(m_a18r : _)))","trace_a18q@(T _ (!(m_a18r : _)))","!trace_a18q@(T _ (!(m_a18r : _)))","(!trace_a18q@(T _ (!(m_a18r : _))))","fs_a18s","!fs_a18s","(!fs_a18s)","n_a18t","s_a18u","!s_a18u","(!s_a18u)","[]","e_a18x","es_a18y","e_a18x : es_a18y","(e_a18x : es_a18y)","!(e_a18x : es_a18y)","(!(e_a18x : es_a18y))","ex_a18w@(!(e_a18x : es_a18y))","!ex_a18w@(!(e_a18x : es_a18y))","(!ex_a18w@(!(e_a18x : es_a18y)))","nullstate","n_a18z","a_a18A","T n_a18z a_a18A","[T n_a18z a_a18A]","x_a18B","!x_a18B","(!x_a18B)","n_a18C","a_a18D","T n_a18C a_a18D","more_a18E","T n_a18C a_a18D : more_a18E","(T n_a18C a_a18D : more_a18E)","!(T n_a18C a_a18D : more_a18E)","(!(T n_a18C a_a18D : more_a18E))","x_a18F","[]","_","f_a18G","safebang@!f_a18G","(!f_a18G)","fs_a18H","safebang@!fs_a18H","(!fs_a18H)","(!f_a18G) : (!fs_a18H)","((!f_a18G) : (!fs_a18H))","!((!f_a18G) : (!fs_a18H))","(!((!f_a18G) : (!fs_a18H)))","a_a18I","t_a18J","safebang@!t_a18J","(!t_a18J)","[]","![]","(![])","t_a18K","!t_a18K","(!t_a18K)","a_a18M","!a_a18M","(!a_a18M)","as_a18N","!as_a18N","(!as_a18N)","(!a_a18M) : (!as_a18N)","((!a_a18M) : (!as_a18N))","!((!a_a18M) : (!as_a18N))","(!((!a_a18M) : (!as_a18N)))","((!((!a_a18M) : (!as_a18N))))","l_a18L@((!((!a_a18M) : (!as_a18N))))","!l_a18L@((!((!a_a18M) : (!as_a18N))))","(!l_a18L@((!((!a_a18M) : (!as_a18N)))))","n_a18O","lazydmd@!n_a18O","(!n_a18O)","n_a18P","a_a18Q","b_a18R","!b_a18R","(!b_a18R)","c_a18S","d_a18T","!d_a18T","(!d_a18T)","Sp n_a18P a_a18Q (!b_a18R) c_a18S (!d_a18T)","(Sp n_a18P a_a18Q (!b_a18R) c_a18S (!d_a18T))","_","!_","(!_)","e_a18U","f_a18V","g_a18W","!g_a18W","(!g_a18W)","h_a18X","!h_a18X","(!h_a18X)","Sp (!_) e_a18U f_a18V (!g_a18W) (!h_a18X)","(Sp (!_) e_a18U f_a18V (!g_a18W) (!h_a18X))","CREATED","i_a18Y","!i_a18Y","(!i_a18Y)","_","!_","(!_)","_","_","((!i_a18Y), (!_), _, _)","USED","!USED","(!USED)","_","!_","(!_)","r_a1hi","!r_a1hi","(!r_a1hi)","_","_","((!_), (!r_a1hi), _, _)","RESUMED","_","!_","(!_)","_","g_a1hj","_","!_","(!_)","((!_), _, g_a1hj, (!_))","!((!_), _, g_a1hj, (!_))","(!((!_), _, g_a1hj, (!_)))","LOST","!LOST","(!LOST)","_","_","_","f_a1hk","!f_a1hk","(!f_a1hk)","(_, _, _, (!f_a1hk))","LOST","CREATED","RESUMED","!RESUMED","(!RESUMED)","USED","!USED","(!USED)","LOST","CREATED","!CREATED","(!CREATED)","RESUMED","!RESUMED","(!RESUMED)","USED","!USED","(!USED)","LOST","!LOST","(!LOST)","CREATED","!CREATED","(!CREATED)","RESUMED","USED","'L'","string_a1hl","'L' : string_a1hl","('L' : string_a1hl)","!('L' : string_a1hl)","(!('L' : string_a1hl))","'C'","!'C'","(!'C')","string_a1hm","(!'C') : string_a1hm","((!'C') : string_a1hm)","'R'","string_a1hn","lazydmd@!string_a1hn","(!string_a1hn)","'R' : (!string_a1hn)","('R' : (!string_a1hn))","!('R' : (!string_a1hn))","(!('R' : (!string_a1hn)))","((!('R' : (!string_a1hn))))","!((!('R' : (!string_a1hn))))","(!((!('R' : (!string_a1hn)))))","'U'","!'U'","(!'U')","string_a1ho","(!'U') : string_a1ho","((!'U') : string_a1ho)","string_a1hp","!string_a1hp","(!string_a1hp)","((!string_a1hp))","!((!string_a1hp))","(!((!string_a1hp)))"]
module Spark (sparkGraph, Spark(..)) where
import StdLib
import GRIP
import PSlib
import Graph
import Parse
sparkGraph ordering_aOA selectpes_aOB statFile_aOC
  = initGraph "Spark Activity Graph" (pes_aOE, selectpes_aOB)
      (100 * ticks_aOF, height_aOH)
      ("Time (ms)", "Sparks")
      (map f_aOD ordering_aOA)
      ++
      scale (my_fromInt dimX / my_fromInt 100)
        (my_fromInt dimY / my_fromInt height_aOH)
      ++
      concat
        (map2 plotCurve (map colourSpark order_aOM)
           (outlinesTrace traces_aOI))
  where f_aOD (norecord@a_aOO)
          = (colourSpark a_aOO, displaySpark a_aOO, aggr a_aOO aggs_aOJ)
        ((norecord@pes_aOE), ticks_aOF, orderedStats_aOG)
          = getParameters stats_aON
        height_aOH = axisScale h_aOK
        (norecord@(traces_aOI, ((!aggs_aOJ), h_aOK, (!w_aOL))))
          = akkumulate (processSparks (map extractor order_aOM)) nullstate
              (gatherSp (Sp 0 0 0 0 0) (getSp selectpes_aOB orderedStats_aOG))
        (norecord@order_aOM) = reverse ordering_aOA
        (!stats_aON) = parseFile statFile_aOC

processSparks ::
              [Sparks -> Int] -> State -> Sparks -> (Trace, State)
processSparks extractors_a18e
  (((!c_a18f), (!u_a18g), r_a18h, (!l_a18i)), (!graphmax_a18j), _)
  s_a18k@(norecord@(Sp n_a18l c'_a18m (!u'_a18n) (!r'_a18o) l'_a18p))
  = (trace_a18q,
     ((c'_a18m + c_a18f, u'_a18n + u_a18g, r'_a18o + r_a18h,
       l'_a18p + l_a18i),
      max graphmax_a18j m_a18r, n_a18l))
  where (norecord@trace_a18q@(T _ (norecord@(m_a18r : _))))
          = makeTrace extractors_a18e n_a18l s_a18k
makeTrace (norecord@fs_a18s) n_a18t (norecord@s_a18u)
  = T n_a18t (f_a18v fs_a18s)
  where f_a18v [] = []
        f_a18v (norecord@ex_a18w@(norecord@(e_a18x : es_a18y)))
          = sum (pam ex_a18w s_a18u) : f_a18v es_a18y
nullstate = ((0, 0, 0, 0), 0, 0)

outlinesTrace :: [Trace] -> [[Point]]
outlinesTrace [T n_a18z a_a18A]
  = map (\ (norecord@x_a18B) -> [Pt n_a18z x_a18B]) a_a18A
outlinesTrace (norecord@(T n_a18C a_a18D : more_a18E))
  = map2 (:) (map (\ x_a18F -> Pt n_a18C x_a18F) a_a18D)
      (outlinesTrace more_a18E)
pam [] _ = []
pam (norecord@((!f_a18G) : (!fs_a18H))) a_a18I
  = f_a18G a_a18I : pam fs_a18H a_a18I
gatherSp (!t_a18J) (norecord@[])
  = [t_a18J, (Sp (numberSp t_a18J + 1) 0 0 0 0)]
gatherSp (norecord@t_a18K)
  (norecord@l_a18L@((norecord@((norecord@a_a18M) :
                                 (norecord@as_a18N)))))
  | numberSp t_a18K == numberSp a_a18M =
    gatherSp (addSparks t_a18K a_a18M) as_a18N
  | otherwise = t_a18K : gatherSp (Sp (n_a18O + 1) 0 0 0 0) l_a18L
  where (lazydmd@n_a18O) = numberSp t_a18K
addSparks
  (Sp n_a18P a_a18Q (norecord@b_a18R) c_a18S (norecord@d_a18T))
  (Sp (norecord@_) e_a18U f_a18V (norecord@g_a18W) (norecord@h_a18X))
  = Sp n_a18P (a_a18Q + e_a18U) (b_a18R + f_a18V) (c_a18S + g_a18W)
      (d_a18T + h_a18X)

aggr :: Spark -> (Int, Int, Int, Int) -> String
aggr CREATED ((norecord@i_a18Y), (norecord@_), _, _) = show i_a18Y
aggr (norecord@USED) ((norecord@_), (norecord@r_a1hi), _, _)
  = show r_a1hi
aggr RESUMED (norecord@((norecord@_), _, g_a1hj, (norecord@_)))
  = show g_a1hj
aggr (norecord@LOST) (_, _, _, (norecord@f_a1hk)) = show f_a1hk
extractor LOST = lost
extractor CREATED = created
extractor (norecord@RESUMED) = resumed
extractor (norecord@USED) = used

colourSpark :: Spark -> Int
colourSpark LOST = 8
colourSpark (norecord@CREATED) = 5
colourSpark (norecord@RESUMED) = 2
colourSpark (norecord@USED) = 0

displaySpark :: Spark -> String
displaySpark (norecord@LOST) = "Sparks Lost"
displaySpark (norecord@CREATED) = "Sparks Created"
displaySpark RESUMED = "Resumed Sparks"
displaySpark USED = "Used Sparks"

type State = ((Int, Int, Int, Int), Int, Int)

data Trace = T Int [Int]

data Spark = USED
           | RESUMED
           | CREATED
           | LOST
           deriving Eq

instance Parse Spark where
        parseType (norecord@('L' : string_a1hl)) = (LOST, string_a1hl)
        parseType ((norecord@'C') : string_a1hm) = (CREATED, string_a1hm)
        parseType (norecord@((norecord@('R' : (lazydmd@string_a1hn)))))
          = (RESUMED, string_a1hn)
        parseType ((norecord@'U') : string_a1ho) = (USED, string_a1ho)
        parseType (norecord@((norecord@string_a1hp)))
          = error ("No such Activity : " ++ show string_a1hp ++ "\n")

==================== Renamer ====================
Main.main :: IO ()
Main.main
  = do { args_asE <- getArgs;
         if (length args_asE < 4 || length args_asE > 6) then
             putStr
               (unlines
                  ["Set Circuit Simulator",
                   "scs <file> <seed> <dt> <end time> [<temperature>] [<random background charge>]"])
         else
             do { let [file_aT0,
                       seed'_aT1,
                       dt'_aT2,
                       end_time'_aT3,
                       temperature'_aT4,
                       rbc'_aT5]
                        = take 6 (args_asE ++ ["0", "0"]);
                  input_aWk <- readFile (file_aT0 ++ ".in");
                  let (circuit_aWl, names_aWm)
                        = get_asA
                            (parse_circuit input_aWk) "Syntactic error in circuit description"
                      seed_aWn
                        = get_asA
                            (parse_integer seed'_aT1) ("Can't read seed: " ++ seed'_aT1)
                      dt_aWo
                        = get_asA (parse_exact dt'_aT2) ("Can't read dt: " ++ dt'_aT2)
                      end_time_aWp
                        = get_asA
                            (parse_exact end_time'_aT3)
                            ("Can't read end time: " ++ end_time'_aT3)
                      temperature_aWq
                        = get_asA
                            (parse_approx temperature'_aT4)
                            ("Can't read temperature: " ++ temperature'_aT4)
                      rbc_aWr
                        = get_asA
                            (parse_approx rbc'_aT5)
                            ("Can't read random background charge: " ++ rbc'_aT5)
                      trace_aWs
                        = simulate
                            circuit_aWl seed_aWn dt_aWo end_time_aWp temperature_aWq rbc_aWr
                      output_aWt
                        | dt_aWo <= 0 = error "dt must be positive"
                        | end_time_aWp <= 0 = error "end time must be positive"
                        | temperature_aWq < 0 = error "temperature must be nonnegative"
                        | otherwise = Main.list names_aWm trace_aWs;
                  putStr output_aWt } }
  where
      get_asA [e_asB] _ = e_asB
      get_asA _ s_asC = error s_asC
Main.scs ::
  Name -> Seed -> Time -> Time -> Temperature -> RBC -> IO ()
Main.scs
  file_aWu
  seed_aWv
  dt_aWw
  end_time_aWx
  temperature_aWy
  rbc_aWz
  = do { input_aWA <- readFile (file_aWu ++ ".in");
         let (circuit_aWB, names_aWC) = head (parse_circuit input_aWA)
             trace_aWD
               = simulate
                   circuit_aWB seed_aWv dt_aWw end_time_aWx temperature_aWy rbc_aWz
             output_aWE = Main.list names_aWC trace_aWD;
         putStr output_aWE }
Main.list :: [Name] -> [(Time, Vector Approx)] -> String
Main.list names_aWF trace_aWG
  = unlines (header_aWH : results_aWI)
  where
      header_aWH = "t:Time\t" ++ show (tail names_aWF)
      results_aWI
        = map
            (\ (t_a158, v_a159)
               -> (show . circa) t_a158 ++ "\t" ++ (show . elems) v_a159)
            trace_aWG



==================== Renamer ====================
LinearAlgebra.apply ::
  Num a_aqO => Matrix a_aqO -> Vector a_aqO -> Vector a_aqO
LinearAlgebra.apply m_aqP v_aqQ
  | cm_aqS == cv_aqT
  = accumArray
      (+)
      0
      (1, rm_aqR)
      [(r_aMn, v_aqQ ! c_aMo * m_aqP ! (r_aMn, c_aMo)) |
         (r_aMn, c_aMo) <- indices m_aqP]
  | otherwise
  = error "apply: matrix and vector dimensions are not compatible"
  where
      ((1, 1), (rm_aqR, cm_aqS)) = bounds m_aqP
      (1, cv_aqT) = bounds v_aqQ
LinearAlgebra.m_mul ::
  Num a_aqN => Matrix a_aqN -> Matrix a_aqN -> Matrix a_aqN
LinearAlgebra.m_mul a_aMq b_aMr
  | ca_aMt == rb_aMu
  = accumArray
      (+)
      0
      ((1, 1), (ra_aMs, cb_aMv))
      [((r_aMw, c_aMy), 
        a_aMq ! (r_aMw, t_aMx) * b_aMr ! (t_aMx, c_aMy)) |
         r_aMw <- [1 .. ra_aMs],
         t_aMx <- [1 .. ca_aMt],
         c_aMy <- [1 .. cb_aMv]]
  | otherwise = error "m_mul: matrix dimensions are not compatible"
  where
      ((1, 1), (ra_aMs, ca_aMt)) = bounds a_aMq
      ((1, 1), (rb_aMu, cb_aMv)) = bounds b_aMr
LinearAlgebra.m_add ::
  Num a_aqM => Matrix a_aqM -> Matrix a_aqM -> Matrix a_aqM
LinearAlgebra.m_add = LinearAlgebra.m_zipWith (+)
LinearAlgebra.m_sub ::
  Num a_aqL => Matrix a_aqL -> Matrix a_aqL -> Matrix a_aqL
LinearAlgebra.m_sub = LinearAlgebra.m_zipWith (-)
LinearAlgebra.m_map ::
  (a_aqJ -> b_aqK) -> Matrix a_aqJ -> Matrix b_aqK
LinearAlgebra.m_map f_aMz a_aMA
  = listArray (bounds a_aMA) (map f_aMz (elems a_aMA))
LinearAlgebra.m_zipWith ::
  (a_aqG -> b_aqH -> c_aqI)
  -> Matrix a_aqG -> Matrix b_aqH -> Matrix c_aqI
LinearAlgebra.m_zipWith f_aMB a_aMC b_aMD
  | compatible_aME
  = listArray
      (bounds a_aMC) (zipWith f_aMB (elems a_aMC) (elems b_aMD))
  | otherwise
  = error "m_zipWith: matrix dimensions are not compatible"
  where
      compatible_aME = bounds a_aMC == bounds b_aMD
LinearAlgebra.v_add ::
  Num a_aqF => Vector a_aqF -> Vector a_aqF -> Vector a_aqF
LinearAlgebra.v_add = LinearAlgebra.v_zipWith (+)
LinearAlgebra.v_sub ::
  Num a_aqE => Vector a_aqE -> Vector a_aqE -> Vector a_aqE
LinearAlgebra.v_sub = LinearAlgebra.v_zipWith (-)
LinearAlgebra.v_map ::
  (a_aqC -> b_aqD) -> Vector a_aqC -> Vector b_aqD
LinearAlgebra.v_map f_aQd a_aQe
  = listArray (bounds a_aQe) (map f_aQd (elems a_aQe))
LinearAlgebra.v_zipWith f_aQf a_aQg b_aQh
  | compatible_aQi
  = listArray
      (bounds a_aQg) (zipWith f_aQf (elems a_aQg) (elems b_aQh))
  | otherwise
  = error "v_zipWith: vector dimensions are not compatible"
  where
      compatible_aQi = bounds a_aQg == bounds b_aQh
LinearAlgebra.m_transpose :: Matrix a_aqB -> Matrix a_aqB
LinearAlgebra.m_transpose m_aQj
  = let ((1, 1), (r_aQk, c_aQl)) = bounds m_aQj
    in
      array
        ((1, 1), (c_aQl, r_aQk))
        [((c_aQn, r_aQm), v_aQo) | ((r_aQm, c_aQn), v_aQo) <- assocs m_aQj]
LinearAlgebra.m_is_square :: Matrix a_aqt -> Bool
LinearAlgebra.m_is_square m_aQp
  = let ((1, 1), (r_aQq, c_aQr)) = bounds m_aQp in r_aQq == c_aQr
LinearAlgebra.m_zero :: Num a_aqs => Index -> Matrix a_aqs
LinearAlgebra.m_zero s_aQs
  = accumArray (+) 0 ((1, 1), (s_aQs, s_aQs)) []
LinearAlgebra.m_unit :: Num a_apt => Index -> Matrix a_apt
LinearAlgebra.m_unit s_aQt
  = accumArray
      (+)
      0
      ((1, 1), (s_aQt, s_aQt))
      [((i_aQu, i_aQu), 1) | i_aQu <- [1 .. s_aQt]]
LinearAlgebra.nullspace :: Matrix Exact -> Matrix Exact
LinearAlgebra.nullspace
  = LinearAlgebra.m_transpose
    . LinearAlgebra.left_nullspace . LinearAlgebra.m_transpose
LinearAlgebra.left_nullspace :: Matrix Exact -> Matrix Exact
LinearAlgebra.left_nullspace m_aQv
  = let (rows_aQw, _, i_aQx) = LinearAlgebra.gauss_jordan m_aQv
    in LinearAlgebra.m_select_rows rows_aQw i_aQx
LinearAlgebra.m_select_rows ::
  [Index] -> Matrix a_aps -> Matrix a_aps
LinearAlgebra.m_select_rows rows_aQy matrix_aQz
  = listArray
      ((1, 1), (length rows_aQy, size_aQA))
      [matrix_aQz ! (r_aWr, c_aWs) |
         r_aWr <- rows_aQy, c_aWs <- [1 .. size_aQA]]
  where
      size_aQA = (snd . snd . bounds) matrix_aQz
LinearAlgebra.m_inv :: Matrix Exact -> Matrix Exact
LinearAlgebra.m_inv m_aWt
  | l_aWu == [] = i_aWw
  | otherwise = error "m_inv: matrix isn't invertible"
  where
      (l_aWu, u_aWv, i_aWw) = LinearAlgebra.gauss_jordan m_aWt
      ((1, 1), (r_aWx, c_aWy)) = bounds m_aWt
LinearAlgebra.gauss_jordan ::
  Matrix Exact -> ([Index], Matrix Exact, Matrix Exact)
LinearAlgebra.gauss_jordan m_aWz
  | LinearAlgebra.m_is_square m_aWz
  = (foldr1
       (.) [step_aWA c_a18x | c_a18x <- reverse [1 .. size_aWG]])
      ([1 .. size_aWG], m_aWz, LinearAlgebra.m_unit size_aWG)
  | otherwise = error "gauss_jordan: not a square matrix"
  where
      step_aWA c_aWH (rs_aWI, m0_aWJ, i0_aWK)
        = if v_aWS /= 0 then
              (delete c_aWH rs_aWI, m2_aWL, i2_aWM)
          else
              (rs_aWI, m0_aWJ, i0_aWK)
        where
            (m2_aWL, i2_aWM) = (sweep_aWQ m1_aWN, sweep_aWQ i1_aWO)
            (m1_aWN, i1_aWO) = (swap_norm_aWP m0_aWJ, swap_norm_aWP i0_aWK)
            swap_norm_aWP
              = (multiply_aWE c_aWH (1 / v_aWS))
                . (if r_aWR /= c_aWH then swap_aWD r_aWR c_aWH else id)
            sweep_aWQ = eliminate_aWF c_aWH m1_aWN
            (r_aWR, v_aWS) = pivot_aWB c_aWH rs_aWI m0_aWJ
      pivot_aWB c_a18c rs_a18d m0_a18e
        = foldl1
            max'_aWC [(r_a18f, m0_a18e ! (r_a18f, c_a18c)) | r_a18f <- rs_a18d]
      max'_aWC (r1_a18g, v1_a18h) (r2_a18i, v2_a18j)
        = if (abs (v1_a18h) >= abs (v2_a18j)) then
              (r1_a18g, v1_a18h)
          else
              (r2_a18i, v2_a18j)
      swap_aWD r_a18k s_a18l m_a18m
        = m_a18m
          //
            concat
              ([[((r_a18k, c_a18n), m_a18m ! (s_a18l, c_a18n)),
                 ((s_a18l, c_a18n), m_a18m ! (r_a18k, c_a18n))] |
                  c_a18n <- [1 .. size_aWG]])
      multiply_aWE r_a18o f_a18p m_a18q
        = m_a18q
          //
            [((r_a18o, c_a18r), f_a18p * m_a18q ! (r_a18o, c_a18r)) |
               c_a18r <- [1 .. size_aWG]]
      eliminate_aWF w_a18s m1_a18t m_a18u
        = m_a18u
          //
            [((r_a18v, c_a18w), 
              m_a18u ! (r_a18v, c_a18w)
              - m1_a18t ! (r_a18v, w_a18s) * m_a18u ! (w_a18s, c_a18w)) |
               r_a18v <- [1 .. size_aWG],
               r_a18v /= w_a18s,
               c_a18w <- [1 .. size_aWG]]
      size_aWG = (snd . snd . bounds) m_aWz


["m_aqP","v_aqQ","r_aMn","c_aMo","(r_aMn, c_aMo)","1","1","(1, 1)","rm_aqR","cm_aqS","(rm_aqR, cm_aqS)","((1, 1), (rm_aqR, cm_aqS))","1","cv_aqT","(1, cv_aqT)","a_aMq","b_aMr","r_aMw","t_aMx","c_aMy","1","1","(1, 1)","ra_aMs","ca_aMt","(ra_aMs, ca_aMt)","((1, 1), (ra_aMs, ca_aMt))","1","1","(1, 1)","rb_aMu","cb_aMv","(rb_aMu, cb_aMv)","((1, 1), (rb_aMu, cb_aMv))","m_add","m_sub","f_aMz","a_aMA","f_aMB","a_aMC","b_aMD","compatible_aME","v_add","v_sub","f_aQd","a_aQe","f_aQf","a_aQg","b_aQh","compatible_aQi","m_aQj","1","1","(1, 1)","r_aQk","c_aQl","(r_aQk, c_aQl)","((1, 1), (r_aQk, c_aQl))","r_aQm","c_aQn","(r_aQm, c_aQn)","v_aQo","((r_aQm, c_aQn), v_aQo)","m_aQp","1","1","(1, 1)","r_aQq","c_aQr","(r_aQq, c_aQr)","((1, 1), (r_aQq, c_aQr))","s_aQs","s_aQt","i_aQu","nullspace","m_aQv","rows_aQw","_","i_aQx","(rows_aQw, _, i_aQx)","rows_aQy","matrix_aQz","r_aWr","c_aWs","size_aQA","m_aWt","l_aWu","u_aWv","i_aWw","(l_aWu, u_aWv, i_aWw)","1","1","(1, 1)","r_aWx","c_aWy","(r_aWx, c_aWy)","((1, 1), (r_aWx, c_aWy))","m_aWz","c_a18x","c_aWH","rs_aWI","m0_aWJ","i0_aWK","(rs_aWI, m0_aWJ, i0_aWK)","m2_aWL","i2_aWM","(m2_aWL, i2_aWM)","m1_aWN","i1_aWO","(m1_aWN, i1_aWO)","swap_norm_aWP","sweep_aWQ","r_aWR","v_aWS","(r_aWR, v_aWS)","c_a18c","rs_a18d","m0_a18e","r_a18f","r1_a18g","v1_a18h","(r1_a18g, v1_a18h)","r2_a18i","v2_a18j","(r2_a18i, v2_a18j)","r_a18k","s_a18l","m_a18m","c_a18n","r_a18o","f_a18p","m_a18q","c_a18r","w_a18s","m1_a18t","m_a18u","r_a18v","c_a18w","size_aWG"]
module LinearAlgebra where
import Data.Array
import Data.List
import Types

apply :: Num a_aqO => Matrix a_aqO -> Vector a_aqO -> Vector a_aqO
apply m_aqP v_aqQ
  | cm_aqS == cv_aqT =
    accumArray (+) 0 (1, rm_aqR)
      [(r_aMn, v_aqQ ! c_aMo * m_aqP ! (r_aMn, c_aMo)) |
       (r_aMn, c_aMo) <- indices m_aqP]
  | otherwise =
    error "apply: matrix and vector dimensions are not compatible"
  where ((1, 1), (rm_aqR, cm_aqS)) = bounds m_aqP
        (1, cv_aqT) = bounds v_aqQ

m_mul :: Num a_aqN => Matrix a_aqN -> Matrix a_aqN -> Matrix a_aqN
m_mul a_aMq b_aMr
  | ca_aMt == rb_aMu =
    accumArray (+) 0 ((1, 1), (ra_aMs, cb_aMv))
      [((r_aMw, c_aMy), a_aMq ! (r_aMw, t_aMx) * b_aMr ! (t_aMx, c_aMy))
       | r_aMw <- [1 .. ra_aMs], t_aMx <- [1 .. ca_aMt],
       c_aMy <- [1 .. cb_aMv]]
  | otherwise = error "m_mul: matrix dimensions are not compatible"
  where ((1, 1), (ra_aMs, ca_aMt)) = bounds a_aMq
        ((1, 1), (rb_aMu, cb_aMv)) = bounds b_aMr

m_add :: Num a_aqM => Matrix a_aqM -> Matrix a_aqM -> Matrix a_aqM
m_add = m_zipWith (+)

m_sub :: Num a_aqL => Matrix a_aqL -> Matrix a_aqL -> Matrix a_aqL
m_sub = m_zipWith (-)

m_map :: (a_aqJ -> b_aqK) -> Matrix a_aqJ -> Matrix b_aqK
m_map f_aMz a_aMA
  = listArray (bounds a_aMA) (map f_aMz (elems a_aMA))

m_zipWith ::
          (a_aqG -> b_aqH -> c_aqI) ->
            Matrix a_aqG -> Matrix b_aqH -> Matrix c_aqI
m_zipWith f_aMB a_aMC b_aMD
  | compatible_aME =
    listArray (bounds a_aMC)
      (zipWith f_aMB (elems a_aMC) (elems b_aMD))
  | otherwise =
    error "m_zipWith: matrix dimensions are not compatible"
  where compatible_aME = bounds a_aMC == bounds b_aMD

v_add :: Num a_aqF => Vector a_aqF -> Vector a_aqF -> Vector a_aqF
v_add = v_zipWith (+)

v_sub :: Num a_aqE => Vector a_aqE -> Vector a_aqE -> Vector a_aqE
v_sub = v_zipWith (-)

v_map :: (a_aqC -> b_aqD) -> Vector a_aqC -> Vector b_aqD
v_map f_aQd a_aQe
  = listArray (bounds a_aQe) (map f_aQd (elems a_aQe))
v_zipWith f_aQf a_aQg b_aQh
  | compatible_aQi =
    listArray (bounds a_aQg)
      (zipWith f_aQf (elems a_aQg) (elems b_aQh))
  | otherwise =
    error "v_zipWith: vector dimensions are not compatible"
  where compatible_aQi = bounds a_aQg == bounds b_aQh

m_transpose :: Matrix a_aqB -> Matrix a_aqB
m_transpose m_aQj
  = let ((1, 1), (r_aQk, c_aQl)) = bounds m_aQj in
      array ((1, 1), (c_aQl, r_aQk))
        [((c_aQn, r_aQm), v_aQo) | ((r_aQm, c_aQn), v_aQo) <- assocs m_aQj]

m_is_square :: Matrix a_aqt -> Bool
m_is_square m_aQp
  = let ((1, 1), (r_aQq, c_aQr)) = bounds m_aQp in r_aQq == c_aQr

m_zero :: Num a_aqs => Index -> Matrix a_aqs
m_zero s_aQs = accumArray (+) 0 ((1, 1), (s_aQs, s_aQs)) []

m_unit :: Num a_apt => Index -> Matrix a_apt
m_unit s_aQt
  = accumArray (+) 0 ((1, 1), (s_aQt, s_aQt))
      [((i_aQu, i_aQu), 1) | i_aQu <- [1 .. s_aQt]]

nullspace :: Matrix Exact -> Matrix Exact
nullspace = m_transpose . left_nullspace . m_transpose

left_nullspace :: Matrix Exact -> Matrix Exact
left_nullspace m_aQv
  = let (rows_aQw, _, i_aQx) = gauss_jordan m_aQv in
      m_select_rows rows_aQw i_aQx

m_select_rows :: [Index] -> Matrix a_aps -> Matrix a_aps
m_select_rows rows_aQy matrix_aQz
  = listArray ((1, 1), (length rows_aQy, size_aQA))
      [matrix_aQz ! (r_aWr, c_aWs) | r_aWr <- rows_aQy,
       c_aWs <- [1 .. size_aQA]]
  where size_aQA = (snd . snd . bounds) matrix_aQz

m_inv :: Matrix Exact -> Matrix Exact
m_inv m_aWt
  | l_aWu == [] = i_aWw
  | otherwise = error "m_inv: matrix isn't invertible"
  where (l_aWu, u_aWv, i_aWw) = gauss_jordan m_aWt
        ((1, 1), (r_aWx, c_aWy)) = bounds m_aWt

gauss_jordan ::
             Matrix Exact -> ([Index], Matrix Exact, Matrix Exact)
gauss_jordan m_aWz
  | m_is_square m_aWz =
    (foldr1 (.) [step_aWA c_a18x | c_a18x <- reverse [1 .. size_aWG]])
      ([1 .. size_aWG], m_aWz, m_unit size_aWG)
  | otherwise = error "gauss_jordan: not a square matrix"
  where step_aWA c_aWH (rs_aWI, m0_aWJ, i0_aWK)
          = if v_aWS /= 0 then (delete c_aWH rs_aWI, m2_aWL, i2_aWM) else
              (rs_aWI, m0_aWJ, i0_aWK)
          where (m2_aWL, i2_aWM) = (sweep_aWQ m1_aWN, sweep_aWQ i1_aWO)
                (m1_aWN, i1_aWO) = (swap_norm_aWP m0_aWJ, swap_norm_aWP i0_aWK)
                swap_norm_aWP
                  = (multiply_aWE c_aWH (1 / v_aWS)) .
                      (if r_aWR /= c_aWH then swap_aWD r_aWR c_aWH else id)
                sweep_aWQ = eliminate_aWF c_aWH m1_aWN
                (r_aWR, v_aWS) = pivot_aWB c_aWH rs_aWI m0_aWJ
        pivot_aWB c_a18c rs_a18d m0_a18e
          = foldl1 max'_aWC
              [(r_a18f, m0_a18e ! (r_a18f, c_a18c)) | r_a18f <- rs_a18d]
        max'_aWC (r1_a18g, v1_a18h) (r2_a18i, v2_a18j)
          = if (abs (v1_a18h) >= abs (v2_a18j)) then (r1_a18g, v1_a18h) else
              (r2_a18i, v2_a18j)
        swap_aWD r_a18k s_a18l m_a18m
          = m_a18m //
              concat
                ([[((r_a18k, c_a18n), m_a18m ! (s_a18l, c_a18n)),
                   ((s_a18l, c_a18n), m_a18m ! (r_a18k, c_a18n))]
                  | c_a18n <- [1 .. size_aWG]])
        multiply_aWE r_a18o f_a18p m_a18q
          = m_a18q //
              [((r_a18o, c_a18r), f_a18p * m_a18q ! (r_a18o, c_a18r)) |
               c_a18r <- [1 .. size_aWG]]
        eliminate_aWF w_a18s m1_a18t m_a18u
          = m_a18u //
              [((r_a18v, c_a18w),
                m_a18u ! (r_a18v, c_a18w) - m1_a18t ! (r_a18v, w_a18s) * m_a18u !
                  (w_a18s, c_a18w))
               | r_a18v <- [1 .. size_aWG], r_a18v /= w_a18s,
               c_a18w <- [1 .. size_aWG]]
        size_aWG = (snd . snd . bounds) m_aWz

==================== Renamer ====================
Simulate.simulate ::
  Circuit
  -> Seed -> Time -> Time -> Temperature -> RBC -> [(Time, Output)]
Simulate.simulate
  circuit_aqH
  seed_aqI
  dt_aqJ
  end_time_aqK
  temp_aqL
  rbc_aqM
  = select_aqN trace_aqO
  where
      select_aqN
        = takeWhile (\ (t_auC, _) -> t_auC <= end_time_aqK)
          . map (\ (t_aI4, s_aI5, o_aI6, r_aI7) -> (t_aI4, o_aI6))
      trace_aqO
        = (concat . iterate step_aqP)
            ((tunnel_ar3 . correct_ar1 . solve_aqZ . sources_ar2)
               (0, initial'_aqU, initial'_aqU, randoms_aqQ))
      step_aqP
        = tunnel_ar3
          . correct_ar1 . solve_aqZ . sources_ar2 . integrate_ar0 . last
      randoms_aqQ
        = map
            ((/ (2 ^ 30)) . fromInteger) (random (0, 2 ^ 30 - 1) seed_aqI)
      e_aqR = 1.6021773e-19
      k_aqS = 1.38066e-23
      dt'_aqT = circa dt_aqJ
      (initial'_aqU,
       solve'_aqV,
       integrate'_aqW,
       correct_state'_aqX,
       backdate'_aqY)
        = Simulate.prepare circuit_aqH dt_aqJ
      solve_aqZ (t_aXZ, s_aY0, o_aY1, r_aY2)
        = (t_aXZ, s_aY0, apply solve'_aqV s_aY0, r_aY2)
      integrate_ar0 (t_aY3, s_aY4, o_aY5, r_aY6)
        = (t_aY3 + dt_aqJ, apply integrate'_aqW s_aY4, o_aY5, r_aY6)
      correct_ar1 (t_aY7, s_aY8, o_aY9, r_aYa)
        = (t_aY7, apply correct_state'_aqX s_aY8, 
           v_sub o_aY9 (apply backdate'_aqY s_aY8), r_aYa)
      sources_ar2 (t_aYb, s_aYc, o_aYd, r_aYe)
        = (t_aYb, random_offsets_aYg // map elements_aYf circuit_aqH, 
           o_aYd, drop size_aYh r_aYe)
        where
            elements_aYf (i_aYk, p_aYl, m_aYm, Conductor _) = (i_aYk, 0)
            elements_aYf (i_aYn, p_aYo, m_aYp, Resistor _) = (i_aYn, 0)
            elements_aYf (i_aYq, p_aYr, m_aYs, Capacitor _)
              = (i_aYq, s_aYc ! i_aYq)
            elements_aYf (i_a16k, p_a16l, m_a16m, Inductor _)
              = (i_a16k, s_aYc ! i_a16k)
            elements_aYf (i_a16n, p_a16o, m_a16p, Vsource list_a16q)
              = (i_a16n, source_aYj list_a16q)
            elements_aYf (i_a16r, p_a16s, m_a16t, Isource list_a16u)
              = (i_a16r, source_aYj list_a16u)
            elements_aYf (i_a16v, p_a16w, m_a16x, Junction _)
              = (i_a16v, s_aYc ! i_a16v)
            random_offsets_aYg
              = listArray
                  (1, size_aYh)
                  (map
                     ((/ dt'_aqT) . (* e_aqR) . (* rbc_aqM) . (* 2) . (+ (- 0.5)))
                     r_aYe)
            (1, size_aYh) = bounds s_aYc
            t'_aYi = circa t_aYb
            source_aYj [(t0_a16y, v0_a16z)] = v0_a16z
            source_aYj ((t0_a16A, v0_a16B) : _) | t'_aYi < t0_a16A = v0_a16B
            source_aYj ((t0_a16J, v0_a16K) : (t1_a16L, v1_a16M) : rest_a16N)
              | t0_a16J >= t1_a16L = error "sources must have increasing times"
              | t'_aYi < t1_a16L
              = v0_a16K
                + (v1_a16M - v0_a16K) * (t'_aYi - t0_a16J) / (t1_a16L - t0_a16J)
              | otherwise = source_aYj ((t1_a16L, v1_a16M) : rest_a16N)
      tunnel_ar3 (t_a16P, s_a16Q, o_a16R, r_a16S)
        = select_a176 (zip cumulative_probabilities_a175 new_states_a16Z)
        where
            e2_a16T = e_aqR * e_aqR
            kT_a16U = k_aqS * temp_aqL
            e0_a16V = energy_state_a16W s_a16Q
            energy_state_a16W s_a17c
              = sum (map (energy_state'_a179 s_a17c) circuit_aqH)
            energy_source_a16X s_a17d o_a17e
              = sum (map (energy_source'_a17a s_a17d o_a17e) circuit_aqH)
            events_a16Y = (concat . map events'_a17b) circuit_aqH
            new_states_a16Z = map (\ (_, s_a17f, _, _) -> s_a17f) events_a16Y
            delta_energies_a170
              = map
                  ((\ (r_a17g, s_a17h, o_a17i, _)
                      -> (r_a17g, 
                          energy_state_a16W s_a17h - e0_a16V
                          + energy_source_a16X s_a17h o_a17i))
                   . correct_ar1)
                  events_a16Y
            probabilities_a171
              = limit_total_a174
                  (map (no_negative_a173 . probability_a172) delta_energies_a170)
            probability_a172 (r_a17j, de_a17k)
              | r_a17j == 0
              = error
                  "tunnel resistance must be nonzero (and should be >> 26k anyway)"
              | temp_aqL == 0 = dt'_aqT * (- de_a17k) / (e2_a16T * circa r_a17j)
              | de_a17k == 0 = dt'_aqT * kT_a16U / (e2_a16T * circa r_a17j)
              | otherwise
              = dt'_aqT * (- de_a17k)
                / (e2_a16T * circa r_a17j * (1 - exp (de_a17k / kT_a16U)))
            no_negative_a173 p_a17l = if p_a17l < 0 then 0 else p_a17l
            limit_total_a174 ps_a17m
              = let total_a17n = sum ps_a17m
                in if total_a17n > 1 then map (/ total_a17n) ps_a17m else ps_a17m
            cumulative_probabilities_a175
              = tail (scanl (+) 0 probabilities_a171)
            select_a176 [] = [(t_a16P, s_a16Q, o_a16R, r'_a178)]
            select_a176 ((p'_a17o, s'_a17p) : zs_a17q)
              | p_a177 < p'_a17o
              = [(t_a16P, s_a16Q, o_a16R, r'_a178),
                 (correct_ar1 . solve_aqZ) (t_a16P, s'_a17p, o_a16R, r'_a178)]
              | otherwise = select_a176 zs_a17q
            (p_a177 : r'_a178) = r_a16S
            energy_state'_a179
              s_a17r
              (i_a17s, p_a17t, m_a17u, Capacitor (c_a17v, _))
              | c_a17v == 0 = error "capacitance must be nonzero"
              | otherwise = 1 / 2 * (s_a17r ! i_a17s) ^ 2 / circa c_a17v
            energy_state'_a179
              s_a17w
              (i_a17x, p_a17y, m_a17z, Junction (c_a17A, _, _))
              | c_a17A == 0 = error "junction capacitance must be nonzero"
              | otherwise = 1 / 2 * (s_a17w ! i_a17x) ^ 2 / circa c_a17A
            energy_state'_a179 _ _ = 0
            energy_source'_a17a
              s_a17B
              o_a17C
              (i_a17D, p_a17E, m_a17F, Vsource _)
              = (s_a17B ! i_a17D) * (o_a17C ! i_a17D) * dt'_aqT
            energy_source'_a17a _ _ _ = 0
            events'_a17b (i_a17G, p_a17H, m_a17I, Junction (c_a17J, r_a17K, _))
              = [(r_a17K, s_a16Q // [(i_a17G, s_a16Q ! i_a17G + e_aqR)], 
                  v_map (const 0) o_a16R, []),
                 (r_a17K, s_a16Q // [(i_a17G, s_a16Q ! i_a17G - e_aqR)], 
                  v_map (const 0) o_a16R, [])]
            events'_a17b _ = []
Simulate.prepare ::
  Circuit
  -> Time
     -> (Vector Approx,
         Matrix Approx,
         Matrix Approx,
         Matrix Approx,
         Matrix Approx)
Simulate.prepare circuit_a17L dt_a17M
  = (v_map circa initial_a17P, m_map circa solve_a185, 
     m_map circa integrate_a18a, m_map circa correct_state_a183, 
     m_map circa backdate_a18b)
  where
      elements_a17N = matrix_a18c element_a18e
      derivative_a17O = matrix_a18c deriv_a18f
      initial_a17P = vector_a18d init_a18g
      (l1_a17Q, u1_a17R, i1_a17S) = gauss_jordan elements_a17N
      (l2_a17T, u2_a17U, i2_a17V)
        = gauss_jordan (m_transpose elements_a17N)
      constraint_a17W = m_select_rows l1_a17Q i1_a17S
      freedom_a17X = m_transpose (m_select_rows l2_a17T i2_a17V)
      (l3_a17Y, u3_a17Z, i3_a180)
        = gauss_jordan
            (m_mul constraint_a17W (m_mul derivative_a17O freedom_a17X))
      inverse3_a181
        | l3_a17Y == [] = i3_a180
        | otherwise = error "illegal circuit"
      correct_a182
        | l1_a17Q == [] = m_zero size_a18i
        | otherwise
        = m_mul freedom_a17X (m_mul inverse3_a181 constraint_a17W)
      correct_state_a183
        = m_sub (m_unit size_a18i) (m_mul derivative_a17O correct_a182)
      correct_output_a184
        = m_sub (m_unit size_a18i) (m_mul correct_a182 derivative_a17O)
      solve_a185
        = m_mul correct_output_a184 (m_mul i1_a17S correct_state_a183)
      scaled_derivative_a186
        = m_map (* (dt_a17M / 2)) (m_mul derivative_a17O solve_a185)
      (l4_a187, u4_a188, i4_a189)
        = gauss_jordan (m_sub (m_unit size_a18i) scaled_derivative_a186)
      integrate_a18a
        | l4_a187 == []
        = m_mul i4_a189 (m_add (m_unit size_a18i) scaled_derivative_a186)
        | otherwise = error "unlucky choice of dt - try a smaller one"
      backdate_a18b = m_map (/ dt_a17M) correct_a182
      matrix_a18c f_a18j
        = accumArray
            (+)
            (0 % 1)
            ((1, 1), (size_a18i, size_a18i))
            ((filter no_ground_a18h . concat . map f_a18j) circuit_a17L)
      vector_a18d f_a18k
        = accumArray
            (+) (0 % 1) (1, size_a18i) ((concat . map f_a18k) circuit_a17L)
      element_a18e (i_a18l, p_a18m, m_a18n, Conductor g_a18o)
        = [((p_a18m, i_a18l), - 1 % 1), ((m_a18n, i_a18l), 1 % 1),
           ((i_a18l, m_a18n), - g_a18o), ((i_a18l, p_a18m), g_a18o),
           ((i_a18l, i_a18l), - 1 % 1)]
      element_a18e (i_a18p, p_a18q, m_a18r, Resistor r_a18s)
        = [((p_a18q, i_a18p), - 1 % 1), ((m_a18r, i_a18p), 1 % 1),
           ((i_a18p, m_a18r), - 1 % 1), ((i_a18p, p_a18q), 1 % 1),
           ((i_a18p, i_a18p), - r_a18s)]
      element_a18e (i_a18t, p_a18u, m_a18v, Capacitor (c_a18w, _))
        = [((p_a18u, i_a18t), - 1 % 1), ((m_a18v, i_a18t), 1 % 1),
           ((i_a18t, m_a18v), - c_a18w), ((i_a18t, p_a18u), c_a18w)]
      element_a18e (i_a18x, p_a18y, m_a18z, Inductor (l_a18A, _))
        = [((p_a18y, i_a18x), - 1 % 1), ((m_a18z, i_a18x), 1 % 1),
           ((i_a18x, i_a18x), l_a18A)]
      element_a18e (i_a18B, p_a18C, m_a18D, Vsource _)
        = [((p_a18C, i_a18B), - 1 % 1), ((m_a18D, i_a18B), 1 % 1),
           ((i_a18B, m_a18D), - 1 % 1), ((i_a18B, p_a18C), 1 % 1)]
      element_a18e (i_a18E, p_a18F, m_a18G, Isource _)
        = [((p_a18F, i_a18E), - 1 % 1), ((m_a18G, i_a18E), 1 % 1),
           ((i_a18E, i_a18E), 1 % 1)]
      element_a18e (i_a18H, p_a18I, m_a18J, Junction (c_a18K, _, _))
        = [((p_a18I, i_a18H), - 1 % 1), ((m_a18J, i_a18H), 1 % 1),
           ((i_a18H, m_a18J), - c_a18K), ((i_a18H, p_a18I), c_a18K)]
      deriv_a18f (i_a18L, p_a18M, m_a18N, Conductor _) = []
      deriv_a18f (i_a18O, p_a18P, m_a18Q, Resistor _) = []
      deriv_a18f (i_a18R, p_a18S, m_a18T, Capacitor (_, _))
        = [((i_a18R, i_a18R), 1)]
      deriv_a18f (i_a18U, p_a18V, m_a18W, Inductor (_, _))
        = [((i_a18U, p_a18V), 1), ((i_a18U, m_a18W), - 1)]
      deriv_a18f (i_a18X, p_a18Y, m_a18Z, Vsource _) = []
      deriv_a18f (i_a190, p_a191, m_a192, Isource _) = []
      deriv_a18f (i_a193, p_a194, m_a195, Junction (_, _, _))
        = [((i_a193, i_a193), 1)]
      init_a18g (i_a196, p_a197, m_a198, Conductor _) = []
      init_a18g (i_a199, p_a19a, m_a19b, Resistor _) = []
      init_a18g (i_a19c, p_a19d, m_a19e, Capacitor (_, q_a19f))
        = [(i_a19c, q_a19f)]
      init_a18g (i_a19g, p_a19h, m_a19i, Inductor (_, f_a19j))
        = [(i_a19g, f_a19j)]
      init_a18g (i_a19k, p_a19l, m_a19m, Vsource _) = []
      init_a18g (i_a19n, p_a19o, m_a19p, Isource _) = []
      init_a18g (i_a19q, p_a19r, m_a19s, Junction (_, _, q_a19t))
        = [(i_a19q, q_a19t)]
      no_ground_a18h ((r_a19u, c_a19v), _) = r_a19u /= 0 && c_a19v /= 0
      size_a18i
        = maximum
            (concat
               (map
                  (\ (p_a19w, m_a19x, i_a19y, _) -> [p_a19w, m_a19x, i_a19y])
                  circuit_a17L))


["circuit_aqH","seed_aqI","dt_aqJ","end_time_aqK","temp_aqL","rbc_aqM","select_aqN","t_auC","_","(t_auC, _)","t_aI4","s_aI5","o_aI6","r_aI7","(t_aI4, s_aI5, o_aI6, r_aI7)","trace_aqO","step_aqP","randoms_aqQ","e_aqR","k_aqS","dt'_aqT","initial'_aqU","solve'_aqV","integrate'_aqW","correct_state'_aqX","backdate'_aqY","(initial'_aqU, solve'_aqV, integrate'_aqW, correct_state'_aqX,\n backdate'_aqY)","t_aXZ","s_aY0","o_aY1","r_aY2","(t_aXZ, s_aY0, o_aY1, r_aY2)","t_aY3","s_aY4","o_aY5","r_aY6","(t_aY3, s_aY4, o_aY5, r_aY6)","t_aY7","s_aY8","o_aY9","r_aYa","(t_aY7, s_aY8, o_aY9, r_aYa)","t_aYb","s_aYc","o_aYd","r_aYe","(t_aYb, s_aYc, o_aYd, r_aYe)","i_aYk","p_aYl","m_aYm","_","Conductor _","(i_aYk, p_aYl, m_aYm, Conductor _)","i_aYn","p_aYo","m_aYp","_","Resistor _","(i_aYn, p_aYo, m_aYp, Resistor _)","i_aYq","p_aYr","m_aYs","_","Capacitor _","(i_aYq, p_aYr, m_aYs, Capacitor _)","i_a16k","p_a16l","m_a16m","_","Inductor _","(i_a16k, p_a16l, m_a16m, Inductor _)","i_a16n","p_a16o","m_a16p","list_a16q","Vsource list_a16q","(i_a16n, p_a16o, m_a16p, Vsource list_a16q)","i_a16r","p_a16s","m_a16t","list_a16u","Isource list_a16u","(i_a16r, p_a16s, m_a16t, Isource list_a16u)","i_a16v","p_a16w","m_a16x","_","Junction _","(i_a16v, p_a16w, m_a16x, Junction _)","random_offsets_aYg","1","size_aYh","(1, size_aYh)","t'_aYi","t0_a16y","v0_a16z","(t0_a16y, v0_a16z)","[(t0_a16y, v0_a16z)]","t0_a16A","v0_a16B","(t0_a16A, v0_a16B)","_","(t0_a16A, v0_a16B) : _","((t0_a16A, v0_a16B) : _)","t0_a16J","v0_a16K","(t0_a16J, v0_a16K)","t1_a16L","v1_a16M","(t1_a16L, v1_a16M)","(t0_a16J, v0_a16K) : (t1_a16L, v1_a16M)","rest_a16N","((t0_a16J, v0_a16K) : (t1_a16L, v1_a16M)) : rest_a16N","(((t0_a16J, v0_a16K) : (t1_a16L, v1_a16M)) : rest_a16N)","t_a16P","s_a16Q","o_a16R","r_a16S","(t_a16P, s_a16Q, o_a16R, r_a16S)","e2_a16T","kT_a16U","e0_a16V","s_a17c","s_a17d","o_a17e","events_a16Y","new_states_a16Z","_","s_a17f","_","_","(_, s_a17f, _, _)","delta_energies_a170","r_a17g","s_a17h","o_a17i","_","(r_a17g, s_a17h, o_a17i, _)","probabilities_a171","r_a17j","de_a17k","(r_a17j, de_a17k)","p_a17l","ps_a17m","total_a17n","cumulative_probabilities_a175","[]","p'_a17o","s'_a17p","(p'_a17o, s'_a17p)","zs_a17q","(p'_a17o, s'_a17p) : zs_a17q","((p'_a17o, s'_a17p) : zs_a17q)","p_a177","r'_a178","p_a177 : r'_a178","(p_a177 : r'_a178)","s_a17r","i_a17s","p_a17t","m_a17u","c_a17v","_","(c_a17v, _)","Capacitor (c_a17v, _)","(i_a17s, p_a17t, m_a17u, Capacitor (c_a17v, _))","s_a17w","i_a17x","p_a17y","m_a17z","c_a17A","_","_","(c_a17A, _, _)","Junction (c_a17A, _, _)","(i_a17x, p_a17y, m_a17z, Junction (c_a17A, _, _))","_","_","s_a17B","o_a17C","i_a17D","p_a17E","m_a17F","_","Vsource _","(i_a17D, p_a17E, m_a17F, Vsource _)","_","_","_","i_a17G","p_a17H","m_a17I","c_a17J","r_a17K","_","(c_a17J, r_a17K, _)","Junction (c_a17J, r_a17K, _)","(i_a17G, p_a17H, m_a17I, Junction (c_a17J, r_a17K, _))","_","circuit_a17L","dt_a17M","elements_a17N","derivative_a17O","initial_a17P","l1_a17Q","u1_a17R","i1_a17S","(l1_a17Q, u1_a17R, i1_a17S)","l2_a17T","u2_a17U","i2_a17V","(l2_a17T, u2_a17U, i2_a17V)","constraint_a17W","freedom_a17X","l3_a17Y","u3_a17Z","i3_a180","(l3_a17Y, u3_a17Z, i3_a180)","inverse3_a181","correct_a182","correct_state_a183","correct_output_a184","solve_a185","scaled_derivative_a186","l4_a187","u4_a188","i4_a189","(l4_a187, u4_a188, i4_a189)","integrate_a18a","backdate_a18b","f_a18j","f_a18k","i_a18l","p_a18m","m_a18n","g_a18o","Conductor g_a18o","(i_a18l, p_a18m, m_a18n, Conductor g_a18o)","i_a18p","p_a18q","m_a18r","r_a18s","Resistor r_a18s","(i_a18p, p_a18q, m_a18r, Resistor r_a18s)","i_a18t","p_a18u","m_a18v","c_a18w","_","(c_a18w, _)","Capacitor (c_a18w, _)","(i_a18t, p_a18u, m_a18v, Capacitor (c_a18w, _))","i_a18x","p_a18y","m_a18z","l_a18A","_","(l_a18A, _)","Inductor (l_a18A, _)","(i_a18x, p_a18y, m_a18z, Inductor (l_a18A, _))","i_a18B","p_a18C","m_a18D","_","Vsource _","(i_a18B, p_a18C, m_a18D, Vsource _)","i_a18E","p_a18F","m_a18G","_","Isource _","(i_a18E, p_a18F, m_a18G, Isource _)","i_a18H","p_a18I","m_a18J","c_a18K","_","_","(c_a18K, _, _)","Junction (c_a18K, _, _)","(i_a18H, p_a18I, m_a18J, Junction (c_a18K, _, _))","i_a18L","p_a18M","m_a18N","_","Conductor _","(i_a18L, p_a18M, m_a18N, Conductor _)","i_a18O","p_a18P","m_a18Q","_","Resistor _","(i_a18O, p_a18P, m_a18Q, Resistor _)","i_a18R","p_a18S","m_a18T","_","_","(_, _)","Capacitor (_, _)","(i_a18R, p_a18S, m_a18T, Capacitor (_, _))","i_a18U","p_a18V","m_a18W","_","_","(_, _)","Inductor (_, _)","(i_a18U, p_a18V, m_a18W, Inductor (_, _))","i_a18X","p_a18Y","m_a18Z","_","Vsource _","(i_a18X, p_a18Y, m_a18Z, Vsource _)","i_a190","p_a191","m_a192","_","Isource _","(i_a190, p_a191, m_a192, Isource _)","i_a193","p_a194","m_a195","_","_","_","(_, _, _)","Junction (_, _, _)","(i_a193, p_a194, m_a195, Junction (_, _, _))","i_a196","p_a197","m_a198","_","Conductor _","(i_a196, p_a197, m_a198, Conductor _)","i_a199","p_a19a","m_a19b","_","Resistor _","(i_a199, p_a19a, m_a19b, Resistor _)","i_a19c","p_a19d","m_a19e","_","q_a19f","(_, q_a19f)","Capacitor (_, q_a19f)","(i_a19c, p_a19d, m_a19e, Capacitor (_, q_a19f))","i_a19g","p_a19h","m_a19i","_","f_a19j","(_, f_a19j)","Inductor (_, f_a19j)","(i_a19g, p_a19h, m_a19i, Inductor (_, f_a19j))","i_a19k","p_a19l","m_a19m","_","Vsource _","(i_a19k, p_a19l, m_a19m, Vsource _)","i_a19n","p_a19o","m_a19p","_","Isource _","(i_a19n, p_a19o, m_a19p, Isource _)","i_a19q","p_a19r","m_a19s","_","_","q_a19t","(_, _, q_a19t)","Junction (_, _, q_a19t)","(i_a19q, p_a19r, m_a19s, Junction (_, _, q_a19t))","r_a19u","c_a19v","(r_a19u, c_a19v)","_","((r_a19u, c_a19v), _)","size_a18i","p_a19w","m_a19x","i_a19y","_","(p_a19w, m_a19x, i_a19y, _)"]
module Simulate where
import Data.Array
import Data.List
import Data.Ratio
import RandomFix
import LinearAlgebra
import Types

simulate ::
         Circuit ->
           Seed -> Time -> Time -> Temperature -> RBC -> [(Time, Output)]
simulate circuit_aqH seed_aqI dt_aqJ end_time_aqK temp_aqL rbc_aqM
  = select_aqN trace_aqO
  where select_aqN
          = takeWhile (\ (t_auC, _) -> t_auC <= end_time_aqK) .
              map (\ (t_aI4, s_aI5, o_aI6, r_aI7) -> (t_aI4, o_aI6))
        trace_aqO
          = (concat . iterate step_aqP)
              ((tunnel_ar3 . correct_ar1 . solve_aqZ . sources_ar2)
                 (0, initial'_aqU, initial'_aqU, randoms_aqQ))
        step_aqP
          = tunnel_ar3 . correct_ar1 . solve_aqZ . sources_ar2 .
              integrate_ar0
              . last
        randoms_aqQ
          = map ((/ (2 ^ 30)) . fromInteger)
              (random (0, 2 ^ 30 - 1) seed_aqI)
        e_aqR = 1.6021773e-19
        k_aqS = 1.38066e-23
        dt'_aqT = circa dt_aqJ
        (initial'_aqU, solve'_aqV, integrate'_aqW, correct_state'_aqX,
         backdate'_aqY)
          = prepare circuit_aqH dt_aqJ
        solve_aqZ (t_aXZ, s_aY0, o_aY1, r_aY2)
          = (t_aXZ, s_aY0, apply solve'_aqV s_aY0, r_aY2)
        integrate_ar0 (t_aY3, s_aY4, o_aY5, r_aY6)
          = (t_aY3 + dt_aqJ, apply integrate'_aqW s_aY4, o_aY5, r_aY6)
        correct_ar1 (t_aY7, s_aY8, o_aY9, r_aYa)
          = (t_aY7, apply correct_state'_aqX s_aY8,
             v_sub o_aY9 (apply backdate'_aqY s_aY8), r_aYa)
        sources_ar2 (t_aYb, s_aYc, o_aYd, r_aYe)
          = (t_aYb, random_offsets_aYg // map elements_aYf circuit_aqH,
             o_aYd, drop size_aYh r_aYe)
          where elements_aYf (i_aYk, p_aYl, m_aYm, Conductor _) = (i_aYk, 0)
                elements_aYf (i_aYn, p_aYo, m_aYp, Resistor _) = (i_aYn, 0)
                elements_aYf (i_aYq, p_aYr, m_aYs, Capacitor _)
                  = (i_aYq, s_aYc ! i_aYq)
                elements_aYf (i_a16k, p_a16l, m_a16m, Inductor _)
                  = (i_a16k, s_aYc ! i_a16k)
                elements_aYf (i_a16n, p_a16o, m_a16p, Vsource list_a16q)
                  = (i_a16n, source_aYj list_a16q)
                elements_aYf (i_a16r, p_a16s, m_a16t, Isource list_a16u)
                  = (i_a16r, source_aYj list_a16u)
                elements_aYf (i_a16v, p_a16w, m_a16x, Junction _)
                  = (i_a16v, s_aYc ! i_a16v)
                random_offsets_aYg
                  = listArray (1, size_aYh)
                      (map ((/ dt'_aqT) . (* e_aqR) . (* rbc_aqM) . (* 2) . (+ (-0.5)))
                         r_aYe)
                (1, size_aYh) = bounds s_aYc
                t'_aYi = circa t_aYb
                source_aYj [(t0_a16y, v0_a16z)] = v0_a16z
                source_aYj ((t0_a16A, v0_a16B) : _) | t'_aYi < t0_a16A = v0_a16B
                source_aYj (((t0_a16J, v0_a16K) : (t1_a16L, v1_a16M)) : rest_a16N)
                  | t0_a16J >= t1_a16L = error "sources must have increasing times"
                  | t'_aYi < t1_a16L =
                    v0_a16K + (v1_a16M - v0_a16K) * (t'_aYi - t0_a16J) /
                      (t1_a16L - t0_a16J)
                  | otherwise = source_aYj ((t1_a16L, v1_a16M) : rest_a16N)
        tunnel_ar3 (t_a16P, s_a16Q, o_a16R, r_a16S)
          = select_a176 (zip cumulative_probabilities_a175 new_states_a16Z)
          where e2_a16T = e_aqR * e_aqR
                kT_a16U = k_aqS * temp_aqL
                e0_a16V = energy_state_a16W s_a16Q
                energy_state_a16W s_a17c
                  = sum (map (energy_state'_a179 s_a17c) circuit_aqH)
                energy_source_a16X s_a17d o_a17e
                  = sum (map (energy_source'_a17a s_a17d o_a17e) circuit_aqH)
                events_a16Y = (concat . map events'_a17b) circuit_aqH
                new_states_a16Z = map (\ (_, s_a17f, _, _) -> s_a17f) events_a16Y
                delta_energies_a170
                  = map
                      ((\ (r_a17g, s_a17h, o_a17i, _) ->
                          (r_a17g,
                           energy_state_a16W s_a17h - e0_a16V +
                             energy_source_a16X s_a17h o_a17i))
                         . correct_ar1)
                      events_a16Y
                probabilities_a171
                  = limit_total_a174
                      (map (no_negative_a173 . probability_a172) delta_energies_a170)
                probability_a172 (r_a17j, de_a17k)
                  | r_a17j == 0 =
                    error
                      "tunnel resistance must be nonzero (and should be >> 26k anyway)"
                  | temp_aqL == 0 = dt'_aqT * (-de_a17k) / (e2_a16T * circa r_a17j)
                  | de_a17k == 0 = dt'_aqT * kT_a16U / (e2_a16T * circa r_a17j)
                  | otherwise =
                    dt'_aqT * (-de_a17k) /
                      (e2_a16T * circa r_a17j * (1 - exp (de_a17k / kT_a16U)))
                no_negative_a173 p_a17l = if p_a17l < 0 then 0 else p_a17l
                limit_total_a174 ps_a17m
                  = let total_a17n = sum ps_a17m in
                      if total_a17n > 1 then map (/ total_a17n) ps_a17m else ps_a17m
                cumulative_probabilities_a175
                  = tail (scanl (+) 0 probabilities_a171)
                select_a176 [] = [(t_a16P, s_a16Q, o_a16R, r'_a178)]
                select_a176 ((p'_a17o, s'_a17p) : zs_a17q)
                  | p_a177 < p'_a17o =
                    [(t_a16P, s_a16Q, o_a16R, r'_a178),
                     (correct_ar1 . solve_aqZ) (t_a16P, s'_a17p, o_a16R, r'_a178)]
                  | otherwise = select_a176 zs_a17q
                (p_a177 : r'_a178) = r_a16S
                energy_state'_a179 s_a17r
                  (i_a17s, p_a17t, m_a17u, Capacitor (c_a17v, _))
                  | c_a17v == 0 = error "capacitance must be nonzero"
                  | otherwise = 1 / 2 * (s_a17r ! i_a17s) ^ 2 / circa c_a17v
                energy_state'_a179 s_a17w
                  (i_a17x, p_a17y, m_a17z, Junction (c_a17A, _, _))
                  | c_a17A == 0 = error "junction capacitance must be nonzero"
                  | otherwise = 1 / 2 * (s_a17w ! i_a17x) ^ 2 / circa c_a17A
                energy_state'_a179 _ _ = 0
                energy_source'_a17a s_a17B o_a17C
                  (i_a17D, p_a17E, m_a17F, Vsource _)
                  = (s_a17B ! i_a17D) * (o_a17C ! i_a17D) * dt'_aqT
                energy_source'_a17a _ _ _ = 0
                events'_a17b (i_a17G, p_a17H, m_a17I, Junction (c_a17J, r_a17K, _))
                  = [(r_a17K, s_a16Q // [(i_a17G, s_a16Q ! i_a17G + e_aqR)],
                      v_map (const 0) o_a16R, []),
                     (r_a17K, s_a16Q // [(i_a17G, s_a16Q ! i_a17G - e_aqR)],
                      v_map (const 0) o_a16R, [])]
                events'_a17b _ = []

prepare ::
        Circuit ->
          Time ->
            (Vector Approx, Matrix Approx, Matrix Approx, Matrix Approx,
             Matrix Approx)
prepare circuit_a17L dt_a17M
  = (v_map circa initial_a17P, m_map circa solve_a185,
     m_map circa integrate_a18a, m_map circa correct_state_a183,
     m_map circa backdate_a18b)
  where elements_a17N = matrix_a18c element_a18e
        derivative_a17O = matrix_a18c deriv_a18f
        initial_a17P = vector_a18d init_a18g
        (l1_a17Q, u1_a17R, i1_a17S) = gauss_jordan elements_a17N
        (l2_a17T, u2_a17U, i2_a17V)
          = gauss_jordan (m_transpose elements_a17N)
        constraint_a17W = m_select_rows l1_a17Q i1_a17S
        freedom_a17X = m_transpose (m_select_rows l2_a17T i2_a17V)
        (l3_a17Y, u3_a17Z, i3_a180)
          = gauss_jordan
              (m_mul constraint_a17W (m_mul derivative_a17O freedom_a17X))
        inverse3_a181
          | l3_a17Y == [] = i3_a180
          | otherwise = error "illegal circuit"
        correct_a182
          | l1_a17Q == [] = m_zero size_a18i
          | otherwise =
            m_mul freedom_a17X (m_mul inverse3_a181 constraint_a17W)
        correct_state_a183
          = m_sub (m_unit size_a18i) (m_mul derivative_a17O correct_a182)
        correct_output_a184
          = m_sub (m_unit size_a18i) (m_mul correct_a182 derivative_a17O)
        solve_a185
          = m_mul correct_output_a184 (m_mul i1_a17S correct_state_a183)
        scaled_derivative_a186
          = m_map (* (dt_a17M / 2)) (m_mul derivative_a17O solve_a185)
        (l4_a187, u4_a188, i4_a189)
          = gauss_jordan (m_sub (m_unit size_a18i) scaled_derivative_a186)
        integrate_a18a
          | l4_a187 == [] =
            m_mul i4_a189 (m_add (m_unit size_a18i) scaled_derivative_a186)
          | otherwise = error "unlucky choice of dt - try a smaller one"
        backdate_a18b = m_map (/ dt_a17M) correct_a182
        matrix_a18c f_a18j
          = accumArray (+) (0 % 1) ((1, 1), (size_a18i, size_a18i))
              ((filter no_ground_a18h . concat . map f_a18j) circuit_a17L)
        vector_a18d f_a18k
          = accumArray (+) (0 % 1) (1, size_a18i)
              ((concat . map f_a18k) circuit_a17L)
        element_a18e (i_a18l, p_a18m, m_a18n, Conductor g_a18o)
          = [((p_a18m, i_a18l), (-1) % 1), ((m_a18n, i_a18l), 1 % 1),
             ((i_a18l, m_a18n), -g_a18o), ((i_a18l, p_a18m), g_a18o),
             ((i_a18l, i_a18l), (-1) % 1)]
        element_a18e (i_a18p, p_a18q, m_a18r, Resistor r_a18s)
          = [((p_a18q, i_a18p), (-1) % 1), ((m_a18r, i_a18p), 1 % 1),
             ((i_a18p, m_a18r), (-1) % 1), ((i_a18p, p_a18q), 1 % 1),
             ((i_a18p, i_a18p), -r_a18s)]
        element_a18e (i_a18t, p_a18u, m_a18v, Capacitor (c_a18w, _))
          = [((p_a18u, i_a18t), (-1) % 1), ((m_a18v, i_a18t), 1 % 1),
             ((i_a18t, m_a18v), -c_a18w), ((i_a18t, p_a18u), c_a18w)]
        element_a18e (i_a18x, p_a18y, m_a18z, Inductor (l_a18A, _))
          = [((p_a18y, i_a18x), (-1) % 1), ((m_a18z, i_a18x), 1 % 1),
             ((i_a18x, i_a18x), l_a18A)]
        element_a18e (i_a18B, p_a18C, m_a18D, Vsource _)
          = [((p_a18C, i_a18B), (-1) % 1), ((m_a18D, i_a18B), 1 % 1),
             ((i_a18B, m_a18D), (-1) % 1), ((i_a18B, p_a18C), 1 % 1)]
        element_a18e (i_a18E, p_a18F, m_a18G, Isource _)
          = [((p_a18F, i_a18E), (-1) % 1), ((m_a18G, i_a18E), 1 % 1),
             ((i_a18E, i_a18E), 1 % 1)]
        element_a18e (i_a18H, p_a18I, m_a18J, Junction (c_a18K, _, _))
          = [((p_a18I, i_a18H), (-1) % 1), ((m_a18J, i_a18H), 1 % 1),
             ((i_a18H, m_a18J), -c_a18K), ((i_a18H, p_a18I), c_a18K)]
        deriv_a18f (i_a18L, p_a18M, m_a18N, Conductor _) = []
        deriv_a18f (i_a18O, p_a18P, m_a18Q, Resistor _) = []
        deriv_a18f (i_a18R, p_a18S, m_a18T, Capacitor (_, _))
          = [((i_a18R, i_a18R), 1)]
        deriv_a18f (i_a18U, p_a18V, m_a18W, Inductor (_, _))
          = [((i_a18U, p_a18V), 1), ((i_a18U, m_a18W), -1)]
        deriv_a18f (i_a18X, p_a18Y, m_a18Z, Vsource _) = []
        deriv_a18f (i_a190, p_a191, m_a192, Isource _) = []
        deriv_a18f (i_a193, p_a194, m_a195, Junction (_, _, _))
          = [((i_a193, i_a193), 1)]
        init_a18g (i_a196, p_a197, m_a198, Conductor _) = []
        init_a18g (i_a199, p_a19a, m_a19b, Resistor _) = []
        init_a18g (i_a19c, p_a19d, m_a19e, Capacitor (_, q_a19f))
          = [(i_a19c, q_a19f)]
        init_a18g (i_a19g, p_a19h, m_a19i, Inductor (_, f_a19j))
          = [(i_a19g, f_a19j)]
        init_a18g (i_a19k, p_a19l, m_a19m, Vsource _) = []
        init_a18g (i_a19n, p_a19o, m_a19p, Isource _) = []
        init_a18g (i_a19q, p_a19r, m_a19s, Junction (_, _, q_a19t))
          = [(i_a19q, q_a19t)]
        no_ground_a18h ((r_a19u, c_a19v), _) = r_a19u /= 0 && c_a19v /= 0
        size_a18i
          = maximum
              (concat
                 (map (\ (p_a19w, m_a19x, i_a19y, _) -> [p_a19w, m_a19x, i_a19y])
                    circuit_a17L))

==================== Renamer ====================
RandomFix.random :: (Integer, Integer) -> Integer -> [Integer]
RandomFix.random (l_avz, h_avA) s_avB
  = if l_avz > h_avA then
        error "Random.random: Empty interval"
    else
        if s_avB < 0 then
            RandomFix.random (l_avz, h_avA) (- s_avB)
        else
            let
              (q_aJ4, s1_aJ5) = s_avB `divMod` 2147483562
              s2_aJ6 = q_aJ4 `mod` 2147483398
              k_aJ7 = h_avA - l_avz + 1
              b_aJ8 = 2147483561
              n_aJ9 = RandomFix.iLogBase b_aJ8 k_aJ7
              f_aJa is_aT7
                = let (xs_aT8, is'_aT9) = splitAt n_aJ9 is_aT7
                  in
                    foldr
                      (\ i_a12H r_a12I -> fromIntegral i_a12H + r_a12I * b_aJ8) 0 xs_aT8
                    `mod` k_aJ7
                    + l_avz
                    : f_aJa is'_aT9
            in
              f_aJa
                (RandomFix.randomInts
                   (fromIntegral (s1_aJ5 + 1)) (fromIntegral (s2_aJ6 + 1)))
RandomFix.iLogBase b_a12J i_a12K
  = if i_a12K < b_a12J then
        1
    else
        1 + RandomFix.iLogBase b_a12J (i_a12K `div` b_a12J)
RandomFix.randomInts :: Int -> Int -> [Int]
RandomFix.randomInts s1_a12L s2_a12M
  = if 1 <= s1_a12L && s1_a12L <= 2147483562 then
        if 1 <= s2_a12M && s2_a12M <= 2147483398 then
            RandomFix.rands s1_a12L s2_a12M
        else
            error "randomInts: Bad second seed."
    else
        error "randomInts: Bad first seed."
RandomFix.rands :: Int -> Int -> [Int]
RandomFix.rands s1_a12N s2_a12O
  = z'_a12P : RandomFix.rands s1''_a12T s2''_a12W
  where
      z'_a12P = if z_a12Q < 1 then z_a12Q + 2147483562 else z_a12Q
      z_a12Q = s1''_a12T - s2''_a12W
      k_a12R = s1_a12N `quot` 53668
      s1'_a12S = 40014 * (s1_a12N - k_a12R * 53668) - k_a12R * 12211
      s1''_a12T
        = if s1'_a12S < 0 then s1'_a12S + 2147483563 else s1'_a12S
      k'_a12U = s2_a12O `quot` 52774
      s2'_a12V = 40692 * (s2_a12O - k'_a12U * 52774) - k'_a12U * 3791
      s2''_a12W
        = if s2'_a12V < 0 then s2'_a12V + 2147483399 else s2'_a12V


["l_avz","h_avA","(l_avz, h_avA)","s_avB","q_aJ4","s1_aJ5","(q_aJ4, s1_aJ5)","s2_aJ6","k_aJ7","b_aJ8","n_aJ9","is_aT7","xs_aT8","is'_aT9","(xs_aT8, is'_aT9)","i_a12H","r_a12I","b_a12J","i_a12K","s1_a12L","s2_a12M","s1_a12N","s2_a12O","z'_a12P","z_a12Q","k_a12R","s1'_a12S","s1''_a12T","k'_a12U","s2'_a12V","s2''_a12W"]
module RandomFix (random) where

random :: (Integer, Integer) -> Integer -> [Integer]
random (l_avz, h_avA) s_avB
  = if l_avz > h_avA then error "Random.random: Empty interval" else
      if s_avB < 0 then random (l_avz, h_avA) (-s_avB) else
        let (q_aJ4, s1_aJ5) = s_avB `divMod` 2147483562
            s2_aJ6 = q_aJ4 `mod` 2147483398
            k_aJ7 = h_avA - l_avz + 1
            b_aJ8 = 2147483561
            n_aJ9 = iLogBase b_aJ8 k_aJ7
            f_aJa is_aT7
              = let (xs_aT8, is'_aT9) = splitAt n_aJ9 is_aT7 in
                  foldr (\ i_a12H r_a12I -> fromIntegral i_a12H + r_a12I * b_aJ8) 0
                    xs_aT8
                    `mod` k_aJ7
                    + l_avz
                    : f_aJa is'_aT9
          in
          f_aJa
            (randomInts (fromIntegral (s1_aJ5 + 1))
               (fromIntegral (s2_aJ6 + 1)))
iLogBase b_a12J i_a12K
  = if i_a12K < b_a12J then 1 else
      1 + iLogBase b_a12J (i_a12K `div` b_a12J)

randomInts :: Int -> Int -> [Int]
randomInts s1_a12L s2_a12M
  = if 1 <= s1_a12L && s1_a12L <= 2147483562 then
      if 1 <= s2_a12M && s2_a12M <= 2147483398 then rands s1_a12L s2_a12M
        else error "randomInts: Bad second seed."
      else error "randomInts: Bad first seed."

rands :: Int -> Int -> [Int]
rands s1_a12N s2_a12O = z'_a12P : rands s1''_a12T s2''_a12W
  where z'_a12P = if z_a12Q < 1 then z_a12Q + 2147483562 else z_a12Q
        z_a12Q = s1''_a12T - s2''_a12W
        k_a12R = s1_a12N `quot` 53668
        s1'_a12S = 40014 * (s1_a12N - k_a12R * 53668) - k_a12R * 12211
        s1''_a12T
          = if s1'_a12S < 0 then s1'_a12S + 2147483563 else s1'_a12S
        k'_a12U = s2_a12O `quot` 52774
        s2'_a12V = 40692 * (s2_a12O - k'_a12U * 52774) - k'_a12U * 3791
        s2''_a12W
          = if s2'_a12V < 0 then s2'_a12V + 2147483399 else s2'_a12V

==================== Renamer ====================
Parse.parse_circuit = parse (remove_right Parse.circuit whitespace)
Parse.parse_exact = parse (remove_right Parse.exact whitespace)
Parse.parse_approx = parse (remove_right Parse.approx whitespace)
Parse.parse_integer = parse (remove_right Parse.integer whitespace)
Parse.circuit :: Parser (Circuit, [Name])
Parse.circuit
  = transform make_indices_aH2 (repetition1 Parse.element)
  where
      make_indices_aH2 list_aH3
        = (circuit_aH6, names_aH5)
        where
            list_with_types_aH4
              = [(e_aH8, ("i:" ++ n1_aH9, "v:" ++ n2_aHa, "v:" ++ n3_aHb)) |
                   (e_aH8, (n1_aH9, n2_aHa, n3_aHb)) <- list_aH3]
            names_aH5
              = (nub . ("v:ground" :) . concat)
                  [[n1_aPA, n2_aPB, n3_aPC] |
                     (_, (n1_aPA, n2_aPB, n3_aPC)) <- list_with_types_aH4]
            circuit_aH6
              = [(index_aH7 n1_aPE, index_aH7 n2_aPF, index_aH7 n3_aPG, e_aPD) |
                   (e_aPD, (n1_aPE, n2_aPF, n3_aPG)) <- list_with_types_aH4]
            index_aH7 name_aPH
              = fromJust (lookup name_aPH (zip names_aH5 [0 .. ]))
Parse.element :: Parser (Element, (Name, Name, Name))
Parse.element
  = choice
      [conductor_aST, resistor_aSU, capacitor_aSV, inductor_aSW,
       vsource_aSX, isource_aSY, junction_aSZ]
  where
      conductor_aST = code_aT0 'g' (transform Conductor Parse.exact)
      resistor_aSU = code_aT0 'r' (transform Resistor Parse.exact)
      capacitor_aSV
        = code_aT0
            'c' (transform Capacitor (sequence2 Parse.exact Parse.exact))
      inductor_aSW
        = code_aT0
            'l' (transform Inductor (sequence2 Parse.exact Parse.exact))
      vsource_aSX = code_aT0 'v' (transform Vsource Parse.list)
      isource_aSY = code_aT0 'i' (transform Isource Parse.list)
      junction_aSZ
        = code_aT0
            'j'
            (transform
               Junction (sequence3 Parse.exact Parse.exact Parse.exact))
      code_aT0 c_aT1
        = transform (\ (n_aT2, e_aT3) -> (e_aT3, n_aT2))
          . (sequence2
               (remove_left
                  (character c_aT1) (sequence3 Parse.name Parse.name Parse.name)))
Parse.list :: Parser List
Parse.list
  = repetition1
      (enclose
         (character '(')
         (glue Parse.approx (character ',') Parse.approx)
         (character ')'))
Parse.approx :: Parser Approx
Parse.approx = transform circa Parse.exact
Parse.exact :: Parser Exact
Parse.exact
  = transform
      (\ ((sign_a13F, int_a13G), (frac_a13H, fact_a13I))
         -> sign_a13F * (int_a13G + frac_a13H) * fact_a13I)
      (sequence2
         (sequence2 sign_aT4 integer_aT6)
         (sequence2 fraction_aT8 factor_aTa))
  where
      sign_aT4 = transform make_sign_aT5 (option (character '-'))
      make_sign_aT5 "" = 1 % 1
      make_sign_aT5 "-" = - 1 % 1
      integer_aT6 = transform make_integer_aT7 (parse_while isDigit)
      make_integer_aT7 s_a12H = read s_a12H % 1
      fraction_aT8
        = transform
            make_fraction_aT9
            (option (remove_left (character' '.') (parse_while isDigit)))
      make_fraction_aT9 [] = 0 % 1
      make_fraction_aT9 [s_a13x]
        = read s_a13x % read ('1' : map (const '0') s_a13x)
      factor_aTa
        = transform
            make_factor_aTb (option (parse_if' (`elem` "afpnumkMGTPE")))
      make_factor_aTb "a" = 1 % 1000000000000000000
      make_factor_aTb "f" = 1 % 1000000000000000
      make_factor_aTb "p" = 1 % 1000000000000
      make_factor_aTb "n" = 1 % 1000000000
      make_factor_aTb "u" = 1 % 1000000
      make_factor_aTb "m" = 1 % 1000
      make_factor_aTb "" = 1 % 1
      make_factor_aTb "k" = 1000 % 1
      make_factor_aTb "M" = 1000000 % 1
      make_factor_aTb "G" = 1000000000 % 1
      make_factor_aTb "T" = 1000000000000 % 1
      make_factor_aTb "P" = 1000000000000000 % 1
      make_factor_aTb "E" = 1000000000000000000 % 1
Parse.integer :: Parser Integer
Parse.integer
  = transform
      read
      (choice
         [cons (character '-') (parse_while isDigit), parse_while isDigit])
Parse.name :: Parser Name
Parse.name = parse_while isAlphaNum


["parse_circuit","parse_exact","parse_approx","parse_integer","circuit","list_aH3","list_with_types_aH4","e_aH8","n1_aH9","n2_aHa","n3_aHb","(n1_aH9, n2_aHa, n3_aHb)","(e_aH8, (n1_aH9, n2_aHa, n3_aHb))","names_aH5","_","n1_aPA","n2_aPB","n3_aPC","(n1_aPA, n2_aPB, n3_aPC)","(_, (n1_aPA, n2_aPB, n3_aPC))","circuit_aH6","e_aPD","n1_aPE","n2_aPF","n3_aPG","(n1_aPE, n2_aPF, n3_aPG)","(e_aPD, (n1_aPE, n2_aPF, n3_aPG))","name_aPH","element","conductor_aST","resistor_aSU","capacitor_aSV","inductor_aSW","vsource_aSX","isource_aSY","junction_aSZ","c_aT1","n_aT2","e_aT3","(n_aT2, e_aT3)","list","approx","exact","sign_a13F","int_a13G","(sign_a13F, int_a13G)","frac_a13H","fact_a13I","(frac_a13H, fact_a13I)","((sign_a13F, int_a13G), (frac_a13H, fact_a13I))","sign_aT4","\"\"","\"-\"","integer_aT6","s_a12H","fraction_aT8","[]","s_a13x","[s_a13x]","factor_aTa","\"a\"","\"f\"","\"p\"","\"n\"","\"u\"","\"m\"","\"\"","\"k\"","\"M\"","\"G\"","\"T\"","\"P\"","\"E\"","integer","name"]
module Parse
       (parse_circuit, parse_exact, parse_approx, parse_integer) where
import Data.Char
import Data.List
import Data.Maybe
import Data.Ratio
import Types
import ParseLib
parse_circuit = parse (remove_right circuit whitespace)
parse_exact = parse (remove_right exact whitespace)
parse_approx = parse (remove_right approx whitespace)
parse_integer = parse (remove_right integer whitespace)

circuit :: Parser (Circuit, [Name])
circuit = transform make_indices_aH2 (repetition1 element)
  where make_indices_aH2 list_aH3 = (circuit_aH6, names_aH5)
          where list_with_types_aH4
                  = [(e_aH8, ("i:" ++ n1_aH9, "v:" ++ n2_aHa, "v:" ++ n3_aHb)) |
                     (e_aH8, (n1_aH9, n2_aHa, n3_aHb)) <- list_aH3]
                names_aH5
                  = (nub . ("v:ground" :) . concat)
                      [[n1_aPA, n2_aPB, n3_aPC] |
                       (_, (n1_aPA, n2_aPB, n3_aPC)) <- list_with_types_aH4]
                circuit_aH6
                  = [(index_aH7 n1_aPE, index_aH7 n2_aPF, index_aH7 n3_aPG, e_aPD) |
                     (e_aPD, (n1_aPE, n2_aPF, n3_aPG)) <- list_with_types_aH4]
                index_aH7 name_aPH
                  = fromJust (lookup name_aPH (zip names_aH5 [0 ..]))

element :: Parser (Element, (Name, Name, Name))
element
  = choice
      [conductor_aST, resistor_aSU, capacitor_aSV, inductor_aSW,
       vsource_aSX, isource_aSY, junction_aSZ]
  where conductor_aST = code_aT0 'g' (transform Conductor exact)
        resistor_aSU = code_aT0 'r' (transform Resistor exact)
        capacitor_aSV
          = code_aT0 'c' (transform Capacitor (sequence2 exact exact))
        inductor_aSW
          = code_aT0 'l' (transform Inductor (sequence2 exact exact))
        vsource_aSX = code_aT0 'v' (transform Vsource list)
        isource_aSY = code_aT0 'i' (transform Isource list)
        junction_aSZ
          = code_aT0 'j' (transform Junction (sequence3 exact exact exact))
        code_aT0 c_aT1
          = transform (\ (n_aT2, e_aT3) -> (e_aT3, n_aT2)) .
              (sequence2
                 (remove_left (character c_aT1) (sequence3 name name name)))

list :: Parser List
list
  = repetition1
      (enclose (character '(') (glue approx (character ',') approx)
         (character ')'))

approx :: Parser Approx
approx = transform circa exact

exact :: Parser Exact
exact
  = transform
      (\ ((sign_a13F, int_a13G), (frac_a13H, fact_a13I)) ->
         sign_a13F * (int_a13G + frac_a13H) * fact_a13I)
      (sequence2 (sequence2 sign_aT4 integer_aT6)
         (sequence2 fraction_aT8 factor_aTa))
  where sign_aT4 = transform make_sign_aT5 (option (character '-'))
        make_sign_aT5 "" = 1 % 1
        make_sign_aT5 "-" = (-1) % 1
        integer_aT6 = transform make_integer_aT7 (parse_while isDigit)
        make_integer_aT7 s_a12H = read s_a12H % 1
        fraction_aT8
          = transform make_fraction_aT9
              (option (remove_left (character' '.') (parse_while isDigit)))
        make_fraction_aT9 [] = 0 % 1
        make_fraction_aT9 [s_a13x]
          = read s_a13x % read ('1' : map (const '0') s_a13x)
        factor_aTa
          = transform make_factor_aTb
              (option (parse_if' (`elem` "afpnumkMGTPE")))
        make_factor_aTb "a" = 1 % 1000000000000000000
        make_factor_aTb "f" = 1 % 1000000000000000
        make_factor_aTb "p" = 1 % 1000000000000
        make_factor_aTb "n" = 1 % 1000000000
        make_factor_aTb "u" = 1 % 1000000
        make_factor_aTb "m" = 1 % 1000
        make_factor_aTb "" = 1 % 1
        make_factor_aTb "k" = 1000 % 1
        make_factor_aTb "M" = 1000000 % 1
        make_factor_aTb "G" = 1000000000 % 1
        make_factor_aTb "T" = 1000000000000 % 1
        make_factor_aTb "P" = 1000000000000000 % 1
        make_factor_aTb "E" = 1000000000000000000 % 1

integer :: Parser Integer
integer
  = transform read
      (choice
         [cons (character '-') (parse_while isDigit), parse_while isDigit])

name :: Parser Name
name = parse_while isAlphaNum

==================== Renamer ====================
ParseLib.empty :: ParseLib.Parser [a_avs]
ParseLib.empty = (\ x_avt -> [([], x_avt)])
ParseLib.character' :: Char -> ParseLib.Parser Char
ParseLib.character' c_avu x_avv
  | null x_avv = []
  | c_avu == head x_avv = [(head x_avv, tail x_avv)]
  | otherwise = []
ParseLib.parse_if' :: (Char -> Bool) -> ParseLib.Parser Char
ParseLib.parse_if' p_aSv x_aSw
  | null x_aSw = []
  | p_aSv (head x_aSw) = [(head x_aSw, tail x_aSw)]
  | otherwise = []
ParseLib.string' :: String -> ParseLib.Parser String
ParseLib.string' s_aSx x_aSy
  | s_aSx == fst split_aSz = [split_aSz]
  | otherwise = []
  where
      split_aSz = splitAt (length s_aSx) x_aSy
ParseLib.parse_while' :: (Char -> Bool) -> ParseLib.Parser String
ParseLib.parse_while' p_aSG x_aSH
  | null x_aSH = []
  | p_aSG (head x_aSH) = [span p_aSG x_aSH]
  | otherwise = []
ParseLib.choice :: [ParseLib.Parser r_avr] -> ParseLib.Parser r_avr
ParseLib.choice ps_aSI x_aSJ
  = [r_aSL | p_aSK <- ps_aSI, r_aSL <- p_aSK x_aSJ]
ParseLib.sequence2 ::
  ParseLib.Parser r1_avp
  -> ParseLib.Parser r2_avq -> ParseLib.Parser (r1_avp, r2_avq)
ParseLib.sequence2 p1_aSM p2_aSN x0_aSO
  = [((r1_aSP, r2_aSR), x2_aSS) |
       (r1_aSP, x1_aSQ) <- p1_aSM x0_aSO,
       (r2_aSR, x2_aSS) <- p2_aSN x1_aSQ]
ParseLib.sequence3 ::
  ParseLib.Parser r1_avm
  -> ParseLib.Parser r2_avn
     -> ParseLib.Parser r3_avo
        -> ParseLib.Parser (r1_avm, r2_avn, r3_avo)
ParseLib.sequence3 p1_aST p2_aSU p3_aSV x0_aSW
  = [((r1_aSX, r2_aSZ, r3_aT1), x3_aT2) |
       (r1_aSX, x1_aSY) <- p1_aST x0_aSW,
       (r2_aSZ, x2_aT0) <- p2_aSU x1_aSY,
       (r3_aT1, x3_aT2) <- p3_aSV x2_aT0]
ParseLib.transform ::
  (a_avk -> b_avl) -> ParseLib.Parser a_avk -> ParseLib.Parser b_avl
ParseLib.transform f_aT3 p_aT4 s_aT5
  = [(f_aT3 r_aT6, x_aT7) | (r_aT6, x_aT7) <- p_aT4 s_aT5]
ParseLib.allow_null ::
  ParseLib.Parser [a_avj] -> ParseLib.Parser [a_avj]
ParseLib.allow_null p_aT8 x_aT9
  | null result_aTa = [([], x_aT9)]
  | otherwise = result_aTa
  where
      result_aTa = p_aT8 x_aT9
ParseLib.forbid_null ::
  ParseLib.Parser [a_avi] -> ParseLib.Parser [a_avi]
ParseLib.forbid_null p_aTb
  = filter (\ (r_aTc, x_aTd) -> (not . null) r_aTc) . p_aTb
ParseLib.cons ::
  ParseLib.Parser a_avh
  -> ParseLib.Parser [a_avh] -> ParseLib.Parser [a_avh]
ParseLib.cons p_aTe ps_aTf
  = ParseLib.transform
      (\ (a_aTg, as_aTh) -> a_aTg : as_aTh)
      (ParseLib.sequence2 p_aTe ps_aTf)
ParseLib.repetition0 ::
  ParseLib.Parser a_avg -> ParseLib.Parser [a_avg]
ParseLib.repetition0 p_aTi
  = ParseLib.allow_null
      (ParseLib.cons p_aTi (ParseLib.repetition0 p_aTi))
ParseLib.repetition1 ::
  ParseLib.Parser a_avf -> ParseLib.Parser [a_avf]
ParseLib.repetition1 p_aTj
  = (ParseLib.cons p_aTj (ParseLib.repetition0 p_aTj))
ParseLib.option :: ParseLib.Parser a_ave -> ParseLib.Parser [a_ave]
ParseLib.option p_aTk
  = ParseLib.choice
      [ParseLib.transform (\ a_aTl -> [a_aTl]) p_aTk, ParseLib.empty]
ParseLib.remove_left ::
  ParseLib.Parser a_avc
  -> ParseLib.Parser b_avd -> ParseLib.Parser b_avd
ParseLib.remove_left p1_aTm p2_aTn
  = ParseLib.transform snd (ParseLib.sequence2 p1_aTm p2_aTn)
ParseLib.remove_right ::
  ParseLib.Parser a_ava
  -> ParseLib.Parser b_avb -> ParseLib.Parser a_ava
ParseLib.remove_right p1_aTo p2_aTp
  = ParseLib.transform fst (ParseLib.sequence2 p1_aTo p2_aTp)
ParseLib.enclose ::
  ParseLib.Parser a_av7
  -> ParseLib.Parser b_av8
     -> ParseLib.Parser c_av9 -> ParseLib.Parser b_av8
ParseLib.enclose p1_aTq p2_aTr p3_aTs
  = ParseLib.transform
      take_mid_aTt (ParseLib.sequence3 p1_aTq p2_aTr p3_aTs)
  where
      take_mid_aTt (a_aTu, b_aTv, c_aTw) = b_aTv
ParseLib.glue ::
  ParseLib.Parser a_av4
  -> ParseLib.Parser b_av5
     -> ParseLib.Parser c_av6 -> ParseLib.Parser (a_av4, c_av6)
ParseLib.glue p1_aTx p2_aTy p3_aTz
  = ParseLib.transform
      drop_mid_aTA (ParseLib.sequence3 p1_aTx p2_aTy p3_aTz)
  where
      drop_mid_aTA (a_aTB, b_aTC, c_aTD) = (a_aTB, c_aTD)
ParseLib.whitespace :: ParseLib.Parser String
ParseLib.whitespace
  = ParseLib.allow_null (ParseLib.parse_while' isSpace)
ParseLib.character :: Char -> ParseLib.Parser Char
ParseLib.character c_aU0
  = ParseLib.remove_left
      ParseLib.whitespace (ParseLib.character' c_aU0)
ParseLib.parse_if :: (Char -> Bool) -> ParseLib.Parser Char
ParseLib.parse_if p_aU1
  = ParseLib.remove_left
      ParseLib.whitespace (ParseLib.parse_if' p_aU1)
ParseLib.string :: String -> ParseLib.Parser String
ParseLib.string s_aU2
  = ParseLib.remove_left ParseLib.whitespace (ParseLib.string' s_aU2)
ParseLib.parse_while :: (Char -> Bool) -> ParseLib.Parser String
ParseLib.parse_while p_aU3
  = ParseLib.remove_left
      ParseLib.whitespace (ParseLib.parse_while' p_aU3)
ParseLib.parse :: ParseLib.Parser a_auW -> String -> [a_auW]
ParseLib.parse parser_aU4
  = map fst . filter (null . snd) . parser_aU4

type ParseLib.Parser a_auV = String -> [(a_auV, String)]


["empty","x_avt","c_avu","x_avv","p_aSv","x_aSw","s_aSx","x_aSy","split_aSz","p_aSG","x_aSH","ps_aSI","x_aSJ","p_aSK","r_aSL","p1_aSM","p2_aSN","x0_aSO","r1_aSP","x1_aSQ","(r1_aSP, x1_aSQ)","r2_aSR","x2_aSS","(r2_aSR, x2_aSS)","p1_aST","p2_aSU","p3_aSV","x0_aSW","r1_aSX","x1_aSY","(r1_aSX, x1_aSY)","r2_aSZ","x2_aT0","(r2_aSZ, x2_aT0)","r3_aT1","x3_aT2","(r3_aT1, x3_aT2)","f_aT3","p_aT4","s_aT5","r_aT6","x_aT7","(r_aT6, x_aT7)","p_aT8","x_aT9","result_aTa","p_aTb","r_aTc","x_aTd","(r_aTc, x_aTd)","p_aTe","ps_aTf","a_aTg","as_aTh","(a_aTg, as_aTh)","p_aTi","p_aTj","p_aTk","a_aTl","p1_aTm","p2_aTn","p1_aTo","p2_aTp","p1_aTq","p2_aTr","p3_aTs","a_aTu","b_aTv","c_aTw","(a_aTu, b_aTv, c_aTw)","p1_aTx","p2_aTy","p3_aTz","a_aTB","b_aTC","c_aTD","(a_aTB, b_aTC, c_aTD)","whitespace","c_aU0","p_aU1","s_aU2","p_aU3","parser_aU4"]
module ParseLib where
import Data.Char

empty :: Parser [a_avs]
empty = (\ x_avt -> [([], x_avt)])

character' :: Char -> Parser Char
character' c_avu x_avv
  | null x_avv = []
  | c_avu == head x_avv = [(head x_avv, tail x_avv)]
  | otherwise = []

parse_if' :: (Char -> Bool) -> Parser Char
parse_if' p_aSv x_aSw
  | null x_aSw = []
  | p_aSv (head x_aSw) = [(head x_aSw, tail x_aSw)]
  | otherwise = []

string' :: String -> Parser String
string' s_aSx x_aSy
  | s_aSx == fst split_aSz = [split_aSz]
  | otherwise = []
  where split_aSz = splitAt (length s_aSx) x_aSy

parse_while' :: (Char -> Bool) -> Parser String
parse_while' p_aSG x_aSH
  | null x_aSH = []
  | p_aSG (head x_aSH) = [span p_aSG x_aSH]
  | otherwise = []

choice :: [Parser r_avr] -> Parser r_avr
choice ps_aSI x_aSJ
  = [r_aSL | p_aSK <- ps_aSI, r_aSL <- p_aSK x_aSJ]

sequence2 ::
          Parser r1_avp -> Parser r2_avq -> Parser (r1_avp, r2_avq)
sequence2 p1_aSM p2_aSN x0_aSO
  = [((r1_aSP, r2_aSR), x2_aSS) | (r1_aSP, x1_aSQ) <- p1_aSM x0_aSO,
     (r2_aSR, x2_aSS) <- p2_aSN x1_aSQ]

sequence3 ::
          Parser r1_avm ->
            Parser r2_avn -> Parser r3_avo -> Parser (r1_avm, r2_avn, r3_avo)
sequence3 p1_aST p2_aSU p3_aSV x0_aSW
  = [((r1_aSX, r2_aSZ, r3_aT1), x3_aT2) |
     (r1_aSX, x1_aSY) <- p1_aST x0_aSW,
     (r2_aSZ, x2_aT0) <- p2_aSU x1_aSY,
     (r3_aT1, x3_aT2) <- p3_aSV x2_aT0]

transform :: (a_avk -> b_avl) -> Parser a_avk -> Parser b_avl
transform f_aT3 p_aT4 s_aT5
  = [(f_aT3 r_aT6, x_aT7) | (r_aT6, x_aT7) <- p_aT4 s_aT5]

allow_null :: Parser [a_avj] -> Parser [a_avj]
allow_null p_aT8 x_aT9
  | null result_aTa = [([], x_aT9)]
  | otherwise = result_aTa
  where result_aTa = p_aT8 x_aT9

forbid_null :: Parser [a_avi] -> Parser [a_avi]
forbid_null p_aTb
  = filter (\ (r_aTc, x_aTd) -> (not . null) r_aTc) . p_aTb

cons :: Parser a_avh -> Parser [a_avh] -> Parser [a_avh]
cons p_aTe ps_aTf
  = transform (\ (a_aTg, as_aTh) -> a_aTg : as_aTh)
      (sequence2 p_aTe ps_aTf)

repetition0 :: Parser a_avg -> Parser [a_avg]
repetition0 p_aTi = allow_null (cons p_aTi (repetition0 p_aTi))

repetition1 :: Parser a_avf -> Parser [a_avf]
repetition1 p_aTj = (cons p_aTj (repetition0 p_aTj))

option :: Parser a_ave -> Parser [a_ave]
option p_aTk = choice [transform (\ a_aTl -> [a_aTl]) p_aTk, empty]

remove_left :: Parser a_avc -> Parser b_avd -> Parser b_avd
remove_left p1_aTm p2_aTn = transform snd (sequence2 p1_aTm p2_aTn)

remove_right :: Parser a_ava -> Parser b_avb -> Parser a_ava
remove_right p1_aTo p2_aTp
  = transform fst (sequence2 p1_aTo p2_aTp)

enclose ::
        Parser a_av7 -> Parser b_av8 -> Parser c_av9 -> Parser b_av8
enclose p1_aTq p2_aTr p3_aTs
  = transform take_mid_aTt (sequence3 p1_aTq p2_aTr p3_aTs)
  where take_mid_aTt (a_aTu, b_aTv, c_aTw) = b_aTv

glue ::
     Parser a_av4 ->
       Parser b_av5 -> Parser c_av6 -> Parser (a_av4, c_av6)
glue p1_aTx p2_aTy p3_aTz
  = transform drop_mid_aTA (sequence3 p1_aTx p2_aTy p3_aTz)
  where drop_mid_aTA (a_aTB, b_aTC, c_aTD) = (a_aTB, c_aTD)

whitespace :: Parser String
whitespace = allow_null (parse_while' isSpace)

character :: Char -> Parser Char
character c_aU0 = remove_left whitespace (character' c_aU0)

parse_if :: (Char -> Bool) -> Parser Char
parse_if p_aU1 = remove_left whitespace (parse_if' p_aU1)

string :: String -> Parser String
string s_aU2 = remove_left whitespace (string' s_aU2)

parse_while :: (Char -> Bool) -> Parser String
parse_while p_aU3 = remove_left whitespace (parse_while' p_aU3)

parse :: Parser a_auW -> String -> [a_auW]
parse parser_aU4 = map fst . filter (null . snd) . parser_aU4

type Parser a_auV = String -> [(a_auV, String)]

==================== Renamer ====================
Types.circa :: Types.Exact -> Types.Approx
Types.circa = fromRational

type Types.Name = String
type Types.Seed = Integer
type Types.Index = Int
type Types.Vector a_aFk = Array Types.Index a_aFk
type Types.Matrix a_awN = Array (Types.Index, Types.Index) a_awN
type Types.Exact = Rational
type Types.Time = Types.Exact
type Types.Approx = Double
type Types.List = [(Types.Approx, Types.Approx)]
data Types.Element
  = Types.Conductor Types.Exact |
    Types.Resistor Types.Exact |
    Types.Capacitor (Types.Exact, Types.Exact) |
    Types.Inductor (Types.Exact, Types.Exact) |
    Types.Vsource Types.List |
    Types.Isource Types.List |
    Types.Junction (Types.Exact, Types.Exact, Types.Exact)
  deriving (Show)
type Types.Circuit =
    [(Types.Index, Types.Index, Types.Index, Types.Element)]
type Types.Random = [Types.Approx]
type Types.Output = Types.Vector Types.Approx
type Types.State = Types.Vector Types.Approx
type Types.RBC = Types.Approx
type Types.Temperature = Types.Approx


["circa"]
module Types where
import Data.Array

circa :: Exact -> Approx
circa = fromRational

type Name = String

type Seed = Integer

type Index = Int

type Vector a_aFk = Array Index a_aFk

type Matrix a_awN = Array (Index, Index) a_awN

type Exact = Rational

type Time = Exact

type Approx = Double

type List = [(Approx, Approx)]

data Element = Conductor Exact
             | Resistor Exact
             | Capacitor (Exact, Exact)
             | Inductor (Exact, Exact)
             | Vsource List
             | Isource List
             | Junction (Exact, Exact, Exact)
             deriving Show

type Circuit = [(Index, Index, Index, Element)]

type Random = [Approx]

type Output = Vector Approx

type State = Vector Approx

type RBC = Approx

type Temperature = Approx

==================== Renamer ====================
Main.main
  = do { hPutStr stderr "Enter the scale of computation: ";
         (!s_auv) <- getContents;
         let (!((!scale_auw), (!rest_aux)))
               = (head (reads s_auv)) :: (Int, String);
         putStr (takeWhile ((/=) '\n') s_auv ++ (gamteb scale_auw)) }



==================== Renamer ====================
Consts.cylLen, Consts.cylLen2, Consts.cylRad, Consts.cylRad2, Consts.wgtCut, Consts.wgtCut2, Consts.ergCut, Consts.big, Consts.small, Consts.nothing ::
  Double
Consts.cylLen = 20.0
Consts.cylLen2 = Consts.cylLen + 10.0
Consts.cylRad = 1.0
Consts.cylRad2 = Consts.cylRad * Consts.cylRad
Consts.big = 100.0
Consts.small = 1.0e-7
Consts.nothing = - 30.0
Consts.wgtCut = 0.5
Consts.wgtCut2 = Consts.wgtCut * Consts.wgtCut
Consts.ergCut = 1.0e-3
Consts.scatter, Consts.escape, Consts.transit, Consts.numExit, Consts.numLev, Consts.numStat ::
  Int
Consts.ne, Consts.nt, Consts.ns, Consts.nek, Consts.nwk, Consts.nr, Consts.nsp, Consts.nc, Consts.nnc, Consts.nrk, Consts.wrl, Consts.wrg ::
  Int
Consts.scatter = 1
Consts.escape = 2
Consts.transit = 3
Consts.numExit = 3
Consts.numLev = 35
Consts.numStat = 12
Consts.ne = 1
Consts.nt = 2
Consts.ns = 3
Consts.nek = 4
Consts.nwk = 5
Consts.nr = 6
Consts.nsp = 7
Consts.nc = 8
Consts.nnc = 9
Consts.nrk = 10
Consts.wrl = 11
Consts.wrg = 12


["cylLen","cylLen2","cylRad","cylRad2","big","small","nothing","wgtCut","wgtCut2","ergCut","scatter","escape","transit","numExit","numLev","numStat","ne","nt","ns","nek","nwk","nr","nsp","nc","nnc","nrk","wrl","wrg"]
module Consts
       (cylLen, cylLen2, cylRad, cylRad2, wgtCut, wgtCut2, ergCut, big,
        small, nothing, scatter, escape, transit, numExit, numLev, numStat,
        ne, nt, ns, nek, nwk, nr, nsp, nc, nnc, nrk, wrl, wrg)
       where

cylLen, cylLen2, cylRad, cylRad2, wgtCut, wgtCut2, ergCut, big,
        small, nothing :: Double
cylLen = 20.0
cylLen2 = cylLen + 10.0
cylRad = 1.0
cylRad2 = cylRad * cylRad
big = 100.0
small = 1.0e-7
nothing = -30.0
wgtCut = 0.5
wgtCut2 = wgtCut * wgtCut
ergCut = 1.0e-3

scatter, escape, transit, numExit, numLev, numStat :: Int

ne, nt, ns, nek, nwk, nr, nsp, nc, nnc, nrk, wrl, wrg :: Int
scatter = 1
escape = 2
transit = 3
numExit = 3
numLev = 35
numStat = 12
ne = 1
nt = 2
ns = 3
nek = 4
nwk = 5
nr = 6
nsp = 7
nc = 8
nnc = 9
nrk = 10
wrl = 11
wrg = 12

==================== Renamer ====================
PhotoElec.photoElec ::
  Particle -> Probability -> (Particle, Value, Bool)
PhotoElec.photoElec (!p_aow) (!prob_aox)
  = if (w'_aoN > wgtCut2) then
        (Part pos_aoy dir_aoz w'_aoN e_aoB eIndx_aoC cell_aoD seed'_aoJ, 
         absorb_aoP, False)
    else
        if ((w'_aoN * fromIntegral cell_aoD) < (r1_aoL * wgtCut)) then
            (Part pos_aoy dir_aoz w'_aoN e_aoB eIndx_aoC cell_aoD seed'_aoJ, 
             absorb_aoP, True)
        else
            (Part pos_aoy dir_aoz w''_aoO e_aoB eIndx_aoC cell_aoD seed'_aoJ, 
             absorb_aoP, False)
  where
      (!((!(Part (!pos_aoy)
                 (!dir_aoz)
                 (!w_aoA)
                 e_aoB
                 eIndx_aoC
                 (!cell_aoD)
                 (!seed_aoE)))))
        = p_aow
      ((!pComp_aoF), (!pPair_aoG), pPhot_aoH, (!pTot_aoI)) = prob_aox
      (seed'_aoJ, r2_aoK) = genRand seed_aoE
      (r1_aoL, (!r3_aoM)) = genRand r2_aoK
      (!w'_aoN) = w_aoA * (1 - pPhot_aoH / pTot_aoI)
      (!w''_aoO) = wgtCut / fromIntegral cell_aoD
      (!absorb_aoP) = w_aoA - w'_aoN


["p_aow","!p_aow","(!p_aow)","prob_aox","!prob_aox","(!prob_aox)","pos_aoy","!pos_aoy","(!pos_aoy)","dir_aoz","!dir_aoz","(!dir_aoz)","w_aoA","!w_aoA","(!w_aoA)","e_aoB","eIndx_aoC","cell_aoD","!cell_aoD","(!cell_aoD)","seed_aoE","!seed_aoE","(!seed_aoE)","Part (!pos_aoy) (!dir_aoz) (!w_aoA) e_aoB eIndx_aoC (!cell_aoD)\n  (!seed_aoE)","(Part (!pos_aoy) (!dir_aoz) (!w_aoA) e_aoB eIndx_aoC (!cell_aoD)\n   (!seed_aoE))","!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) e_aoB eIndx_aoC (!cell_aoD)\n    (!seed_aoE))","(!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) e_aoB eIndx_aoC (!cell_aoD)\n     (!seed_aoE)))","((!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) e_aoB eIndx_aoC (!cell_aoD)\n      (!seed_aoE))))","!((!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) e_aoB eIndx_aoC\n       (!cell_aoD) (!seed_aoE))))","(!((!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) e_aoB eIndx_aoC\n        (!cell_aoD) (!seed_aoE)))))","pComp_aoF","!pComp_aoF","(!pComp_aoF)","pPair_aoG","!pPair_aoG","(!pPair_aoG)","pPhot_aoH","pTot_aoI","!pTot_aoI","(!pTot_aoI)","((!pComp_aoF), (!pPair_aoG), pPhot_aoH, (!pTot_aoI))","seed'_aoJ","r2_aoK","(seed'_aoJ, r2_aoK)","r1_aoL","r3_aoM","!r3_aoM","(!r3_aoM)","(r1_aoL, (!r3_aoM))","w'_aoN","!w'_aoN","(!w'_aoN)","w''_aoO","!w''_aoO","(!w''_aoO)","absorb_aoP","!absorb_aoP","(!absorb_aoP)"]
module PhotoElec (photoElec) where
import GamtebType
import Consts
import Utils

photoElec :: Particle -> Probability -> (Particle, Value, Bool)
photoElec (norecord@p_aow) (norecord@prob_aox)
  = if (w'_aoN > wgtCut2) then
      (Part pos_aoy dir_aoz w'_aoN e_aoB eIndx_aoC cell_aoD seed'_aoJ,
       absorb_aoP, False)
      else
      if ((w'_aoN * fromIntegral cell_aoD) < (r1_aoL * wgtCut)) then
        (Part pos_aoy dir_aoz w'_aoN e_aoB eIndx_aoC cell_aoD seed'_aoJ,
         absorb_aoP, True)
        else
        (Part pos_aoy dir_aoz w''_aoO e_aoB eIndx_aoC cell_aoD seed'_aoJ,
         absorb_aoP, False)
  where (norecord@((norecord@(Part (norecord@pos_aoy)
                                (norecord@dir_aoz) (norecord@w_aoA) e_aoB eIndx_aoC
                                (norecord@cell_aoD) (norecord@seed_aoE)))))
          = p_aow
        ((norecord@pComp_aoF), (norecord@pPair_aoG), pPhot_aoH,
         (norecord@pTot_aoI))
          = prob_aox
        (seed'_aoJ, r2_aoK) = genRand seed_aoE
        (r1_aoL, (norecord@r3_aoM)) = genRand r2_aoK
        (norecord@w'_aoN) = w_aoA * (1 - pPhot_aoH / pTot_aoI)
        (norecord@w''_aoO) = wgtCut / fromIntegral cell_aoD
        (norecord@absorb_aoP) = w_aoA - w'_aoN

==================== Renamer ====================
GamtebMain.sources :: Random -> Int -> Energy -> ([Result], [Stat])
GamtebMain.sources (!seed_aoT) (!nPart_aoU) (!e_aoV)
  | (nPart_aoU <= 1) = transPort p_aoZ prob_aoX
  where
      ((!eIndx_aoW), (!prob_aoX)) = xsectInterp e_aoV
      (!(seed'_aoY, (!_))) = genRand seed_aoT
      (!p_aoZ) = (Part (0, 0, 0) (0, 1, 0) 1 e_aoV eIndx_aoW 1 seed'_aoY)
GamtebMain.sources (!seed_aCs) (!nPart_aCt) (!e_aCu)
  = (res1_aCz ++ res2_aCB, s1_aCA ++ s2_aCC)
  where
      nPart1_aCv = nPart_aCt `div` 2
      (!nPart2_aCw) = nPart_aCt - nPart1_aCv
      (r1_aCx, r2_aCy) = genRand seed_aCs
      (!(res1_aCz, s1_aCA)) = GamtebMain.sources r1_aCx nPart1_aCv e_aCu
      (!(res2_aCB, (!s2_aCC)))
        = GamtebMain.sources r2_aCy nPart2_aCw e_aCu
GamtebMain.gamteb :: Int -> [Char]
GamtebMain.gamteb (!scale_aMH)
  = outGamteb nPart_aMJ stats_aMM result_aML
  where
      (!seed_aMI) = 0.5
      (!nPart_aMJ) = 1 * scale_aMH
      energy_aMK = 6
      (!(result_aML, (!stats_aMM)))
        = GamtebMain.sources seed_aMI nPart_aMJ energy_aMK


["seed_aoT","safebang@!seed_aoT","(!seed_aoT)","nPart_aoU","safebang@!nPart_aoU","(!nPart_aoU)","e_aoV","safebang@!e_aoV","(!e_aoV)","eIndx_aoW","!eIndx_aoW","(!eIndx_aoW)","prob_aoX","!prob_aoX","(!prob_aoX)","((!eIndx_aoW), (!prob_aoX))","seed'_aoY","_","!_","(!_)","(seed'_aoY, (!_))","!(seed'_aoY, (!_))","(!(seed'_aoY, (!_)))","p_aoZ","!p_aoZ","(!p_aoZ)","seed_aCs","!seed_aCs","(!seed_aCs)","nPart_aCt","!nPart_aCt","(!nPart_aCt)","e_aCu","!e_aCu","(!e_aCu)","nPart1_aCv","nPart2_aCw","!nPart2_aCw","(!nPart2_aCw)","r1_aCx","r2_aCy","(r1_aCx, r2_aCy)","res1_aCz","s1_aCA","(res1_aCz, s1_aCA)","!(res1_aCz, s1_aCA)","(!(res1_aCz, s1_aCA))","res2_aCB","s2_aCC","safebang@!s2_aCC","(!s2_aCC)","(res2_aCB, (!s2_aCC))","!(res2_aCB, (!s2_aCC))","(!(res2_aCB, (!s2_aCC)))","scale_aMH","safebang@!scale_aMH","(!scale_aMH)","seed_aMI","!seed_aMI","(!seed_aMI)","nPart_aMJ","!nPart_aMJ","(!nPart_aMJ)","energy_aMK","result_aML","stats_aMM","safebang@!stats_aMM","(!stats_aMM)","(result_aML, (!stats_aMM))","!(result_aML, (!stats_aMM))","(!(result_aML, (!stats_aMM)))"]
module GamtebMain (gamteb) where
import GamtebType
import Consts
import Utils
import TransPort
import Output

sources :: Random -> Int -> Energy -> ([Result], [Stat])
sources (!seed_aoT) (!nPart_aoU) (!e_aoV)
  | (nPart_aoU <= 1) = transPort p_aoZ prob_aoX
  where ((norecord@eIndx_aoW), (norecord@prob_aoX))
          = xsectInterp e_aoV
        (norecord@(seed'_aoY, (norecord@_))) = genRand seed_aoT
        (norecord@p_aoZ)
          = (Part (0, 0, 0) (0, 1, 0) 1 e_aoV eIndx_aoW 1 seed'_aoY)
sources (norecord@seed_aCs) (norecord@nPart_aCt) (norecord@e_aCu)
  = (res1_aCz ++ res2_aCB, s1_aCA ++ s2_aCC)
  where nPart1_aCv = nPart_aCt `div` 2
        (norecord@nPart2_aCw) = nPart_aCt - nPart1_aCv
        (r1_aCx, r2_aCy) = genRand seed_aCs
        (norecord@(res1_aCz, s1_aCA)) = sources r1_aCx nPart1_aCv e_aCu
        (norecord@(res2_aCB, (!s2_aCC))) = sources r2_aCy nPart2_aCw e_aCu

gamteb :: Int -> [Char]
gamteb (!scale_aMH) = outGamteb nPart_aMJ stats_aMM result_aML
  where (norecord@seed_aMI) = 0.5
        (norecord@nPart_aMJ) = 1 * scale_aMH
        energy_aMK = 6
        (norecord@(result_aML, (!stats_aMM)))
          = sources seed_aMI nPart_aMJ energy_aMK

==================== Renamer ====================
Distance.distSurf :: Point -> Point -> (Value, Indx)
Distance.distSurf
  ((!p1_aoj@(!((!x_aok), (!y_aol), (!z_aom)))))
  (!((!p2_aon@(!(u_aoo, (!v_aop), (!w_aoq))))))
  = (dSurf_aoz + small, surf_aoA)
  where
      (!((!d1_aor), s1_aos)) = ((Distance.distPlane y_aol v_aop 0), 1)
      (d2_aot, s2_aou) = ((Distance.distCyl p1_aoj p2_aon), 2)
      (!(d3_aov, s3_aow)) = ((Distance.distPlane y_aol v_aop cylLen), 3)
      (!(d4_aox, (!s4_aoy)))
        = ((Distance.distPlane y_aol v_aop cylLen2), 4)
      (!((!dSurf_aoz), (!surf_aoA)))
        = minP_aoB
            (minP_aoB (d1_aor, s1_aos) (d2_aot, s2_aou))
            (minP_aoB (d3_aov, s3_aow) (d4_aox, s4_aoy))
      minP_aoB (!(d_aoC, j_aoD)) ((!d'_aoE), j'_aoF)
        = if (d_aoC < d'_aoE) then (d_aoC, j_aoD) else (d'_aoE, j'_aoF)
Distance.distCyl :: Point -> Point -> Value
Distance.distCyl
  (!((!x_aD6), y_aD7, z_aD8))
  (!(u_aD9, (!v_aDa), (!w_aDb)))
  | (u_aD9 * u_aD9 + w_aDb * w_aDb) == 0 = big
  | (u_aD9 /= 0)
  = let
      (!m_aDc) = w_aDb / u_aD9
      b_aDd = z_aD8 - m_aDc * x_aD6
      s_aDe = m_aDc * m_aDc + 1
      (!r_aDf) = sqrt (s_aDe - b_aDd * b_aDd)
      x'_aDg
        = if (u_aD9 > 0) then
              ((- m_aDc * b_aDd) + r_aDf) / s_aDe
          else
              ((- m_aDc * b_aDd) - r_aDf) / s_aDe
    in (x'_aDg - x_aD6) / u_aD9
  | (u_aD9 == 0 && v_aDa /= 0)
  = let
      m_aMn = w_aDb / v_aDa
      b_aMo = z_aD8 - m_aMn * y_aD7
      r_aMp = sqrt (1 - x_aD6 * x_aD6)
      y'_aMq
        = if (v_aDa > 0) then
              (r_aMp - b_aMo) / m_aMn
          else
              ((- r_aMp) - b_aMo) / m_aMn
    in (y'_aMq - y_aD7) / v_aDa
  | w_aDb > 0 = (sqrt (1 - x_aD6 * x_aD6)) - z_aD8
  | otherwise = (- (sqrt (1 - x_aD6 * x_aD6))) - z_aD8
Distance.distPlane :: Coord -> Coord -> Value -> Value
Distance.distPlane y_aMr v_aMs yPlane_aMt
  | v_aMs == 0 = big
  | y_aMr >= yPlane_aMt = big
  | otherwise = (yPlane_aMt - y_aMr) / v_aMs


["x_aok","!x_aok","(!x_aok)","y_aol","!y_aol","(!y_aol)","z_aom","!z_aom","(!z_aom)","((!x_aok), (!y_aol), (!z_aom))","!((!x_aok), (!y_aol), (!z_aom))","(!((!x_aok), (!y_aol), (!z_aom)))","p1_aoj@(!((!x_aok), (!y_aol), (!z_aom)))","!p1_aoj@(!((!x_aok), (!y_aol), (!z_aom)))","(!p1_aoj@(!((!x_aok), (!y_aol), (!z_aom))))","((!p1_aoj@(!((!x_aok), (!y_aol), (!z_aom)))))","u_aoo","v_aop","!v_aop","(!v_aop)","w_aoq","!w_aoq","(!w_aoq)","(u_aoo, (!v_aop), (!w_aoq))","!(u_aoo, (!v_aop), (!w_aoq))","(!(u_aoo, (!v_aop), (!w_aoq)))","p2_aon@(!(u_aoo, (!v_aop), (!w_aoq)))","!p2_aon@(!(u_aoo, (!v_aop), (!w_aoq)))","(!p2_aon@(!(u_aoo, (!v_aop), (!w_aoq))))","((!p2_aon@(!(u_aoo, (!v_aop), (!w_aoq)))))","!((!p2_aon@(!(u_aoo, (!v_aop), (!w_aoq)))))","(!((!p2_aon@(!(u_aoo, (!v_aop), (!w_aoq))))))","d1_aor","!d1_aor","(!d1_aor)","s1_aos","((!d1_aor), s1_aos)","!((!d1_aor), s1_aos)","(!((!d1_aor), s1_aos))","d2_aot","s2_aou","(d2_aot, s2_aou)","d3_aov","s3_aow","(d3_aov, s3_aow)","!(d3_aov, s3_aow)","(!(d3_aov, s3_aow))","d4_aox","s4_aoy","!s4_aoy","(!s4_aoy)","(d4_aox, (!s4_aoy))","!(d4_aox, (!s4_aoy))","(!(d4_aox, (!s4_aoy)))","dSurf_aoz","!dSurf_aoz","(!dSurf_aoz)","surf_aoA","!surf_aoA","(!surf_aoA)","((!dSurf_aoz), (!surf_aoA))","!((!dSurf_aoz), (!surf_aoA))","(!((!dSurf_aoz), (!surf_aoA)))","d_aoC","j_aoD","(d_aoC, j_aoD)","!(d_aoC, j_aoD)","(!(d_aoC, j_aoD))","d'_aoE","!d'_aoE","(!d'_aoE)","j'_aoF","((!d'_aoE), j'_aoF)","x_aD6","!x_aD6","(!x_aD6)","y_aD7","z_aD8","((!x_aD6), y_aD7, z_aD8)","!((!x_aD6), y_aD7, z_aD8)","(!((!x_aD6), y_aD7, z_aD8))","u_aD9","v_aDa","!v_aDa","(!v_aDa)","w_aDb","!w_aDb","(!w_aDb)","(u_aD9, (!v_aDa), (!w_aDb))","!(u_aD9, (!v_aDa), (!w_aDb))","(!(u_aD9, (!v_aDa), (!w_aDb)))","m_aDc","!m_aDc","(!m_aDc)","b_aDd","s_aDe","r_aDf","!r_aDf","(!r_aDf)","x'_aDg","m_aMn","b_aMo","r_aMp","y'_aMq","y_aMr","v_aMs","yPlane_aMt"]
module Distance (distSurf) where
import GamtebType
import Consts

distSurf :: Point -> Point -> (Value, Indx)
distSurf
  ((norecord@p1_aoj@(norecord@((norecord@x_aok), (norecord@y_aol),
                               (norecord@z_aom)))))
  (norecord@((norecord@p2_aon@(norecord@(u_aoo, (norecord@v_aop),
                                         (norecord@w_aoq))))))
  = (dSurf_aoz + small, surf_aoA)
  where (norecord@((norecord@d1_aor), s1_aos))
          = ((distPlane y_aol v_aop 0), 1)
        (d2_aot, s2_aou) = ((distCyl p1_aoj p2_aon), 2)
        (norecord@(d3_aov, s3_aow)) = ((distPlane y_aol v_aop cylLen), 3)
        (norecord@(d4_aox, (norecord@s4_aoy)))
          = ((distPlane y_aol v_aop cylLen2), 4)
        (norecord@((norecord@dSurf_aoz), (norecord@surf_aoA)))
          = minP_aoB (minP_aoB (d1_aor, s1_aos) (d2_aot, s2_aou))
              (minP_aoB (d3_aov, s3_aow) (d4_aox, s4_aoy))
        minP_aoB (norecord@(d_aoC, j_aoD)) ((norecord@d'_aoE), j'_aoF)
          = if (d_aoC < d'_aoE) then (d_aoC, j_aoD) else (d'_aoE, j'_aoF)

distCyl :: Point -> Point -> Value
distCyl (norecord@((norecord@x_aD6), y_aD7, z_aD8))
  (norecord@(u_aD9, (norecord@v_aDa), (norecord@w_aDb)))
  | (u_aD9 * u_aD9 + w_aDb * w_aDb) == 0 = big
  | (u_aD9 /= 0) =
    let (norecord@m_aDc) = w_aDb / u_aD9
        b_aDd = z_aD8 - m_aDc * x_aD6
        s_aDe = m_aDc * m_aDc + 1
        (norecord@r_aDf) = sqrt (s_aDe - b_aDd * b_aDd)
        x'_aDg
          = if (u_aD9 > 0) then (((-m_aDc) * b_aDd) + r_aDf) / s_aDe else
              (((-m_aDc) * b_aDd) - r_aDf) / s_aDe
      in (x'_aDg - x_aD6) / u_aD9
  | (u_aD9 == 0 && v_aDa /= 0) =
    let m_aMn = w_aDb / v_aDa
        b_aMo = z_aD8 - m_aMn * y_aD7
        r_aMp = sqrt (1 - x_aD6 * x_aD6)
        y'_aMq
          = if (v_aDa > 0) then (r_aMp - b_aMo) / m_aMn else
              ((-r_aMp) - b_aMo) / m_aMn
      in (y'_aMq - y_aD7) / v_aDa
  | w_aDb > 0 = (sqrt (1 - x_aD6 * x_aD6)) - z_aD8
  | otherwise = (-(sqrt (1 - x_aD6 * x_aD6))) - z_aD8

distPlane :: Coord -> Coord -> Value -> Value
distPlane y_aMr v_aMs yPlane_aMt
  | v_aMs == 0 = big
  | y_aMr >= yPlane_aMt = big
  | otherwise = (yPlane_aMt - y_aMr) / v_aMs

==================== Renamer ====================
RoulSplit.roulet :: Particle -> (Particle, [Stat], Bool)
RoulSplit.roulet
  (!((!(Part (!pos_aox)
             (!dir_aoy)
             (!w_aoz)
             (!e_aoA)
             (!eIndx_aoB)
             cell_aoC
             seed_aoD))))
  = if (r1_aoE < 0.5) then
        (Part pos_aox dir_aoy (2 * w_aoz) e_aoA eIndx_aoB 1 seed'_aoG, 
         [(nr, 1), (wrg, w_aoz)], False)
    else
        (Part pos_aox dir_aoy 0 e_aoA eIndx_aoB 1 seed'_aoG, 
         [(nr, 1), (nrk, 1), (wrl, w_aoz)], True)
  where
      (!((!r1_aoE), (!r2_aoF))) = genRand seed_aoD
      (!((!seed'_aoG), r3_aoH)) = genRand r2_aoF
RoulSplit.split :: Particle -> (Particle, Particle)
RoulSplit.split
  (!((!(Part pos_aD8
             dir_aD9
             w_aDa
             e_aDb
             eIndx_aDc
             (!cell_aDd)
             seed_aDe))))
  = (Part pos_aD8 dir_aD9 (0.5 * w_aDa) e_aDb eIndx_aDc 2 seed1_aDf, 
     Part pos_aD8 dir_aD9 (0.5 * w_aDa) e_aDb eIndx_aDc 2 seed2_aDg)
  where
      (!((!seed1_aDf), (!seed2_aDg))) = genRand seed_aDe


["pos_aox","!pos_aox","(!pos_aox)","dir_aoy","!dir_aoy","(!dir_aoy)","w_aoz","!w_aoz","(!w_aoz)","e_aoA","!e_aoA","(!e_aoA)","eIndx_aoB","!eIndx_aoB","(!eIndx_aoB)","cell_aoC","seed_aoD","Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB) cell_aoC\n  seed_aoD","(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB) cell_aoC\n   seed_aoD)","!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n    cell_aoC seed_aoD)","(!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n     cell_aoC seed_aoD))","((!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n      cell_aoC seed_aoD)))","!((!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n       cell_aoC seed_aoD)))","(!((!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n        cell_aoC seed_aoD))))","r1_aoE","!r1_aoE","(!r1_aoE)","r2_aoF","!r2_aoF","(!r2_aoF)","((!r1_aoE), (!r2_aoF))","!((!r1_aoE), (!r2_aoF))","(!((!r1_aoE), (!r2_aoF)))","seed'_aoG","!seed'_aoG","(!seed'_aoG)","r3_aoH","((!seed'_aoG), r3_aoH)","!((!seed'_aoG), r3_aoH)","(!((!seed'_aoG), r3_aoH))","pos_aD8","dir_aD9","w_aDa","e_aDb","eIndx_aDc","cell_aDd","!cell_aDd","(!cell_aDd)","seed_aDe","Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc (!cell_aDd) seed_aDe","(Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc (!cell_aDd) seed_aDe)","!(Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc (!cell_aDd) seed_aDe)","(!(Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc (!cell_aDd)\n     seed_aDe))","((!(Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc (!cell_aDd)\n      seed_aDe)))","!((!(Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc (!cell_aDd)\n       seed_aDe)))","(!((!(Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc (!cell_aDd)\n        seed_aDe))))","seed1_aDf","!seed1_aDf","(!seed1_aDf)","seed2_aDg","!seed2_aDg","(!seed2_aDg)","((!seed1_aDf), (!seed2_aDg))","!((!seed1_aDf), (!seed2_aDg))","(!((!seed1_aDf), (!seed2_aDg)))"]
module RoulSplit (roulet, split) where
import GamtebType
import Consts
import Utils

roulet :: Particle -> (Particle, [Stat], Bool)
roulet
  (norecord@((norecord@(Part (norecord@pos_aox) (norecord@dir_aoy)
                          (norecord@w_aoz) (norecord@e_aoA) (norecord@eIndx_aoB) cell_aoC
                          seed_aoD))))
  = if (r1_aoE < 0.5) then
      (Part pos_aox dir_aoy (2 * w_aoz) e_aoA eIndx_aoB 1 seed'_aoG,
       [(nr, 1), (wrg, w_aoz)], False)
      else
      (Part pos_aox dir_aoy 0 e_aoA eIndx_aoB 1 seed'_aoG,
       [(nr, 1), (nrk, 1), (wrl, w_aoz)], True)
  where (norecord@((norecord@r1_aoE), (norecord@r2_aoF)))
          = genRand seed_aoD
        (norecord@((norecord@seed'_aoG), r3_aoH)) = genRand r2_aoF

split :: Particle -> (Particle, Particle)
split
  (norecord@((norecord@(Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc
                          (norecord@cell_aDd) seed_aDe))))
  = (Part pos_aD8 dir_aD9 (0.5 * w_aDa) e_aDb eIndx_aDc 2 seed1_aDf,
     Part pos_aD8 dir_aD9 (0.5 * w_aDa) e_aDb eIndx_aDc 2 seed2_aDg)
  where (norecord@((norecord@seed1_aDf), (norecord@seed2_aDg)))
          = genRand seed_aDe

==================== Renamer ====================
(!a_api) TransPort.=: (!b_apj) = (a_api, b_apj)
TransPort.transPort ::
  Particle -> Probability -> ([Result], [Stat])
TransPort.transPort (!p_apk) (!prob_apl)
  = if (dColl_apB < dSurf_apz) then
        (let
           (!pos'_aMe) = TransPort.transPos pos_apm dir_apn dColl_apB
           p'_aMf
             = Part pos'_aMe dir_apn w_apo e_app eIndx_apq cell_apr seed_aps
           doCompton_aMg = (r1_apy < (pComp_apt / (pTot_apw - pPhot_apv)))
           (!((!res_aMh), (!stat_aMi)))
             = TransPort.collision p'_aMf prob_apl doCompton_aMg
         in (res_aMh, [nc TransPort.=: 1] ++ stat_aMi))
    else
        (let
           (!pos'_aNd) = TransPort.transPos pos_apm dir_apn dSurf_apz
           (!p'_aNe)
             = Part pos'_aNd dir_apn w_apo e_app eIndx_apq cell_apr seed_aps
           (!((!res_aNf), stat_aNg))
             = TransPort.noCollision p'_aNe prob_apl surf_apA
         in (res_aNf, [nnc TransPort.=: 1] ++ stat_aNg))
  where
      (!((!(Part pos_apm
                 dir_apn
                 w_apo
                 e_app
                 eIndx_apq
                 (!cell_apr)
                 seed_aps))))
        = p_apk
      ((!pComp_apt), (!pPair_apu), (!pPhot_apv), pTot_apw) = prob_apl
      ((!r_apx), (!r1_apy)) = genRand seed_aps
      (dSurf_apz, (!surf_apA)) = distSurf pos_apm dir_apn
      dColl_apB = - ((log r_apx) / pTot_apw)
TransPort.noCollision ::
  Particle -> Probability -> Int -> ([Result], [Stat])
TransPort.noCollision
  p_aNh@(!(Part (!pos_aNi)
                dir_aNj
                (!w_aNk)
                (!e_aNl)
                (!eIndx_aNm)
                (!cell_aNn)
                seed_aNo))
  prob_aNp
  surf_aNq
  = case surf_aNq of {
      1 -> ([(scatter, eIndx_aNm) TransPort.=: w_aNk], 
            [ns TransPort.=: 1])
      2 -> ([(escape, eIndx_aNm) TransPort.=: w_aNk], 
            [ne TransPort.=: 1])
      4 -> ([(transit, eIndx_aNm) TransPort.=: w_aNk], 
            [nt TransPort.=: 1])
      3 -> if (cell_aNn == 1) then
               (let
                  (p1_aNr, p2_aNs) = split p_aNh
                  ((!r1_aNt), s1_aNu) = TransPort.transPort p1_aNr prob_aNp
                  (!(r2_aNv, s2_aNw)) = TransPort.transPort p2_aNs prob_aNp
                in (r1_aNt ++ r2_aNv, [nsp TransPort.=: 1] ++ s1_aNu ++ s2_aNw))
           else
               (let (!((!p'_aNx), (!stat'_aNy), (!roulKill_aNz))) = roulet p_aNh
                in
                  if (roulKill_aNz) then
                      ([], stat'_aNy)
                  else
                      (let ((!res_aNA), stat_aNB) = TransPort.transPort p'_aNx prob_aNp
                       in (res_aNA, stat_aNB ++ stat'_aNy))) }
TransPort.collision ::
  Particle -> Probability -> Bool -> ([Result], [Stat])
TransPort.collision p_aNC prob_aND doCompton_aNE
  = if (wgtKill_aNS) then
        ([], [nwk TransPort.=: 1])
    else
        if (doCompton_aNE) then
            (let (!((!p''_aNT), prob'_aNU, (!comptonCut_aNV))) = compton p'_aNQ
             in
               if (comptonCut_aNV) then
                   ([], [nek TransPort.=: 1])
               else
                   TransPort.transPort p''_aNT prob'_aNU)
        else
            (let ((!p''_aNW), (!prob'_aNX), (!pairCut_aNY)) = pair p'_aNQ
             in
               if (pairCut_aNY) then
                   ([], [nek TransPort.=: 1])
               else
                   TransPort.transPort p''_aNW prob'_aNX)
  where
      (!((!(Part (!pos_aNF)
                 dir_aNG
                 w_aNH
                 (!e_aNI)
                 (!eIndx_aNJ)
                 cell_aNK
                 seed_aNL))))
        = p_aNC
      (pComp_aNM, pPair_aNN, (!pPhot_aNO), pTot_aNP) = prob_aND
      (!(p'_aNQ, absorb_aNR, (!wgtKill_aNS))) = photoElec p_aNC prob_aND
TransPort.transPos :: Point -> Point -> Value -> Point
TransPort.transPos
  (!(x_aNZ, y_aO0, (!z_aO1)))
  ((!u_aO2), (!v_aO3), w_aO4)
  dist_aO5
  = (x'_aO6, y'_aO7, z'_aO8)
  where
      (!x'_aO6) = x_aNZ + u_aO2 * dist_aO5
      y'_aO7 = y_aO0 + v_aO3 * dist_aO5
      (!z'_aO8) = z_aO1 + w_aO4 * dist_aO5



==================== Renamer ====================
type GamtebType.Angle = Double
type GamtebType.Coord = Double
type GamtebType.Energy = Double
type GamtebType.Indx = Int
type GamtebType.PartType = Int
type GamtebType.Prob = Double
type GamtebType.Random = Double
type GamtebType.StatType = Int
type GamtebType.Weight = Double
type GamtebType.Value = Double
type GamtebType.Result =
    ((GamtebType.PartType, GamtebType.Indx), GamtebType.Weight)
type GamtebType.Stat = (GamtebType.StatType, GamtebType.Value)
type GamtebType.Point =
    (GamtebType.Coord, GamtebType.Coord, GamtebType.Coord)
type GamtebType.Probability =
    (GamtebType.Prob,
     GamtebType.Prob,
     GamtebType.Prob,
     GamtebType.Prob)
data GamtebType.Particle
  = GamtebType.Part GamtebType.Point GamtebType.Point GamtebType.Weight GamtebType.Energy GamtebType.Indx Int GamtebType.Random


[]
module GamtebType
       (Angle, Coord, Energy, Indx, PartType, Prob, Random, StatType,
        Weight, Value, Result, Stat, Point, Particle(..), Probability)
       where

type Angle = Double

type Coord = Double

type Energy = Double

type Indx = Int

type PartType = Int

type Prob = Double

type Random = Double

type StatType = Int

type Weight = Double

type Value = Double

type Result = ((PartType, Indx), Weight)

type Stat = (StatType, Value)

type Point = (Coord, Coord, Coord)

type Probability = (Prob, Prob, Prob, Prob)

data Particle = Part Point Point Weight Energy Indx Int Random

==================== Renamer ====================
Utils.xsectInterp :: Energy -> (Indx, Probability)
Utils.xsectInterp (!e_awH)
  = (eIndx_awJ, 
     (pComp_awM, pPair_awN, pPhot_awO, 
      (pComp_awM + pPair_awN + pPhot_awO)))
  where
      (!logE_awI) = log e_awH
      (!eIndx_awJ)
        = findIndx_awP 1
        where
            findIndx_awP (!i_awQ)
              | (i_awQ < numLev) && (logE_awI > ergs ! i_awQ)
              = findIndx_awP (i_awQ + 1)
            findIndx_awP (!i_aTi) = i_aTi
      i_awK = (if (eIndx_awJ < 2) then 2 else eIndx_awJ)
      f_awL
        = (logE_awI - ergs ! (i_awK - 1))
          / (ergs ! i_awK - ergs ! (i_awK - 1))
      (!pComp_awM)
        = exp
            (xComp ! (i_awK - 1)
             + f_awL * (xComp ! i_awK - xComp ! (i_awK - 1)))
      (!pPair_awN)
        = exp
            (xPair ! (i_awK - 1)
             + f_awL * (xPair ! i_awK - xPair ! (i_awK - 1)))
      (!pPhot_awO)
        = exp
            (xPhot ! (i_awK - 1)
             + f_awL * (xPhot ! i_awK - xPhot ! (i_awK - 1)))
Utils.genRand :: Random -> (Random, Random)
Utils.genRand (!seed_a12o)
  = (r1_a12p / 65599, r2_a12q / 71123)
  where
      (!r1_a12p) = (314557 * seed_a12o + 2711) `fiRem_a12r` 65599
      (!r2_a12q) = (2711 * seed_a12o + 314557) `fiRem_a12r` 71123
      fiRem_a12r x_a12s (!m_a12t)
        = x_a12s - fromIntegral ((truncate x_a12s `div` m_a12t) * m_a12t)


["e_awH","safebang@!e_awH","(!e_awH)","logE_awI","!logE_awI","(!logE_awI)","eIndx_awJ","!eIndx_awJ","(!eIndx_awJ)","i_awQ","safebang@!i_awQ","(!i_awQ)","i_aTi","!i_aTi","(!i_aTi)","i_awK","f_awL","pComp_awM","!pComp_awM","(!pComp_awM)","pPair_awN","!pPair_awN","(!pPair_awN)","pPhot_awO","!pPhot_awO","(!pPhot_awO)","seed_a12o","safebang@!seed_a12o","(!seed_a12o)","r1_a12p","!r1_a12p","(!r1_a12p)","r2_a12q","!r2_a12q","(!r2_a12q)","x_a12s","m_a12t","!m_a12t","(!m_a12t)"]
module Utils (xsectInterp, genRand) where
import GamtebType
import Consts
import InitTable
import Data.Array ((!))

xsectInterp :: Energy -> (Indx, Probability)
xsectInterp (!e_awH)
  = (eIndx_awJ,
     (pComp_awM, pPair_awN, pPhot_awO,
      (pComp_awM + pPair_awN + pPhot_awO)))
  where (norecord@logE_awI) = log e_awH
        (norecord@eIndx_awJ) = findIndx_awP 1
          where findIndx_awP (!i_awQ)
                  | (i_awQ < numLev) && (logE_awI > ergs ! i_awQ) =
                    findIndx_awP (i_awQ + 1)
                findIndx_awP (norecord@i_aTi) = i_aTi
        i_awK = (if (eIndx_awJ < 2) then 2 else eIndx_awJ)
        f_awL
          = (logE_awI - ergs ! (i_awK - 1)) /
              (ergs ! i_awK - ergs ! (i_awK - 1))
        (norecord@pComp_awM)
          = exp
              (xComp ! (i_awK - 1) + f_awL *
                 (xComp ! i_awK - xComp ! (i_awK - 1)))
        (norecord@pPair_awN)
          = exp
              (xPair ! (i_awK - 1) + f_awL *
                 (xPair ! i_awK - xPair ! (i_awK - 1)))
        (norecord@pPhot_awO)
          = exp
              (xPhot ! (i_awK - 1) + f_awL *
                 (xPhot ! i_awK - xPhot ! (i_awK - 1)))

genRand :: Random -> (Random, Random)
genRand (!seed_a12o) = (r1_a12p / 65599, r2_a12q / 71123)
  where (norecord@r1_a12p)
          = (314557 * seed_a12o + 2711) `fiRem_a12r` 65599
        (norecord@r2_a12q) = (2711 * seed_a12o + 314557) `fiRem_a12r` 71123
        fiRem_a12r x_a12s (norecord@m_a12t)
          = x_a12s - fromIntegral ((truncate x_a12s `div` m_a12t) * m_a12t)

==================== Renamer ====================
Compton.compton :: Particle -> (Particle, Probability, Bool)
Compton.compton
  (!((!(Part (!pos_aoy)
             (!dir_aoz)
             (!w_aoA)
             (!e_aoB)
             (!eIndx_aoC)
             cell_aoD
             seed_aoE))))
  = if (e'_aoM <= ergCut) then
        (Part pos_aoy dir_aoz w_aoA e'_aoM eIndx'_aoN cell_aoD seed'_aoF, 
         prob'_aoO, True)
    else
        (Part pos_aoy dir'_aoP w_aoA e'_aoM eIndx'_aoN cell_aoD seed'_aoF, 
         prob'_aoO, False)
  where
      (!((!seed'_aoF), (!r2_aoG))) = genRand seed_aoE
      (!((!r3_aoH), r4_aoI)) = genRand r2_aoG
      eIn_aoJ = 1.956917 * e_aoB
      eOut_aoK = Compton.klein eIn_aoJ r3_aoH
      angle_aoL = 1 + 1 / eIn_aoJ - 1 / eOut_aoK
      e'_aoM = 0.511008 * eOut_aoK
      (eIndx'_aoN, (!prob'_aoO)) = xsectInterp e'_aoM
      (!dir'_aoP) = Compton.rotas dir_aoz angle_aoL r4_aoI
Compton.rotas :: Point -> Angle -> Random -> Point
Compton.rotas (!((!u_aMm), (!v_aMn), (!w_aMo))) a_aMp rn_aMq
  = if (r_aMx > 1) then
        Compton.rotas (u_aMm, v_aMn, w_aMo) a_aMp rn'_aMt
    else
        (let
           (!r'_aMy) = sqrt ((1 - a_aMp * a_aMp) / r_aMx)
           (!t1'_aMz) = t1_aMv * r'_aMy
           t2'_aMA = t2_aMw * r'_aMy
           wsq_aMB = 1 - w_aMo * w_aMo
           (!s_aMC) = sqrt wsq_aMB
           u'_aMD
             = u_aMm * a_aMp
               + (t1'_aMz * u_aMm * w_aMo - t2'_aMA * v_aMn) / s_aMC
           v'_aME
             = v_aMn * a_aMp
               + (t1'_aMz * v_aMn * w_aMo - t2'_aMA * u_aMm) / s_aMC
           (!w'_aMF) = w_aMo * a_aMp - t1'_aMz * s_aMC
         in
           if (wsq_aMB < small) then
               (t1'_aMz, t2'_aMA, (w_aMo * a_aMp))
           else
               (u'_aMD, v'_aME, w'_aMF))
  where
      (!(r1_aMr, (!r2_aMs))) = genRand rn_aMq
      ((!rn'_aMt), (!r3_aMu)) = genRand r2_aMs
      t1_aMv = 2 * r1_aMr - 1
      (!t2_aMw) = 2 * r3_aMu - 1
      r_aMx = t1_aMv * t1_aMv + t2_aMw * t2_aMw
Compton.klein :: Energy -> Random -> Energy
Compton.klein e_aMG r_aMH
  = if (e_aMG > 1.16666667) then
        (let
           a'_aMT = 1.65898 + a_aMI * (0.62537 * a_aMI - 1.00796)
           b'_aMU = a'_aMT / f_aMM
         in
           if (r_aMH > b'_aMU) then
               (let
                  c'_aMV = (d_aML - 1.20397) / (1 - b'_aMU)
                  x'_aMW = 0.3 * exp (c'_aMV * (b'_aMU - r_aMH))
                in x'_aMW * e_aMG)
           else
               (let
                  c'_aMX = a'_aMT / (3.63333 + a_aMI * (5.44444 * a_aMI - 4.66667))
                  x'_aMY = klein1_aMN (r_aMH / b'_aMU) 2.1 c'_aMX 1.4 (0.5 * a'_aMT)
                in x'_aMY * e_aMG))
    else
        (let
           x'_aMZ = klein1_aMN r_aMH (3 * c'_aN2) a'_aN0 (2 * c'_aN2) b'_aN1
           (!a'_aN0) = f_aMM / (b_aMJ + c_aMK)
           b'_aN1 = 0.5 * f_aMM
           c'_aN2 = 1 - c_aMK
         in x'_aMZ * e_aMG)
  where
      a_aMI = 1 / e_aMG
      b_aMJ = 2 * e_aMG + 1
      (!c_aMK) = 1 / b_aMJ
      (!d_aML) = log b_aMJ
      (!f_aMM)
        = 2 * e_aMG * (1 + e_aMG) * c_aMK * c_aMK + 4 * a_aMI
          + (1 - 2 * a_aMI * (1 + a_aMI)) * d_aML
      klein1_aMN (!x2_aMO) (!x3_aMP) (!x4_aMQ) x5_aMR x7_aMS
        = 1
          + x2_aMO
            * (x2_aMO
               * (2 * x7_aMS + x4_aMQ - x3_aMP
                  + x2_aMO * (x5_aMR - x7_aMS - x4_aMQ))
               - x7_aMS)


["pos_aoy","!pos_aoy","(!pos_aoy)","dir_aoz","!dir_aoz","(!dir_aoz)","w_aoA","!w_aoA","(!w_aoA)","e_aoB","!e_aoB","(!e_aoB)","eIndx_aoC","!eIndx_aoC","(!eIndx_aoC)","cell_aoD","seed_aoE","Part (!pos_aoy) (!dir_aoz) (!w_aoA) (!e_aoB) (!eIndx_aoC) cell_aoD\n  seed_aoE","(Part (!pos_aoy) (!dir_aoz) (!w_aoA) (!e_aoB) (!eIndx_aoC) cell_aoD\n   seed_aoE)","!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) (!e_aoB) (!eIndx_aoC)\n    cell_aoD seed_aoE)","(!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) (!e_aoB) (!eIndx_aoC)\n     cell_aoD seed_aoE))","((!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) (!e_aoB) (!eIndx_aoC)\n      cell_aoD seed_aoE)))","!((!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) (!e_aoB) (!eIndx_aoC)\n       cell_aoD seed_aoE)))","(!((!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) (!e_aoB) (!eIndx_aoC)\n        cell_aoD seed_aoE))))","seed'_aoF","!seed'_aoF","(!seed'_aoF)","r2_aoG","!r2_aoG","(!r2_aoG)","((!seed'_aoF), (!r2_aoG))","!((!seed'_aoF), (!r2_aoG))","(!((!seed'_aoF), (!r2_aoG)))","r3_aoH","!r3_aoH","(!r3_aoH)","r4_aoI","((!r3_aoH), r4_aoI)","!((!r3_aoH), r4_aoI)","(!((!r3_aoH), r4_aoI))","eIn_aoJ","eOut_aoK","angle_aoL","e'_aoM","eIndx'_aoN","prob'_aoO","!prob'_aoO","(!prob'_aoO)","(eIndx'_aoN, (!prob'_aoO))","dir'_aoP","!dir'_aoP","(!dir'_aoP)","u_aMm","safebang@!u_aMm","(!u_aMm)","v_aMn","safebang@!v_aMn","(!v_aMn)","w_aMo","safebang@!w_aMo","(!w_aMo)","((!u_aMm), (!v_aMn), (!w_aMo))","!((!u_aMm), (!v_aMn), (!w_aMo))","(!((!u_aMm), (!v_aMn), (!w_aMo)))","a_aMp","rn_aMq","r'_aMy","!r'_aMy","(!r'_aMy)","t1'_aMz","!t1'_aMz","(!t1'_aMz)","t2'_aMA","wsq_aMB","s_aMC","!s_aMC","(!s_aMC)","u'_aMD","v'_aME","w'_aMF","!w'_aMF","(!w'_aMF)","r1_aMr","r2_aMs","!r2_aMs","(!r2_aMs)","(r1_aMr, (!r2_aMs))","!(r1_aMr, (!r2_aMs))","(!(r1_aMr, (!r2_aMs)))","rn'_aMt","!rn'_aMt","(!rn'_aMt)","r3_aMu","!r3_aMu","(!r3_aMu)","((!rn'_aMt), (!r3_aMu))","t1_aMv","t2_aMw","!t2_aMw","(!t2_aMw)","r_aMx","e_aMG","r_aMH","a'_aMT","b'_aMU","c'_aMV","x'_aMW","c'_aMX","x'_aMY","x'_aMZ","a'_aN0","!a'_aN0","(!a'_aN0)","b'_aN1","c'_aN2","a_aMI","b_aMJ","c_aMK","!c_aMK","(!c_aMK)","d_aML","!d_aML","(!d_aML)","f_aMM","!f_aMM","(!f_aMM)","x2_aMO","!x2_aMO","(!x2_aMO)","x3_aMP","!x3_aMP","(!x3_aMP)","x4_aMQ","!x4_aMQ","(!x4_aMQ)","x5_aMR","x7_aMS"]
module Compton (compton) where
import GamtebType
import Consts
import Utils

compton :: Particle -> (Particle, Probability, Bool)
compton
  (norecord@((norecord@(Part (norecord@pos_aoy) (norecord@dir_aoz)
                          (norecord@w_aoA) (norecord@e_aoB) (norecord@eIndx_aoC) cell_aoD
                          seed_aoE))))
  = if (e'_aoM <= ergCut) then
      (Part pos_aoy dir_aoz w_aoA e'_aoM eIndx'_aoN cell_aoD seed'_aoF,
       prob'_aoO, True)
      else
      (Part pos_aoy dir'_aoP w_aoA e'_aoM eIndx'_aoN cell_aoD seed'_aoF,
       prob'_aoO, False)
  where (norecord@((norecord@seed'_aoF), (norecord@r2_aoG)))
          = genRand seed_aoE
        (norecord@((norecord@r3_aoH), r4_aoI)) = genRand r2_aoG
        eIn_aoJ = 1.956917 * e_aoB
        eOut_aoK = klein eIn_aoJ r3_aoH
        angle_aoL = 1 + 1 / eIn_aoJ - 1 / eOut_aoK
        e'_aoM = 0.511008 * eOut_aoK
        (eIndx'_aoN, (norecord@prob'_aoO)) = xsectInterp e'_aoM
        (norecord@dir'_aoP) = rotas dir_aoz angle_aoL r4_aoI

rotas :: Point -> Angle -> Random -> Point
rotas (norecord@((!u_aMm), (!v_aMn), (!w_aMo))) a_aMp rn_aMq
  = if (r_aMx > 1) then rotas (u_aMm, v_aMn, w_aMo) a_aMp rn'_aMt
      else
      (let (norecord@r'_aMy) = sqrt ((1 - a_aMp * a_aMp) / r_aMx)
           (norecord@t1'_aMz) = t1_aMv * r'_aMy
           t2'_aMA = t2_aMw * r'_aMy
           wsq_aMB = 1 - w_aMo * w_aMo
           (norecord@s_aMC) = sqrt wsq_aMB
           u'_aMD
             = u_aMm * a_aMp + (t1'_aMz * u_aMm * w_aMo - t2'_aMA * v_aMn) /
                 s_aMC
           v'_aME
             = v_aMn * a_aMp + (t1'_aMz * v_aMn * w_aMo - t2'_aMA * u_aMm) /
                 s_aMC
           (norecord@w'_aMF) = w_aMo * a_aMp - t1'_aMz * s_aMC
         in
         if (wsq_aMB < small) then (t1'_aMz, t2'_aMA, (w_aMo * a_aMp)) else
           (u'_aMD, v'_aME, w'_aMF))
  where (norecord@(r1_aMr, (norecord@r2_aMs))) = genRand rn_aMq
        ((norecord@rn'_aMt), (norecord@r3_aMu)) = genRand r2_aMs
        t1_aMv = 2 * r1_aMr - 1
        (norecord@t2_aMw) = 2 * r3_aMu - 1
        r_aMx = t1_aMv * t1_aMv + t2_aMw * t2_aMw

klein :: Energy -> Random -> Energy
klein e_aMG r_aMH
  = if (e_aMG > 1.16666667) then
      (let a'_aMT = 1.65898 + a_aMI * (0.62537 * a_aMI - 1.00796)
           b'_aMU = a'_aMT / f_aMM
         in
         if (r_aMH > b'_aMU) then
           (let c'_aMV = (d_aML - 1.20397) / (1 - b'_aMU)
                x'_aMW = 0.3 * exp (c'_aMV * (b'_aMU - r_aMH))
              in x'_aMW * e_aMG)
           else
           (let c'_aMX
                  = a'_aMT / (3.63333 + a_aMI * (5.44444 * a_aMI - 4.66667))
                x'_aMY = klein1_aMN (r_aMH / b'_aMU) 2.1 c'_aMX 1.4 (0.5 * a'_aMT)
              in x'_aMY * e_aMG))
      else
      (let x'_aMZ
             = klein1_aMN r_aMH (3 * c'_aN2) a'_aN0 (2 * c'_aN2) b'_aN1
           (norecord@a'_aN0) = f_aMM / (b_aMJ + c_aMK)
           b'_aN1 = 0.5 * f_aMM
           c'_aN2 = 1 - c_aMK
         in x'_aMZ * e_aMG)
  where a_aMI = 1 / e_aMG
        b_aMJ = 2 * e_aMG + 1
        (norecord@c_aMK) = 1 / b_aMJ
        (norecord@d_aML) = log b_aMJ
        (norecord@f_aMM)
          = 2 * e_aMG * (1 + e_aMG) * c_aMK * c_aMK + 4 * a_aMI +
              (1 - 2 * a_aMI * (1 + a_aMI))
              * d_aML
        klein1_aMN (norecord@x2_aMO) (norecord@x3_aMP) (norecord@x4_aMQ)
          x5_aMR x7_aMS
          = 1 + x2_aMO *
              (x2_aMO *
                 (2 * x7_aMS + x4_aMQ - x3_aMP + x2_aMO *
                    (x5_aMR - x7_aMS - x4_aMQ))
                 - x7_aMS)

==================== Renamer ====================
Pair.pair :: Particle -> (Particle, Probability, Bool)
Pair.pair
  (!((!(Part (!pos_aox)
             (!dir_aoy)
             (!w_aoz)
             (!e_aoA)
             (!eIndx_aoB)
             cell_aoC
             seed_aoD))))
  = if (e'_aoI <= ergCut) then
        (Part pos_aox dir_aoy w'_aoL e'_aoI eIndx'_aoJ cell_aoC seed'_aoE, 
         prob'_aoK, True)
    else
        (Part
           pos_aox dir'_aoM w'_aoL e'_aoI eIndx'_aoJ cell_aoC seed'_aoE, 
         prob'_aoK, False)
  where
      (!((!seed'_aoE), (!r2_aoF))) = genRand seed_aoD
      (!((!r3_aoG), r4_aoH)) = genRand r2_aoF
      e'_aoI = 0.511008
      (eIndx'_aoJ, prob'_aoK) = xsectInterp e'_aoI
      w'_aoL = 2 * w_aoz
      (!dir'_aoM) = Pair.isos r3_aoG
Pair.isos :: Random -> Point
Pair.isos r_aDd
  = isos'_aDk t1_aDi t2_aDj (t1_aDi * t1_aDi + t2_aDj * t2_aDj)
  where
      (!((!r1_aDe), (!r2_aDf))) = genRand r_aDd
      ((!r3_aDg), (!r4_aDh)) = genRand r2_aDf
      t1_aDi = 2 * r4_aDh - 1
      (!t2_aDj) = 2 * r3_aDg - 1
      isos'_aDk (!t1_aDl) t2_aDm rsq_aDn
        | rsq_aDn > 1
        = let
            ((!r1_aDo), r2_aDp) = genRand r1_aDo
            (!((!r3_aDq), r4_aDr)) = genRand r2_aDp
            (!t1_aDs) = 2 * r4_aDr - 1
            (!t2_aDt) = 2 * r3_aDq - 1
          in isos'_aDk t1_aDs t2_aDt (t1_aDs * t1_aDs + t2_aDt * t2_aDt)
        | otherwise
        = let
            (!u_aDu) = 2 * rsq_aDn - 1
            t3_aDv = sqrt (1 - u_aDu * u_aDu) / rsq_aDn
            v_aDw = t1_aDl * t3_aDv
            (!w_aDx) = t2_aDm * t3_aDv
          in (u_aDu, v_aDw, w_aDx)


["pos_aox","!pos_aox","(!pos_aox)","dir_aoy","!dir_aoy","(!dir_aoy)","w_aoz","!w_aoz","(!w_aoz)","e_aoA","!e_aoA","(!e_aoA)","eIndx_aoB","!eIndx_aoB","(!eIndx_aoB)","cell_aoC","seed_aoD","Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB) cell_aoC\n  seed_aoD","(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB) cell_aoC\n   seed_aoD)","!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n    cell_aoC seed_aoD)","(!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n     cell_aoC seed_aoD))","((!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n      cell_aoC seed_aoD)))","!((!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n       cell_aoC seed_aoD)))","(!((!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n        cell_aoC seed_aoD))))","seed'_aoE","!seed'_aoE","(!seed'_aoE)","r2_aoF","!r2_aoF","(!r2_aoF)","((!seed'_aoE), (!r2_aoF))","!((!seed'_aoE), (!r2_aoF))","(!((!seed'_aoE), (!r2_aoF)))","r3_aoG","!r3_aoG","(!r3_aoG)","r4_aoH","((!r3_aoG), r4_aoH)","!((!r3_aoG), r4_aoH)","(!((!r3_aoG), r4_aoH))","e'_aoI","eIndx'_aoJ","prob'_aoK","(eIndx'_aoJ, prob'_aoK)","w'_aoL","dir'_aoM","!dir'_aoM","(!dir'_aoM)","r_aDd","r1_aDe","!r1_aDe","(!r1_aDe)","r2_aDf","!r2_aDf","(!r2_aDf)","((!r1_aDe), (!r2_aDf))","!((!r1_aDe), (!r2_aDf))","(!((!r1_aDe), (!r2_aDf)))","r3_aDg","!r3_aDg","(!r3_aDg)","r4_aDh","!r4_aDh","(!r4_aDh)","((!r3_aDg), (!r4_aDh))","t1_aDi","t2_aDj","!t2_aDj","(!t2_aDj)","t1_aDl","safebang@!t1_aDl","(!t1_aDl)","t2_aDm","rsq_aDn","r1_aDo","!r1_aDo","(!r1_aDo)","r2_aDp","((!r1_aDo), r2_aDp)","r3_aDq","!r3_aDq","(!r3_aDq)","r4_aDr","((!r3_aDq), r4_aDr)","!((!r3_aDq), r4_aDr)","(!((!r3_aDq), r4_aDr))","t1_aDs","!t1_aDs","(!t1_aDs)","t2_aDt","!t2_aDt","(!t2_aDt)","u_aDu","!u_aDu","(!u_aDu)","t3_aDv","v_aDw","w_aDx","!w_aDx","(!w_aDx)"]
module Pair (pair) where
import GamtebType
import Consts
import Utils

pair :: Particle -> (Particle, Probability, Bool)
pair
  (norecord@((norecord@(Part (norecord@pos_aox) (norecord@dir_aoy)
                          (norecord@w_aoz) (norecord@e_aoA) (norecord@eIndx_aoB) cell_aoC
                          seed_aoD))))
  = if (e'_aoI <= ergCut) then
      (Part pos_aox dir_aoy w'_aoL e'_aoI eIndx'_aoJ cell_aoC seed'_aoE,
       prob'_aoK, True)
      else
      (Part pos_aox dir'_aoM w'_aoL e'_aoI eIndx'_aoJ cell_aoC seed'_aoE,
       prob'_aoK, False)
  where (norecord@((norecord@seed'_aoE), (norecord@r2_aoF)))
          = genRand seed_aoD
        (norecord@((norecord@r3_aoG), r4_aoH)) = genRand r2_aoF
        e'_aoI = 0.511008
        (eIndx'_aoJ, prob'_aoK) = xsectInterp e'_aoI
        w'_aoL = 2 * w_aoz
        (norecord@dir'_aoM) = isos r3_aoG

isos :: Random -> Point
isos r_aDd
  = isos'_aDk t1_aDi t2_aDj (t1_aDi * t1_aDi + t2_aDj * t2_aDj)
  where (norecord@((norecord@r1_aDe), (norecord@r2_aDf)))
          = genRand r_aDd
        ((norecord@r3_aDg), (norecord@r4_aDh)) = genRand r2_aDf
        t1_aDi = 2 * r4_aDh - 1
        (norecord@t2_aDj) = 2 * r3_aDg - 1
        isos'_aDk (!t1_aDl) t2_aDm rsq_aDn
          | rsq_aDn > 1 =
            let ((norecord@r1_aDo), r2_aDp) = genRand r1_aDo
                (norecord@((norecord@r3_aDq), r4_aDr)) = genRand r2_aDp
                (norecord@t1_aDs) = 2 * r4_aDr - 1
                (norecord@t2_aDt) = 2 * r3_aDq - 1
              in isos'_aDk t1_aDs t2_aDt (t1_aDs * t1_aDs + t2_aDt * t2_aDt)
          | otherwise =
            let (norecord@u_aDu) = 2 * rsq_aDn - 1
                t3_aDv = sqrt (1 - u_aDu * u_aDu) / rsq_aDn
                v_aDw = t1_aDl * t3_aDv
                (norecord@w_aDx) = t2_aDm * t3_aDv
              in (u_aDu, v_aDw, w_aDx)

==================== Renamer ====================
Output.outGamteb :: Int -> [Stat] -> [Result] -> [Char]
Output.outGamteb (!nPart_awZ) (!stats_ax0) (!results_ax1)
  = "Number of particles "
    ++
      show nPart_awZ
      ++
        "\n"
        ++
          Output.outXsectTbl
          ++
            Output.outResultsRaw results_ax1
            ++ Output.outStats stats_ax0 ++ Output.outResults results_ax1
Output.outResults (!results_aFs)
  = "\n\
    \Scatter, Escape, Transit tables:\n"
    ++ show resArray_aFt
  where
      (!resArray_aFt)
        = accumArray (+) 0 ((1, 1), (numExit, numLev)) results_aFs
Output.outStats stats_aOV
  = showStats_aOZ titles_aOY statList_aOX
  where
      statArray_aOW = accumArray (+) 0 (1, numStat) stats_aOV
      (!statList_aOX) = elems statArray_aOW
      (!titles_aOY)
        = ["Number of escapes: ", "Number of transits: ",
           "Number of scatters: ", "Number of energy kills: ",
           "Number of weight kills: ", "Number of roulettes: ",
           "Number of splits: ", "Number of collisions: ",
           "Number of noncollisions: ", "Number of roulettes kills: ",
           "Weight of roulette kills: ", "Weight of roulette gains: "]
      showStats_aOZ (![]) (![]) = ""
      showStats_aOZ (!((!t_aP0) : (!ts_aP1))) (s_aP2 : ss_aP3)
        = t_aP0 ++ show s_aP2 ++ "\n" ++ showStats_aOZ ts_aP1 ss_aP3
Output.outResultsRaw :: [Result] -> [Char]
Output.outResultsRaw [] = []
Output.outResultsRaw
  ((!((!((!((!i_aP4), t_aP5)), (!w_aP6))) : (!rs_aP7))))
  = "Result: index "
    ++
      show i_aP4
      ++
        "  type "
        ++
          show t_aP5
          ++ "  weight " ++ show w_aP6 ++ "\n" ++ Output.outResultsRaw rs_aP7
Output.outXsectTbl :: [Char]
Output.outXsectTbl
  = "\n\
    \Energy table:\n"
    ++
      show (ergs ! 1)
      ++
        "\n\
        \Compton table:\n"
        ++
          show (xComp ! 1)
          ++
            "\n\
            \Pair table:\n"
            ++
              show (xPair ! 1)
              ++
                "\n\
                \Photo table:\n"
                ++ show (xPhot ! 1) ++ "\n"


["nPart_awZ","safebang@!nPart_awZ","(!nPart_awZ)","stats_ax0","safebang@!stats_ax0","(!stats_ax0)","results_ax1","safebang@!results_ax1","(!results_ax1)","results_aFs","!results_aFs","(!results_aFs)","resArray_aFt","lazydmd@!resArray_aFt","(!resArray_aFt)","stats_aOV","statArray_aOW","statList_aOX","safebang@!statList_aOX","(!statList_aOX)","titles_aOY","!titles_aOY","(!titles_aOY)","[]","![]","(![])","[]","![]","(![])","t_aP0","safebang@!t_aP0","(!t_aP0)","ts_aP1","safebang@!ts_aP1","(!ts_aP1)","(!t_aP0) : (!ts_aP1)","((!t_aP0) : (!ts_aP1))","!((!t_aP0) : (!ts_aP1))","(!((!t_aP0) : (!ts_aP1)))","s_aP2","ss_aP3","s_aP2 : ss_aP3","(s_aP2 : ss_aP3)","[]","i_aP4","safebang@!i_aP4","(!i_aP4)","t_aP5","((!i_aP4), t_aP5)","!((!i_aP4), t_aP5)","(!((!i_aP4), t_aP5))","w_aP6","safebang@!w_aP6","(!w_aP6)","((!((!i_aP4), t_aP5)), (!w_aP6))","!((!((!i_aP4), t_aP5)), (!w_aP6))","(!((!((!i_aP4), t_aP5)), (!w_aP6)))","rs_aP7","safebang@!rs_aP7","(!rs_aP7)","(!((!((!i_aP4), t_aP5)), (!w_aP6))) : (!rs_aP7)","((!((!((!i_aP4), t_aP5)), (!w_aP6))) : (!rs_aP7))","!((!((!((!i_aP4), t_aP5)), (!w_aP6))) : (!rs_aP7))","(!((!((!((!i_aP4), t_aP5)), (!w_aP6))) : (!rs_aP7)))","((!((!((!((!i_aP4), t_aP5)), (!w_aP6))) : (!rs_aP7))))","outXsectTbl"]
module Output (outGamteb) where
import GamtebType
import Consts
import Utils
import InitTable
import Data.Array

outGamteb :: Int -> [Stat] -> [Result] -> [Char]
outGamteb (!nPart_awZ) (!stats_ax0) (!results_ax1)
  = "Number of particles " ++ show nPart_awZ ++ "\n" ++ outXsectTbl
      ++ outResultsRaw results_ax1
      ++ outStats stats_ax0
      ++ outResults results_ax1
outResults (norecord@results_aFs)
  = "\nScatter, Escape, Transit tables:\n" ++ show resArray_aFt
  where (lazydmd@resArray_aFt)
          = accumArray (+) 0 ((1, 1), (numExit, numLev)) results_aFs
outStats stats_aOV = showStats_aOZ titles_aOY statList_aOX
  where statArray_aOW = accumArray (+) 0 (1, numStat) stats_aOV
        (!statList_aOX) = elems statArray_aOW
        (norecord@titles_aOY)
          = ["Number of escapes: ", "Number of transits: ",
             "Number of scatters: ", "Number of energy kills: ",
             "Number of weight kills: ", "Number of roulettes: ",
             "Number of splits: ", "Number of collisions: ",
             "Number of noncollisions: ", "Number of roulettes kills: ",
             "Weight of roulette kills: ", "Weight of roulette gains: "]
        showStats_aOZ (norecord@[]) (norecord@[]) = ""
        showStats_aOZ (norecord@((!t_aP0) : (!ts_aP1))) (s_aP2 : ss_aP3)
          = t_aP0 ++ show s_aP2 ++ "\n" ++ showStats_aOZ ts_aP1 ss_aP3

outResultsRaw :: [Result] -> [Char]
outResultsRaw [] = []
outResultsRaw
  ((norecord@((norecord@((norecord@((!i_aP4), t_aP5)), (!w_aP6))) :
                (!rs_aP7))))
  = "Result: index " ++ show i_aP4 ++ "  type " ++ show t_aP5 ++
      "  weight "
      ++ show w_aP6
      ++ "\n"
      ++ outResultsRaw rs_aP7

outXsectTbl :: [Char]
outXsectTbl
  = "\nEnergy table:\n" ++ show (ergs ! 1) ++ "\nCompton table:\n" ++
      show (xComp ! 1)
      ++ "\nPair table:\n"
      ++ show (xPair ! 1)
      ++ "\nPhoto table:\n"
      ++ show (xPhot ! 1)
      ++ "\n"

==================== Renamer ====================
InitTable.ergs :: Array Indx Value
InitTable.ergs
  = array
      (1, numLev) (zipWith (,) [1 .. numLev] (map InitTable.f2 erg_axa))
  where
      (!erg_axa)
        = [1.0e-3, 1.5e-3, 2.0e-3, 3.0e-3, 4.0e-3, 5.0e-3, 6.0e-3, 8.0e-3,
           1.0e-2, 1.5e-2, 2.0e-2, 3.0e-2, 4.0e-2, 5.0e-2, 6.0e-2, 8.0e-2,
           0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.8, 1.0, 1.5, 2.0, 3.0, 4.0,
           5.0, 6.0, 8.0, 10.0, 15.0, 20.0]
InitTable.xComp :: Array Indx Value
InitTable.xComp
  = array
      (1, numLev) (zipWith (,) [1 .. numLev] (map InitTable.f1 xc_aAM))
  where
      (!xc_aAM)
        = [1.5e-2, 2.96e-2, 4.51e-2, 7.17e-2, 9.13e-2, 0.105, 0.115, 0.128,
           0.137, 0.152, 0.16, 0.165, 0.165, 0.163, 0.16, 0.153, 0.146, 0.133,
           0.122, 0.106, 9.53e-2, 8.67e-2, 8.02e-2, 7.07e-2, 6.37e-2, 5.16e-2,
           4.4e-2, 3.46e-2, 2.89e-2, 2.5e-2, 2.21e-2, 1.81e-2, 1.54e-2,
           1.14e-2, 9.13e-3]
InitTable.xPair :: Array Indx Value
InitTable.xPair
  = array
      (1, numLev) (zipWith (,) [1 .. numLev] (map InitTable.f1 xp_aAN))
  where
      xp_aAN
        = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
           7.92e-5, 3.16e-4, 9.23e-4, 1.53e-3, 2.08e-3, 2.56e-3, 3.43e-3,
           4.14e-3, 5.47e-3, 6.52e-3]
InitTable.xPhot :: Array Indx Value
InitTable.xPhot
  = array
      (1, numLev) (zipWith (,) [1 .. numLev] (map InitTable.f1 xpe_aAO))
  where
      (!xpe_aAO)
        = [2010.0, 632.0, 280.0, 87.7, 37.3, 18.9, 10.4, 4.01, 1.91, 0.489,
           0.192, 4.91e-2, 1.86e-2, 8.87e-3, 4.81e-3, 1.79e-3, 8.62e-4,
           2.34e-4, 9.18e-5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
           0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
InitTable.f1 :: Value -> Value
InitTable.f1 (!x_aAP)
  = if (x_aAP < small) then nothing else log (2.2 * x_aAP)
InitTable.f2 :: Value -> Value
InitTable.f2 (!x_aOI)
  = if (x_aOI < small) then nothing else log x_aOI


["ergs","erg_axa","!erg_axa","(!erg_axa)","xComp","xc_aAM","!xc_aAM","(!xc_aAM)","xPair","xp_aAN","xPhot","xpe_aAO","!xpe_aAO","(!xpe_aAO)","x_aAP","safebang@!x_aAP","(!x_aAP)","x_aOI","!x_aOI","(!x_aOI)"]
module InitTable (ergs, xComp, xPair, xPhot) where
import GamtebType
import Consts
import Data.Array

ergs :: Array Indx Value
ergs
  = array (1, numLev) (zipWith (,) [1 .. numLev] (map f2 erg_axa))
  where (norecord@erg_axa)
          = [1.0e-3, 1.5e-3, 2.0e-3, 3.0e-3, 4.0e-3, 5.0e-3, 6.0e-3, 8.0e-3,
             1.0e-2, 1.5e-2, 2.0e-2, 3.0e-2, 4.0e-2, 5.0e-2, 6.0e-2, 8.0e-2,
             0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.8, 1.0, 1.5, 2.0, 3.0, 4.0,
             5.0, 6.0, 8.0, 10.0, 15.0, 20.0]

xComp :: Array Indx Value
xComp
  = array (1, numLev) (zipWith (,) [1 .. numLev] (map f1 xc_aAM))
  where (norecord@xc_aAM)
          = [1.5e-2, 2.96e-2, 4.51e-2, 7.17e-2, 9.13e-2, 0.105, 0.115, 0.128,
             0.137, 0.152, 0.16, 0.165, 0.165, 0.163, 0.16, 0.153, 0.146, 0.133,
             0.122, 0.106, 9.53e-2, 8.67e-2, 8.02e-2, 7.07e-2, 6.37e-2, 5.16e-2,
             4.4e-2, 3.46e-2, 2.89e-2, 2.5e-2, 2.21e-2, 1.81e-2, 1.54e-2,
             1.14e-2, 9.13e-3]

xPair :: Array Indx Value
xPair
  = array (1, numLev) (zipWith (,) [1 .. numLev] (map f1 xp_aAN))
  where xp_aAN
          = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
             7.92e-5, 3.16e-4, 9.23e-4, 1.53e-3, 2.08e-3, 2.56e-3, 3.43e-3,
             4.14e-3, 5.47e-3, 6.52e-3]

xPhot :: Array Indx Value
xPhot
  = array (1, numLev) (zipWith (,) [1 .. numLev] (map f1 xpe_aAO))
  where (norecord@xpe_aAO)
          = [2010.0, 632.0, 280.0, 87.7, 37.3, 18.9, 10.4, 4.01, 1.91, 0.489,
             0.192, 4.91e-2, 1.86e-2, 8.87e-3, 4.81e-3, 1.79e-3, 8.62e-4,
             2.34e-4, 9.18e-5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

f1 :: Value -> Value
f1 (!x_aAP)
  = if (x_aAP < small) then nothing else log (2.2 * x_aAP)

f2 :: Value -> Value
f2 (norecord@x_aOI)
  = if (x_aOI < small) then nothing else log x_aOI

==================== Renamer ====================
Main.main
  = interact
      (encrypt
         2036450659413645137870851576872812267542175329986469156678671505255564383842535488743101632280716717779536712424613501441720195827856504007305662157107
         387784473137902876992546516170169092918207676456888779623592396031349415024943784869634893342729620092877891356118467738167515879252473323905128540213)


["main"]
module Main where
import Rsa
main
  = interact
      (encrypt
         2036450659413645137870851576872812267542175329986469156678671505255564383842535488743101632280716717779536712424613501441720195827856504007305662157107
         387784473137902876992546516170169092918207676456888779623592396031349415024943784869634893342729620092877891356118467738167515879252473323905128540213)

==================== Renamer ====================
Rsa.encrypt, Rsa.decrypt :: Integer -> Integer -> String -> String
Rsa.encrypt (!n_avI) e_avJ
  = unlines
    . map (show . Rsa.power e_avJ n_avI . Rsa.code)
      . Rsa.collect (Rsa.size n_avI)
Rsa.decrypt (!n_aHD) (!d_aHE)
  = concat . map (Rsa.decode . Rsa.power d_aHE n_aHD . read) . lines
Rsa.code :: String -> Integer
Rsa.code
  = foldl accum_aOz 0
  where
      accum_aOz x_aOA (!y_aOB)
        = (128 * x_aOA) + fromIntegral (fromEnum y_aOB)
Rsa.decode :: Integer -> String
Rsa.decode (!n_a15N)
  = reverse (expand_a15O n_a15N)
  where
      expand_a15O 0 = []
      expand_a15O (!x_a15P)
        = toEnum (fromIntegral (x_a15P `mod` 128))
          : expand_a15O (x_a15P `div` 128)
Rsa.collect :: Int -> [a_avH] -> [[a_avH]]
Rsa.collect 0 (!xs_a193) = []
Rsa.collect (!n_a194) (![]) = []
Rsa.collect (!n_a195) (!xs_a196)
  = take n_a195 xs_a196 : Rsa.collect n_a195 (drop n_a195 xs_a196)
Rsa.size :: Integer -> Int
Rsa.size n_a197 = (length (show n_a197) * 47) `div` 100
Rsa.makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)
Rsa.makeKeys (!p'_a198) (!q'_a199)
  = (n_a19c, Rsa.invert phi_a19d d_a19e, d_a19e)
  where
      (!p_a19a) = Rsa.nextPrime p'_a198
      (!q_a19b) = Rsa.nextPrime q'_a199
      (!n_a19c) = p_a19a * q_a19b
      (!phi_a19d) = (p_a19a - 1) * (q_a19b - 1)
      d_a19e = Rsa.nextPrime (p_a19a + q_a19b + 1)
Rsa.nextPrime :: Integer -> Integer
Rsa.nextPrime a_a19f
  = head (filter prime_a19h [odd_a19g, odd_a19g + 2 .. ])
  where
      (!odd_a19g)
        | even a_a19f = a_a19f + 1
        | True = a_a19f
      prime_a19h p_a19i
        = and
            [Rsa.power (p_a19i - 1) p_a19i x_a19j == 1 |
               (!x_a19j) <- [3, 5, 7]]
Rsa.invert :: Integer -> Integer -> Integer
Rsa.invert n_a1mH (!a_a1mI)
  = if e_a1mJ < 0 then e_a1mJ + n_a1mH else e_a1mJ
  where
      e_a1mJ = Rsa.iter n_a1mH 0 a_a1mI 1
Rsa.iter :: Integer -> Integer -> Integer -> Integer -> Integer
Rsa.iter g_a1mK v_a1mL 0 w_a1mM = v_a1mL
Rsa.iter (!g_a1mN) (!v_a1mO) (!h_a1mP) (!w_a1mQ)
  = Rsa.iter
      h_a1mP
      w_a1mQ
      (g_a1mN - fact_a1mR * h_a1mP)
      (v_a1mO - fact_a1mR * w_a1mQ)
  where
      fact_a1mR = g_a1mN `div` h_a1mP
Rsa.power :: Integer -> Integer -> Integer -> Integer
Rsa.power 0 (!m_a1mS) (!x_a1mT) = 1
Rsa.power n_a1mU m_a1mV (!x_a1mW)
  | even n_a1mU
  = Rsa.sqr (Rsa.power (n_a1mU `div` 2) m_a1mV x_a1mW) `mod` m_a1mV
  | True
  = (x_a1mW * Rsa.power (n_a1mU - 1) m_a1mV x_a1mW) `mod` m_a1mV
Rsa.sqr :: Integer -> Integer
Rsa.sqr (!x_a1mX) = x_a1mX * x_a1mX


["n_avI","safebang@!n_avI","(!n_avI)","e_avJ","n_aHD","safebang@!n_aHD","(!n_aHD)","d_aHE","safebang@!d_aHE","(!d_aHE)","code","x_aOA","y_aOB","!y_aOB","(!y_aOB)","n_a15N","!n_a15N","(!n_a15N)","0","x_a15P","!x_a15P","(!x_a15P)","0","xs_a193","safebang@!xs_a193","(!xs_a193)","n_a194","!n_a194","(!n_a194)","[]","![]","(![])","n_a195","!n_a195","(!n_a195)","xs_a196","!xs_a196","(!xs_a196)","n_a197","p'_a198","safebang@!p'_a198","(!p'_a198)","q'_a199","safebang@!q'_a199","(!q'_a199)","p_a19a","!p_a19a","(!p_a19a)","q_a19b","safebang@!q_a19b","(!q_a19b)","n_a19c","!n_a19c","(!n_a19c)","phi_a19d","!phi_a19d","(!phi_a19d)","d_a19e","a_a19f","odd_a19g","safebang@!odd_a19g","(!odd_a19g)","p_a19i","x_a19j","!x_a19j","(!x_a19j)","n_a1mH","a_a1mI","!a_a1mI","(!a_a1mI)","e_a1mJ","g_a1mK","v_a1mL","0","w_a1mM","g_a1mN","!g_a1mN","(!g_a1mN)","v_a1mO","!v_a1mO","(!v_a1mO)","h_a1mP","!h_a1mP","(!h_a1mP)","w_a1mQ","!w_a1mQ","(!w_a1mQ)","fact_a1mR","0","m_a1mS","safebang@!m_a1mS","(!m_a1mS)","x_a1mT","safebang@!x_a1mT","(!x_a1mT)","n_a1mU","m_a1mV","x_a1mW","!x_a1mW","(!x_a1mW)","x_a1mX","!x_a1mX","(!x_a1mX)"]
module Rsa (encrypt, decrypt, makeKeys) where

encrypt, decrypt :: Integer -> Integer -> String -> String
encrypt (!n_avI) e_avJ
  = unlines . map (show . power e_avJ n_avI . code) .
      collect (size n_avI)
decrypt (!n_aHD) (!d_aHE)
  = concat . map (decode . power d_aHE n_aHD . read) . lines

code :: String -> Integer
code = foldl accum_aOz 0
  where accum_aOz x_aOA (norecord@y_aOB)
          = (128 * x_aOA) + fromIntegral (fromEnum y_aOB)

decode :: Integer -> String
decode (norecord@n_a15N) = reverse (expand_a15O n_a15N)
  where expand_a15O 0 = []
        expand_a15O (norecord@x_a15P)
          = toEnum (fromIntegral (x_a15P `mod` 128)) :
              expand_a15O (x_a15P `div` 128)

collect :: Int -> [a_avH] -> [[a_avH]]
collect 0 (!xs_a193) = []
collect (norecord@n_a194) (norecord@[]) = []
collect (norecord@n_a195) (norecord@xs_a196)
  = take n_a195 xs_a196 : collect n_a195 (drop n_a195 xs_a196)

size :: Integer -> Int
size n_a197 = (length (show n_a197) * 47) `div` 100

makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)
makeKeys (!p'_a198) (!q'_a199)
  = (n_a19c, invert phi_a19d d_a19e, d_a19e)
  where (norecord@p_a19a) = nextPrime p'_a198
        (!q_a19b) = nextPrime q'_a199
        (norecord@n_a19c) = p_a19a * q_a19b
        (norecord@phi_a19d) = (p_a19a - 1) * (q_a19b - 1)
        d_a19e = nextPrime (p_a19a + q_a19b + 1)

nextPrime :: Integer -> Integer
nextPrime a_a19f
  = head (filter prime_a19h [odd_a19g, odd_a19g + 2 ..])
  where (!odd_a19g)
          | even a_a19f = a_a19f + 1
          | True = a_a19f
        prime_a19h p_a19i
          = and
              [power (p_a19i - 1) p_a19i x_a19j == 1 |
               (norecord@x_a19j) <- [3, 5, 7]]

invert :: Integer -> Integer -> Integer
invert n_a1mH (norecord@a_a1mI)
  = if e_a1mJ < 0 then e_a1mJ + n_a1mH else e_a1mJ
  where e_a1mJ = iter n_a1mH 0 a_a1mI 1

iter :: Integer -> Integer -> Integer -> Integer -> Integer
iter g_a1mK v_a1mL 0 w_a1mM = v_a1mL
iter (norecord@g_a1mN) (norecord@v_a1mO) (norecord@h_a1mP)
  (norecord@w_a1mQ)
  = iter h_a1mP w_a1mQ (g_a1mN - fact_a1mR * h_a1mP)
      (v_a1mO - fact_a1mR * w_a1mQ)
  where fact_a1mR = g_a1mN `div` h_a1mP

power :: Integer -> Integer -> Integer -> Integer
power 0 (!m_a1mS) (!x_a1mT) = 1
power n_a1mU m_a1mV (norecord@x_a1mW)
  | even n_a1mU =
    sqr (power (n_a1mU `div` 2) m_a1mV x_a1mW) `mod` m_a1mV
  | True = (x_a1mW * power (n_a1mU - 1) m_a1mV x_a1mW) `mod` m_a1mV

sqr :: Integer -> Integer
sqr (norecord@x_a1mX) = x_a1mX * x_a1mX

==================== Renamer ====================
MyList.minus :: (Eq x_aAl) => [x_aAl] -> [x_aAl] -> [x_aAl]
MyList.minus xs_aAm ys_aAn = foldl MyList.rmv xs_aAm ys_aAn
MyList.rmv :: (Eq x_amS) => [x_amS] -> x_amS -> [x_amS]
MyList.rmv (![]) y_aGv = []
MyList.rmv ((!((!x_aGw) : xs_aGx))) (!y_aGF)
  = if x_aGw == y_aGF then
        xs_aGx
    else
        x_aGw : (xs_aGx `MyList.rmv` y_aGF)


["xs_aAm","ys_aAn","[]","![]","(![])","y_aGv","x_aGw","safebang@!x_aGw","(!x_aGw)","xs_aGx","(!x_aGw) : xs_aGx","((!x_aGw) : xs_aGx)","!((!x_aGw) : xs_aGx)","(!((!x_aGw) : xs_aGx))","((!((!x_aGw) : xs_aGx)))","y_aGF","!y_aGF","(!y_aGF)"]
module MyList (minus) where

minus :: (Eq x_aAl) => [x_aAl] -> [x_aAl] -> [x_aAl]
minus xs_aAm ys_aAn = foldl rmv xs_aAm ys_aAn

rmv :: (Eq x_amS) => [x_amS] -> x_amS -> [x_amS]
rmv (norecord@[]) y_aGv = []
rmv ((norecord@((!x_aGw) : xs_aGx))) (norecord@y_aGF)
  = if x_aGw == y_aGF then xs_aGx else x_aGw : (xs_aGx `rmv` y_aGF)

==================== Renamer ====================
MaybeM.returnM :: x_ani -> Maybe x_ani
MaybeM.returnM x_anj = Just x_anj
MaybeM.eachM :: Maybe x_ang -> (x_ang -> y_anh) -> Maybe y_anh
MaybeM.eachM ((!(Just x_ank))) (!f_anl) = Just (f_anl x_ank)
MaybeM.eachM Nothing (!f_anm) = Nothing
MaybeM.thenM ::
  Maybe x_ane -> (x_ane -> Maybe y_anf) -> Maybe y_anf
MaybeM.thenM ((!(Just x_ann))) kM_ano = kM_ano x_ann
MaybeM.thenM Nothing (!kM_anp) = Nothing
MaybeM.failM :: Maybe x_and
MaybeM.failM = Nothing
MaybeM.orM :: Maybe x_anc -> Maybe x_anc -> Maybe x_anc
MaybeM.orM (Just x_anq) yM_anr = Just x_anq
MaybeM.orM Nothing (!yM_ans) = yM_ans
MaybeM.guardM :: Bool -> Maybe x_anb -> Maybe x_anb
MaybeM.guardM (!b_ant) (!xM_anu)
  = if b_ant then xM_anu else MaybeM.failM
MaybeM.filterM :: (x_ana -> Bool) -> Maybe x_ana -> Maybe x_ana
MaybeM.filterM p_anv xM_anw
  = xM_anw
    `MaybeM.thenM`
      (\ (!x_anx) -> p_anv x_anx `MaybeM.guardM` MaybeM.returnM x_anx)
MaybeM.theM :: Maybe x_an9 -> x_an9
MaybeM.theM (!((!(Just x_any)))) = x_any
MaybeM.existsM :: Maybe x_an1 -> Bool
MaybeM.existsM ((!(Just x_anz))) = True
MaybeM.existsM Nothing = False
MaybeM.useM :: x_an0 -> Maybe x_an0 -> x_an0
MaybeM.useM xfail_anA ((!(Just (!x_anB)))) = x_anB
MaybeM.useM xfail_anC (!Nothing) = xfail_anC


["x_anj","x_ank","Just x_ank","(Just x_ank)","!(Just x_ank)","(!(Just x_ank))","((!(Just x_ank)))","f_anl","safebang@!f_anl","(!f_anl)","Nothing","f_anm","!f_anm","(!f_anm)","x_ann","Just x_ann","(Just x_ann)","!(Just x_ann)","(!(Just x_ann))","((!(Just x_ann)))","kM_ano","Nothing","kM_anp","!kM_anp","(!kM_anp)","failM","x_anq","Just x_anq","(Just x_anq)","yM_anr","Nothing","yM_ans","!yM_ans","(!yM_ans)","b_ant","safebang@!b_ant","(!b_ant)","xM_anu","safebang@!xM_anu","(!xM_anu)","p_anv","xM_anw","x_anx","!x_anx","(!x_anx)","x_any","Just x_any","(Just x_any)","!(Just x_any)","(!(Just x_any))","((!(Just x_any)))","!((!(Just x_any)))","(!((!(Just x_any))))","x_anz","Just x_anz","(Just x_anz)","!(Just x_anz)","(!(Just x_anz))","((!(Just x_anz)))","Nothing","xfail_anA","x_anB","safebang@!x_anB","(!x_anB)","Just (!x_anB)","(Just (!x_anB))","!(Just (!x_anB))","(!(Just (!x_anB)))","((!(Just (!x_anB))))","xfail_anC","Nothing","!Nothing","(!Nothing)"]
module MaybeM
       (Maybe, returnM, eachM, thenM, failM, orM, guardM, filterM, theM,
        existsM, useM)
       where

returnM :: x_ani -> Maybe x_ani
returnM x_anj = Just x_anj

eachM :: Maybe x_ang -> (x_ang -> y_anh) -> Maybe y_anh
eachM ((norecord@(Just x_ank))) (!f_anl) = Just (f_anl x_ank)
eachM Nothing (norecord@f_anm) = Nothing

thenM :: Maybe x_ane -> (x_ane -> Maybe y_anf) -> Maybe y_anf
thenM ((norecord@(Just x_ann))) kM_ano = kM_ano x_ann
thenM Nothing (norecord@kM_anp) = Nothing

failM :: Maybe x_and
failM = Nothing

orM :: Maybe x_anc -> Maybe x_anc -> Maybe x_anc
orM (Just x_anq) yM_anr = Just x_anq
orM Nothing (norecord@yM_ans) = yM_ans

guardM :: Bool -> Maybe x_anb -> Maybe x_anb
guardM (!b_ant) (!xM_anu) = if b_ant then xM_anu else failM

filterM :: (x_ana -> Bool) -> Maybe x_ana -> Maybe x_ana
filterM p_anv xM_anw
  = xM_anw `thenM`
      (\ (norecord@x_anx) -> p_anv x_anx `guardM` returnM x_anx)

theM :: Maybe x_an9 -> x_an9
theM (norecord@((norecord@(Just x_any)))) = x_any

existsM :: Maybe x_an1 -> Bool
existsM ((norecord@(Just x_anz))) = True
existsM Nothing = False

useM :: x_an0 -> Maybe x_an0 -> x_an0
useM xfail_anA ((norecord@(Just (!x_anB)))) = x_anB
useM xfail_anC (norecord@Nothing) = xfail_anC

==================== Renamer ====================
FiniteMap.emptyFM :: FiniteMap.FM a_aB7 b_aB8
FiniteMap.emptyFM = FiniteMap.MkFM []
FiniteMap.unitFM :: a_aB5 -> b_aB6 -> FiniteMap.FM a_aB5 b_aB6
FiniteMap.unitFM a_aB9 (!b_aBa) = FiniteMap.MkFM [(a_aB9, b_aBa)]
FiniteMap.extendFM ::
  FiniteMap.FM a_aB3 b_aB4
  -> a_aB3 -> b_aB4 -> FiniteMap.FM a_aB3 b_aB4
FiniteMap.extendFM ((!(FiniteMap.MkFM abs_aBb))) (!a_aBc) b_aBd
  = FiniteMap.MkFM ((a_aBc, b_aBd) : abs_aBb)
FiniteMap.makeFM :: [(a_aB1, b_aB2)] -> FiniteMap.FM a_aB1 b_aB2
FiniteMap.makeFM (!abs_aBe) = FiniteMap.MkFM abs_aBe
FiniteMap.unmakeFM :: FiniteMap.FM a_aAZ b_aB0 -> [(a_aAZ, b_aB0)]
FiniteMap.unmakeFM (FiniteMap.MkFM abs_aBf) = abs_aBf
FiniteMap.thenFM ::
  FiniteMap.FM a_aAX b_aAY
  -> FiniteMap.FM a_aAX b_aAY -> FiniteMap.FM a_aAX b_aAY
FiniteMap.thenFM
  ((!(FiniteMap.MkFM (!abs1_aBg))))
  (FiniteMap.MkFM abs2_aBh)
  = FiniteMap.MkFM (abs2_aBh ++ abs1_aBg)
FiniteMap.plusFM ::
  (Eq a_aAV) =>
  FiniteMap.FM a_aAV b_aAW
  -> FiniteMap.FM a_aAV b_aAW -> FiniteMap.FM a_aAV b_aAW
FiniteMap.plusFM f_aBi (!g_aBj)
  | f_aBi `FiniteMap.disjointFM` g_aBj
  = f_aBi `FiniteMap.thenFM` g_aBj
FiniteMap.lookupFM ::
  (Eq a_aAT) => FiniteMap.FM a_aAT b_aAU -> a_aAT -> b_aAU
FiniteMap.lookupFM (!f_aBk) (!a_aBl)
  = FiniteMap.lookupElseFM (error "lookup") f_aBk a_aBl
FiniteMap.lookupElseFM ::
  (Eq a_aAS) => b_aAR -> FiniteMap.FM a_aAS b_aAR -> a_aAS -> b_aAR
FiniteMap.lookupElseFM b_aBn ((!(FiniteMap.MkFM abs_aBo))) (!a_aBp)
  = head
      ([b'_aF2 | (!((!a'_aF1), b'_aF2)) <- abs_aBo, a_aBp == a'_aF1]
       ++ [b_aBn])
FiniteMap.mapFM ::
  (b_aAO -> c_aAP)
  -> FiniteMap.FM a_aAQ b_aAO -> FiniteMap.FM a_aAQ c_aAP
FiniteMap.mapFM h_aF3 (!(FiniteMap.MkFM abs_aF4))
  = FiniteMap.MkFM
      [(a_aF5, h_aF3 b_aF6) | ((!a_aF5), b_aF6) <- abs_aF4]
FiniteMap.domFM :: FiniteMap.FM a_aAM b_aAN -> [a_aAM]
FiniteMap.domFM (FiniteMap.MkFM (!abs_aF7))
  = [a_aF8 | (!((!a_aF8), b_aF9)) <- abs_aF7]
FiniteMap.ranFM :: FiniteMap.FM a_aAK b_aAL -> [b_aAL]
FiniteMap.ranFM (!((!(FiniteMap.MkFM abs_aFa))))
  = [b_aFc | ((!a_aFb), b_aFc) <- abs_aFa]
FiniteMap.disjointFM ::
  (Eq a_aAI) =>
  FiniteMap.FM a_aAI b_aAJ -> FiniteMap.FM a_aAI b_aAJ -> Bool
FiniteMap.disjointFM (!f_aFd) g_aFe
  = FiniteMap.domFM f_aFd `FiniteMap.disjoint` FiniteMap.domFM g_aFe
FiniteMap.disjoint :: (Eq a_an8) => [a_an8] -> [a_an8] -> Bool
FiniteMap.disjoint (!xs_aFf) (!ys_aFg)
  = and [not (x_aLd `elem` ys_aFg) | (!x_aLd) <- xs_aFf]

data FiniteMap.FM a_an6 b_an7 = FiniteMap.MkFM [(a_an6, b_an7)]


["emptyFM","a_aB9","b_aBa","safebang@!b_aBa","(!b_aBa)","abs_aBb","MkFM abs_aBb","(MkFM abs_aBb)","!(MkFM abs_aBb)","(!(MkFM abs_aBb))","((!(MkFM abs_aBb)))","a_aBc","safebang@!a_aBc","(!a_aBc)","b_aBd","abs_aBe","safebang@!abs_aBe","(!abs_aBe)","abs_aBf","MkFM abs_aBf","(MkFM abs_aBf)","abs1_aBg","safebang@!abs1_aBg","(!abs1_aBg)","MkFM (!abs1_aBg)","(MkFM (!abs1_aBg))","!(MkFM (!abs1_aBg))","(!(MkFM (!abs1_aBg)))","((!(MkFM (!abs1_aBg))))","abs2_aBh","MkFM abs2_aBh","(MkFM abs2_aBh)","f_aBi","g_aBj","!g_aBj","(!g_aBj)","f_aBk","!f_aBk","(!f_aBk)","a_aBl","safebang@!a_aBl","(!a_aBl)","b_aBn","abs_aBo","MkFM abs_aBo","(MkFM abs_aBo)","!(MkFM abs_aBo)","(!(MkFM abs_aBo))","((!(MkFM abs_aBo)))","a_aBp","safebang@!a_aBp","(!a_aBp)","a'_aF1","safebang@!a'_aF1","(!a'_aF1)","b'_aF2","((!a'_aF1), b'_aF2)","!((!a'_aF1), b'_aF2)","(!((!a'_aF1), b'_aF2))","h_aF3","abs_aF4","MkFM abs_aF4","(MkFM abs_aF4)","!(MkFM abs_aF4)","(!(MkFM abs_aF4))","a_aF5","safebang@!a_aF5","(!a_aF5)","b_aF6","((!a_aF5), b_aF6)","abs_aF7","safebang@!abs_aF7","(!abs_aF7)","MkFM (!abs_aF7)","(MkFM (!abs_aF7))","a_aF8","safebang@!a_aF8","(!a_aF8)","b_aF9","((!a_aF8), b_aF9)","!((!a_aF8), b_aF9)","(!((!a_aF8), b_aF9))","abs_aFa","MkFM abs_aFa","(MkFM abs_aFa)","!(MkFM abs_aFa)","(!(MkFM abs_aFa))","((!(MkFM abs_aFa)))","!((!(MkFM abs_aFa)))","(!((!(MkFM abs_aFa))))","a_aFb","safebang@!a_aFb","(!a_aFb)","b_aFc","((!a_aFb), b_aFc)","f_aFd","!f_aFd","(!f_aFd)","g_aFe","xs_aFf","!xs_aFf","(!xs_aFf)","ys_aFg","!ys_aFg","(!ys_aFg)","x_aLd","!x_aLd","(!x_aLd)"]
module FiniteMap
       (FM, emptyFM, unitFM, extendFM, makeFM, unmakeFM, thenFM, plusFM,
        lookupFM, lookupElseFM, mapFM, domFM, ranFM, disjointFM)
       where

emptyFM :: FM a_aB7 b_aB8
emptyFM = MkFM []

unitFM :: a_aB5 -> b_aB6 -> FM a_aB5 b_aB6
unitFM a_aB9 (!b_aBa) = MkFM [(a_aB9, b_aBa)]

extendFM :: FM a_aB3 b_aB4 -> a_aB3 -> b_aB4 -> FM a_aB3 b_aB4
extendFM ((norecord@(MkFM abs_aBb))) (!a_aBc) b_aBd
  = MkFM ((a_aBc, b_aBd) : abs_aBb)

makeFM :: [(a_aB1, b_aB2)] -> FM a_aB1 b_aB2
makeFM (!abs_aBe) = MkFM abs_aBe

unmakeFM :: FM a_aAZ b_aB0 -> [(a_aAZ, b_aB0)]
unmakeFM (MkFM abs_aBf) = abs_aBf

thenFM :: FM a_aAX b_aAY -> FM a_aAX b_aAY -> FM a_aAX b_aAY
thenFM ((norecord@(MkFM (!abs1_aBg)))) (MkFM abs2_aBh)
  = MkFM (abs2_aBh ++ abs1_aBg)

plusFM ::
         (Eq a_aAV) => FM a_aAV b_aAW -> FM a_aAV b_aAW -> FM a_aAV b_aAW
plusFM f_aBi (norecord@g_aBj)
  | f_aBi `disjointFM` g_aBj = f_aBi `thenFM` g_aBj

lookupFM :: (Eq a_aAT) => FM a_aAT b_aAU -> a_aAT -> b_aAU
lookupFM (norecord@f_aBk) (!a_aBl)
  = lookupElseFM (error "lookup") f_aBk a_aBl

lookupElseFM ::
               (Eq a_aAS) => b_aAR -> FM a_aAS b_aAR -> a_aAS -> b_aAR
lookupElseFM b_aBn ((norecord@(MkFM abs_aBo))) (!a_aBp)
  = head
      ([b'_aF2 | (norecord@((!a'_aF1), b'_aF2)) <- abs_aBo,
        a_aBp == a'_aF1]
         ++ [b_aBn])

mapFM :: (b_aAO -> c_aAP) -> FM a_aAQ b_aAO -> FM a_aAQ c_aAP
mapFM h_aF3 (norecord@(MkFM abs_aF4))
  = MkFM [(a_aF5, h_aF3 b_aF6) | ((!a_aF5), b_aF6) <- abs_aF4]

domFM :: FM a_aAM b_aAN -> [a_aAM]
domFM (MkFM (!abs_aF7))
  = [a_aF8 | (norecord@((!a_aF8), b_aF9)) <- abs_aF7]

ranFM :: FM a_aAK b_aAL -> [b_aAL]
ranFM (norecord@((norecord@(MkFM abs_aFa))))
  = [b_aFc | ((!a_aFb), b_aFc) <- abs_aFa]

disjointFM ::
             (Eq a_aAI) => FM a_aAI b_aAJ -> FM a_aAI b_aAJ -> Bool
disjointFM (norecord@f_aFd) g_aFe
  = domFM f_aFd `disjoint` domFM g_aFe

disjoint :: (Eq a_an8) => [a_an8] -> [a_an8] -> Bool
disjoint (norecord@xs_aFf) (norecord@ys_aFg)
  = and [not (x_aLd `elem` ys_aFg) | (norecord@x_aLd) <- xs_aFf]

data FM a_an6 b_an7 = MkFM [(a_an6, b_an7)]

==================== Renamer ====================
State.rep :: State.State s_and x_ane -> (s_and -> (x_ane, s_and))
State.rep (!(State.Abs f_anf)) = f_anf
State.returnS :: x_anb -> State.State s_anc x_anb
State.returnS x_ang = State.Abs (\ (!s_anh) -> (x_ang, s_anh))
State.eachS ::
  State.State s_an8 x_an9
  -> (x_an9 -> y_ana) -> State.State s_an8 y_ana
State.eachS xS_ani (!f_anj)
  = State.Abs
      (\ s_ank
         -> let ((!x_anl), s'_anm) = State.rep xS_ani s_ank
            in (f_anj x_anl, s'_anm))
State.thenS ::
  State.State s_an5 x_an6
  -> (x_an6 -> State.State s_an5 y_an7) -> State.State s_an5 y_an7
State.thenS xS_ann (!kS_ano)
  = State.Abs
      (\ (!s_anp)
         -> let (x_anq, s'_anr) = State.rep xS_ann s_anp
            in State.rep (kS_ano x_anq) s'_anr)
State.putS :: s_an4 -> State.State s_an4 ()
State.putS s'_ans = State.Abs (\ s_ant -> ((), s'_ans))
State.getS :: State.State s_an3 s_an3
State.getS = State.Abs (\ (!s_anu) -> (s_anu, s_anu))
State.useS :: State.State s_an1 x_an2 -> s_an1 -> x_an2
State.useS (!xS_anv) s_anw
  = let (x_anx, (!s'_any)) = State.rep xS_anv s_anw in x_anx

data State.State s_amZ x_an0 = State.Abs (s_amZ -> (x_an0, s_amZ))


["f_anf","Abs f_anf","(Abs f_anf)","!(Abs f_anf)","(!(Abs f_anf))","x_ang","s_anh","safebang@!s_anh","(!s_anh)","xS_ani","f_anj","safebang@!f_anj","(!f_anj)","s_ank","x_anl","!x_anl","(!x_anl)","s'_anm","((!x_anl), s'_anm)","xS_ann","kS_ano","safebang@!kS_ano","(!kS_ano)","s_anp","safebang@!s_anp","(!s_anp)","x_anq","s'_anr","(x_anq, s'_anr)","s'_ans","s_ant","getS","s_anu","safebang@!s_anu","(!s_anu)","xS_anv","!xS_anv","(!xS_anv)","s_anw","x_anx","s'_any","!s'_any","(!s'_any)","(x_anx, (!s'_any))"]
module State (State, returnS, eachS, thenS, putS, getS, useS) where

rep :: State s_and x_ane -> (s_and -> (x_ane, s_and))
rep (norecord@(Abs f_anf)) = f_anf

returnS :: x_anb -> State s_anc x_anb
returnS x_ang = Abs (\ (!s_anh) -> (x_ang, s_anh))

eachS :: State s_an8 x_an9 -> (x_an9 -> y_ana) -> State s_an8 y_ana
eachS xS_ani (!f_anj)
  = Abs
      (\ s_ank ->
         let ((norecord@x_anl), s'_anm) = rep xS_ani s_ank in
           (f_anj x_anl, s'_anm))

thenS ::
      State s_an5 x_an6 ->
        (x_an6 -> State s_an5 y_an7) -> State s_an5 y_an7
thenS xS_ann (!kS_ano)
  = Abs
      (\ (!s_anp) ->
         let (x_anq, s'_anr) = rep xS_ann s_anp in
           rep (kS_ano x_anq) s'_anr)

putS :: s_an4 -> State s_an4 ()
putS s'_ans = Abs (\ s_ant -> ((), s'_ans))

getS :: State s_an3 s_an3
getS = Abs (\ (!s_anu) -> (s_anu, s_anu))

useS :: State s_an1 x_an2 -> s_an1 -> x_an2
useS (norecord@xS_anv) s_anw
  = let (x_anx, (norecord@s'_any)) = rep xS_anv s_anw in x_anx

data State s_amZ x_an0 = Abs (s_amZ -> (x_an0, s_amZ))

==================== Renamer ====================
InferMonad.rep (!(InferMonad.MkI xJ_aqX)) = xJ_aqX
InferMonad.returnI :: x_aqW -> InferMonad.Infer x_aqW
InferMonad.returnI x_aqY
  = InferMonad.MkI (returnSX (returnSX returnM) x_aqY)
InferMonad.eachI ::
  InferMonad.Infer x_aqU
  -> (x_aqU -> y_aqV) -> InferMonad.Infer y_aqV
InferMonad.eachI (!xI_aqZ) f_ar0
  = InferMonad.MkI
      (eachSX (eachSX eachM) (InferMonad.rep xI_aqZ) f_ar0)
InferMonad.thenI ::
  InferMonad.Infer x_aqS
  -> (x_aqS -> InferMonad.Infer y_aqT) -> InferMonad.Infer y_aqT
InferMonad.thenI (!xI_ar1) kI_ar2
  = InferMonad.MkI
      (thenSX
         (thenSX thenM) (InferMonad.rep xI_ar1) (InferMonad.rep . kI_ar2))
InferMonad.failI :: InferMonad.Infer x_aqR
InferMonad.failI
  = InferMonad.MkI (toSX (eachSX eachM) (toSX eachM failM))
InferMonad.useI :: x_aqQ -> InferMonad.Infer x_aqQ -> x_aqQ
InferMonad.useI xfail_ar3
  = useM xfail_ar3
    . useSX eachM 0 . useSX (eachSX eachM) emptySub . InferMonad.rep
InferMonad.guardI ::
  Bool -> InferMonad.Infer x_aqP -> InferMonad.Infer x_aqP
InferMonad.guardI b_ar4 xI_ar5
  = if b_ar4 then xI_ar5 else InferMonad.failI
InferMonad.putSubI :: Sub -> InferMonad.Infer ()
InferMonad.putSubI (!s_ar6)
  = InferMonad.MkI (putSX (returnSX returnM) s_ar6)
InferMonad.getSubI :: InferMonad.Infer Sub
InferMonad.getSubI = InferMonad.MkI (getSX (returnSX returnM))
InferMonad.putCounterI :: InferMonad.Counter -> InferMonad.Infer ()
InferMonad.putCounterI c_ar7
  = InferMonad.MkI (toSX (eachSX eachM) (putSX returnM c_ar7))
InferMonad.getCounterI :: InferMonad.Infer InferMonad.Counter
InferMonad.getCounterI
  = InferMonad.MkI (toSX (eachSX eachM) (getSX returnM))
InferMonad.substituteI :: MonoType -> InferMonad.Infer MonoType
InferMonad.substituteI t_ar8
  = InferMonad.getSubI
    `InferMonad.thenI`
      (\ s_ar9 -> InferMonad.returnI (applySub s_ar9 t_ar8))
InferMonad.unifyI :: MonoType -> MonoType -> InferMonad.Infer ()
InferMonad.unifyI t_ara (!u_arb)
  = InferMonad.getSubI
    `InferMonad.thenI`
      (\ (!s_arc)
         -> let (!sM_ard) = unifySub t_ara u_arb s_arc
            in
              existsM sM_ard
              `InferMonad.guardI`
                (InferMonad.putSubI (theM sM_ard)
                 `InferMonad.thenI` (\ () -> InferMonad.returnI ())))
InferMonad.freshI :: InferMonad.Infer MonoType
InferMonad.freshI
  = InferMonad.getCounterI
    `InferMonad.thenI`
      (\ (!c_are)
         -> InferMonad.putCounterI (c_are + 1)
            `InferMonad.thenI`
              (\ () -> InferMonad.returnI (TVar ("a" ++ show c_are))))
InferMonad.freshesI :: Int -> InferMonad.Infer [MonoType]
InferMonad.freshesI (!0) = InferMonad.returnI []
InferMonad.freshesI (!n_aAD)
  = InferMonad.freshI
    `InferMonad.thenI`
      (\ x_aAE
         -> InferMonad.freshesI (n_aAD - 1)
            `InferMonad.thenI`
              (\ (!xs_aAF) -> InferMonad.returnI (x_aAE : xs_aAF)))

type InferMonad.Counter = Int
data InferMonad.Infer x_aqH
  = InferMonad.MkI (StateX Sub (StateX InferMonad.Counter (Maybe ((x_aqH,
                                                                   Sub),
                                                                  InferMonad.Counter))))


["xJ_aqX","MkI xJ_aqX","(MkI xJ_aqX)","!(MkI xJ_aqX)","(!(MkI xJ_aqX))","x_aqY","xI_aqZ","safebang@!xI_aqZ","(!xI_aqZ)","f_ar0","xI_ar1","safebang@!xI_ar1","(!xI_ar1)","kI_ar2","failI","xfail_ar3","b_ar4","xI_ar5","s_ar6","!s_ar6","(!s_ar6)","getSubI","c_ar7","getCounterI","t_ar8","s_ar9","t_ara","u_arb","safebang@!u_arb","(!u_arb)","s_arc","!s_arc","(!s_arc)","sM_ard","!sM_ard","(!sM_ard)","()","freshI","c_are","!c_are","(!c_are)","()","0","!0","(!0)","n_aAD","!n_aAD","(!n_aAD)","x_aAE","xs_aAF","!xs_aAF","(!xs_aAF)"]
module InferMonad
       (Infer, returnI, eachI, thenI, guardI, useI, getSubI, substituteI,
        unifyI, freshI, freshesI)
       where
import MaybeM
       (Maybe, returnM, eachM, thenM, failM, guardM, theM, existsM, useM)
import StateX
       (StateX, returnSX, eachSX, thenSX, toSX, putSX, getSX, useSX)
import Type (TVarId, TConId, MonoType(TVar, TCon), freeTVarMono)
import Substitution
       (Sub, applySub, lookupSub, emptySub, extendSub, domSub, unifySub)
rep (norecord@(MkI xJ_aqX)) = xJ_aqX

returnI :: x_aqW -> Infer x_aqW
returnI x_aqY = MkI (returnSX (returnSX returnM) x_aqY)

eachI :: Infer x_aqU -> (x_aqU -> y_aqV) -> Infer y_aqV
eachI (!xI_aqZ) f_ar0
  = MkI (eachSX (eachSX eachM) (rep xI_aqZ) f_ar0)

thenI :: Infer x_aqS -> (x_aqS -> Infer y_aqT) -> Infer y_aqT
thenI (!xI_ar1) kI_ar2
  = MkI (thenSX (thenSX thenM) (rep xI_ar1) (rep . kI_ar2))

failI :: Infer x_aqR
failI = MkI (toSX (eachSX eachM) (toSX eachM failM))

useI :: x_aqQ -> Infer x_aqQ -> x_aqQ
useI xfail_ar3
  = useM xfail_ar3 . useSX eachM 0 . useSX (eachSX eachM) emptySub .
      rep

guardI :: Bool -> Infer x_aqP -> Infer x_aqP
guardI b_ar4 xI_ar5 = if b_ar4 then xI_ar5 else failI

putSubI :: Sub -> Infer ()
putSubI (norecord@s_ar6) = MkI (putSX (returnSX returnM) s_ar6)

getSubI :: Infer Sub
getSubI = MkI (getSX (returnSX returnM))

putCounterI :: Counter -> Infer ()
putCounterI c_ar7 = MkI (toSX (eachSX eachM) (putSX returnM c_ar7))

getCounterI :: Infer Counter
getCounterI = MkI (toSX (eachSX eachM) (getSX returnM))

substituteI :: MonoType -> Infer MonoType
substituteI t_ar8
  = getSubI `thenI` (\ s_ar9 -> returnI (applySub s_ar9 t_ar8))

unifyI :: MonoType -> MonoType -> Infer ()
unifyI t_ara (!u_arb)
  = getSubI `thenI`
      (\ (norecord@s_arc) ->
         let (norecord@sM_ard) = unifySub t_ara u_arb s_arc in
           existsM sM_ard `guardI`
             (putSubI (theM sM_ard) `thenI` (\ () -> returnI ())))

freshI :: Infer MonoType
freshI
  = getCounterI `thenI`
      (\ (norecord@c_are) ->
         putCounterI (c_are + 1) `thenI`
           (\ () -> returnI (TVar ("a" ++ show c_are))))

freshesI :: Int -> Infer [MonoType]
freshesI (norecord@0) = returnI []
freshesI (norecord@n_aAD)
  = freshI `thenI`
      (\ x_aAE ->
         freshesI (n_aAD - 1) `thenI`
           (\ (norecord@xs_aAF) -> returnI (x_aAE : xs_aAF)))

type Counter = Int

data Infer x_aqH = MkI (StateX Sub
                          (StateX Counter (Maybe ((x_aqH, Sub), Counter))))

==================== Renamer ====================
Shows.showsEmpty :: ShowS
Shows.showsEmpty r_avD = r_avD
Shows.showsConcat :: [ShowS] -> ShowS
Shows.showsConcat = foldr (.) Shows.showsEmpty
Shows.showsString :: Shows.Shows String
Shows.showsString = (++)
Shows.showsChar :: Shows.Shows Char
Shows.showsChar = (:)
Shows.showsStar :: Shows.Shows x_avC -> Shows.Shows [x_avC]
Shows.showsStar (!showsX_aBL) xs_aBM
  = Shows.showsConcat (map showsX_aBL xs_aBM)
Shows.showsStarSep ::
  String -> Shows.Shows x_avB -> Shows.Shows [x_avB]
Shows.showsStarSep (!s_aBN) showsX_aBO (![]) = Shows.showsEmpty
Shows.showsStarSep s_aBP showsX_aBQ ((!(x_aBR : (!xs_aBS))))
  = showsX_aBQ x_aBR
    . Shows.showsConcat
        [showString s_aBP . showsX_aBQ x'_aBT | x'_aBT <- xs_aBS]
Shows.showsSurround ::
  String -> Shows.Shows x_avA -> String -> Shows.Shows x_avA
Shows.showsSurround l_aBU showsX_aBV r_aBW (!x_aBX)
  = showString l_aBU . showsX_aBV x_aBX . showString r_aBW
Shows.showsListOf :: Shows.Shows x_avz -> Shows.Shows [x_avz]
Shows.showsListOf (!showsX_aBY)
  = Shows.showsSurround "[" (Shows.showsStarSep ", " showsX_aBY) "]"
Shows.showsParen :: ShowS -> ShowS
Shows.showsParen = Shows.showsSurround "(" id ")"
Shows.showsParenIf :: Bool -> ShowS -> ShowS
Shows.showsParenIf b_aBZ xS_aC0
  = if b_aBZ then Shows.showsParen xS_aC0 else xS_aC0

type Shows.Shows x_an1 = x_an1 -> ShowS


["r_avD","showsConcat","showsString","showsChar","showsX_aBL","safebang@!showsX_aBL","(!showsX_aBL)","xs_aBM","s_aBN","safebang@!s_aBN","(!s_aBN)","showsX_aBO","[]","![]","(![])","s_aBP","showsX_aBQ","x_aBR","xs_aBS","!xs_aBS","(!xs_aBS)","x_aBR : (!xs_aBS)","(x_aBR : (!xs_aBS))","!(x_aBR : (!xs_aBS))","(!(x_aBR : (!xs_aBS)))","((!(x_aBR : (!xs_aBS))))","x'_aBT","l_aBU","showsX_aBV","r_aBW","x_aBX","safebang@!x_aBX","(!x_aBX)","showsX_aBY","safebang@!showsX_aBY","(!showsX_aBY)","showsParen","b_aBZ","xS_aC0"]
module Shows
       (Shows, showsEmpty, showsConcat, showsString, showsChar, showsStar,
        showsStarSep, showsSurround, showsListOf, showsParen, showsParenIf)
       where

showsEmpty :: ShowS
showsEmpty r_avD = r_avD

showsConcat :: [ShowS] -> ShowS
showsConcat = foldr (.) showsEmpty

showsString :: Shows String
showsString = (++)

showsChar :: Shows Char
showsChar = (:)

showsStar :: Shows x_avC -> Shows [x_avC]
showsStar (!showsX_aBL) xs_aBM
  = showsConcat (map showsX_aBL xs_aBM)

showsStarSep :: String -> Shows x_avB -> Shows [x_avB]
showsStarSep (!s_aBN) showsX_aBO (norecord@[]) = showsEmpty
showsStarSep s_aBP showsX_aBQ
  ((norecord@(x_aBR : (norecord@xs_aBS))))
  = showsX_aBQ x_aBR .
      showsConcat
        [showString s_aBP . showsX_aBQ x'_aBT | x'_aBT <- xs_aBS]

showsSurround :: String -> Shows x_avA -> String -> Shows x_avA
showsSurround l_aBU showsX_aBV r_aBW (!x_aBX)
  = showString l_aBU . showsX_aBV x_aBX . showString r_aBW

showsListOf :: Shows x_avz -> Shows [x_avz]
showsListOf (!showsX_aBY)
  = showsSurround "[" (showsStarSep ", " showsX_aBY) "]"

showsParen :: ShowS -> ShowS
showsParen = showsSurround "(" id ")"

showsParenIf :: Bool -> ShowS -> ShowS
showsParenIf b_aBZ xS_aC0
  = if b_aBZ then showsParen xS_aC0 else xS_aC0

type Shows x_an1 = x_an1 -> ShowS

==================== Renamer ====================
StateX.rep (!(StateX.MkSX f_an2)) = f_an2
StateX.returnSX returnX_an3 (!x_an4)
  = StateX.MkSX (\ s_an5 -> returnX_an3 (x_an4, s_an5))
StateX.eachSX (!eachX_an6) xSX_an7 (!f_an8)
  = StateX.MkSX
      (\ s_an9
         -> StateX.rep xSX_an7 s_an9
            `eachX_an6` (\ (!(x_ana, s'_anb)) -> (f_an8 x_ana, s'_anb)))
StateX.thenSX (!thenX_anc) xSX_and kSX_ane
  = StateX.MkSX
      (\ s_anf
         -> StateX.rep xSX_and s_anf
            `thenX_anc`
              (\ (!(x_ang, s'_anh)) -> StateX.rep (kSX_ane x_ang) s'_anh))
StateX.toSX (!eachX_ani) (!xX_anj)
  = StateX.MkSX
      (\ s_ank -> xX_anj `eachX_ani` (\ x_anl -> (x_anl, s_ank)))
StateX.putSX (!returnX_anm) s'_ann
  = StateX.MkSX (\ (!s_ano) -> returnX_anm ((), s'_ann))
StateX.getSX (!returnX_anp)
  = StateX.MkSX (\ s_anq -> returnX_anp (s_anq, s_anq))
StateX.useSX (!eachX_anr) s_ans xSX_ant
  = StateX.rep xSX_ant s_ans
    `eachX_anr` (\ (!(x_anu, (!s'_anv))) -> x_anu)

data StateX.StateX s_an0 a_an1 = StateX.MkSX (s_an0 -> a_an1)


["f_an2","MkSX f_an2","(MkSX f_an2)","!(MkSX f_an2)","(!(MkSX f_an2))","returnX_an3","x_an4","safebang@!x_an4","(!x_an4)","s_an5","eachX_an6","safebang@!eachX_an6","(!eachX_an6)","xSX_an7","f_an8","safebang@!f_an8","(!f_an8)","s_an9","x_ana","s'_anb","(x_ana, s'_anb)","!(x_ana, s'_anb)","(!(x_ana, s'_anb))","thenX_anc","safebang@!thenX_anc","(!thenX_anc)","xSX_and","kSX_ane","s_anf","x_ang","s'_anh","(x_ang, s'_anh)","!(x_ang, s'_anh)","(!(x_ang, s'_anh))","eachX_ani","safebang@!eachX_ani","(!eachX_ani)","xX_anj","safebang@!xX_anj","(!xX_anj)","s_ank","x_anl","returnX_anm","safebang@!returnX_anm","(!returnX_anm)","s'_ann","s_ano","safebang@!s_ano","(!s_ano)","returnX_anp","safebang@!returnX_anp","(!returnX_anp)","s_anq","eachX_anr","safebang@!eachX_anr","(!eachX_anr)","s_ans","xSX_ant","x_anu","s'_anv","safebang@!s'_anv","(!s'_anv)","(x_anu, (!s'_anv))","!(x_anu, (!s'_anv))","(!(x_anu, (!s'_anv)))"]
module StateX
       (StateX, returnSX, eachSX, thenSX, toSX, putSX, getSX, useSX) where
rep (norecord@(MkSX f_an2)) = f_an2
returnSX returnX_an3 (!x_an4)
  = MkSX (\ s_an5 -> returnX_an3 (x_an4, s_an5))
eachSX (!eachX_an6) xSX_an7 (!f_an8)
  = MkSX
      (\ s_an9 ->
         rep xSX_an7 s_an9 `eachX_an6`
           (\ (norecord@(x_ana, s'_anb)) -> (f_an8 x_ana, s'_anb)))
thenSX (!thenX_anc) xSX_and kSX_ane
  = MkSX
      (\ s_anf ->
         rep xSX_and s_anf `thenX_anc`
           (\ (norecord@(x_ang, s'_anh)) -> rep (kSX_ane x_ang) s'_anh))
toSX (!eachX_ani) (!xX_anj)
  = MkSX (\ s_ank -> xX_anj `eachX_ani` (\ x_anl -> (x_anl, s_ank)))
putSX (!returnX_anm) s'_ann
  = MkSX (\ (!s_ano) -> returnX_anm ((), s'_ann))
getSX (!returnX_anp) = MkSX (\ s_anq -> returnX_anp (s_anq, s_anq))
useSX (!eachX_anr) s_ans xSX_ant
  = rep xSX_ant s_ans `eachX_anr`
      (\ (norecord@(x_anu, (!s'_anv))) -> x_anu)

data StateX s_an0 a_an1 = MkSX (s_an0 -> a_an1)

==================== Renamer ====================
Main.main
  = print (stronglyConnComp edges_ane vertices_and)
  where
      a_an6, b_an7, c_an8, d_an9, f_ana, g_anb, h_anc :: Int
      (!a_an6) = 1
      (!b_an7) = 2
      c_an8 = 3
      (!d_an9) = 4
      f_ana = 5
      g_anb = 6
      (!h_anc) = 7
      (!vertices_and) = [a_an6, b_an7, c_an8, d_an9, f_ana, g_anb, h_anc]
      edges_ane
        = [(b_an7, a_an6), (c_an8, b_an7), (c_an8, d_an9), (c_an8, h_anc),
           (d_an9, c_an8), (f_ana, a_an6), (f_ana, g_anb), (f_ana, h_anc),
           (g_anb, f_ana), (h_anc, g_anb)]


["main","a_an6","!a_an6","(!a_an6)","b_an7","!b_an7","(!b_an7)","c_an8","d_an9","!d_an9","(!d_an9)","f_ana","g_anb","h_anc","!h_anc","(!h_anc)","vertices_and","!vertices_and","(!vertices_and)","edges_ane"]
module Main (main) where
import Digraph
main = print (stronglyConnComp edges_ane vertices_and)
  where a_an6, b_an7, c_an8, d_an9, f_ana, g_anb, h_anc :: Int
        (norecord@a_an6) = 1
        (norecord@b_an7) = 2
        c_an8 = 3
        (norecord@d_an9) = 4
        f_ana = 5
        g_anb = 6
        (norecord@h_anc) = 7
        (norecord@vertices_and)
          = [a_an6, b_an7, c_an8, d_an9, f_ana, g_anb, h_anc]
        edges_ane
          = [(b_an7, a_an6), (c_an8, b_an7), (c_an8, d_an9), (c_an8, h_anc),
             (d_an9, c_an8), (f_ana, a_an6), (f_ana, g_anb), (f_ana, h_anc),
             (g_anb, f_ana), (h_anc, g_anb)]

==================== Renamer ====================
Digraph.stronglyConnComp ::
  Eq vertex_aAp =>
  [Digraph.Edge vertex_aAp] -> [vertex_aAp] -> [[vertex_aAp]]
Digraph.stronglyConnComp es_aAq (!vs_aAr)
  = snd
      (span_tree_aAv
         (new_range_aAu reversed_edges_aAs)
         ([], [])
         (snd (Digraph.dfs (new_range_aAu es_aAq) ([], []) vs_aAr)))
  where
      (!reversed_edges_aAs) = map swap_aAt es_aAq
      swap_aAt (x_aAw, (!y_aAx)) = (y_aAx, x_aAw)
      new_range_aAu [] (!w_aAy) = []
      new_range_aAu ((!(((!x_aAz), y_aAA) : xys_aAB))) w_aAJ
        = if x_aAz == w_aAJ then
              (y_aAA : (new_range_aAu xys_aAB w_aAJ))
          else
              (new_range_aAu xys_aAB w_aAJ)
      span_tree_aAv (!r_aAK) ((!vs_aAL), ns_aAM) [] = (vs_aAL, ns_aAM)
      span_tree_aAv
        r_aAN
        (!((!vs_aAO), (!ns_aAP)))
        (!((!(x_aAQ : (!xs_aAR)))))
        | x_aAQ `elem` vs_aAO = span_tree_aAv r_aAN (vs_aAO, ns_aAP) xs_aAR
        | True
        = span_tree_aAv r_aAN (vs'_aAS, (x_aAQ : ns'_aAT) : ns_aAP) xs_aAR
        where
            (vs'_aAS, ns'_aAT)
              = Digraph.dfs r_aAN (x_aAQ : vs_aAO, []) (r_aAN x_aAQ)
Digraph.dfs ::
  Eq v_amW =>
  (v_amW -> [v_amW])
  -> ([v_amW], [v_amW]) -> [v_amW] -> ([v_amW], [v_amW])
Digraph.dfs (!r_aH7) ((!vs_aH8), (!ns_aH9)) (![])
  = (vs_aH8, ns_aH9)
Digraph.dfs r_aHa ((!vs_aHb), ns_aHc) (x_aHd : (!xs_aHe))
  | x_aHd `elem` vs_aHb = Digraph.dfs r_aHa (vs_aHb, ns_aHc) xs_aHe
  | True
  = Digraph.dfs r_aHa (vs'_aHf, (x_aHd : ns'_aHg) ++ ns_aHc) xs_aHe
  where
      ((!vs'_aHf), ns'_aHg)
        = Digraph.dfs r_aHa (x_aHd : vs_aHb, []) (r_aHa x_aHd)

type Digraph.Edge vertex_amV = (vertex_amV, vertex_amV)
type Digraph.Cycle vertex_amU = [vertex_amU]


["es_aAq","vs_aAr","safebang@!vs_aAr","(!vs_aAr)","reversed_edges_aAs","!reversed_edges_aAs","(!reversed_edges_aAs)","x_aAw","y_aAx","safebang@!y_aAx","(!y_aAx)","(x_aAw, (!y_aAx))","[]","w_aAy","!w_aAy","(!w_aAy)","x_aAz","safebang@!x_aAz","(!x_aAz)","y_aAA","((!x_aAz), y_aAA)","xys_aAB","((!x_aAz), y_aAA) : xys_aAB","(((!x_aAz), y_aAA) : xys_aAB)","!(((!x_aAz), y_aAA) : xys_aAB)","(!(((!x_aAz), y_aAA) : xys_aAB))","((!(((!x_aAz), y_aAA) : xys_aAB)))","w_aAJ","r_aAK","safebang@!r_aAK","(!r_aAK)","vs_aAL","safebang@!vs_aAL","(!vs_aAL)","ns_aAM","((!vs_aAL), ns_aAM)","[]","r_aAN","vs_aAO","!vs_aAO","(!vs_aAO)","ns_aAP","!ns_aAP","(!ns_aAP)","((!vs_aAO), (!ns_aAP))","!((!vs_aAO), (!ns_aAP))","(!((!vs_aAO), (!ns_aAP)))","x_aAQ","xs_aAR","!xs_aAR","(!xs_aAR)","x_aAQ : (!xs_aAR)","(x_aAQ : (!xs_aAR))","!(x_aAQ : (!xs_aAR))","(!(x_aAQ : (!xs_aAR)))","((!(x_aAQ : (!xs_aAR))))","!((!(x_aAQ : (!xs_aAR))))","(!((!(x_aAQ : (!xs_aAR)))))","vs'_aAS","ns'_aAT","(vs'_aAS, ns'_aAT)","r_aH7","safebang@!r_aH7","(!r_aH7)","vs_aH8","safebang@!vs_aH8","(!vs_aH8)","ns_aH9","safebang@!ns_aH9","(!ns_aH9)","((!vs_aH8), (!ns_aH9))","[]","![]","(![])","r_aHa","vs_aHb","!vs_aHb","(!vs_aHb)","ns_aHc","((!vs_aHb), ns_aHc)","x_aHd","xs_aHe","!xs_aHe","(!xs_aHe)","x_aHd : (!xs_aHe)","(x_aHd : (!xs_aHe))","vs'_aHf","!vs'_aHf","(!vs'_aHf)","ns'_aHg","((!vs'_aHf), ns'_aHg)"]
module Digraph where

stronglyConnComp ::
                   Eq vertex_aAp =>
                   [Edge vertex_aAp] -> [vertex_aAp] -> [[vertex_aAp]]
stronglyConnComp es_aAq (!vs_aAr)
  = snd
      (span_tree_aAv (new_range_aAu reversed_edges_aAs) ([], [])
         (snd (dfs (new_range_aAu es_aAq) ([], []) vs_aAr)))
  where (norecord@reversed_edges_aAs) = map swap_aAt es_aAq
        swap_aAt (x_aAw, (!y_aAx)) = (y_aAx, x_aAw)
        new_range_aAu [] (norecord@w_aAy) = []
        new_range_aAu ((norecord@(((!x_aAz), y_aAA) : xys_aAB))) w_aAJ
          = if x_aAz == w_aAJ then (y_aAA : (new_range_aAu xys_aAB w_aAJ))
              else (new_range_aAu xys_aAB w_aAJ)
        span_tree_aAv (!r_aAK) ((!vs_aAL), ns_aAM) [] = (vs_aAL, ns_aAM)
        span_tree_aAv r_aAN
          (norecord@((norecord@vs_aAO), (norecord@ns_aAP)))
          (norecord@((norecord@(x_aAQ : (norecord@xs_aAR)))))
          | x_aAQ `elem` vs_aAO = span_tree_aAv r_aAN (vs_aAO, ns_aAP) xs_aAR
          | True =
            span_tree_aAv r_aAN (vs'_aAS, (x_aAQ : ns'_aAT) : ns_aAP) xs_aAR
          where (vs'_aAS, ns'_aAT)
                  = dfs r_aAN (x_aAQ : vs_aAO, []) (r_aAN x_aAQ)

dfs ::
      Eq v_amW =>
      (v_amW -> [v_amW]) ->
        ([v_amW], [v_amW]) -> [v_amW] -> ([v_amW], [v_amW])
dfs (!r_aH7) ((!vs_aH8), (!ns_aH9)) (norecord@[])
  = (vs_aH8, ns_aH9)
dfs r_aHa ((norecord@vs_aHb), ns_aHc) (x_aHd : (norecord@xs_aHe))
  | x_aHd `elem` vs_aHb = dfs r_aHa (vs_aHb, ns_aHc) xs_aHe
  | True = dfs r_aHa (vs'_aHf, (x_aHd : ns'_aHg) ++ ns_aHc) xs_aHe
  where ((norecord@vs'_aHf), ns'_aHg)
          = dfs r_aHa (x_aHd : vs_aHb, []) (r_aHa x_aHd)

type Edge vertex_amV = (vertex_amV, vertex_amV)

type Cycle vertex_amU = [vertex_amU]

==================== Renamer ====================
Tree.repTree ::
  (a_avw -> [a_avw])
  -> (a_avw -> [a_avw]) -> a_avw -> (Tree.Tree a_avw)
Tree.repTree f_avx g_avy (!a_avz)
  = Tree.Branch a_avz (map (Tree.repTree g_avy f_avx) (f_avx a_avz))
Tree.mapTree ::
  (a_avu -> b_avv) -> (Tree.Tree a_avu) -> (Tree.Tree b_avv)
Tree.mapTree (!f_avA) (!((!(Tree.Branch a_avB (!l_avC)))))
  = Tree.Branch (f_avA a_avB) (map (Tree.mapTree f_avA) l_avC)
Tree.prune :: Int -> (Tree.Tree a_avm) -> (Tree.Tree a_avm)
Tree.prune 0 (!((!(Tree.Branch (!a_avD) l_avE))))
  = Tree.Branch a_avD []
Tree.prune (!n_avF) (!(Tree.Branch (!a_avG) l_avH))
  | n_avF < 0 = error "Tree.prune: < 0"
  | otherwise
  = Tree.Branch a_avG (map (Tree.prune (n_avF - 1)) l_avH)

data Tree.Tree a_amV
  = Tree.Branch a_amV [Tree.Tree a_amV]
  deriving (Show)


["f_avx","g_avy","a_avz","safebang@!a_avz","(!a_avz)","f_avA","safebang@!f_avA","(!f_avA)","a_avB","l_avC","!l_avC","(!l_avC)","Branch a_avB (!l_avC)","(Branch a_avB (!l_avC))","!(Branch a_avB (!l_avC))","(!(Branch a_avB (!l_avC)))","((!(Branch a_avB (!l_avC))))","!((!(Branch a_avB (!l_avC))))","(!((!(Branch a_avB (!l_avC)))))","0","a_avD","!a_avD","(!a_avD)","l_avE","Branch (!a_avD) l_avE","(Branch (!a_avD) l_avE)","!(Branch (!a_avD) l_avE)","(!(Branch (!a_avD) l_avE))","((!(Branch (!a_avD) l_avE)))","!((!(Branch (!a_avD) l_avE)))","(!((!(Branch (!a_avD) l_avE))))","n_avF","!n_avF","(!n_avF)","a_avG","safebang@!a_avG","(!a_avG)","l_avH","Branch (!a_avG) l_avH","(Branch (!a_avG) l_avH)","!(Branch (!a_avG) l_avH)","(!(Branch (!a_avG) l_avH))"]
module Tree where

repTree ::
        (a_avw -> [a_avw]) -> (a_avw -> [a_avw]) -> a_avw -> (Tree a_avw)
repTree f_avx g_avy (!a_avz)
  = Branch a_avz (map (repTree g_avy f_avx) (f_avx a_avz))

mapTree :: (a_avu -> b_avv) -> (Tree a_avu) -> (Tree b_avv)
mapTree (!f_avA)
  (norecord@((norecord@(Branch a_avB (norecord@l_avC)))))
  = Branch (f_avA a_avB) (map (mapTree f_avA) l_avC)

prune :: Int -> (Tree a_avm) -> (Tree a_avm)
prune 0 (norecord@((norecord@(Branch (norecord@a_avD) l_avE))))
  = Branch a_avD []
prune (norecord@n_avF) (norecord@(Branch (!a_avG) l_avH))
  | n_avF < 0 = error "prune: < 0"
  | otherwise = Branch a_avG (map (prune (n_avF - 1)) l_avH)

data Tree a_amV = Branch a_amV [Tree a_amV]
                deriving Show

==================== Renamer ====================
Main.main
  = do { _ <- getContents;
         putStr (prog "") }


["main","_"]
module Main where
import Prog (prog)
main
  = do _ <- getContents
       putStr (prog "")

==================== Renamer ====================
Wins.wins :: [Wins.Win]
Wins.wins
  = [Wins.win1, Wins.win2, Wins.win3, Wins.win4, Wins.win5,
     Wins.win6, Wins.win7, Wins.win8]
Wins.win1, Wins.win2, Wins.win3, Wins.win4, Wins.win5, Wins.win6, Wins.win7, Wins.win8 ::
  Wins.Win
Wins.win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
Wins.win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
Wins.win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
Wins.win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
Wins.win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
Wins.win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
Wins.win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
Wins.win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Wins.Win = [[Int]]


["wins","win1","win2","win3","win4","win5","win6","win7","win8"]
module Wins where

wins :: [Win]
wins = [win1, win2, win3, win4, win5, win6, win7, win8]

win1, win2, win3, win4, win5, win6, win7, win8 :: Win
win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Win = [[Int]]

==================== Renamer ====================
Prog.prog :: String -> String
Prog.prog _
  = "OXO\n" ++ concat (map showMove game_arx)
  where
      game_arx = alternate X max' min' Prog.testBoard
Prog.testBoard
  = [[Empty, O, Empty], [Empty, X, Empty], [Empty, Empty, Empty]]


["_","game_arx","testBoard"]
module Prog (prog) where
import Board
import Wins
import Game
import Tree

prog :: String -> String
prog _ = "OXO\n" ++ concat (map showMove game_arx)
  where game_arx = alternate X max' min' testBoard
testBoard
  = [[Empty, O, Empty], [Empty, X, Empty], [Empty, Empty, Empty]]

==================== Renamer ====================
Game.alternate ::
  Piece -> Game.Player -> Game.Player -> Board -> [Game.Move]
Game.alternate _ _ (!_) (!b_ar7) | fullBoard b_ar7 = []
Game.alternate _ (!_) (!_) (!b_ar8) | static b_ar8 == XWin = []
Game.alternate _ (!_) _ (!b_aEB) | static b_aEB == OWin = []
Game.alternate (!player_aEC) (!f_aED) (!g_aEE) board_aEF
  = move_aEG : Game.alternate opposition_aEL g_aEE f_aED board'_aEH
  where
      (!move_aEG@(board'_aEH, (!eval_aEI)))
        = Game.best f_aED possibles_aEK scores_aEJ
      scores_aEJ
        = map (Game.bestMove opposition_aEL g_aEE f_aED) possibles_aEK
      (!possibles_aEK) = newPositions player_aEC board_aEF
      (!opposition_aEL) = Game.opposite player_aEC
Game.opposite :: Piece -> Piece
Game.opposite X = O
Game.opposite O = X
Game.best :: Game.Player -> [Board] -> [Evaluation] -> Game.Move
Game.best
  f_aET
  ((!((!b_aEU) : (!bs_aEV))))
  (!((!((!s_aEW) : ss_aEX))))
  = best'_aEY b_aEU s_aEW bs_aEV ss_aEX
  where
      best'_aEY (!b_aEZ) (!s_aF0) [] [] = (b_aEZ, s_aF0)
      best'_aEY b_aF1 (!s_aF2) (b'_aF3 : bs_aF4) (s'_aF5 : (!ss_aF6))
        | s_aF2 == (f_aET s_aF2 s'_aF5)
        = best'_aEY b_aF1 s_aF2 bs_aF4 ss_aF6
        | otherwise = best'_aEY b'_aF3 s'_aF5 bs_aF4 ss_aF6
Game.showMove :: Game.Move -> String
Game.showMove (b_aF7, e_aF8)
  = show e_aF8 ++ "\n" ++ showBoard b_aF7
Game.bestMove ::
  Piece -> Game.Player -> Game.Player -> Board -> Evaluation
Game.bestMove (!p_aNy) (!f_aNz) g_aNA
  = (Game.mise f_aNz g_aNA)
    . Game.cropTree . mapTree static . Game.searchTree p_aNy
Game.cropTree :: (Tree Evaluation) -> (Tree Evaluation)
Game.cropTree (!((!(Branch a_aNB [])))) = (Branch a_aNB [])
Game.cropTree (!(Branch ((!(Score x_aNC))) l_aND))
  = Branch (Score x_aNC) (map Game.cropTree l_aND)
Game.cropTree (Branch x_aNE l_aNF) = Branch x_aNE []
Game.searchTree :: Piece -> Board -> (Tree Board)
Game.searchTree p_aNG board_aNH
  = prune
      5
      (repTree
         (newPositions p_aNG)
         (newPositions (Game.opposite p_aNG))
         board_aNH)
Game.mise ::
  Game.Player -> Game.Player -> (Tree Evaluation) -> Evaluation
Game.mise (!f_aNI) (!g_aNJ) (!(Branch a_aNK [])) = a_aNK
Game.mise f_aNL g_aNM (!(Branch _ l_aNN))
  = foldr f_aNL (g_aNM OWin XWin) (map (Game.mise g_aNM f_aNL) l_aNN)
Game.max' :: Evaluation -> Evaluation -> Evaluation
Game.max' (!XWin) _ = XWin
Game.max' (!_) (!XWin) = XWin
Game.max' b_aTT OWin = b_aTT
Game.max' OWin (!b_aTU) = b_aTU
Game.max' a_aTV@(!(Score x_aTW)) (!b_aTX@(!(Score (!y_aTY))))
  | x_aTW > y_aTY = a_aTV
  | otherwise = b_aTX
Game.min' :: Evaluation -> Evaluation -> Evaluation
Game.min' (!OWin) _ = OWin
Game.min' (!_) (!OWin) = OWin
Game.min' (!b_aTZ) (!XWin) = b_aTZ
Game.min' (!XWin) (!b_aU0) = b_aU0
Game.min' (!a_aU1@(!(Score x_aU2))) (!b_aU3@(Score y_aU4))
  | x_aU2 < y_aU4 = a_aU1
  | otherwise = b_aU3

type Game.Player = Evaluation -> Evaluation -> Evaluation
type Game.Move = (Board, Evaluation)


["_","_","_","!_","(!_)","b_ar7","safebang@!b_ar7","(!b_ar7)","_","_","!_","(!_)","_","!_","(!_)","b_ar8","!b_ar8","(!b_ar8)","_","_","!_","(!_)","_","b_aEB","!b_aEB","(!b_aEB)","player_aEC","!player_aEC","(!player_aEC)","f_aED","!f_aED","(!f_aED)","g_aEE","!g_aEE","(!g_aEE)","board_aEF","board'_aEH","eval_aEI","safebang@!eval_aEI","(!eval_aEI)","(board'_aEH, (!eval_aEI))","move_aEG@(board'_aEH, (!eval_aEI))","!move_aEG@(board'_aEH, (!eval_aEI))","(!move_aEG@(board'_aEH, (!eval_aEI)))","scores_aEJ","possibles_aEK","safebang@!possibles_aEK","(!possibles_aEK)","opposition_aEL","!opposition_aEL","(!opposition_aEL)","X","O","f_aET","b_aEU","safebang@!b_aEU","(!b_aEU)","bs_aEV","safebang@!bs_aEV","(!bs_aEV)","(!b_aEU) : (!bs_aEV)","((!b_aEU) : (!bs_aEV))","!((!b_aEU) : (!bs_aEV))","(!((!b_aEU) : (!bs_aEV)))","((!((!b_aEU) : (!bs_aEV))))","s_aEW","safebang@!s_aEW","(!s_aEW)","ss_aEX","(!s_aEW) : ss_aEX","((!s_aEW) : ss_aEX)","!((!s_aEW) : ss_aEX)","(!((!s_aEW) : ss_aEX))","((!((!s_aEW) : ss_aEX)))","!((!((!s_aEW) : ss_aEX)))","(!((!((!s_aEW) : ss_aEX))))","b_aEZ","safebang@!b_aEZ","(!b_aEZ)","s_aF0","safebang@!s_aF0","(!s_aF0)","[]","[]","b_aF1","s_aF2","!s_aF2","(!s_aF2)","b'_aF3","bs_aF4","b'_aF3 : bs_aF4","(b'_aF3 : bs_aF4)","s'_aF5","ss_aF6","safebang@!ss_aF6","(!ss_aF6)","s'_aF5 : (!ss_aF6)","(s'_aF5 : (!ss_aF6))","b_aF7","e_aF8","(b_aF7, e_aF8)","p_aNy","safebang@!p_aNy","(!p_aNy)","f_aNz","safebang@!f_aNz","(!f_aNz)","g_aNA","a_aNB","[]","Branch a_aNB []","(Branch a_aNB [])","!(Branch a_aNB [])","(!(Branch a_aNB []))","((!(Branch a_aNB [])))","!((!(Branch a_aNB [])))","(!((!(Branch a_aNB []))))","x_aNC","Score x_aNC","(Score x_aNC)","!(Score x_aNC)","(!(Score x_aNC))","((!(Score x_aNC)))","l_aND","Branch ((!(Score x_aNC))) l_aND","(Branch ((!(Score x_aNC))) l_aND)","!(Branch ((!(Score x_aNC))) l_aND)","(!(Branch ((!(Score x_aNC))) l_aND))","x_aNE","l_aNF","Branch x_aNE l_aNF","(Branch x_aNE l_aNF)","p_aNG","board_aNH","f_aNI","safebang@!f_aNI","(!f_aNI)","g_aNJ","safebang@!g_aNJ","(!g_aNJ)","a_aNK","[]","Branch a_aNK []","(Branch a_aNK [])","!(Branch a_aNK [])","(!(Branch a_aNK []))","f_aNL","g_aNM","_","l_aNN","Branch _ l_aNN","(Branch _ l_aNN)","!(Branch _ l_aNN)","(!(Branch _ l_aNN))","XWin","!XWin","(!XWin)","_","_","!_","(!_)","XWin","!XWin","(!XWin)","b_aTT","OWin","OWin","b_aTU","!b_aTU","(!b_aTU)","x_aTW","Score x_aTW","(Score x_aTW)","!(Score x_aTW)","(!(Score x_aTW))","a_aTV@(!(Score x_aTW))","y_aTY","!y_aTY","(!y_aTY)","Score (!y_aTY)","(Score (!y_aTY))","!(Score (!y_aTY))","(!(Score (!y_aTY)))","b_aTX@(!(Score (!y_aTY)))","!b_aTX@(!(Score (!y_aTY)))","(!b_aTX@(!(Score (!y_aTY))))","OWin","!OWin","(!OWin)","_","_","!_","(!_)","OWin","!OWin","(!OWin)","b_aTZ","!b_aTZ","(!b_aTZ)","XWin","!XWin","(!XWin)","XWin","!XWin","(!XWin)","b_aU0","!b_aU0","(!b_aU0)","x_aU2","Score x_aU2","(Score x_aU2)","!(Score x_aU2)","(!(Score x_aU2))","a_aU1@(!(Score x_aU2))","!a_aU1@(!(Score x_aU2))","(!a_aU1@(!(Score x_aU2)))","y_aU4","Score y_aU4","(Score y_aU4)","b_aU3@(Score y_aU4)","!b_aU3@(Score y_aU4)","(!b_aU3@(Score y_aU4))"]
module Game where
import Board
import Wins
import Tree

alternate :: Piece -> Player -> Player -> Board -> [Move]
alternate _ _ (norecord@_) (!b_ar7) | fullBoard b_ar7 = []
alternate _ (norecord@_) (norecord@_) (norecord@b_ar8)
  | static b_ar8 == XWin = []
alternate _ (norecord@_) _ (norecord@b_aEB)
  | static b_aEB == OWin = []
alternate (norecord@player_aEC) (norecord@f_aED) (norecord@g_aEE)
  board_aEF
  = move_aEG : alternate opposition_aEL g_aEE f_aED board'_aEH
  where (norecord@move_aEG@(board'_aEH, (!eval_aEI)))
          = best f_aED possibles_aEK scores_aEJ
        scores_aEJ
          = map (bestMove opposition_aEL g_aEE f_aED) possibles_aEK
        (!possibles_aEK) = newPositions player_aEC board_aEF
        (norecord@opposition_aEL) = opposite player_aEC

opposite :: Piece -> Piece
opposite X = O
opposite O = X

best :: Player -> [Board] -> [Evaluation] -> Move
best f_aET ((norecord@((!b_aEU) : (!bs_aEV))))
  (norecord@((norecord@((!s_aEW) : ss_aEX))))
  = best'_aEY b_aEU s_aEW bs_aEV ss_aEX
  where best'_aEY (!b_aEZ) (!s_aF0) [] [] = (b_aEZ, s_aF0)
        best'_aEY b_aF1 (norecord@s_aF2) (b'_aF3 : bs_aF4)
          (s'_aF5 : (!ss_aF6))
          | s_aF2 == (f_aET s_aF2 s'_aF5) =
            best'_aEY b_aF1 s_aF2 bs_aF4 ss_aF6
          | otherwise = best'_aEY b'_aF3 s'_aF5 bs_aF4 ss_aF6

showMove :: Move -> String
showMove (b_aF7, e_aF8) = show e_aF8 ++ "\n" ++ showBoard b_aF7

bestMove :: Piece -> Player -> Player -> Board -> Evaluation
bestMove (!p_aNy) (!f_aNz) g_aNA
  = (mise f_aNz g_aNA) . cropTree . mapTree static . searchTree p_aNy

cropTree :: (Tree Evaluation) -> (Tree Evaluation)
cropTree (norecord@((norecord@(Branch a_aNB []))))
  = (Branch a_aNB [])
cropTree (norecord@(Branch ((norecord@(Score x_aNC))) l_aND))
  = Branch (Score x_aNC) (map cropTree l_aND)
cropTree (Branch x_aNE l_aNF) = Branch x_aNE []

searchTree :: Piece -> Board -> (Tree Board)
searchTree p_aNG board_aNH
  = prune 5
      (repTree (newPositions p_aNG) (newPositions (opposite p_aNG))
         board_aNH)

mise :: Player -> Player -> (Tree Evaluation) -> Evaluation
mise (!f_aNI) (!g_aNJ) (norecord@(Branch a_aNK [])) = a_aNK
mise f_aNL g_aNM (norecord@(Branch _ l_aNN))
  = foldr f_aNL (g_aNM OWin XWin) (map (mise g_aNM f_aNL) l_aNN)

max' :: Evaluation -> Evaluation -> Evaluation
max' (norecord@XWin) _ = XWin
max' (norecord@_) (norecord@XWin) = XWin
max' b_aTT OWin = b_aTT
max' OWin (norecord@b_aTU) = b_aTU
max' a_aTV@(norecord@(Score x_aTW))
  (norecord@b_aTX@(norecord@(Score (norecord@y_aTY))))
  | x_aTW > y_aTY = a_aTV
  | otherwise = b_aTX

min' :: Evaluation -> Evaluation -> Evaluation
min' (norecord@OWin) _ = OWin
min' (norecord@_) (norecord@OWin) = OWin
min' (norecord@b_aTZ) (norecord@XWin) = b_aTZ
min' (norecord@XWin) (norecord@b_aU0) = b_aU0
min' (norecord@a_aU1@(norecord@(Score x_aU2)))
  (norecord@b_aU3@(Score y_aU4))
  | x_aU2 < y_aU4 = a_aU1
  | otherwise = b_aU3

type Player = Evaluation -> Evaluation -> Evaluation

type Move = (Board, Evaluation)

==================== Renamer ====================
Board.showBoard :: Board.Board -> String
Board.showBoard (![r1_aKG, r2_aKH, (!r3_aKI)])
  = Board.showRow r1_aKG
    ++
      "\n\
      \------\n"
      ++
        Board.showRow r2_aKH
        ++
          "\n\
          \------\n"
          ++
            Board.showRow r3_aKI
            ++
              "\n\
              \\n"
Board.showRow (![p1_aKJ, (!p2_aKK), (!p3_aKL)])
  = Board.showPiece p1_aKJ
    ++ "|" ++ Board.showPiece p2_aKK ++ "|" ++ Board.showPiece p3_aKL
Board.showPiece :: Board.Piece -> String
Board.showPiece Board.X = "X"
Board.showPiece (!Board.O) = "O"
Board.showPiece Board.Empty = " "
Board.placePiece ::
  Board.Piece -> Board.Board -> (Int, Int) -> [Board.Board]
Board.placePiece (!p_aKM) (!board_aKN) (!pos_aKO)
  | not (Board.empty pos_aKO board_aKN) = []
Board.placePiece
  (!p_aKP)
  [r1_aKQ, r2_aKR, (!r3_aKS)]
  (!((!1), x_aKT))
  = [[Board.insert p_aKP r1_aKQ x_aKT, r2_aKR, r3_aKS]]
Board.placePiece
  (!p_aKU)
  (![r1_aKV, r2_aKW, r3_aKX])
  ((!2), (!x_aKY))
  = [[r1_aKV, Board.insert p_aKU r2_aKW x_aKY, r3_aKX]]
Board.placePiece
  (!p_aKZ)
  (![r1_aL0, (!r2_aL1), (!r3_aL2)])
  ((!3), x_aL3)
  = [[r1_aL0, r2_aL1, Board.insert p_aKZ r3_aL2 x_aL3]]
Board.insert :: Board.Piece -> Board.Row -> Int -> Board.Row
Board.insert p_aL4 [(!p1_aL5), p2_aL6, p3_aL7] 1
  = [p_aL4, p2_aL6, p3_aL7]
Board.insert p_aL8 [(!p1_aL9), p2_aLa, p3_aLb] 2
  = [p1_aL9, p_aL8, p3_aLb]
Board.insert p_aLc [(!p1_aLd), (!p2_aLe), p3_aLf] 3
  = [p1_aLd, p2_aLe, p_aLc]
Board.empty :: (Int, Int) -> Board.Board -> Bool
Board.empty ((!1), (!x_aLg)) [(!r1_aLh), r2_aLi, r3_aLj]
  = Board.empty' x_aLg r1_aLh
Board.empty ((!2), x_aLk) [r1_aLl, r2_aLm, r3_aLn]
  = Board.empty' x_aLk r2_aLm
Board.empty ((!3), (!x_aLo)) [r1_aLp, r2_aLq, (!r3_aLr)]
  = Board.empty' x_aLo r3_aLr
Board.empty' :: Int -> Board.Row -> Bool
Board.empty' 1 (![Board.Empty, _, _]) = True
Board.empty' (!2) [_, (!Board.Empty), (!_)] = True
Board.empty' 3 [_, (!_), Board.Empty] = True
Board.empty' (!_) _ = False
Board.fullBoard (!b_aLs)
  = and (map notEmpty_aLt (concat b_aLs))
  where
      notEmpty_aLt x_aLu = not (x_aLu == Board.Empty)
Board.newPositions (!piece_aRC) (!board_aRD)
  = concat
      (map
         (Board.placePiece piece_aRC board_aRD)
         [(x_aRE, y_aRF) | (!x_aRE) <- [1 .. 3], y_aRF <- [1 .. 3]])
Board.initialBoard :: Board.Board
Board.initialBoard
  = [[Board.Empty, Board.Empty, Board.Empty],
     [Board.Empty, Board.Empty, Board.Empty],
     [Board.Empty, Board.Empty, Board.Empty]]
Board.eval (!3) = Board.XWin
Board.eval (!((!(-3)))) = Board.OWin
Board.eval (!x_aRG) = Board.Score x_aRG
Board.static :: Board.Board -> Board.Evaluation
Board.static (!board_aRH)
  = Board.interpret 0 (map (Board.score board_aRH) wins)
Board.interpret :: Int -> [Board.Evaluation] -> Board.Evaluation
Board.interpret x_aRI [] = (Board.Score x_aRI)
Board.interpret (!x_aRJ) (!(Board.Score (!y_aRK) : l_aRL))
  = Board.interpret (x_aRJ + y_aRK) l_aRL
Board.interpret x_aSK (!((!(Board.XWin : l_aSL)))) = Board.XWin
Board.interpret x_aSM (!((!((!Board.OWin) : (!l_aSN)))))
  = Board.OWin
Board.score :: Board.Board -> Win -> Board.Evaluation
Board.score board_aSO win_aSP
  = Board.eval
      (sum
         (map
            sum (Board.map2 (Board.map2 Board.scorePiece) board_aSO win_aSP)))
Board.scorePiece :: Board.Piece -> Int -> Int
Board.scorePiece Board.X (!score_aSQ) = score_aSQ
Board.scorePiece Board.Empty _ = 0
Board.scorePiece Board.O score_aSR = - score_aSR
Board.map2 ::
  (a_aKD -> b_aKE -> c_aKF) -> [a_aKD] -> [b_aKE] -> [c_aKF]
Board.map2 f_aSS (![]) x_aST = []
Board.map2 f_aSU (!x_aSV) [] = []
Board.map2 (!f_aSW) (!((!(x_aSX : xs_aSY)))) (!(y_aSZ : ys_aT0))
  = f_aSW x_aSX y_aSZ : Board.map2 f_aSW xs_aSY ys_aT0

data Board.Piece
  = Board.X | Board.O | Board.Empty
  deriving (Eq)
type Board.Row = [Board.Piece]
type Board.Board = [Board.Row]
data Board.Evaluation
  = Board.XWin | Board.OWin | Board.Score Int
  deriving (Show, Eq)


["r1_aKG","r2_aKH","r3_aKI","safebang@!r3_aKI","(!r3_aKI)","[r1_aKG, r2_aKH, (!r3_aKI)]","![r1_aKG, r2_aKH, (!r3_aKI)]","(![r1_aKG, r2_aKH, (!r3_aKI)])","p1_aKJ","p2_aKK","safebang@!p2_aKK","(!p2_aKK)","p3_aKL","safebang@!p3_aKL","(!p3_aKL)","[p1_aKJ, (!p2_aKK), (!p3_aKL)]","![p1_aKJ, (!p2_aKK), (!p3_aKL)]","(![p1_aKJ, (!p2_aKK), (!p3_aKL)])","X","O","!O","(!O)","Empty","p_aKM","safebang@!p_aKM","(!p_aKM)","board_aKN","safebang@!board_aKN","(!board_aKN)","pos_aKO","!pos_aKO","(!pos_aKO)","p_aKP","!p_aKP","(!p_aKP)","r1_aKQ","r2_aKR","r3_aKS","safebang@!r3_aKS","(!r3_aKS)","[r1_aKQ, r2_aKR, (!r3_aKS)]","1","!1","(!1)","x_aKT","((!1), x_aKT)","!((!1), x_aKT)","(!((!1), x_aKT))","p_aKU","!p_aKU","(!p_aKU)","r1_aKV","r2_aKW","r3_aKX","[r1_aKV, r2_aKW, r3_aKX]","![r1_aKV, r2_aKW, r3_aKX]","(![r1_aKV, r2_aKW, r3_aKX])","2","!2","(!2)","x_aKY","!x_aKY","(!x_aKY)","((!2), (!x_aKY))","p_aKZ","!p_aKZ","(!p_aKZ)","r1_aL0","r2_aL1","!r2_aL1","(!r2_aL1)","r3_aL2","safebang@!r3_aL2","(!r3_aL2)","[r1_aL0, (!r2_aL1), (!r3_aL2)]","![r1_aL0, (!r2_aL1), (!r3_aL2)]","(![r1_aL0, (!r2_aL1), (!r3_aL2)])","3","!3","(!3)","x_aL3","((!3), x_aL3)","p_aL4","p1_aL5","safebang@!p1_aL5","(!p1_aL5)","p2_aL6","p3_aL7","[(!p1_aL5), p2_aL6, p3_aL7]","1","p_aL8","p1_aL9","!p1_aL9","(!p1_aL9)","p2_aLa","p3_aLb","[(!p1_aL9), p2_aLa, p3_aLb]","2","p_aLc","p1_aLd","!p1_aLd","(!p1_aLd)","p2_aLe","!p2_aLe","(!p2_aLe)","p3_aLf","[(!p1_aLd), (!p2_aLe), p3_aLf]","3","1","!1","(!1)","x_aLg","!x_aLg","(!x_aLg)","((!1), (!x_aLg))","r1_aLh","safebang@!r1_aLh","(!r1_aLh)","r2_aLi","r3_aLj","[(!r1_aLh), r2_aLi, r3_aLj]","2","!2","(!2)","x_aLk","((!2), x_aLk)","r1_aLl","r2_aLm","r3_aLn","[r1_aLl, r2_aLm, r3_aLn]","3","!3","(!3)","x_aLo","!x_aLo","(!x_aLo)","((!3), (!x_aLo))","r1_aLp","r2_aLq","r3_aLr","safebang@!r3_aLr","(!r3_aLr)","[r1_aLp, r2_aLq, (!r3_aLr)]","1","Empty","_","_","[Empty, _, _]","![Empty, _, _]","(![Empty, _, _])","2","!2","(!2)","_","Empty","!Empty","(!Empty)","_","!_","(!_)","[_, (!Empty), (!_)]","3","_","_","!_","(!_)","Empty","[_, (!_), Empty]","_","!_","(!_)","_","b_aLs","safebang@!b_aLs","(!b_aLs)","x_aLu","piece_aRC","safebang@!piece_aRC","(!piece_aRC)","board_aRD","safebang@!board_aRD","(!board_aRD)","x_aRE","!x_aRE","(!x_aRE)","y_aRF","initialBoard","3","!3","(!3)","-3","(-3)","!(-3)","(!(-3))","((!(-3)))","!((!(-3)))","(!((!(-3))))","x_aRG","!x_aRG","(!x_aRG)","board_aRH","safebang@!board_aRH","(!board_aRH)","x_aRI","[]","x_aRJ","!x_aRJ","(!x_aRJ)","y_aRK","safebang@!y_aRK","(!y_aRK)","Score (!y_aRK)","l_aRL","Score (!y_aRK) : l_aRL","(Score (!y_aRK) : l_aRL)","!(Score (!y_aRK) : l_aRL)","(!(Score (!y_aRK) : l_aRL))","x_aSK","XWin","l_aSL","XWin : l_aSL","(XWin : l_aSL)","!(XWin : l_aSL)","(!(XWin : l_aSL))","((!(XWin : l_aSL)))","!((!(XWin : l_aSL)))","(!((!(XWin : l_aSL))))","x_aSM","OWin","!OWin","(!OWin)","l_aSN","!l_aSN","(!l_aSN)","(!OWin) : (!l_aSN)","((!OWin) : (!l_aSN))","!((!OWin) : (!l_aSN))","(!((!OWin) : (!l_aSN)))","((!((!OWin) : (!l_aSN))))","!((!((!OWin) : (!l_aSN))))","(!((!((!OWin) : (!l_aSN)))))","board_aSO","win_aSP","X","score_aSQ","lazydmd@!score_aSQ","(!score_aSQ)","Empty","_","O","score_aSR","f_aSS","[]","![]","(![])","x_aST","f_aSU","x_aSV","!x_aSV","(!x_aSV)","[]","f_aSW","!f_aSW","(!f_aSW)","x_aSX","xs_aSY","x_aSX : xs_aSY","(x_aSX : xs_aSY)","!(x_aSX : xs_aSY)","(!(x_aSX : xs_aSY))","((!(x_aSX : xs_aSY)))","!((!(x_aSX : xs_aSY)))","(!((!(x_aSX : xs_aSY))))","y_aSZ","ys_aT0","y_aSZ : ys_aT0","(y_aSZ : ys_aT0)","!(y_aSZ : ys_aT0)","(!(y_aSZ : ys_aT0))"]
module Board where
import Wins

showBoard :: Board -> String
showBoard (norecord@[r1_aKG, r2_aKH, (!r3_aKI)])
  = showRow r1_aKG ++ "\n------\n" ++ showRow r2_aKH ++ "\n------\n"
      ++ showRow r3_aKI
      ++ "\n\n"
showRow (norecord@[p1_aKJ, (!p2_aKK), (!p3_aKL)])
  = showPiece p1_aKJ ++ "|" ++ showPiece p2_aKK ++ "|" ++
      showPiece p3_aKL

showPiece :: Piece -> String
showPiece X = "X"
showPiece (norecord@O) = "O"
showPiece Empty = " "

placePiece :: Piece -> Board -> (Int, Int) -> [Board]
placePiece (!p_aKM) (!board_aKN) (norecord@pos_aKO)
  | not (empty pos_aKO board_aKN) = []
placePiece (norecord@p_aKP) [r1_aKQ, r2_aKR, (!r3_aKS)]
  (norecord@((norecord@1), x_aKT))
  = [[insert p_aKP r1_aKQ x_aKT, r2_aKR, r3_aKS]]
placePiece (norecord@p_aKU) (norecord@[r1_aKV, r2_aKW, r3_aKX])
  ((norecord@2), (norecord@x_aKY))
  = [[r1_aKV, insert p_aKU r2_aKW x_aKY, r3_aKX]]
placePiece (norecord@p_aKZ)
  (norecord@[r1_aL0, (norecord@r2_aL1), (!r3_aL2)])
  ((norecord@3), x_aL3)
  = [[r1_aL0, r2_aL1, insert p_aKZ r3_aL2 x_aL3]]

insert :: Piece -> Row -> Int -> Row
insert p_aL4 [(!p1_aL5), p2_aL6, p3_aL7] 1
  = [p_aL4, p2_aL6, p3_aL7]
insert p_aL8 [(norecord@p1_aL9), p2_aLa, p3_aLb] 2
  = [p1_aL9, p_aL8, p3_aLb]
insert p_aLc [(norecord@p1_aLd), (norecord@p2_aLe), p3_aLf] 3
  = [p1_aLd, p2_aLe, p_aLc]

empty :: (Int, Int) -> Board -> Bool
empty ((norecord@1), (norecord@x_aLg)) [(!r1_aLh), r2_aLi, r3_aLj]
  = empty' x_aLg r1_aLh
empty ((norecord@2), x_aLk) [r1_aLl, r2_aLm, r3_aLn]
  = empty' x_aLk r2_aLm
empty ((norecord@3), (norecord@x_aLo)) [r1_aLp, r2_aLq, (!r3_aLr)]
  = empty' x_aLo r3_aLr

empty' :: Int -> Row -> Bool
empty' 1 (norecord@[Empty, _, _]) = True
empty' (norecord@2) [_, (norecord@Empty), (norecord@_)] = True
empty' 3 [_, (norecord@_), Empty] = True
empty' (norecord@_) _ = False
fullBoard (!b_aLs) = and (map notEmpty_aLt (concat b_aLs))
  where notEmpty_aLt x_aLu = not (x_aLu == Empty)
newPositions (!piece_aRC) (!board_aRD)
  = concat
      (map (placePiece piece_aRC board_aRD)
         [(x_aRE, y_aRF) | (norecord@x_aRE) <- [1 .. 3], y_aRF <- [1 .. 3]])

initialBoard :: Board
initialBoard
  = [[Empty, Empty, Empty], [Empty, Empty, Empty],
     [Empty, Empty, Empty]]
eval (norecord@3) = XWin
eval (norecord@((norecord@(-3)))) = OWin
eval (norecord@x_aRG) = Score x_aRG

static :: Board -> Evaluation
static (!board_aRH) = interpret 0 (map (score board_aRH) wins)

interpret :: Int -> [Evaluation] -> Evaluation
interpret x_aRI [] = (Score x_aRI)
interpret (norecord@x_aRJ) (norecord@(Score (!y_aRK) : l_aRL))
  = interpret (x_aRJ + y_aRK) l_aRL
interpret x_aSK (norecord@((norecord@(XWin : l_aSL)))) = XWin
interpret x_aSM
  (norecord@((norecord@((norecord@OWin) : (norecord@l_aSN))))) = OWin

score :: Board -> Win -> Evaluation
score board_aSO win_aSP
  = eval (sum (map sum (map2 (map2 scorePiece) board_aSO win_aSP)))

scorePiece :: Piece -> Int -> Int
scorePiece X (lazydmd@score_aSQ) = score_aSQ
scorePiece Empty _ = 0
scorePiece O score_aSR = -score_aSR

map2 :: (a_aKD -> b_aKE -> c_aKF) -> [a_aKD] -> [b_aKE] -> [c_aKF]
map2 f_aSS (norecord@[]) x_aST = []
map2 f_aSU (norecord@x_aSV) [] = []
map2 (norecord@f_aSW) (norecord@((norecord@(x_aSX : xs_aSY))))
  (norecord@(y_aSZ : ys_aT0))
  = f_aSW x_aSX y_aSZ : map2 f_aSW xs_aSY ys_aT0

data Piece = X
           | O
           | Empty
           deriving Eq

type Row = [Piece]

type Board = [Row]

data Evaluation = XWin
                | OWin
                | Score Int
                deriving (Show, Eq)

==================== Renamer ====================
Rewritefns.applysubst :: Lisplist -> Lisplist -> Lisplist
Rewritefns.applysubst (!alist_aoz) (!Nil) = Nil
Rewritefns.applysubst (!alist_aoA) term_aoB@(!(Atom (!x_aoC)))
  = case assoc (term_aoB, alist_aoA) of {
      Cons (yh_aoD, yt_aoE) -> yt_aoE
      (!_) -> term_aoB }
Rewritefns.applysubst
  (!alist_aoF)
  ((!(Cons (!((!x_aoG), (!y_aoH))))))
  = Cons (x_aoG, Rewritefns.applysubstlst alist_aoF y_aoH)
Rewritefns.applysubstlst :: Lisplist -> Lisplist -> Lisplist
Rewritefns.applysubstlst alist_aoI (!Nil) = Nil
Rewritefns.applysubstlst alist_aoJ (Atom (!x_aoK))
  = error "Malformed list"
Rewritefns.applysubstlst
  (!alist_aoM)
  (!((!(Cons ((!x_aoN), (!y_aoO))))))
  = Cons
      (Rewritefns.applysubst alist_aoM x_aoN, 
       Rewritefns.applysubstlst alist_aoM y_aoO)
Rewritefns.rewrite :: Lisplist -> LUT -> Lisplist
Rewritefns.rewrite Nil term_aoP = Nil
Rewritefns.rewrite (!expr_aoQ@(!(Atom x_aoR))) term_aoS = expr_aoQ
Rewritefns.rewrite ((!(Cons (!(l1_aoT, (!l2_aoU)))))) term_aoV
  = Rewritefns.rewritewithlemmas
      (Cons (l1_aoT, Rewritefns.rewriteargs l2_aoU term_aoV))
      (getLUT (tv l1_aoT, term_aoV))
      term_aoV
Rewritefns.rewriteargs :: Lisplist -> LUT -> Lisplist
Rewritefns.rewriteargs Nil (!term_aoW) = Nil
Rewritefns.rewriteargs (Atom x_aoX) (!term_aoY)
  = error "Malformed list"
Rewritefns.rewriteargs ((!(Cons (x_aoZ, y_ap0)))) (!term_ap1)
  = Cons
      (Rewritefns.rewrite x_aoZ term_ap1, 
       Rewritefns.rewriteargs y_ap0 term_ap1)
Rewritefns.rewritewithlemmas ::
  Lisplist -> [Lisplist] -> LUT -> Lisplist
Rewritefns.rewritewithlemmas (!t_ap2) (![]) (!term_ap3) = t_ap2
Rewritefns.rewritewithlemmas
  (!t_ap4)
  (!((!((!lh_ap5) : lt_ap6))))
  (!term_ap7)
  | b_ap8
  = Rewritefns.rewrite
      (Rewritefns.applysubst u_ap9 (caddr lh_ap5)) term_ap7
  | otherwise = Rewritefns.rewritewithlemmas t_ap4 lt_ap6 term_ap7
  where
      (!(b_ap8, u_ap9)) = Rewritefns.onewayunify t_ap4 (cadr lh_ap5)
Rewritefns.onewayunify :: Lisplist -> Lisplist -> (Bool, Lisplist)
Rewritefns.onewayunify t1_apa (!t2_apb)
  = Rewritefns.onewayunify1 t1_apa t2_apb Nil
Rewritefns.onewayunify1 ::
  Lisplist -> Lisplist -> Lisplist -> (Bool, Lisplist)
Rewritefns.onewayunify1 t1_apc t2_apd u_ape
  | atom t2_apd
  = case assoc (t2_apd, u_ape) of {
      Cons (!(x_apf, y_apg)) -> (t1_apc == y_apg, u_ape)
      (!_) -> (True, Cons (Cons (t2_apd, t1_apc), u_ape)) }
  | atom t1_apc = (False, u_ape)
  | car t1_apc == car t2_apd
  = Rewritefns.onewayunify1lst (cdr t1_apc) (cdr t2_apd) u_ape
  | otherwise = (False, u_ape)
Rewritefns.onewayunify1lst ::
  Lisplist -> Lisplist -> Lisplist -> (Bool, Lisplist)
Rewritefns.onewayunify1lst (!Nil) (!_) u_aCI = (True, u_aCI)
Rewritefns.onewayunify1lst l1_aCJ (!l2_aCK) u_aCL
  | b_aCM
  = Rewritefns.onewayunify1lst (cdr l1_aCJ) (cdr l2_aCK) u1_aCN
  | otherwise = (False, u1_aCN)
  where
      (!(b_aCM, u1_aCN))
        = Rewritefns.onewayunify1 (car l1_aCJ) (car l2_aCK) u_aCL



==================== Renamer ====================
Main.lemmas :: LUT
Main.lemmas = Main.addlemmalst (Main.makelemmas rules) newLUT
Main.makelemmas :: [String] -> [Lisplist]
Main.makelemmas (![]) = []
Main.makelemmas (!((!h_avB) : (!t_avC)))
  = mkLisplist (strToToken h_avB) : (Main.makelemmas t_avC)
Main.addlemmalst :: [Lisplist] -> LUT -> LUT
Main.addlemmalst [] term_avD = term_avD
Main.addlemmalst (!(h_avE : t_avF)) (!term_avG)
  = Main.addlemmalst t_avF (Main.addlemma h_avE term_avG)
Main.addlemma :: Lisplist -> LUT -> LUT
Main.addlemma (!Nil) (!term_avH) = term_avH
Main.addlemma ((!(Atom (!x_avI)))) term_avJ
  = error "Atoms can't be lemmas"
Main.addlemma (Cons (!((!x_avL), y_avM))) (!term_avN)
  | tv x_avL == "equal" && not (atom z_avO)
  = addtoLUT (tv (car z_avO), Cons (x_avL, y_avM), term_avN)
  | otherwise = error "Malformed lemma"
  where
      (!z_avO) = car y_avM
Main.tautp :: Lisplist -> Bool
Main.tautp (!term_aJg)
  = tautologyp (rewrite term_aJg Main.lemmas, Nil, Nil)
Main.statement :: Lisplist
Main.statement
  = mkLisplist
      (strToToken
         ("( implies ( and ( implies x y )( and ( implies y z )( and ( implies z u )( implies u w ) ) ) )( implies x w ) )"))
Main.subterm :: Lisplist
Main.subterm
  = mkLisplist
      (strToToken
         ("( ( x f ( plus ( plus a b )( plus c ( zero ) ) ) )( y f ( times ( times a b )( plus c d ) ) )( z f ( reverse ( append ( append a b ) ( [] ) ) ) )(u equal ( plus a b ) ( difference x y ) )(w lessp ( remainder a b )( member a ( length b ) ) ) )"))
Main.teststatement :: Lisplist
Main.teststatement = applysubst Main.subterm Main.statement
Main.testresult :: Bool
Main.testresult = Main.tautp Main.teststatement
Main.report :: Bool -> String
Main.report True = "The term is a tautology\n"
Main.report False = "The term is not a tautology\n"
Main.main = putStr (Main.report Main.testresult)


["lemmas","[]","![]","(![])","h_avB","safebang@!h_avB","(!h_avB)","t_avC","safebang@!t_avC","(!t_avC)","(!h_avB) : (!t_avC)","((!h_avB) : (!t_avC))","!((!h_avB) : (!t_avC))","(!((!h_avB) : (!t_avC)))","[]","term_avD","h_avE","t_avF","h_avE : t_avF","(h_avE : t_avF)","!(h_avE : t_avF)","(!(h_avE : t_avF))","term_avG","!term_avG","(!term_avG)","Nil","!Nil","(!Nil)","term_avH","!term_avH","(!term_avH)","x_avI","lazydmd@!x_avI","(!x_avI)","Atom (!x_avI)","(Atom (!x_avI))","!(Atom (!x_avI))","(!(Atom (!x_avI)))","((!(Atom (!x_avI))))","term_avJ","x_avL","safebang@!x_avL","(!x_avL)","y_avM","((!x_avL), y_avM)","!((!x_avL), y_avM)","(!((!x_avL), y_avM))","Cons (!((!x_avL), y_avM))","(Cons (!((!x_avL), y_avM)))","term_avN","!term_avN","(!term_avN)","z_avO","safebang@!z_avO","(!z_avO)","term_aJg","!term_aJg","(!term_aJg)","statement","subterm","teststatement","testresult","True","False","main"]
module Main (main) where
import Lisplikefns
import Rewritefns
import Rulebasetext
import Checker

lemmas :: LUT
lemmas = addlemmalst (makelemmas rules) newLUT

makelemmas :: [String] -> [Lisplist]
makelemmas (norecord@[]) = []
makelemmas (norecord@((!h_avB) : (!t_avC)))
  = mkLisplist (strToToken h_avB) : (makelemmas t_avC)

addlemmalst :: [Lisplist] -> LUT -> LUT
addlemmalst [] term_avD = term_avD
addlemmalst (norecord@(h_avE : t_avF)) (norecord@term_avG)
  = addlemmalst t_avF (addlemma h_avE term_avG)

addlemma :: Lisplist -> LUT -> LUT
addlemma (norecord@Nil) (norecord@term_avH) = term_avH
addlemma ((norecord@(Atom (lazydmd@x_avI)))) term_avJ
  = error "Atoms can't be lemmas"
addlemma (Cons (norecord@((!x_avL), y_avM))) (norecord@term_avN)
  | tv x_avL == "equal" && not (atom z_avO) =
    addtoLUT (tv (car z_avO), Cons (x_avL, y_avM), term_avN)
  | otherwise = error "Malformed lemma"
  where (!z_avO) = car y_avM

tautp :: Lisplist -> Bool
tautp (norecord@term_aJg)
  = tautologyp (rewrite term_aJg lemmas, Nil, Nil)

statement :: Lisplist
statement
  = mkLisplist
      (strToToken
         ("( implies ( and ( implies x y )( and ( implies y z )( and ( implies z u )( implies u w ) ) ) )( implies x w ) )"))

subterm :: Lisplist
subterm
  = mkLisplist
      (strToToken
         ("( ( x f ( plus ( plus a b )( plus c ( zero ) ) ) )( y f ( times ( times a b )( plus c d ) ) )( z f ( reverse ( append ( append a b ) ( [] ) ) ) )(u equal ( plus a b ) ( difference x y ) )(w lessp ( remainder a b )( member a ( length b ) ) ) )"))

teststatement :: Lisplist
teststatement = applysubst subterm statement

testresult :: Bool
testresult = tautp teststatement

report :: Bool -> String
report True = "The term is a tautology\n"
report False = "The term is not a tautology\n"
main = putStr (report testresult)

==================== Renamer ====================
Rulebasetext.rules :: [String]
Rulebasetext.rules
  = ["(equal (compile form)(reverse (codegen (optimize form) (nil) ) ) )",
     "(equal (eqp x y)(equal (fix x)(fix y) ) )",
     "(equal (greaterp x y)(lessp y x) )",
     "(equal (lesseqp x y)(not (lessp y x) ) )",
     "(equal (greatereqp x y)(not (lessp y x) ) )",
     "(equal (boolean x)(or (equal x (t) )(equal x (f) ) )",
     "(equal (iff x y)(and (implies x y)(implies y x) ) )",
     "(equal (even1 x)(if (zerop x)(t)(odd (1- x) ) ) )",
     "(equal (countps- l pred)(countps-loop l pred (zero) ) )",
     "(equal (fact- i)(fact-loop i 1) )",
     "(equal (reverse- x)(reverse-loop x (nil) ) )",
     "(equal (divides x y)(zerop (remainder y x) ) )",
     "(equal (assume-true var alist)(cons (cons var (t) )alist) )",
     "(equal (assume-false var alist)(cons (cons var (f) )alist) )",
     "(equal (tautology-checker x)(tautologyp (normalize x)(nil) ) )",
     "(equal (falsify x)(falsify1 (normalize x)(nil) ) )",
     "(equal (prime x)(and (not (zerop x))(not (equal x (add1 (zero) ) ) )(prime1 x (1- x) ) ) )",
     "(equal (and p q)(if p (if q (t) (f) ) (f) ) )",
     "(equal (or p q)(if p (t) (if q (t) (f) ) ) )",
     "(equal (not p)(if p (f) (t) ) )",
     "(equal (implies p q)(if p (if q (t) (f) ) (t) ) )",
     "(equal (fix x)(if (numberp x) x (zero) ) )",
     "(equal (if (if a b c) d e)(if a (if b d e) (if c d e) ) )",
     "(equal (zerop x)(or (equal x (zero) )(not (numberp x) ) ) )",
     "(equal (plus (plus x y) z )(plus x (plus y z) ) )",
     "(equal (equal (plus a b) (zero ) )(and (zerop a) (zerop b) ) )",
     "(equal (difference x x)(zero) )",
     "(equal (equal (plus a b) (plus a c) )(equal (fix b) (fix c) ) )",
     "(equal (equal (zero) (difference x y) )(not (lessp y x) ) )",
     "(equal (equal x (difference x y) )(and (numberp x)(or (equal x (zero) )(zerop y) ) ) )",
     "(equal (meaning (plus-tree (append x y) ) a)(plus (meaning (plus-tree x) a)(meaning (plus-tree y) a) ) )",
     "(equal (meaning (plus-tree (plus-fringe x) ) a)(fix (meaning x a) ) )",
     "(equal (append (append x y) z)(append x (append y z) ) )",
     "(equal (reverse (append a b) )(append (reverse b) (reverse a) ) )",
     "(equal (times x (plus y z) )(plus (times x y)(times x z) ) )",
     "(equal (times (times x y) z)(times x (times y z) ) )",
     "(equal (equal (times x y) (zero) )(or (zerop x)(zerop y) ) )",
     "(equal (exec (append x y)pds envrn)(exec y (exec x pds envrn)envrn) )",
     "(equal (mc-flatten x y)(append (flatten x)y) )",
     "(equal (member x (append a b) )(or (member x a)(member x b) ) )",
     "(equal (member x (reverse y) )(member x y) )",
     "(equal (length (reverse x) )(length x) )",
     "(equal (member a (intersect b c) )(and (member a b)(member a c) ) )",
     "(equal (nth (zero)i)(zero) )",
     "(equal (exp i (plus j k) )(times (exp i j)(exp i k) ) )",
     "(equal (exp i (times j k) )(exp (exp i j)k) )",
     "(equal (reverse-loop x y)(append (reverse x)y) )",
     "(equal (reverse-loop x (nil) )(reverse x) )",
     "(equal (count-list z (sort-lp x y) )(plus (count-list z x)(count-list z y) ) )",
     "(equal (equal (append a b)(append a c) )(equal b c) )",
     "(equal (plus (remainder x y)(times y (quotient x y) ) )(fix x) )",
     "(equal (power-eval (big-plus1 l i base)base)(plus (power-eval l base)i) )",
     "(equal (power-eval (big-plus x y i base)base)(plus i (plus (power-eval x base)(power-eval y base) ) ) )",
     "(equal (remainder y 1)(zero) )",
     "(equal (lessp (remainder x y)y)(not (zerop y) ) )",
     "(equal (remainder x x)(zero) )",
     "(equal (lessp (quotient i j)i)(and (not (zerop i) )(or (zerop j)(not (equal j 1) ) ) ) )",
     "(equal (lessp (remainder x y)x)(and (not (zerop y) )(not (zerop x) )(not (lessp x y) ) ) )",
     "(equal (power-eval (power-rep i base)base)(fix i) )",
     "(equal (power-eval (big-plus (power-rep i base)(power-rep j base)(zero)base)base)(plus i j) )",
     "(equal (gcd x y)(gcd y x) )",
     "(equal (nth (append a b)i)(append (nth a i)(nth b (difference i (length a) ) ) ) )",
     "(equal (difference (plus x y)x)(fix y) )",
     "(equal (difference (plus y x)x)(fix y) )",
     "(equal (difference (plus x y)(plus x z) )(difference y z) )",
     "(equal (times x (difference c w) )(difference (times c x)(times w x) ) )",
     "(equal (remainder (times x z)z)(zero) )",
     "(equal (difference (plus b (plus a c) )a)(plus b c) )",
     "(equal (difference (add1 (plus y z)z)(add1 y) )",
     "(equal (lessp (plus x y)(plus x z ) )(lessp y z) )",
     "(equal (lessp (times x z)(times y z) )(and (not (zerop z) )(lessp x y) ) )",
     "(equal (lessp y (plus x y) )(not (zerop x) ) )",
     "(equal (gcd (times x z)(times y z) )(times z (gcd x y) ) )",
     "(equal (value (normalize x)a)(value x a) )",
     "(equal (equal (flatten x)(cons y (nil) ) )(and (nlistp x)(equal x y) ) )",
     "(equal (listp (gopher x) )(listp x) )",
     "(equal (samefringe x y)(equal (flatten x)(flatten y) ) )",
     "(equal (equal (greatest-factor x y)(zero) )(and (or (zerop y)(equal y 1) )(equal x (zero) ) ) )",
     "(equal (equal (greatest-factor x y)1)(equal x 1) )",
     "(equal (numberp (greatest-factor x y) )(not (and (or (zerop y)(equal y 1) )(not (numberp x) ) ) ) )",
     "(equal (times-list (append x y) )(times (times-list x)(times-list y) ) )",
     "(equal (prime-list (append x y) )(and (prime-list x)(prime-list y) ) )",
     "(equal (equal z (times w z) )(and (numberp z)(or (equal z (zero) )(equal w 1) ) ) )",
     "(equal (greatereqpr x y)(not (lessp x y) ) )",
     "(equal (equal x (times x y) )(or (equal x (zero) )(and (numberp x)(equal y 1) ) ) )",
     "(equal (remainder (times y x)y)(zero) )",
     "(equal (equal (times a b)1)(and (not (equal a (zero) ) )(not (equal b (zero) ) )(numberp a)(numberp b)(equal (1- a)(zero) )(equal (1- b)(zero) ) ) )",
     "(equal (lessp (length (delete x l) )(length l) )(member x l) )",
     "(equal (sort2 (delete x l) )(delete x (sort2 l) ) )",
     "(equal (dsort x)(sort2 x) )",
     "(equal (length(cons x1(cons x2(cons x3(cons x4(cons x5(cons x6 x7) ) ) ) ) ) )(plus 6 (length x7) ) )",
     "(equal (difference (add1 (add1 x) )2)(fix x) )",
     "(equal (quotient (plus x (plus x y) )2)(plus x (quotient y 2) ) )",
     "(equal (sigma (zero)i)(quotient (times i (add1 i) )2) )",
     "(equal (plus x (add1 y) )(if (numberp y)(add1 (plus x y) )(add1 x) ) )",
     "(equal (equal (difference x y)(difference z y) )(if (lessp x y)(not (lessp y z) )(if (lessp z y)(not (lessp y x) )(equal (fix x)(fix z) ) ) ) )",
     "(equal (meaning (plus-tree (delete x y) )a)(if (member x y)(difference (meaning (plus-tree y)a)(meaning x a) )(meaning (plus-tree y)a) ) )",
     "(equal (times x (add1 y) )(if (numberp y)(plus x (times x y) )(fix x) ) )",
     "(equal (nth (nil)i)(if (zerop i)(nil)(zero) ) )",
     "(equal (last (append a b) )(if (listp b)(last b)(if (listp a)(cons (car (last a) )b)b) ) )",
     "(equal (equal (lessp x y)z)(if (lessp x y)(equal t z)(equal f z) ) )",
     "(equal (assignment x (append a b) )(if (assignedp x a)(assignment x a)(assignment x b) ) )",
     "(equal (car (gopher x) )(if (listp x)(car (flatten x) )(zero) ) )",
     "(equal (flatten (cdr (gopher x) ) )(if (listp x)(cdr (flatten x) )(cons (zero)(nil) ) ) )",
     "(equal (quotient (times y x)y)(if (zerop y)(zero)(fix x) ) )",
     "(equal (get j (set i val mem) )(if (eqp j i)val(get j mem) ) )"]


["rules"]
module Rulebasetext (rules) where

rules :: [String]
rules
  = ["(equal (compile form)(reverse (codegen (optimize form) (nil) ) ) )",
     "(equal (eqp x y)(equal (fix x)(fix y) ) )",
     "(equal (greaterp x y)(lessp y x) )",
     "(equal (lesseqp x y)(not (lessp y x) ) )",
     "(equal (greatereqp x y)(not (lessp y x) ) )",
     "(equal (boolean x)(or (equal x (t) )(equal x (f) ) )",
     "(equal (iff x y)(and (implies x y)(implies y x) ) )",
     "(equal (even1 x)(if (zerop x)(t)(odd (1- x) ) ) )",
     "(equal (countps- l pred)(countps-loop l pred (zero) ) )",
     "(equal (fact- i)(fact-loop i 1) )",
     "(equal (reverse- x)(reverse-loop x (nil) ) )",
     "(equal (divides x y)(zerop (remainder y x) ) )",
     "(equal (assume-true var alist)(cons (cons var (t) )alist) )",
     "(equal (assume-false var alist)(cons (cons var (f) )alist) )",
     "(equal (tautology-checker x)(tautologyp (normalize x)(nil) ) )",
     "(equal (falsify x)(falsify1 (normalize x)(nil) ) )",
     "(equal (prime x)(and (not (zerop x))(not (equal x (add1 (zero) ) ) )(prime1 x (1- x) ) ) )",
     "(equal (and p q)(if p (if q (t) (f) ) (f) ) )",
     "(equal (or p q)(if p (t) (if q (t) (f) ) ) )",
     "(equal (not p)(if p (f) (t) ) )",
     "(equal (implies p q)(if p (if q (t) (f) ) (t) ) )",
     "(equal (fix x)(if (numberp x) x (zero) ) )",
     "(equal (if (if a b c) d e)(if a (if b d e) (if c d e) ) )",
     "(equal (zerop x)(or (equal x (zero) )(not (numberp x) ) ) )",
     "(equal (plus (plus x y) z )(plus x (plus y z) ) )",
     "(equal (equal (plus a b) (zero ) )(and (zerop a) (zerop b) ) )",
     "(equal (difference x x)(zero) )",
     "(equal (equal (plus a b) (plus a c) )(equal (fix b) (fix c) ) )",
     "(equal (equal (zero) (difference x y) )(not (lessp y x) ) )",
     "(equal (equal x (difference x y) )(and (numberp x)(or (equal x (zero) )(zerop y) ) ) )",
     "(equal (meaning (plus-tree (append x y) ) a)(plus (meaning (plus-tree x) a)(meaning (plus-tree y) a) ) )",
     "(equal (meaning (plus-tree (plus-fringe x) ) a)(fix (meaning x a) ) )",
     "(equal (append (append x y) z)(append x (append y z) ) )",
     "(equal (reverse (append a b) )(append (reverse b) (reverse a) ) )",
     "(equal (times x (plus y z) )(plus (times x y)(times x z) ) )",
     "(equal (times (times x y) z)(times x (times y z) ) )",
     "(equal (equal (times x y) (zero) )(or (zerop x)(zerop y) ) )",
     "(equal (exec (append x y)pds envrn)(exec y (exec x pds envrn)envrn) )",
     "(equal (mc-flatten x y)(append (flatten x)y) )",
     "(equal (member x (append a b) )(or (member x a)(member x b) ) )",
     "(equal (member x (reverse y) )(member x y) )",
     "(equal (length (reverse x) )(length x) )",
     "(equal (member a (intersect b c) )(and (member a b)(member a c) ) )",
     "(equal (nth (zero)i)(zero) )",
     "(equal (exp i (plus j k) )(times (exp i j)(exp i k) ) )",
     "(equal (exp i (times j k) )(exp (exp i j)k) )",
     "(equal (reverse-loop x y)(append (reverse x)y) )",
     "(equal (reverse-loop x (nil) )(reverse x) )",
     "(equal (count-list z (sort-lp x y) )(plus (count-list z x)(count-list z y) ) )",
     "(equal (equal (append a b)(append a c) )(equal b c) )",
     "(equal (plus (remainder x y)(times y (quotient x y) ) )(fix x) )",
     "(equal (power-eval (big-plus1 l i base)base)(plus (power-eval l base)i) )",
     "(equal (power-eval (big-plus x y i base)base)(plus i (plus (power-eval x base)(power-eval y base) ) ) )",
     "(equal (remainder y 1)(zero) )",
     "(equal (lessp (remainder x y)y)(not (zerop y) ) )",
     "(equal (remainder x x)(zero) )",
     "(equal (lessp (quotient i j)i)(and (not (zerop i) )(or (zerop j)(not (equal j 1) ) ) ) )",
     "(equal (lessp (remainder x y)x)(and (not (zerop y) )(not (zerop x) )(not (lessp x y) ) ) )",
     "(equal (power-eval (power-rep i base)base)(fix i) )",
     "(equal (power-eval (big-plus (power-rep i base)(power-rep j base)(zero)base)base)(plus i j) )",
     "(equal (gcd x y)(gcd y x) )",
     "(equal (nth (append a b)i)(append (nth a i)(nth b (difference i (length a) ) ) ) )",
     "(equal (difference (plus x y)x)(fix y) )",
     "(equal (difference (plus y x)x)(fix y) )",
     "(equal (difference (plus x y)(plus x z) )(difference y z) )",
     "(equal (times x (difference c w) )(difference (times c x)(times w x) ) )",
     "(equal (remainder (times x z)z)(zero) )",
     "(equal (difference (plus b (plus a c) )a)(plus b c) )",
     "(equal (difference (add1 (plus y z)z)(add1 y) )",
     "(equal (lessp (plus x y)(plus x z ) )(lessp y z) )",
     "(equal (lessp (times x z)(times y z) )(and (not (zerop z) )(lessp x y) ) )",
     "(equal (lessp y (plus x y) )(not (zerop x) ) )",
     "(equal (gcd (times x z)(times y z) )(times z (gcd x y) ) )",
     "(equal (value (normalize x)a)(value x a) )",
     "(equal (equal (flatten x)(cons y (nil) ) )(and (nlistp x)(equal x y) ) )",
     "(equal (listp (gopher x) )(listp x) )",
     "(equal (samefringe x y)(equal (flatten x)(flatten y) ) )",
     "(equal (equal (greatest-factor x y)(zero) )(and (or (zerop y)(equal y 1) )(equal x (zero) ) ) )",
     "(equal (equal (greatest-factor x y)1)(equal x 1) )",
     "(equal (numberp (greatest-factor x y) )(not (and (or (zerop y)(equal y 1) )(not (numberp x) ) ) ) )",
     "(equal (times-list (append x y) )(times (times-list x)(times-list y) ) )",
     "(equal (prime-list (append x y) )(and (prime-list x)(prime-list y) ) )",
     "(equal (equal z (times w z) )(and (numberp z)(or (equal z (zero) )(equal w 1) ) ) )",
     "(equal (greatereqpr x y)(not (lessp x y) ) )",
     "(equal (equal x (times x y) )(or (equal x (zero) )(and (numberp x)(equal y 1) ) ) )",
     "(equal (remainder (times y x)y)(zero) )",
     "(equal (equal (times a b)1)(and (not (equal a (zero) ) )(not (equal b (zero) ) )(numberp a)(numberp b)(equal (1- a)(zero) )(equal (1- b)(zero) ) ) )",
     "(equal (lessp (length (delete x l) )(length l) )(member x l) )",
     "(equal (sort2 (delete x l) )(delete x (sort2 l) ) )",
     "(equal (dsort x)(sort2 x) )",
     "(equal (length(cons x1(cons x2(cons x3(cons x4(cons x5(cons x6 x7) ) ) ) ) ) )(plus 6 (length x7) ) )",
     "(equal (difference (add1 (add1 x) )2)(fix x) )",
     "(equal (quotient (plus x (plus x y) )2)(plus x (quotient y 2) ) )",
     "(equal (sigma (zero)i)(quotient (times i (add1 i) )2) )",
     "(equal (plus x (add1 y) )(if (numberp y)(add1 (plus x y) )(add1 x) ) )",
     "(equal (equal (difference x y)(difference z y) )(if (lessp x y)(not (lessp y z) )(if (lessp z y)(not (lessp y x) )(equal (fix x)(fix z) ) ) ) )",
     "(equal (meaning (plus-tree (delete x y) )a)(if (member x y)(difference (meaning (plus-tree y)a)(meaning x a) )(meaning (plus-tree y)a) ) )",
     "(equal (times x (add1 y) )(if (numberp y)(plus x (times x y) )(fix x) ) )",
     "(equal (nth (nil)i)(if (zerop i)(nil)(zero) ) )",
     "(equal (last (append a b) )(if (listp b)(last b)(if (listp a)(cons (car (last a) )b)b) ) )",
     "(equal (equal (lessp x y)z)(if (lessp x y)(equal t z)(equal f z) ) )",
     "(equal (assignment x (append a b) )(if (assignedp x a)(assignment x a)(assignment x b) ) )",
     "(equal (car (gopher x) )(if (listp x)(car (flatten x) )(zero) ) )",
     "(equal (flatten (cdr (gopher x) ) )(if (listp x)(cdr (flatten x) )(cons (zero)(nil) ) ) )",
     "(equal (quotient (times y x)y)(if (zerop y)(zero)(fix x) ) )",
     "(equal (get j (set i val mem) )(if (eqp j i)val(get j mem) ) )"]

==================== Renamer ====================
Main.main
  = do { [_1_axb, _2_axc, (!_3_axd)] <- getArgs;
         let astart_axe = read _1_axb
             (!astep_axf) = read _2_axc
             (!alim_axg) = read _3_axd;
         Main.runalltests
           astart_axe astep_axf alim_axg astart_axe astep_axf alim_axg }
Main.runalltests ::
  Integer
  -> Integer -> Integer -> Integer -> Integer -> Integer -> IO ()
Main.runalltests
  astart_ayf
  astep_ayg
  (!alim_ayh)
  bstart_ayi
  bstep_ayj
  (!blim_ayk)
  = do { Main.runbench
           (+)
           (+)
           "(+)"
           astart_ayf
           astep_ayg
           alim_ayh
           astart_ayf
           astep_ayg
           alim_ayh;
         Main.runbench
           (-)
           (-)
           "(-)"
           astart_ayf
           astep_ayg
           alim_ayh
           astart_ayf
           astep_ayg
           alim_ayh;
         Main.runbench
           (*)
           (*)
           "(*)"
           astart_ayf
           astep_ayg
           alim_ayh
           astart_ayf
           astep_ayg
           alim_ayh;
         Main.runbench
           div
           div
           "div"
           astart_ayf
           astep_ayg
           alim_ayh
           astart_ayf
           astep_ayg
           alim_ayh;
         Main.runbench
           mod
           mod
           "mod"
           astart_ayf
           astep_ayg
           alim_ayh
           astart_ayf
           astep_ayg
           alim_ayh;
         Main.runbench
           quot
           quot
           "quot"
           astart_ayf
           astep_ayg
           alim_ayh
           astart_ayf
           astep_ayg
           alim_ayh;
         Main.runbench
           rem
           rem
           "rem"
           astart_ayf
           astep_ayg
           alim_ayh
           astart_ayf
           astep_ayg
           alim_ayh;
         Main.runbench
           gcd
           gcd
           "gcd"
           astart_ayf
           astep_ayg
           alim_ayh
           astart_ayf
           astep_ayg
           alim_ayh;
         Main.runbench
           lcm
           lcm
           "lcm"
           astart_ayf
           astep_ayg
           alim_ayh
           astart_ayf
           astep_ayg
           alim_ayh;
         Main.runbench
           (==)
           (==)
           "(==)"
           astart_ayf
           astep_ayg
           alim_ayh
           astart_ayf
           astep_ayg
           alim_ayh;
         Main.runbench
           (<)
           (<)
           "(<)"
           astart_ayf
           astep_ayg
           alim_ayh
           astart_ayf
           astep_ayg
           alim_ayh;
         Main.runbench
           (<=)
           (<=)
           "(<=)"
           astart_ayf
           astep_ayg
           alim_ayh
           astart_ayf
           astep_ayg
           alim_ayh;
         Main.runbench
           (>)
           (>)
           "(>)"
           astart_ayf
           astep_ayg
           alim_ayh
           astart_ayf
           astep_ayg
           alim_ayh;
         Main.runbench
           (>=)
           (>=)
           "(>=)"
           astart_ayf
           astep_ayg
           alim_ayh
           astart_ayf
           astep_ayg
           alim_ayh }
Main.runbench ::
  (Integer -> Integer -> a_ax9)
  -> (Int -> Int -> b_axa)
     -> String
        -> Integer
           -> Integer -> Integer -> Integer -> Integer -> Integer -> IO ()
Main.runbench
  jop_aVH
  iop_aVI
  opstr_aVJ
  (!astart_aVK)
  astep_aVL
  (!alim_aVM)
  bstart_aVN
  (!bstep_aVO)
  (!blim_aVP)
  = do { Main.intbench
           iop_aVI
           astart_aVK
           astep_aVL
           alim_aVM
           astart_aVK
           astep_aVL
           alim_aVM;
         Main.integerbench
           jop_aVH
           astart_aVK
           astep_aVL
           alim_aVM
           astart_aVK
           astep_aVL
           alim_aVM }
Main.integerbench ::
  (Integer -> Integer -> a_ax8)
  -> Integer
     -> Integer -> Integer -> Integer -> Integer -> Integer -> IO ()
Main.integerbench
  op_aVQ
  (!astart_aVR)
  (!astep_aVS)
  alim_aVT
  bstart_aVU
  (!bstep_aVV)
  blim_aVW
  = do { Main.seqlist
           ([a_aVX `op_aVQ` b_aVY |
               a_aVX <- [astart_aVR, astart_aVR + astep_aVS .. alim_aVT],
               (!b_aVY) <- [bstart_aVU, astart_aVR + bstep_aVV .. blim_aVW]]);
         return () }
Main.intbench ::
  (Int -> Int -> a_aos)
  -> Integer
     -> Integer -> Integer -> Integer -> Integer -> Integer -> IO ()
Main.intbench
  (!op_aVZ)
  astart_aW0
  (!astep_aW1)
  alim_aW2
  (!bstart_aW3)
  bstep_aW4
  blim_aW5
  = do { Main.seqlist
           ([a_aW6 `op_aVZ` b_aW7 |
               a_aW6 <- [fromInteger astart_aW0, fromInteger astart_aW0
                                                 + fromInteger astep_aW1 .. fromInteger alim_aW2],
               (!b_aW7) <- [fromInteger bstart_aW3, fromInteger astart_aW0
                                                    + fromInteger bstep_aW4 .. fromInteger
                                                                                 blim_aW5]]);
         return () }
Main.seqlist [] = return ()
Main.seqlist (!((!(x_aW8 : xs_aW9))))
  = x_aW8 `seq` Main.seqlist xs_aW9



==================== Renamer ====================
Main.main
  = putStr
    $ shows (filter condition_an1 $ Main.permutations p0_an0) "\n"
  where
      (!p0_an0) = [0 .. 9] :: [Int]
      condition_an1
        (![t_an2,
           (!h_an3),
           (!i_an4),
           r_an5,
           (!y_an6),
           (!w_an7),
           e_an8,
           l_an9,
           (!v_ana),
           n_anb])
        = Main.expand t_an2 h_an3 i_an4 r_an5 t_an2 y_an6
          + 5 * Main.expand t_an2 w_an7 e_an8 l_an9 v_ana e_an8
          == Main.expand n_anb i_an4 n_anb e_an8 t_an2 y_an6
Main.expand (!a_aRh) (!b_aRi) c_aRj d_aRk e_aRl (!f_aRm)
  = f_aRm + e_aRl * 10 + d_aRk * 100 + c_aRj * 1000 + b_aRi * 10000
    + a_aRh * 100000 ::
      Int
Main.permutations :: [Int] -> [[Int]]
Main.permutations [] = [[]]
Main.permutations ((!((!j_aRn) : (!js_aRo))))
  = [r_aRu |
       pjs_aRt <- Main.permutations js_aRo, r_aRu <- addj_aRp pjs_aRt]
  where
      addj_aRp [] = [[j_aRn]]
      addj_aRp (!((!((!k_aRq) : (!ks_aRr)))))
        = (j_aRn : k_aRq : ks_aRr)
          : [(k_aRq : aks_aRs) | (!aks_aRs) <- addj_aRp ks_aRr]


["main","p0_an0","lazydmd@!p0_an0","(!p0_an0)","t_an2","h_an3","safebang@!h_an3","(!h_an3)","i_an4","safebang@!i_an4","(!i_an4)","r_an5","y_an6","safebang@!y_an6","(!y_an6)","w_an7","safebang@!w_an7","(!w_an7)","e_an8","l_an9","v_ana","safebang@!v_ana","(!v_ana)","n_anb","[t_an2, (!h_an3), (!i_an4), r_an5, (!y_an6), (!w_an7), e_an8,\n l_an9, (!v_ana), n_anb]","![t_an2, (!h_an3), (!i_an4), r_an5, (!y_an6), (!w_an7), e_an8,\n  l_an9, (!v_ana), n_anb]","(![t_an2, (!h_an3), (!i_an4), r_an5, (!y_an6), (!w_an7), e_an8,\n   l_an9, (!v_ana), n_anb])","a_aRh","!a_aRh","(!a_aRh)","b_aRi","!b_aRi","(!b_aRi)","c_aRj","d_aRk","e_aRl","f_aRm","!f_aRm","(!f_aRm)","[]","j_aRn","safebang@!j_aRn","(!j_aRn)","js_aRo","safebang@!js_aRo","(!js_aRo)","(!j_aRn) : (!js_aRo)","((!j_aRn) : (!js_aRo))","!((!j_aRn) : (!js_aRo))","(!((!j_aRn) : (!js_aRo)))","((!((!j_aRn) : (!js_aRo))))","pjs_aRt","r_aRu","[]","k_aRq","!k_aRq","(!k_aRq)","ks_aRr","!ks_aRr","(!ks_aRr)","(!k_aRq) : (!ks_aRr)","((!k_aRq) : (!ks_aRr))","!((!k_aRq) : (!ks_aRr))","(!((!k_aRq) : (!ks_aRr)))","((!((!k_aRq) : (!ks_aRr))))","!((!((!k_aRq) : (!ks_aRr))))","(!((!((!k_aRq) : (!ks_aRr)))))","aks_aRs","!aks_aRs","(!aks_aRs)"]
module Main (main) where
main
  = putStr $ shows (filter condition_an1 $ permutations p0_an0) "\n"
  where (lazydmd@p0_an0) = [0 .. 9] :: [Int]
        condition_an1
          (norecord@[t_an2, (!h_an3), (!i_an4), r_an5, (!y_an6), (!w_an7),
                     e_an8, l_an9, (!v_ana), n_anb])
          = expand t_an2 h_an3 i_an4 r_an5 t_an2 y_an6 + 5 *
              expand t_an2 w_an7 e_an8 l_an9 v_ana e_an8
              == expand n_anb i_an4 n_anb e_an8 t_an2 y_an6
expand (norecord@a_aRh) (norecord@b_aRi) c_aRj d_aRk e_aRl
  (norecord@f_aRm)
  = f_aRm + e_aRl * 10 + d_aRk * 100 + c_aRj * 1000 + b_aRi * 10000 +
      a_aRh
      * 100000
      :: Int

permutations :: [Int] -> [[Int]]
permutations [] = [[]]
permutations ((norecord@((!j_aRn) : (!js_aRo))))
  = [r_aRu | pjs_aRt <- permutations js_aRo,
     r_aRu <- addj_aRp pjs_aRt]
  where addj_aRp [] = [[j_aRn]]
        addj_aRp
          (norecord@((norecord@((norecord@k_aRq) : (norecord@ks_aRr)))))
          = (j_aRn : k_aRq : ks_aRr) :
              [(k_aRq : aks_aRs) | (norecord@aks_aRs) <- addj_aRp ks_aRr]

==================== Renamer ====================
Sort.quickSort :: Ord a_aBL => [a_aBL] -> [a_aBL]
Sort.quickSort2 :: Ord a_aBK => [a_aBK] -> [a_aBK]
Sort.quickerSort :: Ord a_aBJ => [a_aBJ] -> [a_aBJ]
Sort.insertSort :: Ord a_aBI => [a_aBI] -> [a_aBI]
Sort.treeSort :: Ord a_aBH => [a_aBH] -> [a_aBH]
Sort.treeSort2 :: Ord a_aBG => [a_aBG] -> [a_aBG]
Sort.heapSort :: Ord a_aBF => [a_aBF] -> [a_aBF]
Sort.mergeSort :: Ord a_aoc => [a_aoc] -> [a_aoc]
Sort.quickSort (![]) = []
Sort.quickSort ((!(x_aBM : (!xs_aBN))))
  = (Sort.quickSort lo_aBV) ++ (x_aBM : Sort.quickSort hi_aBW)
  where
      lo_aBV = [y_aBX | (!y_aBX) <- xs_aBN, y_aBX <= x_aBM]
      (!hi_aBW) = [y_aBY | y_aBY <- xs_aBN, y_aBY > x_aBM]
Sort.quickSort2 (![]) = []
Sort.quickSort2 (x_aBZ : xs_aC0)
  = (Sort.quickSort2 lo_aC1) ++ (x_aBZ : Sort.quickSort2 hi_aC2)
  where
      (lo_aC1, hi_aC2) = partition ((>=) x_aBZ) xs_aC0
Sort.quickerSort [] = []
Sort.quickerSort (![x_aEB]) = [x_aEB]
Sort.quickerSort (!((!((!x_aEC) : (!xs_aED)))))
  = split_aEE x_aEC [] [] xs_aED
  where
      split_aEE x_aEF lo_aEG hi_aEH (![])
        = Sort.quickerSort lo_aEG ++ (x_aEF : Sort.quickerSort hi_aEH)
      split_aEE x_aEI (!lo_aEJ) hi_aEK (!((!y_aEL) : ys_aEM))
        | y_aEL <= x_aEI = split_aEE x_aEI (y_aEL : lo_aEJ) hi_aEK ys_aEM
        | True = split_aEE x_aEI lo_aEJ (y_aEL : hi_aEK) ys_aEM
Sort.insertSort [] = []
Sort.insertSort ((!x_aEN) : xs_aEO)
  = trins_aEP [] [x_aEN] xs_aEO
  where
      trins_aEP :: Ord a_aEQ => [a_aEQ] -> [a_aEQ] -> [a_aEQ] -> [a_aEQ]
      trins_aEP rev_aER [] (!(y_aES : ys_aET))
        = trins_aEP [] ((reverse rev_aER) ++ [y_aES]) ys_aET
      trins_aEP (!rev_aI8) (!xs_aI9) [] = (reverse rev_aI8) ++ xs_aI9
      trins_aEP rev_aIa (x_aIb : xs_aIc) ((!y_aId) : (!ys_aIe))
        | x_aIb < y_aId
        = trins_aEP (x_aIb : rev_aIa) xs_aIc (y_aId : ys_aIe)
        | True
        = trins_aEP [] (reverse rev_aIa ++ (y_aId : x_aIb : xs_aIc)) ys_aIe
Sort.treeSort
  = readTree_aIg . mkTree_aIf
  where
      mkTree_aIf :: Ord a_aIh => [a_aIh] -> Sort.Tree a_aIh
      (!mkTree_aIf)
        = foldr to_tree_aIj Sort.Tip
        where
            to_tree_aIj ::
              Ord a_aIk => a_aIk -> Sort.Tree a_aIk -> Sort.Tree a_aIk
            to_tree_aIj (!x_aIl) Sort.Tip = Sort.Branch x_aIl Sort.Tip Sort.Tip
            to_tree_aIj (!x_aIm) (!((!(Sort.Branch y_aIn (!l_aIo) r_aIp))))
              | x_aIm <= y_aIn
              = Sort.Branch y_aIn (to_tree_aIj x_aIm l_aIo) r_aIp
              | True = Sort.Branch y_aIn l_aIo (to_tree_aIj x_aIm r_aIp)
      readTree_aIg :: Ord a_aIi => Sort.Tree a_aIi -> [a_aIi]
      readTree_aIg Sort.Tip = []
      readTree_aIg (!(Sort.Branch x_aOi l_aOj r_aOk))
        = readTree_aIg l_aOj ++ (x_aOi : readTree_aIg r_aOk)
Sort.treeSort2
  = readTree_aOm . mkTree_aOl
  where
      mkTree_aOl :: Ord a_aOn => [a_aOn] -> Sort.Tree2 a_aOn
      mkTree_aOl
        = foldr to_tree_aOp Sort.Tip2
        where
            to_tree_aOp ::
              Ord a_aOq => a_aOq -> Sort.Tree2 a_aOq -> Sort.Tree2 a_aOq
            to_tree_aOp x_aOr Sort.Tip2 = Sort.Twig2 x_aOr
            to_tree_aOp (!x_aOs) ((!(Sort.Twig2 y_aOt)))
              | x_aOs <= y_aOt = Sort.Branch2 y_aOt (Sort.Twig2 x_aOs) Sort.Tip2
              | True = Sort.Branch2 y_aOt Sort.Tip2 (Sort.Twig2 x_aOs)
            to_tree_aOp (!x_aOu) (Sort.Branch2 y_aOv (!l_aOw) r_aOx)
              | x_aOu <= y_aOv
              = Sort.Branch2 y_aOv (to_tree_aOp x_aOu l_aOw) r_aOx
              | True = Sort.Branch2 y_aOv l_aOw (to_tree_aOp x_aOu r_aOx)
      readTree_aOm :: Ord a_aOo => Sort.Tree2 a_aOo -> [a_aOo]
      readTree_aOm Sort.Tip2 = []
      readTree_aOm (Sort.Twig2 (!x_aOy)) = [x_aOy]
      readTree_aOm (!(Sort.Branch2 (!x_aOz) (!l_aOA) r_aOB))
        = readTree_aOm l_aOA ++ (x_aOz : readTree_aOm r_aOB)
Sort.heapSort xs_aOC
  = clear_aOF (heap_aOD (0 :: Int) xs_aOC)
  where
      heap_aOD :: Ord a_aOI => Int -> [a_aOI] -> Sort.Tree a_aOI
      heap_aOD k_aOM [] = Sort.Tip
      heap_aOD k_aON (!((!x_aOO) : (!xs_aOP)))
        = to_heap_aOE k_aON x_aOO (heap_aOD (k_aON + (1 :: Int)) xs_aOP)
      to_heap_aOE ::
        Ord a_aOJ => Int -> a_aOJ -> Sort.Tree a_aOJ -> Sort.Tree a_aOJ
      to_heap_aOE k_aPO x_aPP (!Sort.Tip)
        = Sort.Branch x_aPP Sort.Tip Sort.Tip
      to_heap_aOE
        k_aPQ
        (!x_aPR)
        (!((!(Sort.Branch (!y_aPS) (!l_aPT) r_aPU))))
        | x_aPR <= y_aPS && odd k_aPQ
        = Sort.Branch
            x_aPR (to_heap_aOE (div2_aOH k_aPQ) y_aPS l_aPT) r_aPU
        | x_aPR <= y_aPS
        = Sort.Branch
            x_aPR l_aPT (to_heap_aOE (div2_aOH k_aPQ) y_aPS r_aPU)
        | odd k_aPQ
        = Sort.Branch
            y_aPS (to_heap_aOE (div2_aOH k_aPQ) x_aPR l_aPT) r_aPU
        | True
        = Sort.Branch
            y_aPS l_aPT (to_heap_aOE (div2_aOH k_aPQ) x_aPR r_aPU)
      clear_aOF :: Ord a_aOK => Sort.Tree a_aOK -> [a_aOK]
      clear_aOF Sort.Tip = []
      clear_aOF (Sort.Branch (!x_aZ1) (!l_aZ2) (!r_aZ3))
        = x_aZ1 : clear_aOF (mix_aOG l_aZ2 r_aZ3)
      mix_aOG ::
        Ord a_aOL => Sort.Tree a_aOL -> Sort.Tree a_aOL -> Sort.Tree a_aOL
      mix_aOG (!Sort.Tip) r_aZ4 = r_aZ4
      mix_aOG (!l_aZ5) (!Sort.Tip) = l_aZ5
      mix_aOG
        t1_aZ6@(!(Sort.Branch (!x_aZ7) l1_aZ8 (!r1_aZ9)))
        t2_aZa@(!((!(Sort.Branch (!y_aZb) (!l2_aZc) r2_aZd))))
        | x_aZ7 <= y_aZb = Sort.Branch x_aZ7 (mix_aOG l1_aZ8 r1_aZ9) t2_aZa
        | True = Sort.Branch y_aZb t1_aZ6 (mix_aOG l2_aZc r2_aZd)
      div2_aOH :: Int -> Int
      div2_aOH (!k_aZe) = k_aZe `div` 2
Sort.mergeSort
  = merge_lists_aZg . (runsplit_aZf [])
  where
      runsplit_aZf :: Ord a_aZi => [a_aZi] -> [a_aZi] -> [[a_aZi]]
      runsplit_aZf (![]) [] = []
      runsplit_aZf (!run_aZl) [] = [run_aZl]
      runsplit_aZf [] (!((!((!x_aZm) : (!xs_aZn)))))
        = runsplit_aZf [x_aZm] xs_aZn
      runsplit_aZf (![(!r_aZo)]) (!((!((!x_aZp) : (!xs_aZq)))))
        | x_aZp > r_aZo = runsplit_aZf [r_aZo, x_aZp] xs_aZq
      runsplit_aZf
        (!rl_aZr@(!((!(r_aZs : rs_aZt)))))
        (!((!x_aZu) : (!xs_aZv)))
        | x_aZu <= r_aZs = runsplit_aZf (x_aZu : rl_aZr) xs_aZv
        | True = rl_aZr : (runsplit_aZf [x_aZu] xs_aZv)
      merge_lists_aZg :: Ord a_aZj => [[a_aZj]] -> [a_aZj]
      merge_lists_aZg [] = []
      merge_lists_aZg (!((!(x_aZw : (!xs_aZx)))))
        = merge_aZh x_aZw (merge_lists_aZg xs_aZx)
      merge_aZh :: Ord a_aZk => [a_aZk] -> [a_aZk] -> [a_aZk]
      merge_aZh (![]) (!ys_aZy) = ys_aZy
      merge_aZh (!xs_aZz) [] = xs_aZz
      merge_aZh (!xl_aZA@(x_aZB : xs_aZC)) (!yl_aZD@((!y_aZE) : ys_aZF))
        | x_aZB == y_aZE = x_aZB : y_aZE : (merge_aZh xs_aZC ys_aZF)
        | x_aZB < y_aZE = x_aZB : (merge_aZh xs_aZC yl_aZD)
        | True = y_aZE : (merge_aZh xl_aZA ys_aZF)

data Sort.Tree a_aob
  = Sort.Tip | Sort.Branch a_aob (Sort.Tree a_aob) (Sort.Tree a_aob)
data Sort.Tree2 a_aoa
  = Sort.Tip2 |
    Sort.Twig2 a_aoa |
    Sort.Branch2 a_aoa (Sort.Tree2 a_aoa) (Sort.Tree2 a_aoa)



==================== Renamer ====================
Match.subst (!env_ap5) (!(Term x_ap6 ps_ap7))
  = Term x_ap6 [Match.subst env_ap5 p_ap8 | p_ap8 <- ps_ap7]
Match.subst (!env_ap9) (!((!(Var x_apa))))
  = if fails lookup_apb then
        (Var x_apa)
    else
        Match.subst env_ap9 (answer lookup_apb)
  where
      lookup_apb = find env_ap9 x_apa
Match.match env_apc p1_apd p2_ape
  = Match.compear
      env_apc (Match.subst env_apc p1_apd) (Match.subst env_apc p2_ape)
Match.matchList (!env_apf) [] = success env_apf
Match.matchList env_apg (!((p1_aph, p2_api) : pairs_apj))
  = if fails res_apr then
        res_apr
    else
        Match.matchList (answer res_apr) pairs_apj
  where
      res_apr = Match.match env_apg p1_aph p2_api
Match.compear
  (!env_aps)
  (!((!(Term x1_apt (!ps1_apu)))))
  (Term x2_apv (!ps2_apw))
  | x1_apt == x2_apv = Match.matchList env_aps (zip ps1_apu ps2_apw)
  | otherwise = failure "no match"
Match.compear env_aGu (Var x_aGv) (!((!(Var (!y_aGw)))))
  | x_aGv /= y_aGw = success (update env_aGu x_aGv (Var y_aGw))
  | otherwise = success env_aGu
Match.compear (!env_aGx) (!((!(Var (!x_aGy))))) p_aGz
  | not (Match.occurs (Var x_aGy) p_aGz)
  = success (update env_aGx x_aGy p_aGz)
  | otherwise = failure "occurs check failed"
Match.compear env_aGA (!p_aGB) ((!(Var x_aGC)))
  = Match.compear env_aGA (Var x_aGC) p_aGB
Match.occurs (!v_aGD) (!((!(Term (!x_aGE) (!ps_aGF)))))
  = or [Match.occurs v_aGD p_aMB | p_aMB <- ps_aGF]
Match.occurs ((!(Var (!y_aMC)))) (Var x_aMD) = y_aMC == x_aMD
Match.occurs (!p_aME) ((!(Var (!x_aMF)))) = False

type Match.Environment = Table String Phrase


["env_ap5","safebang@!env_ap5","(!env_ap5)","x_ap6","ps_ap7","Term x_ap6 ps_ap7","(Term x_ap6 ps_ap7)","!(Term x_ap6 ps_ap7)","(!(Term x_ap6 ps_ap7))","p_ap8","env_ap9","!env_ap9","(!env_ap9)","x_apa","Var x_apa","(Var x_apa)","!(Var x_apa)","(!(Var x_apa))","((!(Var x_apa)))","!((!(Var x_apa)))","(!((!(Var x_apa))))","lookup_apb","env_apc","p1_apd","p2_ape","env_apf","safebang@!env_apf","(!env_apf)","[]","env_apg","p1_aph","p2_api","(p1_aph, p2_api)","pairs_apj","(p1_aph, p2_api) : pairs_apj","((p1_aph, p2_api) : pairs_apj)","!((p1_aph, p2_api) : pairs_apj)","(!((p1_aph, p2_api) : pairs_apj))","res_apr","env_aps","safebang@!env_aps","(!env_aps)","x1_apt","ps1_apu","safebang@!ps1_apu","(!ps1_apu)","Term x1_apt (!ps1_apu)","(Term x1_apt (!ps1_apu))","!(Term x1_apt (!ps1_apu))","(!(Term x1_apt (!ps1_apu)))","((!(Term x1_apt (!ps1_apu))))","!((!(Term x1_apt (!ps1_apu))))","(!((!(Term x1_apt (!ps1_apu)))))","x2_apv","ps2_apw","safebang@!ps2_apw","(!ps2_apw)","Term x2_apv (!ps2_apw)","(Term x2_apv (!ps2_apw))","env_aGu","x_aGv","Var x_aGv","(Var x_aGv)","y_aGw","safebang@!y_aGw","(!y_aGw)","Var (!y_aGw)","(Var (!y_aGw))","!(Var (!y_aGw))","(!(Var (!y_aGw)))","((!(Var (!y_aGw))))","!((!(Var (!y_aGw))))","(!((!(Var (!y_aGw)))))","env_aGx","!env_aGx","(!env_aGx)","x_aGy","safebang@!x_aGy","(!x_aGy)","Var (!x_aGy)","(Var (!x_aGy))","!(Var (!x_aGy))","(!(Var (!x_aGy)))","((!(Var (!x_aGy))))","!((!(Var (!x_aGy))))","(!((!(Var (!x_aGy)))))","p_aGz","env_aGA","p_aGB","!p_aGB","(!p_aGB)","x_aGC","Var x_aGC","(Var x_aGC)","!(Var x_aGC)","(!(Var x_aGC))","((!(Var x_aGC)))","v_aGD","safebang@!v_aGD","(!v_aGD)","x_aGE","safebang@!x_aGE","(!x_aGE)","ps_aGF","safebang@!ps_aGF","(!ps_aGF)","Term (!x_aGE) (!ps_aGF)","(Term (!x_aGE) (!ps_aGF))","!(Term (!x_aGE) (!ps_aGF))","(!(Term (!x_aGE) (!ps_aGF)))","((!(Term (!x_aGE) (!ps_aGF))))","!((!(Term (!x_aGE) (!ps_aGF))))","(!((!(Term (!x_aGE) (!ps_aGF)))))","p_aMB","y_aMC","safebang@!y_aMC","(!y_aMC)","Var (!y_aMC)","(Var (!y_aMC))","!(Var (!y_aMC))","(!(Var (!y_aMC)))","((!(Var (!y_aMC))))","x_aMD","Var x_aMD","(Var x_aMD)","p_aME","!p_aME","(!p_aME)","x_aMF","!x_aMF","(!x_aMF)","Var (!x_aMF)","(Var (!x_aMF))","!(Var (!x_aMF))","(!(Var (!x_aMF)))","((!(Var (!x_aMF))))"]
module Match where
import Result
import Table
import Knowledge
subst (!env_ap5) (norecord@(Term x_ap6 ps_ap7))
  = Term x_ap6 [subst env_ap5 p_ap8 | p_ap8 <- ps_ap7]
subst (norecord@env_ap9) (norecord@((norecord@(Var x_apa))))
  = if fails lookup_apb then (Var x_apa) else
      subst env_ap9 (answer lookup_apb)
  where lookup_apb = find env_ap9 x_apa
match env_apc p1_apd p2_ape
  = compear env_apc (subst env_apc p1_apd) (subst env_apc p2_ape)
matchList (!env_apf) [] = success env_apf
matchList env_apg (norecord@((p1_aph, p2_api) : pairs_apj))
  = if fails res_apr then res_apr else
      matchList (answer res_apr) pairs_apj
  where res_apr = match env_apg p1_aph p2_api
compear (!env_aps) (norecord@((norecord@(Term x1_apt (!ps1_apu)))))
  (Term x2_apv (!ps2_apw))
  | x1_apt == x2_apv = matchList env_aps (zip ps1_apu ps2_apw)
  | otherwise = failure "no match"
compear env_aGu (Var x_aGv) (norecord@((norecord@(Var (!y_aGw)))))
  | x_aGv /= y_aGw = success (update env_aGu x_aGv (Var y_aGw))
  | otherwise = success env_aGu
compear (norecord@env_aGx) (norecord@((norecord@(Var (!x_aGy)))))
  p_aGz
  | not (occurs (Var x_aGy) p_aGz) =
    success (update env_aGx x_aGy p_aGz)
  | otherwise = failure "occurs check failed"
compear env_aGA (norecord@p_aGB) ((norecord@(Var x_aGC)))
  = compear env_aGA (Var x_aGC) p_aGB
occurs (!v_aGD) (norecord@((norecord@(Term (!x_aGE) (!ps_aGF)))))
  = or [occurs v_aGD p_aMB | p_aMB <- ps_aGF]
occurs ((norecord@(Var (!y_aMC)))) (Var x_aMD) = y_aMC == x_aMD
occurs (norecord@p_aME) ((norecord@(Var (norecord@x_aMF)))) = False

type Environment = Table String Phrase

==================== Renamer ====================
Knowledge.vars (!p_ap9)
  = nub (names_apa p_ap9)
  where
      names_apa (Knowledge.Var x_apb) = [x_apb]
      names_apa ((!(Knowledge.Term (!x_apc) ps_apd)))
        = concat [names_apa p_avh | (!p_avh) <- ps_apd]
Knowledge.showPhrase (Knowledge.Var (!x_axG)) = x_axG
Knowledge.showPhrase ((!(Knowledge.Term x_axH []))) = x_axH
Knowledge.showPhrase (Knowledge.Term op_axI [p1_axJ, p2_axK])
  = Knowledge.showPhrase p1_axJ
    ++ " " ++ op_axI ++ " " ++ Knowledge.showPhrase p2_axK
Knowledge.rule (!ws_axL)
  = Knowledge.split ws_axL Knowledge.relation "if" Knowledge.goal
Knowledge.goal ws_axM
  | elem "or" ws_axM
  = Knowledge.split ws_axM Knowledge.goal "or" Knowledge.goal
  | elem "and" ws_axM
  = Knowledge.split ws_axM Knowledge.goal "and" Knowledge.goal
  | otherwise = Knowledge.relation ws_axM
Knowledge.relation (!ws_axN)
  = Knowledge.split ws_axN Knowledge.noun verb_axO Knowledge.noun
  where
      verb_axO = head [w_aB4 | (!w_aB4) <- ws_axN, elem w_aB4 verbs_axP]
      (!verbs_axP) = ["is", "describes", "has", "can", "eats"]
Knowledge.noun (![(!a_aB5), x_aB6])
  | elem a_aB5 ["a", "an", "the"]
  = Knowledge.noun [a_aB5 ++ " " ++ x_aB6]
Knowledge.noun [x_aB7]
  | ('A' <= head x_aB7) && (head x_aB7 <= 'Z') = Knowledge.Var x_aB7
Knowledge.noun [x_aOz] = Knowledge.Term x_aOz []
Knowledge.split ws_aOA f_aOB (!op_aOC) (!g_aOD)
  = Knowledge.Term op_aOC [f_aOB lhs_aOE, g_aOD rhs_aOF]
  where
      (!lhs_aOE) = takeWhile (/= op_aOC) ws_aOA
      (!rhs_aOF) = tail (dropWhile (/= op_aOC) ws_aOA)
Knowledge.definitions (!ls_aOG)
  = updateList
      newTable [(v_aOS, def_aOH v_aOS) | (!v_aOS) <- verbs_aOI]
  where
      def_aOH (!v_aOL)
        = [r_aOM | r_aOM <- rs_aOK, verb_aOJ r_aOM == v_aOL]
      verbs_aOI = nub [verb_aOJ r_aON | (!r_aON) <- rs_aOK]
      verb_aOJ
        (!((!(Knowledge.Term "if"
                             (![(!(Knowledge.Term (!v_aOO) ns_aOP)), (!g_aOQ)])))))
        = v_aOO
      rs_aOK = [Knowledge.rule (words l_aOR) | (!l_aOR) <- ls_aOG]
Knowledge.relevant (!defs_aOT) (Knowledge.Term v_aOU ns_aOV)
  = if fails lookup_aOW then [] else answer lookup_aOW
  where
      (!lookup_aOW) = find defs_aOT v_aOU

data Knowledge.Phrase
  = Knowledge.Term String [Knowledge.Phrase] | Knowledge.Var String


["p_ap9","safebang@!p_ap9","(!p_ap9)","x_apb","Var x_apb","(Var x_apb)","x_apc","safebang@!x_apc","(!x_apc)","ps_apd","Term (!x_apc) ps_apd","(Term (!x_apc) ps_apd)","!(Term (!x_apc) ps_apd)","(!(Term (!x_apc) ps_apd))","((!(Term (!x_apc) ps_apd)))","p_avh","!p_avh","(!p_avh)","x_axG","safebang@!x_axG","(!x_axG)","Var (!x_axG)","(Var (!x_axG))","x_axH","[]","Term x_axH []","(Term x_axH [])","!(Term x_axH [])","(!(Term x_axH []))","((!(Term x_axH [])))","op_axI","p1_axJ","p2_axK","[p1_axJ, p2_axK]","Term op_axI [p1_axJ, p2_axK]","(Term op_axI [p1_axJ, p2_axK])","ws_axL","safebang@!ws_axL","(!ws_axL)","ws_axM","ws_axN","safebang@!ws_axN","(!ws_axN)","verb_axO","w_aB4","!w_aB4","(!w_aB4)","verbs_axP","!verbs_axP","(!verbs_axP)","a_aB5","safebang@!a_aB5","(!a_aB5)","x_aB6","[(!a_aB5), x_aB6]","![(!a_aB5), x_aB6]","(![(!a_aB5), x_aB6])","x_aB7","[x_aB7]","x_aOz","[x_aOz]","ws_aOA","f_aOB","op_aOC","safebang@!op_aOC","(!op_aOC)","g_aOD","safebang@!g_aOD","(!g_aOD)","lhs_aOE","!lhs_aOE","(!lhs_aOE)","rhs_aOF","!rhs_aOF","(!rhs_aOF)","ls_aOG","safebang@!ls_aOG","(!ls_aOG)","v_aOS","!v_aOS","(!v_aOS)","v_aOL","!v_aOL","(!v_aOL)","r_aOM","verbs_aOI","r_aON","!r_aON","(!r_aON)","\"if\"","v_aOO","safebang@!v_aOO","(!v_aOO)","ns_aOP","Term (!v_aOO) ns_aOP","(Term (!v_aOO) ns_aOP)","!(Term (!v_aOO) ns_aOP)","(!(Term (!v_aOO) ns_aOP))","g_aOQ","safebang@!g_aOQ","(!g_aOQ)","[(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)]","![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)]","(![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)])","Term \"if\" (![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)])","(Term \"if\" (![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)]))","!(Term \"if\" (![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)]))","(!(Term \"if\" (![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)])))","((!(Term \"if\" (![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)]))))","!((!(Term \"if\" (![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)]))))","(!((!(Term \"if\" (![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)])))))","rs_aOK","l_aOR","!l_aOR","(!l_aOR)","defs_aOT","safebang@!defs_aOT","(!defs_aOT)","v_aOU","ns_aOV","Term v_aOU ns_aOV","(Term v_aOU ns_aOV)","lookup_aOW","!lookup_aOW","(!lookup_aOW)"]
module Knowledge where
import Result
import Table
import Data.List (nub)
vars (!p_ap9) = nub (names_apa p_ap9)
  where names_apa (Var x_apb) = [x_apb]
        names_apa ((norecord@(Term (!x_apc) ps_apd)))
          = concat [names_apa p_avh | (norecord@p_avh) <- ps_apd]
showPhrase (Var (!x_axG)) = x_axG
showPhrase ((norecord@(Term x_axH []))) = x_axH
showPhrase (Term op_axI [p1_axJ, p2_axK])
  = showPhrase p1_axJ ++ " " ++ op_axI ++ " " ++ showPhrase p2_axK
rule (!ws_axL) = split ws_axL relation "if" goal
goal ws_axM
  | elem "or" ws_axM = split ws_axM goal "or" goal
  | elem "and" ws_axM = split ws_axM goal "and" goal
  | otherwise = relation ws_axM
relation (!ws_axN) = split ws_axN noun verb_axO noun
  where verb_axO
          = head [w_aB4 | (norecord@w_aB4) <- ws_axN, elem w_aB4 verbs_axP]
        (norecord@verbs_axP) = ["is", "describes", "has", "can", "eats"]
noun (norecord@[(!a_aB5), x_aB6])
  | elem a_aB5 ["a", "an", "the"] = noun [a_aB5 ++ " " ++ x_aB6]
noun [x_aB7]
  | ('A' <= head x_aB7) && (head x_aB7 <= 'Z') = Var x_aB7
noun [x_aOz] = Term x_aOz []
split ws_aOA f_aOB (!op_aOC) (!g_aOD)
  = Term op_aOC [f_aOB lhs_aOE, g_aOD rhs_aOF]
  where (norecord@lhs_aOE) = takeWhile (/= op_aOC) ws_aOA
        (norecord@rhs_aOF) = tail (dropWhile (/= op_aOC) ws_aOA)
definitions (!ls_aOG)
  = updateList newTable
      [(v_aOS, def_aOH v_aOS) | (norecord@v_aOS) <- verbs_aOI]
  where def_aOH (norecord@v_aOL)
          = [r_aOM | r_aOM <- rs_aOK, verb_aOJ r_aOM == v_aOL]
        verbs_aOI = nub [verb_aOJ r_aON | (norecord@r_aON) <- rs_aOK]
        verb_aOJ
          (norecord@((norecord@(Term "if"
                                  (norecord@[(norecord@(Term (!v_aOO) ns_aOP)), (!g_aOQ)])))))
          = v_aOO
        rs_aOK = [rule (words l_aOR) | (norecord@l_aOR) <- ls_aOG]
relevant (!defs_aOT) (Term v_aOU ns_aOV)
  = if fails lookup_aOW then [] else answer lookup_aOW
  where (norecord@lookup_aOW) = find defs_aOT v_aOU

data Phrase = Term String [Phrase]
            | Var String

==================== Renamer ====================
Main.main
  = do { prog_avf <- getProgName;
         args_avg <- getArgs;
         case args_avg of {
           (![filename_avh]) -> Main.getData filename_avh
           [] -> Main.getData "animals"
           (!_) -> hPutStr stderr ("Usage: " ++ prog_avf ++ " datafile\n") } }
Main.getData filename_az5
  = do { (!contents_az6) <- readFile filename_az5;
         interact (Main.process contents_az6) }
Main.process (!contents_az7) input_az8
  = "Solving: "
    ++
      showPhrase problem_az9
      ++ "\n" ++ Main.display results_azf (vars problem_az9) replies_azc
  where
      problem_az9 = goal (words (head (lines contents_az7)))
      defs_aza = definitions (tail (lines contents_az7))
      info_azb
        = enterList
            newTable
            [(q_aFR, a_aFS) |
               (Question (!q_aFR), a_aFS) <- zip results_azf replies_azc]
      replies_azc = [words l_aFT /= ["no"] | l_aFT <- lines input_az8]
      db_azd = (defs_aza, info_azb)
      newsoln_aze
        = Soln newTable ['X' : show n_aTh | (!n_aTh) <- [0 .. ]]
      results_azf = Main.strip [] (solve db_azd newsoln_aze problem_az9)
Main.strip (!qs_a11N) [] = []
Main.strip (!qs_a11O) ((!((!(Question (!q_a11P))) : rs_a11Q)))
  = if elem q_a11P qs_a11O then
        Main.strip qs_a11O rs_a11Q
    else
        Question q_a11P : Main.strip (q_a11P : qs_a11O) rs_a11Q
Main.strip qs_a17M (soln_a17N : rs_a17O)
  = soln_a17N : Main.strip qs_a17M rs_a17O
Main.display (![]) (!xs_a17P) (!as_a17Q) = "No (more) solutions\n"
Main.display
  ((!((!(Question (!q_a17R))) : (!rs_a17S))))
  xs_a17T
  (!as_a17U)
  = "Is it true that "
    ++ q_a17R ++ "?\n" ++ Main.display rs_a17S xs_a17T (tail as_a17U)
Main.display
  (!((!(Soln env_a17V (!vs_a17W) : (!rs_a17X)))))
  (!xs_a17Y)
  (!as_a17Z)
  = "Solution: " ++ sol_a180 ++ ". More?\n" ++ etc_a181
  where
      sol_a180 = Main.showVars env_a17V xs_a17Y
      (!etc_a181)
        = if as_a17Z == [] || head as_a17Z == False then
              ""
          else
              Main.display rs_a17X xs_a17Y (tail as_a17Z)
Main.showVars (!env_a182) vs_a183
  = foldr1 join_a184 (map showVar_a185 vs_a183)
  where
      join_a184 x_a186 y_a187 = x_a186 ++ "; " ++ y_a187
      showVar_a185 v_a188
        = v_a188 ++ " = " ++ showPhrase (subst env_a182 (Var v_a188))



==================== Renamer ====================
Result.success (!a_an2) = Result.Answer a_an2
Result.succeeds (Result.Answer a_an3) = True
Result.succeeds (!_) = False
Result.answer ((!(Result.Answer a_anb))) = a_anb
Result.failure (!r_anc) = Result.Reason r_anc
Result.fails = not . Result.succeeds
Result.reason (Result.Reason r_aAF) = r_aAF
Result.answers ((!(Result.Answer a_aAG))) = [a_aAG]
Result.answers _ = []

data Result.Result a_an0 r_an1
  = Result.Answer a_an0 | Result.Reason r_an1


["a_an2","safebang@!a_an2","(!a_an2)","a_an3","Answer a_an3","(Answer a_an3)","_","!_","(!_)","a_anb","Answer a_anb","(Answer a_anb)","!(Answer a_anb)","(!(Answer a_anb))","((!(Answer a_anb)))","r_anc","safebang@!r_anc","(!r_anc)","fails","r_aAF","Reason r_aAF","(Reason r_aAF)","a_aAG","Answer a_aAG","(Answer a_aAG)","!(Answer a_aAG)","(!(Answer a_aAG))","((!(Answer a_aAG)))","_"]
module Result where
success (!a_an2) = Answer a_an2
succeeds (Answer a_an3) = True
succeeds (norecord@_) = False
answer ((norecord@(Answer a_anb))) = a_anb
failure (!r_anc) = Reason r_anc
fails = not . succeeds
reason (Reason r_aAF) = r_aAF
answers ((norecord@(Answer a_aAG))) = [a_aAG]
answers _ = []

data Result a_an0 r_an1 = Answer a_an0
                        | Reason r_an1

==================== Renamer ====================
Table.newTable = Table.Empty
Table.find Table.Empty key_ant = failure "not found"
Table.find
  (!((!(Table.Fork left_anu (!((!k_anv), v_anw)) right_anx))))
  key_any
  | key_any < k_anv = Table.find left_anu key_any
  | key_any == k_anv = success v_anw
  | key_any > k_anv = Table.find right_anx key_any
Table.enter Table.Empty key_aB1 val_aB2
  = Table.Fork Table.Empty (key_aB1, val_aB2) Table.Empty
Table.enter
  (Table.Fork (!left_aB3) (k_aB4, v_aB5) right_aB6)
  key_aB7
  (!val_aB8)
  | key_aB7 < k_aB4
  = Table.Fork
      (Table.enter left_aB3 key_aB7 val_aB8) (k_aB4, v_aB5) right_aB6
  | key_aB7 == k_aB4 = Table.Fork left_aB3 (k_aB4, v_aB5) right_aB6
  | key_aB7 > k_aB4
  = Table.Fork
      left_aB3 (k_aB4, v_aB5) (Table.enter right_aB6 key_aB7 val_aB8)
Table.update Table.Empty (!key_aB9) val_aBa
  = Table.Fork Table.Empty (key_aB9, val_aBa) Table.Empty
Table.update
  (Table.Fork (!left_aBb) ((!k_aBc), (!v_aBd)) (!right_aBe))
  key_aBf
  val_aBg
  | key_aBf < k_aBc
  = Table.Fork
      (Table.update left_aBb key_aBf val_aBg) (k_aBc, v_aBd) right_aBe
  | key_aBf == k_aBc
  = Table.Fork left_aBb (key_aBf, val_aBg) right_aBe
  | key_aBf > k_aBc
  = Table.Fork
      left_aBb (k_aBc, v_aBd) (Table.update right_aBe key_aBf val_aBg)
Table.delete Table.Empty key_aBh = Table.Empty
Table.delete
  (!((!(Table.Fork (!left_aBi)
                   (!((!k_aBj), (!v_aBk)))
                   (!right_aBl)))))
  key_aBm
  | key_aBm < k_aBj
  = Table.Fork
      (Table.delete left_aBi key_aBm) (k_aBj, v_aBk) right_aBl
  | key_aBm == k_aBj = graft_aBn left_aBi right_aBl
  | key_aBm > k_aBj
  = Table.Fork
      left_aBi (k_aBj, v_aBk) (Table.delete right_aBl key_aBm)
  where
      graft_aBn left_aBp (!Table.Empty) = left_aBp
      graft_aBn left_aBq (!right_aBr)
        = Table.Fork left_aBq e_aBs right'_aBt
        where
            (!(e_aBs, (!right'_aBt))) = leftmost_aBo right_aBr
      leftmost_aBo (!(Table.Fork (!Table.Empty) (!e_aBu) (!r_aBv)))
        = (e_aBu, r_aBv)
      leftmost_aBo (Table.Fork (!l_aBw) e_aBx r_aBy)
        = (e2_aBz, Table.Fork l'_aBA e_aBx r_aBy)
        where
            (!((!e2_aBz), (!l'_aBA))) = leftmost_aBo l_aBw
Table.enterList t_aBB [] = t_aBB
Table.enterList Table.Empty ((!e_aBC) : res_aBD)
  = Table.Fork left_aBM e_aBC right_aBN
  where
      (!k_aBL) = fst e_aBC
      left_aBM
        = Table.enterList
            Table.Empty [e1_aBU | (!e1_aBU) <- res_aBD, fst e1_aBU < k_aBL]
      right_aBN
        = Table.enterList
            Table.Empty [e1_aBV | (!e1_aBV) <- res_aBD, fst e1_aBV > k_aBL]
Table.enterList
  ((!(Table.Fork left_aBW (!e_aBX) (!right_aBY))))
  es_aBZ
  = Table.Fork left'_aC1 e_aBX right'_aC2
  where
      (!k_aC0) = fst e_aBX
      (!left'_aC1)
        = Table.enterList
            left_aBW [e1_aC3 | e1_aC3 <- es_aBZ, fst e1_aC3 < k_aC0]
      right'_aC2
        = Table.enterList
            right_aBY [e1_aC4 | (!e1_aC4) <- es_aBZ, fst e1_aC4 > k_aC0]
Table.updateList t_aC5 es_aC6
  = balance_aC7
      (Table.mergeKey
         (Table.entries t_aC5) (unique_aC8 (Table.sortKey es_aC6)))
  where
      balance_aC7 [] = Table.Empty
      balance_aC7 es_aC9
        = Table.Fork left_aCa (es_aC9 !! m_aCc) right_aCb
        where
            (!left_aCa) = balance_aC7 (take m_aCc es_aC9)
            (!right_aCb) = balance_aC7 (drop (m_aCc + 1) es_aC9)
            m_aCc = length es_aC9 `div` 2
      unique_aC8 [] = []
      unique_aC8 (![e_aVO]) = [e_aVO]
      unique_aC8
        ((!((!(k1_aVP, v1_aVQ)) : ((!(k2_aVR, (!v2_aVS))) : res_aVT))))
        = if k1_aVP == k2_aVR then
              unique_aC8 ((k2_aVR, v2_aVS) : res_aVT)
          else
              (k1_aVP, v1_aVQ) : unique_aC8 ((k2_aVR, v2_aVS) : res_aVT)
Table.sortKey kvs_aVU
  = foldr insertKey_aVV [] kvs_aVU
  where
      insertKey_aVV (!kv_aVW) (![]) = [kv_aVW]
      insertKey_aVV
        ((!k1_aVX), (!v1_aVY))
        ((!((k2_aVZ, v2_aW0) : res_aW1)))
        | k1_aVX <= k2_aVZ = (k1_aVX, v1_aVY) : (k2_aVZ, v2_aW0) : res_aW1
        | otherwise
        = (k2_aVZ, v2_aW0) : insertKey_aVV (k1_aVX, v1_aVY) res_aW1
Table.mergeKey [] (!kvs_aW2) = kvs_aW2
Table.mergeKey kvs_aW3 (![]) = kvs_aW3
Table.mergeKey
  (((!k1_aW4), (!v1_aW5)) : kvs1_aW6)
  (!((!((k2_aW7, (!v2_aW8)) : kvs2_aW9))))
  | k1_aW4 <= k2_aW7
  = (k1_aW4, v1_aW5)
    : Table.mergeKey kvs1_aW6 ((k2_aW7, v2_aW8) : kvs2_aW9)
  | otherwise
  = (k2_aW7, v2_aW8)
    : Table.mergeKey ((k1_aW4, v1_aW5) : kvs1_aW6) kvs2_aW9
Table.entries (!Table.Empty) = []
Table.entries (Table.Fork (!left_aWa) e_aWb (!right_aWc))
  = Table.entries left_aWa ++ [e_aWb] ++ Table.entries right_aWc

data Table.Table k_anr v_ans
  = Table.Empty |
    Table.Fork (Table.Table k_anr v_ans) (k_anr,
                                          v_ans) (Table.Table k_anr v_ans)


["newTable","Empty","key_ant","left_anu","k_anv","safebang@!k_anv","(!k_anv)","v_anw","((!k_anv), v_anw)","!((!k_anv), v_anw)","(!((!k_anv), v_anw))","right_anx","Fork left_anu (!((!k_anv), v_anw)) right_anx","(Fork left_anu (!((!k_anv), v_anw)) right_anx)","!(Fork left_anu (!((!k_anv), v_anw)) right_anx)","(!(Fork left_anu (!((!k_anv), v_anw)) right_anx))","((!(Fork left_anu (!((!k_anv), v_anw)) right_anx)))","!((!(Fork left_anu (!((!k_anv), v_anw)) right_anx)))","(!((!(Fork left_anu (!((!k_anv), v_anw)) right_anx))))","key_any","Empty","key_aB1","val_aB2","left_aB3","safebang@!left_aB3","(!left_aB3)","k_aB4","v_aB5","(k_aB4, v_aB5)","right_aB6","Fork (!left_aB3) (k_aB4, v_aB5) right_aB6","(Fork (!left_aB3) (k_aB4, v_aB5) right_aB6)","key_aB7","val_aB8","!val_aB8","(!val_aB8)","Empty","key_aB9","!key_aB9","(!key_aB9)","val_aBa","left_aBb","safebang@!left_aBb","(!left_aBb)","k_aBc","safebang@!k_aBc","(!k_aBc)","v_aBd","safebang@!v_aBd","(!v_aBd)","((!k_aBc), (!v_aBd))","right_aBe","safebang@!right_aBe","(!right_aBe)","Fork (!left_aBb) ((!k_aBc), (!v_aBd)) (!right_aBe)","(Fork (!left_aBb) ((!k_aBc), (!v_aBd)) (!right_aBe))","key_aBf","val_aBg","Empty","key_aBh","left_aBi","!left_aBi","(!left_aBi)","k_aBj","safebang@!k_aBj","(!k_aBj)","v_aBk","safebang@!v_aBk","(!v_aBk)","((!k_aBj), (!v_aBk))","!((!k_aBj), (!v_aBk))","(!((!k_aBj), (!v_aBk)))","right_aBl","!right_aBl","(!right_aBl)","Fork (!left_aBi) (!((!k_aBj), (!v_aBk))) (!right_aBl)","(Fork (!left_aBi) (!((!k_aBj), (!v_aBk))) (!right_aBl))","!(Fork (!left_aBi) (!((!k_aBj), (!v_aBk))) (!right_aBl))","(!(Fork (!left_aBi) (!((!k_aBj), (!v_aBk))) (!right_aBl)))","((!(Fork (!left_aBi) (!((!k_aBj), (!v_aBk))) (!right_aBl))))","!((!(Fork (!left_aBi) (!((!k_aBj), (!v_aBk))) (!right_aBl))))","(!((!(Fork (!left_aBi) (!((!k_aBj), (!v_aBk))) (!right_aBl)))))","key_aBm","left_aBp","Empty","!Empty","(!Empty)","left_aBq","right_aBr","!right_aBr","(!right_aBr)","e_aBs","right'_aBt","safebang@!right'_aBt","(!right'_aBt)","(e_aBs, (!right'_aBt))","!(e_aBs, (!right'_aBt))","(!(e_aBs, (!right'_aBt)))","Empty","!Empty","(!Empty)","e_aBu","lazydmd@!e_aBu","(!e_aBu)","r_aBv","!r_aBv","(!r_aBv)","Fork (!Empty) (!e_aBu) (!r_aBv)","(Fork (!Empty) (!e_aBu) (!r_aBv))","!(Fork (!Empty) (!e_aBu) (!r_aBv))","(!(Fork (!Empty) (!e_aBu) (!r_aBv)))","l_aBw","!l_aBw","(!l_aBw)","e_aBx","r_aBy","Fork (!l_aBw) e_aBx r_aBy","(Fork (!l_aBw) e_aBx r_aBy)","e2_aBz","safebang@!e2_aBz","(!e2_aBz)","l'_aBA","safebang@!l'_aBA","(!l'_aBA)","((!e2_aBz), (!l'_aBA))","!((!e2_aBz), (!l'_aBA))","(!((!e2_aBz), (!l'_aBA)))","t_aBB","[]","Empty","e_aBC","!e_aBC","(!e_aBC)","res_aBD","(!e_aBC) : res_aBD","((!e_aBC) : res_aBD)","k_aBL","!k_aBL","(!k_aBL)","left_aBM","e1_aBU","!e1_aBU","(!e1_aBU)","right_aBN","e1_aBV","!e1_aBV","(!e1_aBV)","left_aBW","e_aBX","!e_aBX","(!e_aBX)","right_aBY","safebang@!right_aBY","(!right_aBY)","Fork left_aBW (!e_aBX) (!right_aBY)","(Fork left_aBW (!e_aBX) (!right_aBY))","!(Fork left_aBW (!e_aBX) (!right_aBY))","(!(Fork left_aBW (!e_aBX) (!right_aBY)))","((!(Fork left_aBW (!e_aBX) (!right_aBY))))","es_aBZ","k_aC0","!k_aC0","(!k_aC0)","left'_aC1","!left'_aC1","(!left'_aC1)","e1_aC3","right'_aC2","e1_aC4","!e1_aC4","(!e1_aC4)","t_aC5","es_aC6","[]","es_aC9","left_aCa","!left_aCa","(!left_aCa)","right_aCb","!right_aCb","(!right_aCb)","m_aCc","[]","e_aVO","[e_aVO]","![e_aVO]","(![e_aVO])","k1_aVP","v1_aVQ","(k1_aVP, v1_aVQ)","!(k1_aVP, v1_aVQ)","(!(k1_aVP, v1_aVQ))","k2_aVR","v2_aVS","safebang@!v2_aVS","(!v2_aVS)","(k2_aVR, (!v2_aVS))","!(k2_aVR, (!v2_aVS))","(!(k2_aVR, (!v2_aVS)))","res_aVT","(!(k2_aVR, (!v2_aVS))) : res_aVT","((!(k2_aVR, (!v2_aVS))) : res_aVT)","(!(k1_aVP, v1_aVQ)) : ((!(k2_aVR, (!v2_aVS))) : res_aVT)","((!(k1_aVP, v1_aVQ)) : ((!(k2_aVR, (!v2_aVS))) : res_aVT))","!((!(k1_aVP, v1_aVQ)) : ((!(k2_aVR, (!v2_aVS))) : res_aVT))","(!((!(k1_aVP, v1_aVQ)) : ((!(k2_aVR, (!v2_aVS))) : res_aVT)))","((!((!(k1_aVP, v1_aVQ)) : ((!(k2_aVR, (!v2_aVS))) : res_aVT))))","kvs_aVU","kv_aVW","safebang@!kv_aVW","(!kv_aVW)","[]","![]","(![])","k1_aVX","!k1_aVX","(!k1_aVX)","v1_aVY","!v1_aVY","(!v1_aVY)","((!k1_aVX), (!v1_aVY))","k2_aVZ","v2_aW0","(k2_aVZ, v2_aW0)","res_aW1","(k2_aVZ, v2_aW0) : res_aW1","((k2_aVZ, v2_aW0) : res_aW1)","!((k2_aVZ, v2_aW0) : res_aW1)","(!((k2_aVZ, v2_aW0) : res_aW1))","((!((k2_aVZ, v2_aW0) : res_aW1)))","[]","kvs_aW2","safebang@!kvs_aW2","(!kvs_aW2)","kvs_aW3","[]","![]","(![])","k1_aW4","safebang@!k1_aW4","(!k1_aW4)","v1_aW5","safebang@!v1_aW5","(!v1_aW5)","((!k1_aW4), (!v1_aW5))","kvs1_aW6","((!k1_aW4), (!v1_aW5)) : kvs1_aW6","(((!k1_aW4), (!v1_aW5)) : kvs1_aW6)","k2_aW7","v2_aW8","safebang@!v2_aW8","(!v2_aW8)","(k2_aW7, (!v2_aW8))","kvs2_aW9","(k2_aW7, (!v2_aW8)) : kvs2_aW9","((k2_aW7, (!v2_aW8)) : kvs2_aW9)","!((k2_aW7, (!v2_aW8)) : kvs2_aW9)","(!((k2_aW7, (!v2_aW8)) : kvs2_aW9))","((!((k2_aW7, (!v2_aW8)) : kvs2_aW9)))","!((!((k2_aW7, (!v2_aW8)) : kvs2_aW9)))","(!((!((k2_aW7, (!v2_aW8)) : kvs2_aW9))))","Empty","!Empty","(!Empty)","left_aWa","safebang@!left_aWa","(!left_aWa)","e_aWb","right_aWc","safebang@!right_aWc","(!right_aWc)","Fork (!left_aWa) e_aWb (!right_aWc)","(Fork (!left_aWa) e_aWb (!right_aWc))"]
module Table where
import Result
newTable = Empty
find Empty key_ant = failure "not found"
find
  (norecord@((norecord@(Fork left_anu (norecord@((!k_anv), v_anw))
                          right_anx))))
  key_any
  | key_any < k_anv = find left_anu key_any
  | key_any == k_anv = success v_anw
  | key_any > k_anv = find right_anx key_any
enter Empty key_aB1 val_aB2 = Fork Empty (key_aB1, val_aB2) Empty
enter (Fork (!left_aB3) (k_aB4, v_aB5) right_aB6) key_aB7
  (norecord@val_aB8)
  | key_aB7 < k_aB4 =
    Fork (enter left_aB3 key_aB7 val_aB8) (k_aB4, v_aB5) right_aB6
  | key_aB7 == k_aB4 = Fork left_aB3 (k_aB4, v_aB5) right_aB6
  | key_aB7 > k_aB4 =
    Fork left_aB3 (k_aB4, v_aB5) (enter right_aB6 key_aB7 val_aB8)
update Empty (norecord@key_aB9) val_aBa
  = Fork Empty (key_aB9, val_aBa) Empty
update (Fork (!left_aBb) ((!k_aBc), (!v_aBd)) (!right_aBe)) key_aBf
  val_aBg
  | key_aBf < k_aBc =
    Fork (update left_aBb key_aBf val_aBg) (k_aBc, v_aBd) right_aBe
  | key_aBf == k_aBc = Fork left_aBb (key_aBf, val_aBg) right_aBe
  | key_aBf > k_aBc =
    Fork left_aBb (k_aBc, v_aBd) (update right_aBe key_aBf val_aBg)
delete Empty key_aBh = Empty
delete
  (norecord@((norecord@(Fork (norecord@left_aBi)
                          (norecord@((!k_aBj), (!v_aBk))) (norecord@right_aBl)))))
  key_aBm
  | key_aBm < k_aBj =
    Fork (delete left_aBi key_aBm) (k_aBj, v_aBk) right_aBl
  | key_aBm == k_aBj = graft_aBn left_aBi right_aBl
  | key_aBm > k_aBj =
    Fork left_aBi (k_aBj, v_aBk) (delete right_aBl key_aBm)
  where graft_aBn left_aBp (norecord@Empty) = left_aBp
        graft_aBn left_aBq (norecord@right_aBr)
          = Fork left_aBq e_aBs right'_aBt
          where (norecord@(e_aBs, (!right'_aBt))) = leftmost_aBo right_aBr
        leftmost_aBo
          (norecord@(Fork (norecord@Empty) (lazydmd@e_aBu) (norecord@r_aBv)))
          = (e_aBu, r_aBv)
        leftmost_aBo (Fork (norecord@l_aBw) e_aBx r_aBy)
          = (e2_aBz, Fork l'_aBA e_aBx r_aBy)
          where (norecord@((!e2_aBz), (!l'_aBA))) = leftmost_aBo l_aBw
enterList t_aBB [] = t_aBB
enterList Empty ((norecord@e_aBC) : res_aBD)
  = Fork left_aBM e_aBC right_aBN
  where (norecord@k_aBL) = fst e_aBC
        left_aBM
          = enterList Empty
              [e1_aBU | (norecord@e1_aBU) <- res_aBD, fst e1_aBU < k_aBL]
        right_aBN
          = enterList Empty
              [e1_aBV | (norecord@e1_aBV) <- res_aBD, fst e1_aBV > k_aBL]
enterList
  ((norecord@(Fork left_aBW (norecord@e_aBX) (!right_aBY)))) es_aBZ
  = Fork left'_aC1 e_aBX right'_aC2
  where (norecord@k_aC0) = fst e_aBX
        (norecord@left'_aC1)
          = enterList left_aBW
              [e1_aC3 | e1_aC3 <- es_aBZ, fst e1_aC3 < k_aC0]
        right'_aC2
          = enterList right_aBY
              [e1_aC4 | (norecord@e1_aC4) <- es_aBZ, fst e1_aC4 > k_aC0]
updateList t_aC5 es_aC6
  = balance_aC7
      (mergeKey (entries t_aC5) (unique_aC8 (sortKey es_aC6)))
  where balance_aC7 [] = Empty
        balance_aC7 es_aC9 = Fork left_aCa (es_aC9 !! m_aCc) right_aCb
          where (norecord@left_aCa) = balance_aC7 (take m_aCc es_aC9)
                (norecord@right_aCb) = balance_aC7 (drop (m_aCc + 1) es_aC9)
                m_aCc = length es_aC9 `div` 2
        unique_aC8 [] = []
        unique_aC8 (norecord@[e_aVO]) = [e_aVO]
        unique_aC8
          ((norecord@((norecord@(k1_aVP, v1_aVQ)) :
                        ((norecord@(k2_aVR, (!v2_aVS))) : res_aVT))))
          = if k1_aVP == k2_aVR then unique_aC8 ((k2_aVR, v2_aVS) : res_aVT)
              else (k1_aVP, v1_aVQ) : unique_aC8 ((k2_aVR, v2_aVS) : res_aVT)
sortKey kvs_aVU = foldr insertKey_aVV [] kvs_aVU
  where insertKey_aVV (!kv_aVW) (norecord@[]) = [kv_aVW]
        insertKey_aVV ((norecord@k1_aVX), (norecord@v1_aVY))
          ((norecord@((k2_aVZ, v2_aW0) : res_aW1)))
          | k1_aVX <= k2_aVZ = (k1_aVX, v1_aVY) : (k2_aVZ, v2_aW0) : res_aW1
          | otherwise =
            (k2_aVZ, v2_aW0) : insertKey_aVV (k1_aVX, v1_aVY) res_aW1
mergeKey [] (!kvs_aW2) = kvs_aW2
mergeKey kvs_aW3 (norecord@[]) = kvs_aW3
mergeKey (((!k1_aW4), (!v1_aW5)) : kvs1_aW6)
  (norecord@((norecord@((k2_aW7, (!v2_aW8)) : kvs2_aW9))))
  | k1_aW4 <= k2_aW7 =
    (k1_aW4, v1_aW5) : mergeKey kvs1_aW6 ((k2_aW7, v2_aW8) : kvs2_aW9)
  | otherwise =
    (k2_aW7, v2_aW8) : mergeKey ((k1_aW4, v1_aW5) : kvs1_aW6) kvs2_aW9
entries (norecord@Empty) = []
entries (Fork (!left_aWa) e_aWb (!right_aWc))
  = entries left_aWa ++ [e_aWb] ++ entries right_aWc

data Table k_anr v_ans = Empty
                       | Fork (Table k_anr v_ans) (k_anr, v_ans) (Table k_anr v_ans)

==================== Renamer ====================
Search.freshCopy (Search.Soln (!env_apw) vs_apx) (!p_apy)
  = ((Search.Soln env_apw (drop n_apB vs_apx)), subst tab_apz p_apy)
  where
      tab_apz
        = updateList
            newTable (zip xs_apA [Var v_ata | (!v_ata) <- take n_apB vs_apx])
      xs_apA = vars p_apy
      (!n_apB) = length xs_apA
Search.solve (!db_az6) (Search.Question q_az7) g_az8
  = [Search.Question q_az7]
Search.solve (!db_az9) soln_aza (Term "or" [g1_azb, g2_azc])
  = Search.solve db_az9 soln_aza g1_azb
    ++ Search.solve db_az9 soln_aza g2_azc
Search.solve
  (!db_azd)
  soln_aze
  ((!(Term (!"and") (![g1_azf, (!g2_azg)]))))
  = concat
      [Search.solve db_azd res_azh g2_azg |
         (!res_azh) <- Search.solve db_azd soln_aze g1_azf]
Search.solve db_azi soln_azj g_azk
  = if not (null rs_azn) then
        Search.lookUp db_azi soln_azj g_azk rs_azn
    else
        Search.ask info_azm soln_azj g_azk
  where
      (defs_azl, info_azm) = db_azi
      (!rs_azn) = relevant defs_azl g_azk
Search.lookUp (!db_aMN) (!soln_aMO) (!g_aMP) (!rs_aMQ)
  = concat
      [Search.try db_aMN soln'_aMT g_aMP r'_aMU |
         ((!soln'_aMT), (!r'_aMU)) <- copies_aMR]
  where
      copies_aMR = [Search.freshCopy soln_aMO r_aMS | (!r_aMS) <- rs_aMQ]
Search.try
  db_aMV
  (!((!(Search.Soln (!env_aMW) vs_aMX))))
  (!g_aMY)
  ((!(Term (!"if") (![(!p_aMZ), newg_aN0]))))
  = if fails m_aN1 then
        []
    else
        Search.solve db_aMV (Search.Soln (answer m_aN1) vs_aMX) newg_aN0
  where
      m_aN1 = match env_aMW g_aMY p_aMZ
Search.ask info_aN2 (!((!(Search.Soln env_aN3 (!vs_aN4))))) g_aN5
  = Search.Question sp_aN7
    : if ans_aN6 then [Search.Soln env_aN3 vs_aN4] else []
  where
      ans_aN6 = answer (find info_aN2 sp_aN7)
      sp_aN7 = showPhrase (subst env_aN3 g_aN5)

data Search.Solution
  = Search.Soln Environment [String] | Search.Question String


["env_apw","safebang@!env_apw","(!env_apw)","vs_apx","Soln (!env_apw) vs_apx","(Soln (!env_apw) vs_apx)","p_apy","safebang@!p_apy","(!p_apy)","tab_apz","v_ata","!v_ata","(!v_ata)","xs_apA","n_apB","lazydmd@!n_apB","(!n_apB)","db_az6","safebang@!db_az6","(!db_az6)","q_az7","Question q_az7","(Question q_az7)","g_az8","db_az9","!db_az9","(!db_az9)","soln_aza","\"or\"","g1_azb","g2_azc","[g1_azb, g2_azc]","Term \"or\" [g1_azb, g2_azc]","(Term \"or\" [g1_azb, g2_azc])","db_azd","!db_azd","(!db_azd)","soln_aze","\"and\"","!\"and\"","(!\"and\")","g1_azf","g2_azg","safebang@!g2_azg","(!g2_azg)","[g1_azf, (!g2_azg)]","![g1_azf, (!g2_azg)]","(![g1_azf, (!g2_azg)])","Term (!\"and\") (![g1_azf, (!g2_azg)])","(Term (!\"and\") (![g1_azf, (!g2_azg)]))","!(Term (!\"and\") (![g1_azf, (!g2_azg)]))","(!(Term (!\"and\") (![g1_azf, (!g2_azg)])))","((!(Term (!\"and\") (![g1_azf, (!g2_azg)]))))","res_azh","!res_azh","(!res_azh)","db_azi","soln_azj","g_azk","defs_azl","info_azm","(defs_azl, info_azm)","rs_azn","lazydmd@!rs_azn","(!rs_azn)","db_aMN","safebang@!db_aMN","(!db_aMN)","soln_aMO","safebang@!soln_aMO","(!soln_aMO)","g_aMP","safebang@!g_aMP","(!g_aMP)","rs_aMQ","safebang@!rs_aMQ","(!rs_aMQ)","soln'_aMT","safebang@!soln'_aMT","(!soln'_aMT)","r'_aMU","safebang@!r'_aMU","(!r'_aMU)","((!soln'_aMT), (!r'_aMU))","copies_aMR","r_aMS","!r_aMS","(!r_aMS)","db_aMV","env_aMW","safebang@!env_aMW","(!env_aMW)","vs_aMX","Soln (!env_aMW) vs_aMX","(Soln (!env_aMW) vs_aMX)","!(Soln (!env_aMW) vs_aMX)","(!(Soln (!env_aMW) vs_aMX))","((!(Soln (!env_aMW) vs_aMX)))","!((!(Soln (!env_aMW) vs_aMX)))","(!((!(Soln (!env_aMW) vs_aMX))))","g_aMY","safebang@!g_aMY","(!g_aMY)","\"if\"","!\"if\"","(!\"if\")","p_aMZ","safebang@!p_aMZ","(!p_aMZ)","newg_aN0","[(!p_aMZ), newg_aN0]","![(!p_aMZ), newg_aN0]","(![(!p_aMZ), newg_aN0])","Term (!\"if\") (![(!p_aMZ), newg_aN0])","(Term (!\"if\") (![(!p_aMZ), newg_aN0]))","!(Term (!\"if\") (![(!p_aMZ), newg_aN0]))","(!(Term (!\"if\") (![(!p_aMZ), newg_aN0])))","((!(Term (!\"if\") (![(!p_aMZ), newg_aN0]))))","m_aN1","info_aN2","env_aN3","vs_aN4","safebang@!vs_aN4","(!vs_aN4)","Soln env_aN3 (!vs_aN4)","(Soln env_aN3 (!vs_aN4))","!(Soln env_aN3 (!vs_aN4))","(!(Soln env_aN3 (!vs_aN4)))","((!(Soln env_aN3 (!vs_aN4))))","!((!(Soln env_aN3 (!vs_aN4))))","(!((!(Soln env_aN3 (!vs_aN4)))))","g_aN5","ans_aN6","sp_aN7"]
module Search where
import Result
import Table
import Knowledge
import Match
freshCopy (Soln (!env_apw) vs_apx) (!p_apy)
  = ((Soln env_apw (drop n_apB vs_apx)), subst tab_apz p_apy)
  where tab_apz
          = updateList newTable
              (zip xs_apA [Var v_ata | (norecord@v_ata) <- take n_apB vs_apx])
        xs_apA = vars p_apy
        (lazydmd@n_apB) = length xs_apA
solve (!db_az6) (Question q_az7) g_az8 = [Question q_az7]
solve (norecord@db_az9) soln_aza (Term "or" [g1_azb, g2_azc])
  = solve db_az9 soln_aza g1_azb ++ solve db_az9 soln_aza g2_azc
solve (norecord@db_azd) soln_aze
  ((norecord@(Term (norecord@"and") (norecord@[g1_azf, (!g2_azg)]))))
  = concat
      [solve db_azd res_azh g2_azg |
       (norecord@res_azh) <- solve db_azd soln_aze g1_azf]
solve db_azi soln_azj g_azk
  = if not (null rs_azn) then lookUp db_azi soln_azj g_azk rs_azn
      else ask info_azm soln_azj g_azk
  where (defs_azl, info_azm) = db_azi
        (lazydmd@rs_azn) = relevant defs_azl g_azk
lookUp (!db_aMN) (!soln_aMO) (!g_aMP) (!rs_aMQ)
  = concat
      [try db_aMN soln'_aMT g_aMP r'_aMU |
       ((!soln'_aMT), (!r'_aMU)) <- copies_aMR]
  where copies_aMR
          = [freshCopy soln_aMO r_aMS | (norecord@r_aMS) <- rs_aMQ]
try db_aMV (norecord@((norecord@(Soln (!env_aMW) vs_aMX))))
  (!g_aMY)
  ((norecord@(Term (norecord@"if") (norecord@[(!p_aMZ), newg_aN0]))))
  = if fails m_aN1 then [] else
      solve db_aMV (Soln (answer m_aN1) vs_aMX) newg_aN0
  where m_aN1 = match env_aMW g_aMY p_aMZ
ask info_aN2 (norecord@((norecord@(Soln env_aN3 (!vs_aN4))))) g_aN5
  = Question sp_aN7 : if ans_aN6 then [Soln env_aN3 vs_aN4] else []
  where ans_aN6 = answer (find info_aN2 sp_aN7)
        sp_aN7 = showPhrase (subst env_aN3 g_aN5)

data Solution = Soln Environment [String]
              | Question String

==================== Renamer ====================
Interval.polling = 5 :: Int
Interval.interval = 3 :: Int
Interval.threshold = 100 :: Int


["polling","interval","threshold"]
module Interval where
polling = 5 :: Int
interval = 3 :: Int
threshold = 100 :: Int

==================== Renamer ====================
Auxil.ends :: Auxil.Key -> String
Auxil.ends (Auxil.K _ a_aCo (!z_aCp) (!_)) = [a_aCo, z_aCp]
Auxil.morefreq :: Auxil.Key -> Auxil.Key -> Bool
Auxil.morefreq
  (Auxil.K _ (!a_aCq) x_aCr (!_))
  ((!(Auxil.K _ (!b_aCs) (!y_aCt) _)))
  = Auxil.freq a_aCq + Auxil.freq x_aCr
    > Auxil.freq b_aCs + Auxil.freq y_aCt
Auxil.freq :: Char -> Int
Auxil.freq c_aDs = Auxil.assoc c_aDs Auxil.freqtab
Auxil.assoc :: (Eq a_aCm) => a_aCm -> [(a_aCm, b_aCn)] -> b_aCn
Auxil.assoc (!x_aDt) ((!((!(y_aDu, z_aDv)) : (!yzs_aDw))))
  = if x_aDt == y_aDu then z_aDv else Auxil.assoc x_aDt yzs_aDw
Auxil.assocm ::
  (Eq a_aCk) => a_aCk -> [(a_aCk, b_aCl)] -> Maybe b_aCl
Auxil.assocm x_aDx [] = Nothing
Auxil.assocm x_aDy (((!y_aDz), (!z_aDA)) : yzs_aDB)
  = if x_aDy == y_aDz then Just z_aDA else Auxil.assocm x_aDy yzs_aDB
Auxil.freqtab :: [(Char, Int)]
Auxil.freqtab
  = Auxil.histo (concat (map Auxil.ends Auxil.attribkeys))
Auxil.histo :: (Eq a_aCj) => [a_aCj] -> [(a_aCj, Int)]
Auxil.histo
  = foldr histins_aJJ []
  where
      histins_aJJ x_aJK (![]) = [(x_aJK, 1)]
      histins_aJJ x_aJL (!(yn_aJM@((!y_aJN), n_aJO) : yns_aJP))
        = if x_aJL == y_aJN then
              (y_aJN, n_aJO + 1) : yns_aJP
          else
              yn_aJM : histins_aJJ x_aJL yns_aJP
Auxil.maxval :: Int
Auxil.maxval = length (Auxil.freqtab)
Auxil.subset :: (Eq a_aCi) => [a_aCi] -> [a_aCi] -> Bool
Auxil.subset xs_aJQ (!ys_aJR)
  = all (\ (!x_aJS) -> Auxil.member x_aJS ys_aJR) xs_aJQ
Auxil.union :: (Eq a_aCh) => [a_aCh] -> [a_aCh] -> [a_aCh]
Auxil.union xs_aJT (!ys_aJU)
  = xs_aJT
    ++ [y_aJV | y_aJV <- ys_aJU, not (Auxil.member y_aJV xs_aJT)]
Auxil.attribkeys :: [Auxil.Key]
Auxil.attribkeys
  = map
      (\ k_aJW
         -> (Auxil.K k_aJW (head k_aJW) (last k_aJW) (length k_aJW)))
      keys
Auxil.hinsert :: Int -> Auxil.HashSet -> Maybe Auxil.HashSet
Auxil.hinsert (!h_aNn) (!((!(Auxil.H lo_aNo (!hi_aNp) hs_aNq))))
  = if Auxil.member h_aNn hs_aNq
       || 1 + hi'_aNs - lo'_aNr > Auxil.numberofkeys then
        Nothing
    else
        Just (Auxil.H (Just lo'_aNr) (Just hi'_aNs) (h_aNn : hs_aNq))
  where
      lo'_aNr = Auxil.minm lo_aNo h_aNn
      hi'_aNs = Auxil.maxm hi_aNp h_aNn
Auxil.minm, Auxil.maxm :: Maybe Int -> Int -> Int
Auxil.minm Nothing (!y_aNt) = y_aNt
Auxil.minm ((!(Just x_aNu))) (!y_aNv) = min x_aNu y_aNv
Auxil.maxm (!Nothing) y_aNw = y_aNw
Auxil.maxm (Just x_aNx) y_aNy = max x_aNx y_aNy
Auxil.member :: (Eq a_aoO) => a_aoO -> [a_aoO] -> Bool
Auxil.member (!_) (![]) = False
Auxil.member (!x_aNz) (!(y_aNA : (!ys_aNB)))
  = x_aNz == y_aNA || Auxil.member x_aNz ys_aNB
Auxil.hash :: Auxil.HashFun -> Auxil.Key -> Int
Auxil.hash (!cvs_aNC) (Auxil.K _ a_aND (!z_aNE) (!n_aNF))
  = n_aNF + Auxil.assoc a_aND cvs_aNC + Auxil.assoc z_aNE cvs_aNC
Auxil.numberofkeys :: Int
Auxil.numberofkeys = length keys
Auxil.partition' ::
  (a_aoN -> Bool) -> [a_aoN] -> ([a_aoN], [a_aoN])
Auxil.partition' p_aNG
  = foldr select_aNH ([], [])
  where
      select_aNH (!x_aNI) ((!ts_aNJ), fs_aNK)
        | p_aNG x_aNI = (x_aNI : ts_aNJ, fs_aNK)
        | otherwise = (ts_aNJ, x_aNI : fs_aNK)
Auxil.freqsorted :: [Auxil.Key] -> [Auxil.Key]
Auxil.freqsorted = \ x_aNL -> x_aNL
Auxil.blocked :: [Auxil.Key] -> [Auxil.Key]
Auxil.blocked = Auxil.blocked' []
Auxil.blocked' (!ds_aNM) (![]) = []
Auxil.blocked' (!ds_aNN) ((!(k_aNO : ks_aNP)))
  = k_aNO : det_aNQ ++ Auxil.blocked' ds'_aNS rest_aNR
  where
      (!(det_aNQ, (!rest_aNR)))
        = Auxil.partition'
            (\ x_aNT -> Auxil.subset (Auxil.ends x_aNT) ds'_aNS) ks_aNP
      ds'_aNS = Auxil.union ds_aNN (Auxil.ends k_aNO)

data Auxil.Key = Auxil.K String Char Char Int
data Auxil.HashSet = Auxil.H (Maybe Int) (Maybe Int) [Int]
type Auxil.HashFun = [(Char, Int)]


["_","a_aCo","z_aCp","safebang@!z_aCp","(!z_aCp)","_","!_","(!_)","K _ a_aCo (!z_aCp) (!_)","(K _ a_aCo (!z_aCp) (!_))","_","a_aCq","safebang@!a_aCq","(!a_aCq)","x_aCr","_","!_","(!_)","K _ (!a_aCq) x_aCr (!_)","(K _ (!a_aCq) x_aCr (!_))","_","b_aCs","safebang@!b_aCs","(!b_aCs)","y_aCt","safebang@!y_aCt","(!y_aCt)","_","K _ (!b_aCs) (!y_aCt) _","(K _ (!b_aCs) (!y_aCt) _)","!(K _ (!b_aCs) (!y_aCt) _)","(!(K _ (!b_aCs) (!y_aCt) _))","((!(K _ (!b_aCs) (!y_aCt) _)))","c_aDs","x_aDt","safebang@!x_aDt","(!x_aDt)","y_aDu","z_aDv","(y_aDu, z_aDv)","!(y_aDu, z_aDv)","(!(y_aDu, z_aDv))","yzs_aDw","safebang@!yzs_aDw","(!yzs_aDw)","(!(y_aDu, z_aDv)) : (!yzs_aDw)","((!(y_aDu, z_aDv)) : (!yzs_aDw))","!((!(y_aDu, z_aDv)) : (!yzs_aDw))","(!((!(y_aDu, z_aDv)) : (!yzs_aDw)))","((!((!(y_aDu, z_aDv)) : (!yzs_aDw))))","x_aDx","[]","x_aDy","y_aDz","safebang@!y_aDz","(!y_aDz)","z_aDA","safebang@!z_aDA","(!z_aDA)","((!y_aDz), (!z_aDA))","yzs_aDB","((!y_aDz), (!z_aDA)) : yzs_aDB","(((!y_aDz), (!z_aDA)) : yzs_aDB)","freqtab","histo","x_aJK","[]","![]","(![])","x_aJL","y_aJN","safebang@!y_aJN","(!y_aJN)","n_aJO","((!y_aJN), n_aJO)","yn_aJM@((!y_aJN), n_aJO)","yns_aJP","yn_aJM@((!y_aJN), n_aJO) : yns_aJP","(yn_aJM@((!y_aJN), n_aJO) : yns_aJP)","!(yn_aJM@((!y_aJN), n_aJO) : yns_aJP)","(!(yn_aJM@((!y_aJN), n_aJO) : yns_aJP))","maxval","xs_aJQ","ys_aJR","safebang@!ys_aJR","(!ys_aJR)","x_aJS","!x_aJS","(!x_aJS)","xs_aJT","ys_aJU","safebang@!ys_aJU","(!ys_aJU)","y_aJV","attribkeys","k_aJW","h_aNn","safebang@!h_aNn","(!h_aNn)","lo_aNo","hi_aNp","!hi_aNp","(!hi_aNp)","hs_aNq","H lo_aNo (!hi_aNp) hs_aNq","(H lo_aNo (!hi_aNp) hs_aNq)","!(H lo_aNo (!hi_aNp) hs_aNq)","(!(H lo_aNo (!hi_aNp) hs_aNq))","((!(H lo_aNo (!hi_aNp) hs_aNq)))","!((!(H lo_aNo (!hi_aNp) hs_aNq)))","(!((!(H lo_aNo (!hi_aNp) hs_aNq))))","lo'_aNr","hi'_aNs","Nothing","y_aNt","safebang@!y_aNt","(!y_aNt)","x_aNu","Just x_aNu","(Just x_aNu)","!(Just x_aNu)","(!(Just x_aNu))","((!(Just x_aNu)))","y_aNv","!y_aNv","(!y_aNv)","Nothing","!Nothing","(!Nothing)","y_aNw","x_aNx","Just x_aNx","(Just x_aNx)","y_aNy","_","!_","(!_)","[]","![]","(![])","x_aNz","!x_aNz","(!x_aNz)","y_aNA","ys_aNB","safebang@!ys_aNB","(!ys_aNB)","y_aNA : (!ys_aNB)","(y_aNA : (!ys_aNB))","!(y_aNA : (!ys_aNB))","(!(y_aNA : (!ys_aNB)))","cvs_aNC","safebang@!cvs_aNC","(!cvs_aNC)","_","a_aND","z_aNE","safebang@!z_aNE","(!z_aNE)","n_aNF","safebang@!n_aNF","(!n_aNF)","K _ a_aND (!z_aNE) (!n_aNF)","(K _ a_aND (!z_aNE) (!n_aNF))","numberofkeys","p_aNG","x_aNI","!x_aNI","(!x_aNI)","ts_aNJ","safebang@!ts_aNJ","(!ts_aNJ)","fs_aNK","((!ts_aNJ), fs_aNK)","freqsorted","x_aNL","blocked","ds_aNM","safebang@!ds_aNM","(!ds_aNM)","[]","![]","(![])","ds_aNN","!ds_aNN","(!ds_aNN)","k_aNO","ks_aNP","k_aNO : ks_aNP","(k_aNO : ks_aNP)","!(k_aNO : ks_aNP)","(!(k_aNO : ks_aNP))","((!(k_aNO : ks_aNP)))","det_aNQ","rest_aNR","safebang@!rest_aNR","(!rest_aNR)","(det_aNQ, (!rest_aNR))","!(det_aNQ, (!rest_aNR))","(!(det_aNQ, (!rest_aNR)))","x_aNT","ds'_aNS"]
module Auxil where
import Key

ends :: Key -> String
ends (K _ a_aCo (!z_aCp) (norecord@_)) = [a_aCo, z_aCp]

morefreq :: Key -> Key -> Bool
morefreq (K _ (!a_aCq) x_aCr (norecord@_))
  ((norecord@(K _ (!b_aCs) (!y_aCt) _)))
  = freq a_aCq + freq x_aCr > freq b_aCs + freq y_aCt

freq :: Char -> Int
freq c_aDs = assoc c_aDs freqtab

assoc :: (Eq a_aCm) => a_aCm -> [(a_aCm, b_aCn)] -> b_aCn
assoc (!x_aDt)
  ((norecord@((norecord@(y_aDu, z_aDv)) : (!yzs_aDw))))
  = if x_aDt == y_aDu then z_aDv else assoc x_aDt yzs_aDw

assocm :: (Eq a_aCk) => a_aCk -> [(a_aCk, b_aCl)] -> Maybe b_aCl
assocm x_aDx [] = Nothing
assocm x_aDy (((!y_aDz), (!z_aDA)) : yzs_aDB)
  = if x_aDy == y_aDz then Just z_aDA else assocm x_aDy yzs_aDB

freqtab :: [(Char, Int)]
freqtab = histo (concat (map ends attribkeys))

histo :: (Eq a_aCj) => [a_aCj] -> [(a_aCj, Int)]
histo = foldr histins_aJJ []
  where histins_aJJ x_aJK (norecord@[]) = [(x_aJK, 1)]
        histins_aJJ x_aJL (norecord@(yn_aJM@((!y_aJN), n_aJO) : yns_aJP))
          = if x_aJL == y_aJN then (y_aJN, n_aJO + 1) : yns_aJP else
              yn_aJM : histins_aJJ x_aJL yns_aJP

maxval :: Int
maxval = length (freqtab)

subset :: (Eq a_aCi) => [a_aCi] -> [a_aCi] -> Bool
subset xs_aJQ (!ys_aJR)
  = all (\ (norecord@x_aJS) -> member x_aJS ys_aJR) xs_aJQ

union :: (Eq a_aCh) => [a_aCh] -> [a_aCh] -> [a_aCh]
union xs_aJT (!ys_aJU)
  = xs_aJT ++ [y_aJV | y_aJV <- ys_aJU, not (member y_aJV xs_aJT)]

attribkeys :: [Key]
attribkeys
  = map
      (\ k_aJW -> (K k_aJW (head k_aJW) (last k_aJW) (length k_aJW)))
      keys

hinsert :: Int -> HashSet -> Maybe HashSet
hinsert (!h_aNn)
  (norecord@((norecord@(H lo_aNo (norecord@hi_aNp) hs_aNq))))
  = if member h_aNn hs_aNq || 1 + hi'_aNs - lo'_aNr > numberofkeys
      then Nothing else
      Just (H (Just lo'_aNr) (Just hi'_aNs) (h_aNn : hs_aNq))
  where lo'_aNr = minm lo_aNo h_aNn
        hi'_aNs = maxm hi_aNp h_aNn

minm, maxm :: Maybe Int -> Int -> Int
minm Nothing (!y_aNt) = y_aNt
minm ((norecord@(Just x_aNu))) (norecord@y_aNv) = min x_aNu y_aNv
maxm (norecord@Nothing) y_aNw = y_aNw
maxm (Just x_aNx) y_aNy = max x_aNx y_aNy

member :: (Eq a_aoO) => a_aoO -> [a_aoO] -> Bool
member (norecord@_) (norecord@[]) = False
member (norecord@x_aNz) (norecord@(y_aNA : (!ys_aNB)))
  = x_aNz == y_aNA || member x_aNz ys_aNB

hash :: HashFun -> Key -> Int
hash (!cvs_aNC) (K _ a_aND (!z_aNE) (!n_aNF))
  = n_aNF + assoc a_aND cvs_aNC + assoc z_aNE cvs_aNC

numberofkeys :: Int
numberofkeys = length keys

partition' :: (a_aoN -> Bool) -> [a_aoN] -> ([a_aoN], [a_aoN])
partition' p_aNG = foldr select_aNH ([], [])
  where select_aNH (norecord@x_aNI) ((!ts_aNJ), fs_aNK)
          | p_aNG x_aNI = (x_aNI : ts_aNJ, fs_aNK)
          | otherwise = (ts_aNJ, x_aNI : fs_aNK)

freqsorted :: [Key] -> [Key]
freqsorted = \ x_aNL -> x_aNL

blocked :: [Key] -> [Key]
blocked = blocked' []
blocked' (!ds_aNM) (norecord@[]) = []
blocked' (norecord@ds_aNN) ((norecord@(k_aNO : ks_aNP)))
  = k_aNO : det_aNQ ++ blocked' ds'_aNS rest_aNR
  where (norecord@(det_aNQ, (!rest_aNR)))
          = partition' (\ x_aNT -> subset (ends x_aNT) ds'_aNS) ks_aNP
        ds'_aNS = union ds_aNN (ends k_aNO)

data Key = K String Char Char Int

data HashSet = H (Maybe Int) (Maybe Int) [Int]

type HashFun = [(Char, Int)]

==================== Renamer ====================
Prog.prog :: String -> String
Prog.prog _ = show Prog.cichelli
Prog.cichelli :: Prog.FeedBack
Prog.cichelli
  = Prog.findhash hashkeys_ayk
  where
      (!hashkeys_ayk) = (blocked . freqsorted) attribkeys
Prog.findhash :: [Key] -> Prog.FeedBack
Prog.findhash = Prog.findhash' (H Nothing Nothing []) []
Prog.findhash' :: HashSet -> HashFun -> [Key] -> Prog.FeedBack
Prog.findhash' keyHashSet_ayl charAssocs_aym []
  = (Prog.YesIts 1 charAssocs_aym)
Prog.findhash'
  keyHashSet_ayn
  (!charAssocs_ayo)
  ((!(k_ayp@(K (!s_ayq) a_ayr z_ays n_ayt) : ks_ayu)))
  = (case
         (assocm a_ayr charAssocs_ayo, assocm z_ays charAssocs_ayo)
     of {
       ((!Nothing), Nothing)
         -> if a_ayr == z_ays then
                Prog.firstSuccess
                  (\ m_aM0 -> try_ayv [(a_ayr, m_aM0)]) [0 .. maxval]
            else
                Prog.firstSuccess
                  (\ (!(m_aM1, n_aM2)) -> try_ayv [(a_ayr, m_aM1), (z_ays, n_aM2)])
                  [(m_aM3, n_aM4) |
                     (!m_aM3) <- [0 .. maxval], n_aM4 <- [0 .. maxval]]
       (!((!Nothing), Just (!zc_aM5)))
         -> Prog.firstSuccess
              (\ m_aM6 -> try_ayv [(a_ayr, m_aM6)]) [0 .. maxval]
       (Just ac_aM7, (!Nothing))
         -> Prog.firstSuccess
              (\ (!n_aM8) -> try_ayv [(z_ays, n_aM8)]) [0 .. maxval]
       ((!(Just ac_aM9)), Just (!zc_aMa)) -> try_ayv [] })
  where
      try_ayv newAssocs_ayw
        = (case hinsert (hash newCharAssocs_ayx k_ayp) keyHashSet_ayn of {
             (!Nothing) -> (Prog.NotEver 1)
             (!(Just newKeyHashSet_ayy))
               -> Prog.findhash' newKeyHashSet_ayy newCharAssocs_ayx ks_ayu })
        where
            newCharAssocs_ayx = newAssocs_ayw ++ charAssocs_ayo
Prog.firstSuccess ::
  (a_ayj -> Prog.FeedBack) -> [a_ayj] -> Prog.FeedBack
Prog.firstSuccess (!f_aMb) (!possibles_aMc)
  = Prog.first 0 (map f_aMb possibles_aMc)
Prog.first :: Int -> [Prog.FeedBack] -> Prog.FeedBack
Prog.first k_aMd [] = Prog.NotEver k_aMd
Prog.first k_aMe (!((!(a_aMf : l_aMg))))
  = case a_aMf of {
      ((!(Prog.YesIts (!leaves_aMh) y_aMi)))
        -> Prog.YesIts (k_aMe + leaves_aMh) y_aMi
      ((!(Prog.NotEver (!leaves_aNh))))
        -> Prog.first (k_aMe + leaves_aNh) l_aMg }

data Prog.Status a_ayb = Prog.NotEver Int | Prog.YesIts Int a_ayb
type Prog.FeedBack = Prog.Status HashFun

instance (Show a_aNi) => Show (Prog.Status a_aNi) where
  showsPrec d_aNj ((!(Prog.NotEver (!i_aNk))))
    = showParen (d_aNj >= 10) showStr_aNl
    where
        showStr_aNl
          = showString "NotEver" . showChar ' ' . showsPrec 10 i_aNk
  showsPrec d_aNm ((!(Prog.YesIts (!i_aNn) a_aNo)))
    = showParen (d_aNm >= 10) showStr_aNp
    where
        showStr_aNp
          = showString "YesIts"
            . showChar ' '
              . showsPrec 10 i_aNn . showChar ' ' . showsPrec 10 a_aNo
  showList [] = showString "[]"
  showList (!((!x_aNq) : (!xs_aNr)))
    = showChar '[' . shows x_aNq . showl_aNs xs_aNr
    where
        showl_aNs [] = showChar ']'
        showl_aNs (x_aNt : (!xs_aNu))
          = showChar ',' . shows x_aNt . showl_aNs xs_aNu



==================== Renamer ====================
Main.perms (!m_arb) [] = []
Main.perms (!1) l_arc = map (: []) l_arc
Main.perms (!m_ard) ((!(n_are : ns_arf)))
  = map ((:) n_are) (Main.perms (m_ard - 1) ns_arf)
    ++ Main.perms m_ard ns_arf
Main.awards (!scores_asl)
  = award_aso ("Gold", 70)
    ++ award_aso ("Silver", 60) ++ award_aso ("Bronze", 50)
  where
      (!sumscores_asm)
        = map (\ (!p_asp) -> (sum p_asp, p_asp)) (Main.perms 3 scores_asl)
      atleast_asn threshold_ayo
        = filter
            (\ ((!sum_aBH), (!p_aBI)) -> sum_aBH >= threshold_ayo)
            sumscores_asm
      award_aso ((!name_aPa), (!threshold_aPb))
        = map
            (\ ps_aPc -> (name_aPa, ps_aPc)) (sort (atleast_asn threshold_aPb))
Main.findawards (!scores_aPd)
  | null theawards_aPi = []
  | otherwise
  = firstaward_aPe : Main.findawards (scores_aPd \\ perm_aPh)
  where
      firstaward_aPe@((!award_aPf), (sum_aPg, (!perm_aPh)))
        = head theawards_aPi
      (!theawards_aPi) = Main.awards scores_aPd
Main.findallawards competitors_aRx
  = map
      (\ (name_aRy, (!scores_aRz))
         -> (name_aRy, Main.findawards scores_aRz))
      competitors_aRx
Main.competitors
  = [("Simon", [35, 27, 40, 19, 34, 21]),
     ("Hans", [23, 19, 45, 17, 10, 5, 8, 14]),
     ("Phil", [1, 18, 35, 20, 21, 19, 34, 8, 16, 21]),
     ("Kevin", [9, 23, 17, 54, 18, 41, 9, 18, 14])]
Main.main
  = do { (n_aRA : _) <- getArgs;
         replicateM_ (read n_aRA)
         $ print (Main.findallawards Main.competitors) }


["m_arb","safebang@!m_arb","(!m_arb)","[]","1","!1","(!1)","l_arc","m_ard","!m_ard","(!m_ard)","n_are","ns_arf","n_are : ns_arf","(n_are : ns_arf)","!(n_are : ns_arf)","(!(n_are : ns_arf))","((!(n_are : ns_arf)))","scores_asl","!scores_asl","(!scores_asl)","sumscores_asm","safebang@!sumscores_asm","(!sumscores_asm)","p_asp","!p_asp","(!p_asp)","threshold_ayo","sum_aBH","safebang@!sum_aBH","(!sum_aBH)","p_aBI","safebang@!p_aBI","(!p_aBI)","((!sum_aBH), (!p_aBI))","name_aPa","safebang@!name_aPa","(!name_aPa)","threshold_aPb","safebang@!threshold_aPb","(!threshold_aPb)","((!name_aPa), (!threshold_aPb))","ps_aPc","scores_aPd","safebang@!scores_aPd","(!scores_aPd)","award_aPf","!award_aPf","(!award_aPf)","sum_aPg","perm_aPh","!perm_aPh","(!perm_aPh)","(sum_aPg, (!perm_aPh))","((!award_aPf), (sum_aPg, (!perm_aPh)))","firstaward_aPe@((!award_aPf), (sum_aPg, (!perm_aPh)))","theawards_aPi","!theawards_aPi","(!theawards_aPi)","competitors_aRx","name_aRy","scores_aRz","safebang@!scores_aRz","(!scores_aRz)","(name_aRy, (!scores_aRz))","competitors","main","n_aRA","_","n_aRA : _","(n_aRA : _)"]
module Main (main) where
import QSort
import Data.List ((\\))
import System.Environment
import Control.Monad
perms (!m_arb) [] = []
perms (norecord@1) l_arc = map (: []) l_arc
perms (norecord@m_ard) ((norecord@(n_are : ns_arf)))
  = map ((:) n_are) (perms (m_ard - 1) ns_arf) ++ perms m_ard ns_arf
awards (norecord@scores_asl)
  = award_aso ("Gold", 70) ++ award_aso ("Silver", 60) ++
      award_aso ("Bronze", 50)
  where (!sumscores_asm)
          = map (\ (norecord@p_asp) -> (sum p_asp, p_asp))
              (perms 3 scores_asl)
        atleast_asn threshold_ayo
          = filter (\ ((!sum_aBH), (!p_aBI)) -> sum_aBH >= threshold_ayo)
              sumscores_asm
        award_aso ((!name_aPa), (!threshold_aPb))
          = map (\ ps_aPc -> (name_aPa, ps_aPc))
              (sort (atleast_asn threshold_aPb))
findawards (!scores_aPd)
  | null theawards_aPi = []
  | otherwise = firstaward_aPe : findawards (scores_aPd \\ perm_aPh)
  where firstaward_aPe@((norecord@award_aPf),
                        (sum_aPg, (norecord@perm_aPh)))
          = head theawards_aPi
        (norecord@theawards_aPi) = awards scores_aPd
findallawards competitors_aRx
  = map
      (\ (name_aRy, (!scores_aRz)) -> (name_aRy, findawards scores_aRz))
      competitors_aRx
competitors
  = [("Simon", [35, 27, 40, 19, 34, 21]),
     ("Hans", [23, 19, 45, 17, 10, 5, 8, 14]),
     ("Phil", [1, 18, 35, 20, 21, 19, 34, 8, 16, 21]),
     ("Kevin", [9, 23, 17, 54, 18, 41, 9, 18, 14])]
main
  = do (n_aRA : _) <- getArgs
       replicateM_ (read n_aRA) $ print (findallawards competitors)

==================== Renamer ====================
QSort.sortLe :: (a_aAp -> a_aAp -> Bool) -> [a_aAp] -> [a_aAp]
QSort.sortLe (!le_aAx) l_aAy = QSort.qsort le_aAx l_aAy []
QSort.sort :: (Ord a_amW) => [a_amW] -> [a_amW]
QSort.sort (!l_aAz) = QSort.qsort (<=) l_aAz []
QSort.qsort le_aAA (![]) r_aAB = r_aAB
QSort.qsort le_aAC [(!x_aAD)] (!r_aAE) = x_aAD : r_aAE
QSort.qsort (!le_aAF) (!((!((!x_aAG) : xs_aAH)))) r_aAI
  = QSort.qpart le_aAF x_aAG xs_aAH [] [] r_aAI
QSort.qpart (!le_aAJ) (!x_aAK) [] rlt_aAL (!rge_aAM) (!r_aAN)
  = QSort.rqsort
      le_aAJ rlt_aAL (x_aAK : QSort.rqsort le_aAJ rge_aAM r_aAN)
QSort.qpart
  le_aAO
  (!x_aAP)
  (!(y_aAQ : ys_aAR))
  rlt_aAS
  rge_aAT
  (!r_aAU)
  = if le_aAO x_aAP y_aAQ then
        QSort.qpart le_aAO x_aAP ys_aAR rlt_aAS (y_aAQ : rge_aAT) r_aAU
    else
        QSort.qpart le_aAO x_aAP ys_aAR (y_aAQ : rlt_aAS) rge_aAT r_aAU
QSort.rqsort le_aAV [] r_aAW = r_aAW
QSort.rqsort le_aAX [x_aAY] r_aAZ = x_aAY : r_aAZ
QSort.rqsort le_aB0 (x_aB1 : xs_aB2) r_aB3
  = QSort.rqpart le_aB0 x_aB1 xs_aB2 [] [] r_aB3
QSort.rqpart le_aB4 x_aB5 [] (!rle_aB6) rgt_aB7 (!r_aB8)
  = QSort.qsort
      le_aB4 rle_aB6 (x_aB5 : QSort.qsort le_aB4 rgt_aB7 r_aB8)
QSort.rqpart
  (!le_aB9)
  x_aBa
  (!(y_aBb : ys_aBc))
  rle_aBd
  rgt_aBe
  r_aBf
  = if le_aB9 y_aBb x_aBa then
        QSort.rqpart le_aB9 x_aBa ys_aBc (y_aBb : rle_aBd) rgt_aBe r_aBf
    else
        QSort.rqpart le_aB9 x_aBa ys_aBc rle_aBd (y_aBb : rgt_aBe) r_aBf


["le_aAx","safebang@!le_aAx","(!le_aAx)","l_aAy","l_aAz","safebang@!l_aAz","(!l_aAz)","le_aAA","[]","![]","(![])","r_aAB","le_aAC","x_aAD","safebang@!x_aAD","(!x_aAD)","[(!x_aAD)]","r_aAE","!r_aAE","(!r_aAE)","le_aAF","!le_aAF","(!le_aAF)","x_aAG","!x_aAG","(!x_aAG)","xs_aAH","(!x_aAG) : xs_aAH","((!x_aAG) : xs_aAH)","!((!x_aAG) : xs_aAH)","(!((!x_aAG) : xs_aAH))","((!((!x_aAG) : xs_aAH)))","!((!((!x_aAG) : xs_aAH)))","(!((!((!x_aAG) : xs_aAH))))","r_aAI","le_aAJ","safebang@!le_aAJ","(!le_aAJ)","x_aAK","safebang@!x_aAK","(!x_aAK)","[]","rlt_aAL","rge_aAM","!rge_aAM","(!rge_aAM)","r_aAN","safebang@!r_aAN","(!r_aAN)","le_aAO","x_aAP","!x_aAP","(!x_aAP)","y_aAQ","ys_aAR","y_aAQ : ys_aAR","(y_aAQ : ys_aAR)","!(y_aAQ : ys_aAR)","(!(y_aAQ : ys_aAR))","rlt_aAS","rge_aAT","r_aAU","!r_aAU","(!r_aAU)","le_aAV","[]","r_aAW","le_aAX","x_aAY","[x_aAY]","r_aAZ","le_aB0","x_aB1","xs_aB2","x_aB1 : xs_aB2","(x_aB1 : xs_aB2)","r_aB3","le_aB4","x_aB5","[]","rle_aB6","!rle_aB6","(!rle_aB6)","rgt_aB7","r_aB8","safebang@!r_aB8","(!r_aB8)","le_aB9","!le_aB9","(!le_aB9)","x_aBa","y_aBb","ys_aBc","y_aBb : ys_aBc","(y_aBb : ys_aBc)","!(y_aBb : ys_aBc)","(!(y_aBb : ys_aBc))","rle_aBd","rgt_aBe","r_aBf"]
module QSort (sortLe, sort) where

sortLe :: (a_aAp -> a_aAp -> Bool) -> [a_aAp] -> [a_aAp]
sortLe (!le_aAx) l_aAy = qsort le_aAx l_aAy []

sort :: (Ord a_amW) => [a_amW] -> [a_amW]
sort (!l_aAz) = qsort (<=) l_aAz []
qsort le_aAA (norecord@[]) r_aAB = r_aAB
qsort le_aAC [(!x_aAD)] (norecord@r_aAE) = x_aAD : r_aAE
qsort (norecord@le_aAF)
  (norecord@((norecord@((norecord@x_aAG) : xs_aAH)))) r_aAI
  = qpart le_aAF x_aAG xs_aAH [] [] r_aAI
qpart (!le_aAJ) (!x_aAK) [] rlt_aAL (norecord@rge_aAM) (!r_aAN)
  = rqsort le_aAJ rlt_aAL (x_aAK : rqsort le_aAJ rge_aAM r_aAN)
qpart le_aAO (norecord@x_aAP) (norecord@(y_aAQ : ys_aAR)) rlt_aAS
  rge_aAT (norecord@r_aAU)
  = if le_aAO x_aAP y_aAQ then
      qpart le_aAO x_aAP ys_aAR rlt_aAS (y_aAQ : rge_aAT) r_aAU else
      qpart le_aAO x_aAP ys_aAR (y_aAQ : rlt_aAS) rge_aAT r_aAU
rqsort le_aAV [] r_aAW = r_aAW
rqsort le_aAX [x_aAY] r_aAZ = x_aAY : r_aAZ
rqsort le_aB0 (x_aB1 : xs_aB2) r_aB3
  = rqpart le_aB0 x_aB1 xs_aB2 [] [] r_aB3
rqpart le_aB4 x_aB5 [] (norecord@rle_aB6) rgt_aB7 (!r_aB8)
  = qsort le_aB4 rle_aB6 (x_aB5 : qsort le_aB4 rgt_aB7 r_aB8)
rqpart (norecord@le_aB9) x_aBa (norecord@(y_aBb : ys_aBc)) rle_aBd
  rgt_aBe r_aBf
  = if le_aB9 y_aBb x_aBa then
      rqpart le_aB9 x_aBa ys_aBc (y_aBb : rle_aBd) rgt_aBe r_aBf else
      rqpart le_aB9 x_aBa ys_aBc rle_aBd (y_aBb : rgt_aBe) r_aBf

==================== Renamer ====================
StateMonad.retURN :: a_anI -> StateMonad.SM s_anJ a_anI
StateMonad.retURN (!x_anK) = \ (!s_anL) -> (s_anL, x_anK)
StateMonad.bind ::
  StateMonad.SM s_anF a_anG
  -> (a_anG -> StateMonad.SM s_anF b_anH)
     -> StateMonad.SM s_anF b_anH
StateMonad.bind m_anM f_anN
  = \ (!s_anO)
      -> let (s'_anP, a_anQ) = m_anM s_anO in f_anN a_anQ s'_anP
StateMonad.join ::
  StateMonad.SM s_anD (StateMonad.SM s_anD a_anE)
  -> StateMonad.SM s_anD a_anE
StateMonad.join m_anR
  = \ s_anS -> let (!(s'_anT, ma_anU)) = m_anR s_anS in ma_anU s'_anT
StateMonad.mmap ::
  (a_anA -> b_anB)
  -> (StateMonad.SM s_anC a_anA -> StateMonad.SM s_anC b_anB)
StateMonad.mmap f_anV (!m_anW)
  = \ s_anX
      -> let (s'_anY, (!a_anZ)) = m_anW s_anX in (s'_anY, f_anV a_anZ)
StateMonad.mmapl ::
  (a_anx -> StateMonad.SM s_any b_anz)
  -> ([a_anx] -> StateMonad.SM s_any [b_anz])
StateMonad.mmapl f_ao0 (![]) = StateMonad.retURN []
StateMonad.mmapl f_ao1 ((!(a_ao2 : (!as_ao3))))
  = f_ao1 a_ao2
    `StateMonad.bind`
      \ (!b_ao4)
        -> StateMonad.mmapl f_ao1 as_ao3
           `StateMonad.bind` \ bs_ao5 -> StateMonad.retURN (b_ao4 : bs_ao5)
StateMonad.mmapr ::
  (a_anu -> StateMonad.SM s_anv b_anw)
  -> ([a_anu] -> StateMonad.SM s_anv [b_anw])
StateMonad.mmapr f_ao6 (![]) = StateMonad.retURN []
StateMonad.mmapr (!f_ao7) ((!x_ao8) : (!xs_ao9))
  = StateMonad.mmapr f_ao7 xs_ao9
    `StateMonad.bind`
      \ (!ys_aoa)
        -> f_ao7 x_ao8
           `StateMonad.bind` \ (!y_aob) -> StateMonad.retURN (y_aob : ys_aoa)
StateMonad.mfoldl ::
  (a_anr -> b_ans -> StateMonad.SM s_ant a_anr)
  -> a_anr -> [b_ans] -> StateMonad.SM s_ant a_anr
StateMonad.mfoldl (!f_aoc) a_aod [] = StateMonad.retURN a_aod
StateMonad.mfoldl (!f_aoe) (!a_aof) ((!((!x_aog) : xs_aoh)))
  = f_aoe a_aof x_aog
    `StateMonad.bind`
      \ fax_aoi -> StateMonad.mfoldl f_aoe fax_aoi xs_aoh
StateMonad.mfoldr ::
  (a_ano -> b_anp -> StateMonad.SM s_anq b_anp)
  -> b_anp -> [a_ano] -> StateMonad.SM s_anq b_anp
StateMonad.mfoldr f_aoj a_aok (![]) = StateMonad.retURN a_aok
StateMonad.mfoldr f_aol a_aom (!((!(x_aon : (!xs_aoo)))))
  = StateMonad.mfoldr f_aol a_aom xs_aoo
    `StateMonad.bind` \ (!y_aop) -> f_aol x_aon y_aop
StateMonad.mif ::
  StateMonad.SM s_anm Bool
  -> StateMonad.SM s_anm a_ann
     -> StateMonad.SM s_anm a_ann -> StateMonad.SM s_anm a_ann
StateMonad.mif c_aoq t_aor f_aos
  = c_aoq
    `StateMonad.bind` \ cond_aot -> if cond_aot then t_aor else f_aos
StateMonad.startingWith ::
  StateMonad.SM s_ank a_anl -> s_ank -> a_anl
StateMonad.startingWith (!m_aou) (!v_aov)
  = answer_aox
  where
      ((!final_aow), answer_aox) = m_aou v_aov
StateMonad.fetch :: StateMonad.SM s_anj s_anj
StateMonad.fetch = \ s_aoy -> (s_aoy, s_aoy)
StateMonad.fetchWith ::
  (s_anh -> a_ani) -> StateMonad.SM s_anh a_ani
StateMonad.fetchWith (!f_aoz) = \ s_aoA -> (s_aoA, f_aoz s_aoA)
StateMonad.update :: (s_ang -> s_ang) -> StateMonad.SM s_ang s_ang
StateMonad.update (!f_aoB) = \ s_aoC -> (f_aoB s_aoC, s_aoC)
StateMonad.set :: s_anf -> StateMonad.SM s_anf s_anf
StateMonad.set s'_aoD = \ s_aoE -> (s'_aoD, s_aoE)
StateMonad.incr :: StateMonad.SM Int Int
StateMonad.incr = StateMonad.update (1 +)

type StateMonad.SM s_an6 a_an7 = s_an6 -> (s_an6, a_an7)


["x_anK","safebang@!x_anK","(!x_anK)","s_anL","!s_anL","(!s_anL)","m_anM","f_anN","s_anO","safebang@!s_anO","(!s_anO)","s'_anP","a_anQ","(s'_anP, a_anQ)","m_anR","s_anS","s'_anT","ma_anU","(s'_anT, ma_anU)","!(s'_anT, ma_anU)","(!(s'_anT, ma_anU))","f_anV","m_anW","safebang@!m_anW","(!m_anW)","s_anX","s'_anY","a_anZ","!a_anZ","(!a_anZ)","(s'_anY, (!a_anZ))","f_ao0","[]","![]","(![])","f_ao1","a_ao2","as_ao3","safebang@!as_ao3","(!as_ao3)","a_ao2 : (!as_ao3)","(a_ao2 : (!as_ao3))","!(a_ao2 : (!as_ao3))","(!(a_ao2 : (!as_ao3)))","((!(a_ao2 : (!as_ao3))))","b_ao4","!b_ao4","(!b_ao4)","bs_ao5","f_ao6","[]","![]","(![])","f_ao7","!f_ao7","(!f_ao7)","x_ao8","!x_ao8","(!x_ao8)","xs_ao9","!xs_ao9","(!xs_ao9)","(!x_ao8) : (!xs_ao9)","((!x_ao8) : (!xs_ao9))","ys_aoa","!ys_aoa","(!ys_aoa)","y_aob","!y_aob","(!y_aob)","f_aoc","safebang@!f_aoc","(!f_aoc)","a_aod","[]","f_aoe","!f_aoe","(!f_aoe)","a_aof","!a_aof","(!a_aof)","x_aog","!x_aog","(!x_aog)","xs_aoh","(!x_aog) : xs_aoh","((!x_aog) : xs_aoh)","!((!x_aog) : xs_aoh)","(!((!x_aog) : xs_aoh))","((!((!x_aog) : xs_aoh)))","fax_aoi","f_aoj","a_aok","[]","![]","(![])","f_aol","a_aom","x_aon","xs_aoo","!xs_aoo","(!xs_aoo)","x_aon : (!xs_aoo)","(x_aon : (!xs_aoo))","!(x_aon : (!xs_aoo))","(!(x_aon : (!xs_aoo)))","((!(x_aon : (!xs_aoo))))","!((!(x_aon : (!xs_aoo))))","(!((!(x_aon : (!xs_aoo)))))","y_aop","!y_aop","(!y_aop)","c_aoq","t_aor","f_aos","cond_aot","m_aou","safebang@!m_aou","(!m_aou)","v_aov","safebang@!v_aov","(!v_aov)","final_aow","!final_aow","(!final_aow)","answer_aox","((!final_aow), answer_aox)","fetch","s_aoy","f_aoz","safebang@!f_aoz","(!f_aoz)","s_aoA","f_aoB","safebang@!f_aoB","(!f_aoB)","s_aoC","s'_aoD","s_aoE","incr"]
module StateMonad where

retURN :: a_anI -> SM s_anJ a_anI
retURN (!x_anK) = \ (norecord@s_anL) -> (s_anL, x_anK)

bind ::
     SM s_anF a_anG -> (a_anG -> SM s_anF b_anH) -> SM s_anF b_anH
bind m_anM f_anN
  = \ (!s_anO) ->
      let (s'_anP, a_anQ) = m_anM s_anO in f_anN a_anQ s'_anP

join :: SM s_anD (SM s_anD a_anE) -> SM s_anD a_anE
join m_anR
  = \ s_anS ->
      let (norecord@(s'_anT, ma_anU)) = m_anR s_anS in ma_anU s'_anT

mmap :: (a_anA -> b_anB) -> (SM s_anC a_anA -> SM s_anC b_anB)
mmap f_anV (!m_anW)
  = \ s_anX ->
      let (s'_anY, (norecord@a_anZ)) = m_anW s_anX in
        (s'_anY, f_anV a_anZ)

mmapl :: (a_anx -> SM s_any b_anz) -> ([a_anx] -> SM s_any [b_anz])
mmapl f_ao0 (norecord@[]) = retURN []
mmapl f_ao1 ((norecord@(a_ao2 : (!as_ao3))))
  = f_ao1 a_ao2 `bind`
      \ (norecord@b_ao4) ->
        mmapl f_ao1 as_ao3 `bind` \ bs_ao5 -> retURN (b_ao4 : bs_ao5)

mmapr :: (a_anu -> SM s_anv b_anw) -> ([a_anu] -> SM s_anv [b_anw])
mmapr f_ao6 (norecord@[]) = retURN []
mmapr (norecord@f_ao7) ((norecord@x_ao8) : (norecord@xs_ao9))
  = mmapr f_ao7 xs_ao9 `bind`
      \ (norecord@ys_aoa) ->
        f_ao7 x_ao8 `bind` \ (norecord@y_aob) -> retURN (y_aob : ys_aoa)

mfoldl ::
       (a_anr -> b_ans -> SM s_ant a_anr) ->
         a_anr -> [b_ans] -> SM s_ant a_anr
mfoldl (!f_aoc) a_aod [] = retURN a_aod
mfoldl (norecord@f_aoe) (norecord@a_aof)
  ((norecord@((norecord@x_aog) : xs_aoh)))
  = f_aoe a_aof x_aog `bind` \ fax_aoi -> mfoldl f_aoe fax_aoi xs_aoh

mfoldr ::
       (a_ano -> b_anp -> SM s_anq b_anp) ->
         b_anp -> [a_ano] -> SM s_anq b_anp
mfoldr f_aoj a_aok (norecord@[]) = retURN a_aok
mfoldr f_aol a_aom
  (norecord@((norecord@(x_aon : (norecord@xs_aoo)))))
  = mfoldr f_aol a_aom xs_aoo `bind`
      \ (norecord@y_aop) -> f_aol x_aon y_aop

mif ::
    SM s_anm Bool -> SM s_anm a_ann -> SM s_anm a_ann -> SM s_anm a_ann
mif c_aoq t_aor f_aos
  = c_aoq `bind` \ cond_aot -> if cond_aot then t_aor else f_aos

startingWith :: SM s_ank a_anl -> s_ank -> a_anl
startingWith (!m_aou) (!v_aov) = answer_aox
  where ((norecord@final_aow), answer_aox) = m_aou v_aov

fetch :: SM s_anj s_anj
fetch = \ s_aoy -> (s_aoy, s_aoy)

fetchWith :: (s_anh -> a_ani) -> SM s_anh a_ani
fetchWith (!f_aoz) = \ s_aoA -> (s_aoA, f_aoz s_aoA)

update :: (s_ang -> s_ang) -> SM s_ang s_ang
update (!f_aoB) = \ s_aoC -> (f_aoB s_aoC, s_aoC)

set :: s_anf -> SM s_anf s_anf
set s'_aoD = \ s_aoE -> (s'_aoD, s_aoE)

incr :: SM Int Int
incr = update (1 +)

type SM s_an6 a_an7 = s_an6 -> (s_an6, a_an7)

==================== Renamer ====================
Main.main
  = interact
      (("\n\
        \Hi! I'm Eliza. I am your personal therapy computer.\n\
        \Please tell me your problem.\n\
        \\n"
        ++)
       . Main.session Main.initial []
         . filter (not . null) . map (words . Main.trim) . lines)
Main.trim :: String -> String
Main.trim
  = foldr cons_aYJ "" . dropWhile (`elem` punct_aYK)
  where
      cons_aYJ (!x_aYL) (!xs_aYM)
        | x_aYL `elem` punct_aYK && null xs_aYM = []
        | otherwise = x_aYL : xs_aYM
      (!punct_aYK) = [' ', '.', '!', '?', ',']
Main.session :: Main.State -> Main.Words -> [Main.Words] -> String
Main.session rs_aYN (!prev_aYO) (![]) = []
Main.session (!rs_aYP) (!prev_aYQ) (!((!(l_aYR : ls_aYS))))
  = response_aYT
    ++
      "\n\
      \\n"
      ++ Main.session rs'_aYU l_aYR ls_aYS
  where
      (!(response_aYT, (!rs'_aYU)))
        | prev_aYQ == l_aYR = Main.repeated rs_aYP
        | otherwise = Main.answer rs_aYP l_aYR
Main.answer :: Main.State -> Main.Words -> (String, Main.State)
Main.answer st_aYV (!l_aYW)
  = (response_aYX, Main.newKeyTab kt_aYY st_aYV)
  where
      (!((!response_aYX), (!kt_aYY))) = ans_aZ0 (Main.keyTabOf st_aYV)
      cons_aYZ e_aZ1 (!(r_aZ2, (!es_aZ3))) = (r_aZ2, e_aZ1 : es_aZ3)
      ans_aZ0 ((!e_aZ4) : (!es_aZ5))
        | null rs_aZ6 = e_aZ4 `cons_aYZ` ans_aZ0 es_aZ5
        | otherwise
        = (Main.makeResponse a_aZ8 (head rs_aZ6), 
           (key_aZ7, as_aZ9) : es_aZ5)
        where
            rs_aZ6 = Main.replies key_aZ7 l_aYW
            (!(key_aZ7, (!(a_aZ8 : as_aZ9)))) = e_aZ4
Main.replies :: Main.Words -> Main.Words -> [String]
Main.replies (!key_aZa) l_aZb
  = (map (Main.conjug l_aZb . drop (length key_aZa))
     . filter (Main.prefix key_aZa . map Main.ucase) . Main.tails)
      l_aZb
Main.prefix :: Eq a_auT => [a_auT] -> [a_auT] -> Bool
Main.prefix [] (!xs_aZc) = True
Main.prefix (!(x_aZd : xs_aZe)) [] = False
Main.prefix ((!((!x_aZf) : xs_aZg))) (!((!(y_aZh : ys_aZi))))
  = x_aZf == y_aZh && (xs_aZg `Main.prefix` ys_aZi)
Main.tails :: [a_auS] -> [[a_auS]]
Main.tails (![]) = []
Main.tails (!xs_aZj) = xs_aZj : Main.tails (tail xs_aZj)
Main.ucase :: String -> String
Main.ucase = map toUpper
Main.conjug :: Main.Words -> Main.Words -> String
Main.conjug (!d_aZG)
  = unwords . trailingI_aZJ . map conj_aZI . maybe_aZH d_aZG
  where
      maybe_aZH d_aZK xs_aZL = if null xs_aZL then d_aZK else xs_aZL
      conj_aZI w_aZM
        = head
            ([m_aZP |
                (!((!w'_aZO), (!m_aZP))) <- Main.conjugates, uw_aZN == w'_aZO]
             ++ [w_aZM])
        where
            (!uw_aZN) = Main.ucase w_aZM
      (!trailingI_aZJ)
        = foldr cons_aZQ []
        where
            cons_aZQ (!x_aZR) xs_aZS
              | x_aZR == "I" && null xs_aZS = ["me"]
              | otherwise = x_aZR : xs_aZS
Main.conjugates :: [(Main.Word, Main.Word)]
Main.conjugates
  = prepare_aZV
      (oneways_aZT
       ++
         concat
           [[(x_aZY, y_aZZ), (y_aZZ, x_aZY)] |
              (x_aZY, y_aZZ) <- bothways_aZU])
  where
      oneways_aZT = [("me", "you")]
      bothways_aZU
        = [("are", "am"), ("we're", "was"), ("you", "I"), ("your", "my"),
           ("I've", "you've"), ("I'm", "you're")]
      (!prepare_aZV)
        = map (\ (!(w_aZW, r_aZX)) -> (Main.ucase w_aZW, r_aZX))
Main.repeated :: Main.State -> (String, Main.State)
Main.repeated (!((!kt_a100), ((!r_a101) : (!rp_a102))))
  = (r_a101, (kt_a100, rp_a102))
Main.newKeyTab :: Main.KeyTable -> Main.State -> Main.State
Main.newKeyTab kt'_a103 ((!kt_a104), rp_a105) = (kt'_a103, rp_a105)
Main.keyTabOf :: Main.State -> Main.KeyTable
Main.keyTabOf ((!kt_a106), rp_a107) = kt_a106
Main.makeResponse :: String -> String -> String
Main.makeResponse ((!('?' : (!cs_a108)))) (!us_a109)
  = cs_a108 ++ " " ++ us_a109 ++ "?"
Main.makeResponse ('.' : (!cs_a10a)) us_a10b
  = cs_a10a ++ " " ++ us_a10b ++ "."
Main.makeResponse (!cs_a10c) us_a10d = cs_a10c
Main.initial :: Main.State
Main.initial
  = ([(words k_a10e, cycle rs_a10f) |
        (k_a10e, rs_a10f) <- Main.respMsgs], 
     cycle Main.repeatMsgs)
Main.repeatMsgs
  = ["Why did you repeat yourself?",
     "Do you expect a different answer by repeating yourself?",
     "Come, come, elucidate your thoughts.",
     "Please don't repeat yourself!"]
Main.respMsgs
  = [("CAN YOU", canYou_a10g), ("CAN I", canI_a10h),
     ("YOU ARE", youAre_a10i), ("YOU'RE", youAre_a10i),
     ("I DON'T", iDont_a10j), ("I FEEL", iFeel_a10k),
     ("WHY DON'T YOU", whyDont_a10l), ("WHY CAN'T I", whyCant_a10m),
     ("ARE YOU", areYou_a10n), ("I CAN'T", iCant_a10o),
     ("I AM", iAm_a10p), ("I'M", iAm_a10p), ("YOU", you_a10q),
     ("YES", yes_a10r), ("NO", no_a10s), ("COMPUTER", computer_a10t),
     ("COMPUTERS", computer_a10t), ("I WANT", iWant_a10u),
     ("WHAT", question_a10v), ("HOW", question_a10v),
     ("WHO", question_a10v), ("WHERE", question_a10v),
     ("WHEN", question_a10v), ("WHY", question_a10v),
     ("NAME", name_a10w), ("BECAUSE", because_a10x),
     ("CAUSE", because_a10x), ("SORRY", sorry_a10y),
     ("DREAM", dream_a10z), ("DREAMS", dream_a10z), ("HI", hello_a10A),
     ("HELLO", hello_a10A), ("MAYBE", maybe_a10B), ("YOUR", your_a10C),
     ("ALWAYS", always_a10D), ("THINK", think_a10E),
     ("ALIKE", alike_a10F), ("FRIEND", friend_a10G),
     ("FRIENDS", friend_a10G), ("", nokeyMsgs_a10H)]
  where
      canYou_a10g
        = ["?Don't you believe that I can",
           "?Perhaps you would like to be able to",
           "?You want me to be able to"]
      (!canI_a10h)
        = ["?Perhaps you don't want to", "?Do you want to be able to"]
      (!youAre_a10i)
        = ["?What makes you think I am",
           "?Does it please you to believe I am",
           "?Perhaps you would like to be", "?Do you sometimes wish you were"]
      iDont_a10j
        = ["?Don't you really", "?Why don't you",
           "?Do you wish to be able to", "Does that trouble you?"]
      iFeel_a10k
        = ["Tell me more about such feelings.", "?Do you often feel",
           "?Do you enjoy feeling"]
      (!whyDont_a10l)
        = ["?Do you really believe I don't",
           ".Perhaps in good time I will", "?Do you want me to"]
      (!whyCant_a10m)
        = ["?Do you think you should be able to", "?Why can't you"]
      areYou_a10n
        = ["?Why are you interested in whether or not I am",
           "?Would you prefer if I were not",
           "?Perhaps in your fantasies I am"]
      (!iCant_a10o)
        = ["?How do you know you can't", "Have you tried?",
           "?Perhaps you can now"]
      iAm_a10p
        = ["?Did you come to me because you are",
           "?How long have you been", "?Do you believe it is normal to be",
           "?Do you enjoy being"]
      (!you_a10q)
        = ["We were discussing you --not me.", "?Oh,",
           "You're not really talking about me, are you?"]
      yes_a10r
        = ["You seem quite positive.", "Are you Sure?", "I see.",
           "I understand."]
      (!no_a10s)
        = ["Are you saying no just to be negative?",
           "You are being a bit negative.", "Why not?", "Are you sure?",
           "Why no?"]
      computer_a10t
        = ["Do computers worry you?",
           "Are you talking about me in particular?",
           "Are you frightened by machines?", "Why do you mention computers?",
           "What do you think machines have to do with your problems?",
           "Don't you think computers can help people?",
           "What is it about machines that worries you?"]
      (!iWant_a10u)
        = ["?Why do you want", "?What would it mean to you if you got",
           "?Suppose you got", "?What if you never got",
           ".I sometimes also want"]
      (!question_a10v)
        = ["Why do you ask?", "Does that question interest you?",
           "What answer would please you the most?", "What do you think?",
           "Are such questions on your mind often?",
           "What is it that you really want to know?",
           "Have you asked anyone else?",
           "Have you asked such questions before?",
           "What else comes to mind when you ask that?"]
      (!name_a10w)
        = ["Names don't interest me.",
           "I don't care about names --please go on."]
      because_a10x
        = ["Is that the real reason?",
           "Don't any other reasons come to mind?",
           "Does that reason explain anything else?",
           "What other reasons might there be?"]
      sorry_a10y
        = ["Please don't apologise!", "Apologies are not necessary.",
           "What feelings do you have when you apologise?",
           "Don't be so defensive!"]
      dream_a10z
        = ["What does that dream suggest to you?", "Do you dream often?",
           "What persons appear in your dreams?",
           "Are you disturbed by your dreams?"]
      hello_a10A = ["How do you...please state your problem."]
      maybe_a10B
        = ["You don't seem quite certain.", "Why the uncertain tone?",
           "Can't you be more positive?", "You aren't sure?",
           "Don't you know?"]
      your_a10C
        = ["?Why are you concerned about my", "?What about your own"]
      always_a10D
        = ["Can you think of a specific example?", "When?",
           "What are you thinking of?", "Really, always?"]
      (!think_a10E)
        = ["Do you really think so?", "?But you are not sure you",
           "?Do you doubt you"]
      (!alike_a10F)
        = ["In what way?", "What resemblence do you see?",
           "What does the similarity suggest to you?",
           "What other connections do you see?",
           "Cound there really be some connection?", "How?"]
      (!friend_a10G)
        = ["Why do you bring up the topic of friends?",
           "Do your friends worry you?", "Do your friends pick on you?",
           "Are you sure you have any friends?",
           "Do you impose on your friends?",
           "Perhaps your love for friends worries you."]
      nokeyMsgs_a10H
        = ["I'm not sure I understand you fully.",
           "What does that suggest to you?", "I see.",
           "Can you elaborate on that?",
           "Say, do you have any psychological problems?"]

type Main.Word = String
type Main.Words = [Main.Word]
type Main.Replies = [String]
type Main.Key = Main.Words
type Main.KeyTable = [(Main.Key, Main.Replies)]
type Main.State = (Main.KeyTable, Main.Replies)


["main","trim","x_aYL","!x_aYL","(!x_aYL)","xs_aYM","!xs_aYM","(!xs_aYM)","punct_aYK","!punct_aYK","(!punct_aYK)","rs_aYN","prev_aYO","safebang@!prev_aYO","(!prev_aYO)","[]","![]","(![])","rs_aYP","!rs_aYP","(!rs_aYP)","prev_aYQ","!prev_aYQ","(!prev_aYQ)","l_aYR","ls_aYS","l_aYR : ls_aYS","(l_aYR : ls_aYS)","!(l_aYR : ls_aYS)","(!(l_aYR : ls_aYS))","((!(l_aYR : ls_aYS)))","!((!(l_aYR : ls_aYS)))","(!((!(l_aYR : ls_aYS))))","response_aYT","rs'_aYU","!rs'_aYU","(!rs'_aYU)","(response_aYT, (!rs'_aYU))","!(response_aYT, (!rs'_aYU))","(!(response_aYT, (!rs'_aYU)))","st_aYV","l_aYW","!l_aYW","(!l_aYW)","response_aYX","safebang@!response_aYX","(!response_aYX)","kt_aYY","safebang@!kt_aYY","(!kt_aYY)","((!response_aYX), (!kt_aYY))","!((!response_aYX), (!kt_aYY))","(!((!response_aYX), (!kt_aYY)))","e_aZ1","r_aZ2","es_aZ3","safebang@!es_aZ3","(!es_aZ3)","(r_aZ2, (!es_aZ3))","!(r_aZ2, (!es_aZ3))","(!(r_aZ2, (!es_aZ3)))","e_aZ4","!e_aZ4","(!e_aZ4)","es_aZ5","safebang@!es_aZ5","(!es_aZ5)","(!e_aZ4) : (!es_aZ5)","((!e_aZ4) : (!es_aZ5))","rs_aZ6","key_aZ7","a_aZ8","as_aZ9","a_aZ8 : as_aZ9","(a_aZ8 : as_aZ9)","!(a_aZ8 : as_aZ9)","(!(a_aZ8 : as_aZ9))","(key_aZ7, (!(a_aZ8 : as_aZ9)))","!(key_aZ7, (!(a_aZ8 : as_aZ9)))","(!(key_aZ7, (!(a_aZ8 : as_aZ9))))","key_aZa","!key_aZa","(!key_aZa)","l_aZb","[]","xs_aZc","safebang@!xs_aZc","(!xs_aZc)","x_aZd","xs_aZe","x_aZd : xs_aZe","(x_aZd : xs_aZe)","!(x_aZd : xs_aZe)","(!(x_aZd : xs_aZe))","[]","x_aZf","!x_aZf","(!x_aZf)","xs_aZg","(!x_aZf) : xs_aZg","((!x_aZf) : xs_aZg)","!((!x_aZf) : xs_aZg)","(!((!x_aZf) : xs_aZg))","((!((!x_aZf) : xs_aZg)))","y_aZh","ys_aZi","y_aZh : ys_aZi","(y_aZh : ys_aZi)","!(y_aZh : ys_aZi)","(!(y_aZh : ys_aZi))","((!(y_aZh : ys_aZi)))","!((!(y_aZh : ys_aZi)))","(!((!(y_aZh : ys_aZi))))","[]","![]","(![])","xs_aZj","!xs_aZj","(!xs_aZj)","ucase","d_aZG","!d_aZG","(!d_aZG)","d_aZK","xs_aZL","w_aZM","w'_aZO","safebang@!w'_aZO","(!w'_aZO)","m_aZP","safebang@!m_aZP","(!m_aZP)","((!w'_aZO), (!m_aZP))","!((!w'_aZO), (!m_aZP))","(!((!w'_aZO), (!m_aZP)))","uw_aZN","!uw_aZN","(!uw_aZN)","trailingI_aZJ","!trailingI_aZJ","(!trailingI_aZJ)","x_aZR","!x_aZR","(!x_aZR)","xs_aZS","conjugates","x_aZY","y_aZZ","(x_aZY, y_aZZ)","oneways_aZT","bothways_aZU","prepare_aZV","!prepare_aZV","(!prepare_aZV)","w_aZW","r_aZX","(w_aZW, r_aZX)","!(w_aZW, r_aZX)","(!(w_aZW, r_aZX))","kt_a100","!kt_a100","(!kt_a100)","r_a101","safebang@!r_a101","(!r_a101)","rp_a102","safebang@!rp_a102","(!rp_a102)","(!r_a101) : (!rp_a102)","((!r_a101) : (!rp_a102))","((!kt_a100), ((!r_a101) : (!rp_a102)))","!((!kt_a100), ((!r_a101) : (!rp_a102)))","(!((!kt_a100), ((!r_a101) : (!rp_a102))))","kt'_a103","kt_a104","!kt_a104","(!kt_a104)","rp_a105","((!kt_a104), rp_a105)","kt_a106","!kt_a106","(!kt_a106)","rp_a107","((!kt_a106), rp_a107)","'?'","cs_a108","!cs_a108","(!cs_a108)","'?' : (!cs_a108)","('?' : (!cs_a108))","!('?' : (!cs_a108))","(!('?' : (!cs_a108)))","((!('?' : (!cs_a108))))","us_a109","!us_a109","(!us_a109)","'.'","cs_a10a","!cs_a10a","(!cs_a10a)","'.' : (!cs_a10a)","('.' : (!cs_a10a))","us_a10b","cs_a10c","!cs_a10c","(!cs_a10c)","us_a10d","initial","k_a10e","rs_a10f","(k_a10e, rs_a10f)","repeatMsgs","respMsgs","canYou_a10g","canI_a10h","!canI_a10h","(!canI_a10h)","youAre_a10i","!youAre_a10i","(!youAre_a10i)","iDont_a10j","iFeel_a10k","whyDont_a10l","!whyDont_a10l","(!whyDont_a10l)","whyCant_a10m","!whyCant_a10m","(!whyCant_a10m)","areYou_a10n","iCant_a10o","!iCant_a10o","(!iCant_a10o)","iAm_a10p","you_a10q","!you_a10q","(!you_a10q)","yes_a10r","no_a10s","!no_a10s","(!no_a10s)","computer_a10t","iWant_a10u","!iWant_a10u","(!iWant_a10u)","question_a10v","!question_a10v","(!question_a10v)","name_a10w","!name_a10w","(!name_a10w)","because_a10x","sorry_a10y","dream_a10z","hello_a10A","maybe_a10B","your_a10C","always_a10D","think_a10E","!think_a10E","(!think_a10E)","alike_a10F","!alike_a10F","(!alike_a10F)","friend_a10G","!friend_a10G","(!friend_a10G)","nokeyMsgs_a10H"]
module Main (main) where
import Data.Char
import Prelude hiding (Word)
main
  = interact
      (("\nHi! I'm Eliza. I am your personal therapy computer.\nPlease tell me your problem.\n\n" ++)
         . session initial []
         . filter (not . null)
         . map (words . trim)
         . lines)

trim :: String -> String
trim = foldr cons_aYJ "" . dropWhile (`elem` punct_aYK)
  where cons_aYJ (norecord@x_aYL) (norecord@xs_aYM)
          | x_aYL `elem` punct_aYK && null xs_aYM = []
          | otherwise = x_aYL : xs_aYM
        (norecord@punct_aYK) = [' ', '.', '!', '?', ',']

session :: State -> Words -> [Words] -> String
session rs_aYN (!prev_aYO) (norecord@[]) = []
session (norecord@rs_aYP) (norecord@prev_aYQ)
  (norecord@((norecord@(l_aYR : ls_aYS))))
  = response_aYT ++ "\n\n" ++ session rs'_aYU l_aYR ls_aYS
  where (norecord@(response_aYT, (norecord@rs'_aYU)))
          | prev_aYQ == l_aYR = repeated rs_aYP
          | otherwise = answer rs_aYP l_aYR

answer :: State -> Words -> (String, State)
answer st_aYV (norecord@l_aYW)
  = (response_aYX, newKeyTab kt_aYY st_aYV)
  where (norecord@((!response_aYX), (!kt_aYY)))
          = ans_aZ0 (keyTabOf st_aYV)
        cons_aYZ e_aZ1 (norecord@(r_aZ2, (!es_aZ3)))
          = (r_aZ2, e_aZ1 : es_aZ3)
        ans_aZ0 ((norecord@e_aZ4) : (!es_aZ5))
          | null rs_aZ6 = e_aZ4 `cons_aYZ` ans_aZ0 es_aZ5
          | otherwise =
            (makeResponse a_aZ8 (head rs_aZ6), (key_aZ7, as_aZ9) : es_aZ5)
          where rs_aZ6 = replies key_aZ7 l_aYW
                (norecord@(key_aZ7, (norecord@(a_aZ8 : as_aZ9)))) = e_aZ4

replies :: Words -> Words -> [String]
replies (norecord@key_aZa) l_aZb
  = (map (conjug l_aZb . drop (length key_aZa)) .
       filter (prefix key_aZa . map ucase)
       . tails)
      l_aZb

prefix :: Eq a_auT => [a_auT] -> [a_auT] -> Bool
prefix [] (!xs_aZc) = True
prefix (norecord@(x_aZd : xs_aZe)) [] = False
prefix ((norecord@((norecord@x_aZf) : xs_aZg)))
  (norecord@((norecord@(y_aZh : ys_aZi))))
  = x_aZf == y_aZh && (xs_aZg `prefix` ys_aZi)

tails :: [a_auS] -> [[a_auS]]
tails (norecord@[]) = []
tails (norecord@xs_aZj) = xs_aZj : tails (tail xs_aZj)

ucase :: String -> String
ucase = map toUpper

conjug :: Words -> Words -> String
conjug (norecord@d_aZG)
  = unwords . trailingI_aZJ . map conj_aZI . maybe_aZH d_aZG
  where maybe_aZH d_aZK xs_aZL
          = if null xs_aZL then d_aZK else xs_aZL
        conj_aZI w_aZM
          = head
              ([m_aZP | (norecord@((!w'_aZO), (!m_aZP))) <- conjugates,
                uw_aZN == w'_aZO]
                 ++ [w_aZM])
          where (norecord@uw_aZN) = ucase w_aZM
        (norecord@trailingI_aZJ) = foldr cons_aZQ []
          where cons_aZQ (norecord@x_aZR) xs_aZS
                  | x_aZR == "I" && null xs_aZS = ["me"]
                  | otherwise = x_aZR : xs_aZS

conjugates :: [(Word, Word)]
conjugates
  = prepare_aZV
      (oneways_aZT ++
         concat
           [[(x_aZY, y_aZZ), (y_aZZ, x_aZY)] |
            (x_aZY, y_aZZ) <- bothways_aZU])
  where oneways_aZT = [("me", "you")]
        bothways_aZU
          = [("are", "am"), ("we're", "was"), ("you", "I"), ("your", "my"),
             ("I've", "you've"), ("I'm", "you're")]
        (norecord@prepare_aZV)
          = map (\ (norecord@(w_aZW, r_aZX)) -> (ucase w_aZW, r_aZX))

repeated :: State -> (String, State)
repeated (norecord@((norecord@kt_a100), ((!r_a101) : (!rp_a102))))
  = (r_a101, (kt_a100, rp_a102))

newKeyTab :: KeyTable -> State -> State
newKeyTab kt'_a103 ((norecord@kt_a104), rp_a105)
  = (kt'_a103, rp_a105)

keyTabOf :: State -> KeyTable
keyTabOf ((norecord@kt_a106), rp_a107) = kt_a106

makeResponse :: String -> String -> String
makeResponse ((norecord@('?' : (norecord@cs_a108))))
  (norecord@us_a109) = cs_a108 ++ " " ++ us_a109 ++ "?"
makeResponse ('.' : (norecord@cs_a10a)) us_a10b
  = cs_a10a ++ " " ++ us_a10b ++ "."
makeResponse (norecord@cs_a10c) us_a10d = cs_a10c

initial :: State
initial
  = ([(words k_a10e, cycle rs_a10f) | (k_a10e, rs_a10f) <- respMsgs],
     cycle repeatMsgs)
repeatMsgs
  = ["Why did you repeat yourself?",
     "Do you expect a different answer by repeating yourself?",
     "Come, come, elucidate your thoughts.",
     "Please don't repeat yourself!"]
respMsgs
  = [("CAN YOU", canYou_a10g), ("CAN I", canI_a10h),
     ("YOU ARE", youAre_a10i), ("YOU'RE", youAre_a10i),
     ("I DON'T", iDont_a10j), ("I FEEL", iFeel_a10k),
     ("WHY DON'T YOU", whyDont_a10l), ("WHY CAN'T I", whyCant_a10m),
     ("ARE YOU", areYou_a10n), ("I CAN'T", iCant_a10o),
     ("I AM", iAm_a10p), ("I'M", iAm_a10p), ("YOU", you_a10q),
     ("YES", yes_a10r), ("NO", no_a10s), ("COMPUTER", computer_a10t),
     ("COMPUTERS", computer_a10t), ("I WANT", iWant_a10u),
     ("WHAT", question_a10v), ("HOW", question_a10v),
     ("WHO", question_a10v), ("WHERE", question_a10v),
     ("WHEN", question_a10v), ("WHY", question_a10v),
     ("NAME", name_a10w), ("BECAUSE", because_a10x),
     ("CAUSE", because_a10x), ("SORRY", sorry_a10y),
     ("DREAM", dream_a10z), ("DREAMS", dream_a10z), ("HI", hello_a10A),
     ("HELLO", hello_a10A), ("MAYBE", maybe_a10B), ("YOUR", your_a10C),
     ("ALWAYS", always_a10D), ("THINK", think_a10E),
     ("ALIKE", alike_a10F), ("FRIEND", friend_a10G),
     ("FRIENDS", friend_a10G), ("", nokeyMsgs_a10H)]
  where canYou_a10g
          = ["?Don't you believe that I can",
             "?Perhaps you would like to be able to",
             "?You want me to be able to"]
        (norecord@canI_a10h)
          = ["?Perhaps you don't want to", "?Do you want to be able to"]
        (norecord@youAre_a10i)
          = ["?What makes you think I am",
             "?Does it please you to believe I am",
             "?Perhaps you would like to be", "?Do you sometimes wish you were"]
        iDont_a10j
          = ["?Don't you really", "?Why don't you",
             "?Do you wish to be able to", "Does that trouble you?"]
        iFeel_a10k
          = ["Tell me more about such feelings.", "?Do you often feel",
             "?Do you enjoy feeling"]
        (norecord@whyDont_a10l)
          = ["?Do you really believe I don't",
             ".Perhaps in good time I will", "?Do you want me to"]
        (norecord@whyCant_a10m)
          = ["?Do you think you should be able to", "?Why can't you"]
        areYou_a10n
          = ["?Why are you interested in whether or not I am",
             "?Would you prefer if I were not",
             "?Perhaps in your fantasies I am"]
        (norecord@iCant_a10o)
          = ["?How do you know you can't", "Have you tried?",
             "?Perhaps you can now"]
        iAm_a10p
          = ["?Did you come to me because you are",
             "?How long have you been", "?Do you believe it is normal to be",
             "?Do you enjoy being"]
        (norecord@you_a10q)
          = ["We were discussing you --not me.", "?Oh,",
             "You're not really talking about me, are you?"]
        yes_a10r
          = ["You seem quite positive.", "Are you Sure?", "I see.",
             "I understand."]
        (norecord@no_a10s)
          = ["Are you saying no just to be negative?",
             "You are being a bit negative.", "Why not?", "Are you sure?",
             "Why no?"]
        computer_a10t
          = ["Do computers worry you?",
             "Are you talking about me in particular?",
             "Are you frightened by machines?", "Why do you mention computers?",
             "What do you think machines have to do with your problems?",
             "Don't you think computers can help people?",
             "What is it about machines that worries you?"]
        (norecord@iWant_a10u)
          = ["?Why do you want", "?What would it mean to you if you got",
             "?Suppose you got", "?What if you never got",
             ".I sometimes also want"]
        (norecord@question_a10v)
          = ["Why do you ask?", "Does that question interest you?",
             "What answer would please you the most?", "What do you think?",
             "Are such questions on your mind often?",
             "What is it that you really want to know?",
             "Have you asked anyone else?",
             "Have you asked such questions before?",
             "What else comes to mind when you ask that?"]
        (norecord@name_a10w)
          = ["Names don't interest me.",
             "I don't care about names --please go on."]
        because_a10x
          = ["Is that the real reason?",
             "Don't any other reasons come to mind?",
             "Does that reason explain anything else?",
             "What other reasons might there be?"]
        sorry_a10y
          = ["Please don't apologise!", "Apologies are not necessary.",
             "What feelings do you have when you apologise?",
             "Don't be so defensive!"]
        dream_a10z
          = ["What does that dream suggest to you?", "Do you dream often?",
             "What persons appear in your dreams?",
             "Are you disturbed by your dreams?"]
        hello_a10A = ["How do you...please state your problem."]
        maybe_a10B
          = ["You don't seem quite certain.", "Why the uncertain tone?",
             "Can't you be more positive?", "You aren't sure?",
             "Don't you know?"]
        your_a10C
          = ["?Why are you concerned about my", "?What about your own"]
        always_a10D
          = ["Can you think of a specific example?", "When?",
             "What are you thinking of?", "Really, always?"]
        (norecord@think_a10E)
          = ["Do you really think so?", "?But you are not sure you",
             "?Do you doubt you"]
        (norecord@alike_a10F)
          = ["In what way?", "What resemblence do you see?",
             "What does the similarity suggest to you?",
             "What other connections do you see?",
             "Cound there really be some connection?", "How?"]
        (norecord@friend_a10G)
          = ["Why do you bring up the topic of friends?",
             "Do your friends worry you?", "Do your friends pick on you?",
             "Are you sure you have any friends?",
             "Do you impose on your friends?",
             "Perhaps your love for friends worries you."]
        nokeyMsgs_a10H
          = ["I'm not sure I understand you fully.",
             "What does that suggest to you?", "I see.",
             "Can you elaborate on that?",
             "Say, do you have any psychological problems?"]

type Word = String

type Words = [Word]

type Replies = [String]

type Key = Words

type KeyTable = [(Key, Replies)]

type State = (KeyTable, Replies)

==================== Renamer ====================
Main.main
  = do { ((!((!n_ap3) : _))) <- getArgs;
         putStr (Main.res (read n_ap3)) }
Main.res n_atA
  = concat (map Main.clauses xs_atB)
  where
      xs_atB
        = take n_atA (repeat "(a = a = a) = (a = a = a) = (a = a = a)")
      {-# NOINLINE xs_atB #-}
Main.clause (!p_aD7)
  = clause'_aD8 p_aD7 ([], [])
  where
      clause'_aD8 ((!(Main.Dis (!p_aD9) (!q_aDa)))) x_aDb
        = clause'_aD8 p_aD9 (clause'_aD8 q_aDa x_aDb)
      clause'_aD8 (!(Main.Sym s_aDc)) (!(c_aDd, (!a_aDe)))
        = (Main.insert s_aDc c_aDd, a_aDe)
      clause'_aD8 (!((!(Main.Not (Main.Sym s_aDf))))) (c_aDg, (!a_aDh))
        = (c_aDg, Main.insert s_aDf a_aDh)
Main.clauses
  = concat
    . map Main.disp
      . Main.unicl
        . Main.split . Main.disin . Main.negin . Main.elim . Main.parse
Main.conjunct (!(Main.Con (!p_aDi) (!q_aDj))) = True
Main.conjunct (!p_aDk) = False
Main.disin (!((!(Main.Dis (!p_aDl) ((!(Main.Con q_aDm r_aDn)))))))
  = Main.Con
      (Main.disin (Main.Dis p_aDl q_aDm))
      (Main.disin (Main.Dis p_aDl r_aDn))
Main.disin (Main.Dis (!(Main.Con (!p_aDo) q_aDp)) (!r_aDq))
  = Main.Con
      (Main.disin (Main.Dis p_aDo r_aDq))
      (Main.disin (Main.Dis q_aDp r_aDq))
Main.disin (!((!(Main.Dis (!p_aDr) (!q_aDs)))))
  = if Main.conjunct dp_aDt || Main.conjunct dq_aDu then
        Main.disin (Main.Dis dp_aDt dq_aDu)
    else
        (Main.Dis dp_aDt dq_aDu)
  where
      dp_aDt = Main.disin p_aDr
      (!dq_aDu) = Main.disin q_aDs
Main.disin (Main.Con (!p_aQW) q_aQX)
  = Main.Con (Main.disin p_aQW) (Main.disin q_aQX)
Main.disin (!p_aQY) = p_aQY
Main.disp (l_aQZ, (!r_aR0))
  = Main.interleave l_aQZ Main.spaces
    ++ "<=" ++ Main.interleave Main.spaces r_aR0 ++ "\n"
Main.elim (Main.Sym (!s_aR1)) = Main.Sym s_aR1
Main.elim (!(Main.Not (!p_aR2))) = Main.Not (Main.elim p_aR2)
Main.elim ((!(Main.Dis p_aR3 (!q_aR4))))
  = Main.Dis (Main.elim p_aR3) (Main.elim q_aR4)
Main.elim (!((!(Main.Con (!p_aR5) q_aR6))))
  = Main.Con (Main.elim p_aR5) (Main.elim q_aR6)
Main.elim ((!(Main.Imp p_aR7 (!q_aR8))))
  = Main.Dis (Main.Not (Main.elim p_aR7)) (Main.elim q_aR8)
Main.elim (Main.Eqv (!f_aR9) (!f'_aRa))
  = Main.Con
      (Main.elim (Main.Imp f_aR9 f'_aRa))
      (Main.elim (Main.Imp f'_aRa f_aR9))
Main.insert x_aRb [] = [x_aRb]
Main.insert x_aRc p_aRd@(y_aRe : ys_aRf)
  = if x_aRc < y_aRe then
        x_aRc : p_aRd
    else
        if x_aRc > y_aRe then y_aRe : Main.insert x_aRc ys_aRf else p_aRd
Main.interleave ((!((!x_aRg) : xs_aRh))) ys_aRi
  = x_aRg : Main.interleave ys_aRi xs_aRh
Main.interleave [] (!_) = []
Main.negin (!(Main.Not ((!(Main.Not p_aRj))))) = Main.negin p_aRj
Main.negin ((!(Main.Not (!(Main.Con p_aRk (!q_aRl))))))
  = Main.Dis
      (Main.negin (Main.Not p_aRk)) (Main.negin (Main.Not q_aRl))
Main.negin (Main.Not ((!(Main.Dis p_aRm q_aRn))))
  = Main.Con
      (Main.negin (Main.Not p_aRm)) (Main.negin (Main.Not q_aRn))
Main.negin (!((!(Main.Dis (!p_aRo) (!q_aRp)))))
  = Main.Dis (Main.negin p_aRo) (Main.negin q_aRp)
Main.negin (!(Main.Con (!p_aRq) q_aRr))
  = Main.Con (Main.negin p_aRq) (Main.negin q_aRr)
Main.negin (!p_aRs) = p_aRs
Main.opri '(' = 0
Main.opri (!'=') = 1
Main.opri '>' = 2
Main.opri (!'|') = 3
Main.opri '&' = 4
Main.opri '~' = 5
Main.parse t_aRt
  = f_aRu
  where
      [Main.Ast f_aRu] = Main.parse' t_aRt []
Main.parse' [] (!s_aRv) = Main.redstar s_aRv
Main.parse' (!(' ' : (!t_aRw))) (!s_aRx) = Main.parse' t_aRw s_aRx
Main.parse' ((!((!'(') : t_aRy))) (!s_aRz)
  = Main.parse' t_aRy (Main.Lex '(' : s_aRz)
Main.parse' (!((!((!')') : t_aRA)))) (!s_aRB)
  = Main.parse' t_aRA (x_aRC : s'_aRD)
  where
      ((!(x_aRC : (!((!(Main.Lex (!'('))) : (!s'_aRD))))))
        = Main.redstar s_aRB
Main.parse' ((!c_aRE) : t_aRF) (!s_aRG)
  = if inRange ('a', 'z') c_aRE then
        Main.parse' t_aRF (Main.Ast (Main.Sym c_aRE) : s_aRG)
    else
        if Main.spri s_aRG > Main.opri c_aRE then
            Main.parse' (c_aRE : t_aRF) (Main.red s_aRG)
        else
            Main.parse' t_aRF (Main.Lex c_aRE : s_aRG)
Main.red
  ((!(Main.Ast p_aZM : (!(Main.Lex (!'=') : (Main.Ast q_aZN : (!s_aZO)))))))
  = Main.Ast (Main.Eqv q_aZN p_aZM) : s_aZO
Main.red
  (!((!(Main.Ast (!p_aZP) : (Main.Lex '>' : (!((!(Main.Ast (!q_aZQ))) : (!s_aZR))))))))
  = Main.Ast (Main.Imp q_aZQ p_aZP) : s_aZR
Main.red
  ((!(Main.Ast p_aZS : (!(Main.Lex (!'|') : (!(Main.Ast q_aZT : s_aZU)))))))
  = Main.Ast (Main.Dis q_aZT p_aZS) : s_aZU
Main.red
  ((!(Main.Ast p_aZV : (Main.Lex (!'&') : (!((!(Main.Ast q_aZW)) : s_aZX))))))
  = Main.Ast (Main.Con q_aZW p_aZV) : s_aZX
Main.red (!((!(Main.Ast (!p_aZY) : (Main.Lex '~' : (!s_aZZ))))))
  = Main.Ast (Main.Not p_aZY) : s_aZZ
Main.redstar = Main.while ((/=) 0 . Main.spri) Main.red
Main.spaces = repeat ' '
Main.split (!p_a100)
  = split'_a101 p_a100 []
  where
      split'_a101 ((!(Main.Con p_a102 (!q_a103)))) (!a_a104)
        = split'_a101 p_a102 (split'_a101 q_a103 a_a104)
      split'_a101 p_a105 (!a_a106) = p_a105 : a_a106
Main.spri
  ((!(Main.Ast x_a107 : ((!(Main.Lex (!c_a108))) : (!s_a109)))))
  = Main.opri c_a108
Main.spri (!s_a10a) = 0
Main.tautclause (!(c_a10b, (!a_a10c)))
  = [x_a10d | x_a10d <- c_a10b, x_a10d `elem` a_a10c] /= []
Main.unicl a_a10e
  = foldr unicl'_a10f [] a_a10e
  where
      unicl'_a10f p_a10g x_a10h
        = if Main.tautclause cp_a10i then
              x_a10h
          else
              Main.insert cp_a10i x_a10h
        where
            cp_a10i = Main.clause p_a10g
Main.while (!p_a10j) (!f_a10k) (!x_a10l)
  = if p_a10j x_a10l then
        Main.while p_a10j f_a10k (f_a10k x_a10l)
    else
        x_a10l

data Main.Formula
  = Main.Sym Char |
    Main.Not Main.Formula |
    Main.Dis Main.Formula Main.Formula |
    Main.Con Main.Formula Main.Formula |
    Main.Imp Main.Formula Main.Formula |
    Main.Eqv Main.Formula Main.Formula
data Main.StackFrame = Main.Ast Main.Formula | Main.Lex Char


["main","n_ap3","safebang@!n_ap3","(!n_ap3)","_","(!n_ap3) : _","((!n_ap3) : _)","!((!n_ap3) : _)","(!((!n_ap3) : _))","((!((!n_ap3) : _)))","n_atA","xs_atB","p_aD7","!p_aD7","(!p_aD7)","p_aD9","safebang@!p_aD9","(!p_aD9)","q_aDa","safebang@!q_aDa","(!q_aDa)","Dis (!p_aD9) (!q_aDa)","(Dis (!p_aD9) (!q_aDa))","!(Dis (!p_aD9) (!q_aDa))","(!(Dis (!p_aD9) (!q_aDa)))","((!(Dis (!p_aD9) (!q_aDa))))","x_aDb","s_aDc","Sym s_aDc","(Sym s_aDc)","!(Sym s_aDc)","(!(Sym s_aDc))","c_aDd","a_aDe","safebang@!a_aDe","(!a_aDe)","(c_aDd, (!a_aDe))","!(c_aDd, (!a_aDe))","(!(c_aDd, (!a_aDe)))","s_aDf","Sym s_aDf","(Sym s_aDf)","Not (Sym s_aDf)","(Not (Sym s_aDf))","!(Not (Sym s_aDf))","(!(Not (Sym s_aDf)))","((!(Not (Sym s_aDf))))","!((!(Not (Sym s_aDf))))","(!((!(Not (Sym s_aDf)))))","c_aDg","a_aDh","safebang@!a_aDh","(!a_aDh)","(c_aDg, (!a_aDh))","clauses","p_aDi","safebang@!p_aDi","(!p_aDi)","q_aDj","safebang@!q_aDj","(!q_aDj)","Con (!p_aDi) (!q_aDj)","(Con (!p_aDi) (!q_aDj))","!(Con (!p_aDi) (!q_aDj))","(!(Con (!p_aDi) (!q_aDj)))","p_aDk","!p_aDk","(!p_aDk)","p_aDl","safebang@!p_aDl","(!p_aDl)","q_aDm","r_aDn","Con q_aDm r_aDn","(Con q_aDm r_aDn)","!(Con q_aDm r_aDn)","(!(Con q_aDm r_aDn))","((!(Con q_aDm r_aDn)))","Dis (!p_aDl) ((!(Con q_aDm r_aDn)))","(Dis (!p_aDl) ((!(Con q_aDm r_aDn))))","!(Dis (!p_aDl) ((!(Con q_aDm r_aDn))))","(!(Dis (!p_aDl) ((!(Con q_aDm r_aDn)))))","((!(Dis (!p_aDl) ((!(Con q_aDm r_aDn))))))","!((!(Dis (!p_aDl) ((!(Con q_aDm r_aDn))))))","(!((!(Dis (!p_aDl) ((!(Con q_aDm r_aDn)))))))","p_aDo","safebang@!p_aDo","(!p_aDo)","q_aDp","Con (!p_aDo) q_aDp","(Con (!p_aDo) q_aDp)","!(Con (!p_aDo) q_aDp)","(!(Con (!p_aDo) q_aDp))","r_aDq","lazydmd@!r_aDq","(!r_aDq)","Dis (!(Con (!p_aDo) q_aDp)) (!r_aDq)","(Dis (!(Con (!p_aDo) q_aDp)) (!r_aDq))","p_aDr","safebang@!p_aDr","(!p_aDr)","q_aDs","safebang@!q_aDs","(!q_aDs)","Dis (!p_aDr) (!q_aDs)","(Dis (!p_aDr) (!q_aDs))","!(Dis (!p_aDr) (!q_aDs))","(!(Dis (!p_aDr) (!q_aDs)))","((!(Dis (!p_aDr) (!q_aDs))))","!((!(Dis (!p_aDr) (!q_aDs))))","(!((!(Dis (!p_aDr) (!q_aDs)))))","dp_aDt","dq_aDu","!dq_aDu","(!dq_aDu)","p_aQW","safebang@!p_aQW","(!p_aQW)","q_aQX","Con (!p_aQW) q_aQX","(Con (!p_aQW) q_aQX)","p_aQY","!p_aQY","(!p_aQY)","l_aQZ","r_aR0","safebang@!r_aR0","(!r_aR0)","(l_aQZ, (!r_aR0))","s_aR1","safebang@!s_aR1","(!s_aR1)","Sym (!s_aR1)","(Sym (!s_aR1))","p_aR2","safebang@!p_aR2","(!p_aR2)","Not (!p_aR2)","(Not (!p_aR2))","!(Not (!p_aR2))","(!(Not (!p_aR2)))","p_aR3","q_aR4","safebang@!q_aR4","(!q_aR4)","Dis p_aR3 (!q_aR4)","(Dis p_aR3 (!q_aR4))","!(Dis p_aR3 (!q_aR4))","(!(Dis p_aR3 (!q_aR4)))","((!(Dis p_aR3 (!q_aR4))))","p_aR5","safebang@!p_aR5","(!p_aR5)","q_aR6","Con (!p_aR5) q_aR6","(Con (!p_aR5) q_aR6)","!(Con (!p_aR5) q_aR6)","(!(Con (!p_aR5) q_aR6))","((!(Con (!p_aR5) q_aR6)))","!((!(Con (!p_aR5) q_aR6)))","(!((!(Con (!p_aR5) q_aR6))))","p_aR7","q_aR8","safebang@!q_aR8","(!q_aR8)","Imp p_aR7 (!q_aR8)","(Imp p_aR7 (!q_aR8))","!(Imp p_aR7 (!q_aR8))","(!(Imp p_aR7 (!q_aR8)))","((!(Imp p_aR7 (!q_aR8))))","f_aR9","safebang@!f_aR9","(!f_aR9)","f'_aRa","safebang@!f'_aRa","(!f'_aRa)","Eqv (!f_aR9) (!f'_aRa)","(Eqv (!f_aR9) (!f'_aRa))","x_aRb","[]","x_aRc","y_aRe","ys_aRf","y_aRe : ys_aRf","(y_aRe : ys_aRf)","p_aRd@(y_aRe : ys_aRf)","x_aRg","safebang@!x_aRg","(!x_aRg)","xs_aRh","(!x_aRg) : xs_aRh","((!x_aRg) : xs_aRh)","!((!x_aRg) : xs_aRh)","(!((!x_aRg) : xs_aRh))","((!((!x_aRg) : xs_aRh)))","ys_aRi","[]","_","!_","(!_)","p_aRj","Not p_aRj","(Not p_aRj)","!(Not p_aRj)","(!(Not p_aRj))","((!(Not p_aRj)))","Not ((!(Not p_aRj)))","(Not ((!(Not p_aRj))))","!(Not ((!(Not p_aRj))))","(!(Not ((!(Not p_aRj)))))","p_aRk","q_aRl","safebang@!q_aRl","(!q_aRl)","Con p_aRk (!q_aRl)","(Con p_aRk (!q_aRl))","!(Con p_aRk (!q_aRl))","(!(Con p_aRk (!q_aRl)))","Not (!(Con p_aRk (!q_aRl)))","(Not (!(Con p_aRk (!q_aRl))))","!(Not (!(Con p_aRk (!q_aRl))))","(!(Not (!(Con p_aRk (!q_aRl)))))","((!(Not (!(Con p_aRk (!q_aRl))))))","p_aRm","q_aRn","Dis p_aRm q_aRn","(Dis p_aRm q_aRn)","!(Dis p_aRm q_aRn)","(!(Dis p_aRm q_aRn))","((!(Dis p_aRm q_aRn)))","Not ((!(Dis p_aRm q_aRn)))","(Not ((!(Dis p_aRm q_aRn))))","p_aRo","safebang@!p_aRo","(!p_aRo)","q_aRp","safebang@!q_aRp","(!q_aRp)","Dis (!p_aRo) (!q_aRp)","(Dis (!p_aRo) (!q_aRp))","!(Dis (!p_aRo) (!q_aRp))","(!(Dis (!p_aRo) (!q_aRp)))","((!(Dis (!p_aRo) (!q_aRp))))","!((!(Dis (!p_aRo) (!q_aRp))))","(!((!(Dis (!p_aRo) (!q_aRp)))))","p_aRq","safebang@!p_aRq","(!p_aRq)","q_aRr","Con (!p_aRq) q_aRr","(Con (!p_aRq) q_aRr)","!(Con (!p_aRq) q_aRr)","(!(Con (!p_aRq) q_aRr))","p_aRs","!p_aRs","(!p_aRs)","'('","'='","!'='","(!'=')","'>'","'|'","!'|'","(!'|')","'&'","'~'","t_aRt","f_aRu","Ast f_aRu","[Ast f_aRu]","[]","s_aRv","safebang@!s_aRv","(!s_aRv)","' '","t_aRw","!t_aRw","(!t_aRw)","' ' : (!t_aRw)","(' ' : (!t_aRw))","!(' ' : (!t_aRw))","(!(' ' : (!t_aRw)))","s_aRx","!s_aRx","(!s_aRx)","'('","!'('","(!'(')","t_aRy","(!'(') : t_aRy","((!'(') : t_aRy)","!((!'(') : t_aRy)","(!((!'(') : t_aRy))","((!((!'(') : t_aRy)))","s_aRz","!s_aRz","(!s_aRz)","')'","!')'","(!')')","t_aRA","(!')') : t_aRA","((!')') : t_aRA)","!((!')') : t_aRA)","(!((!')') : t_aRA))","((!((!')') : t_aRA)))","!((!((!')') : t_aRA)))","(!((!((!')') : t_aRA))))","s_aRB","!s_aRB","(!s_aRB)","x_aRC","'('","!'('","(!'(')","Lex (!'(')","(Lex (!'('))","!(Lex (!'('))","(!(Lex (!'(')))","s'_aRD","safebang@!s'_aRD","(!s'_aRD)","(!(Lex (!'('))) : (!s'_aRD)","((!(Lex (!'('))) : (!s'_aRD))","!((!(Lex (!'('))) : (!s'_aRD))","(!((!(Lex (!'('))) : (!s'_aRD)))","x_aRC : (!((!(Lex (!'('))) : (!s'_aRD)))","(x_aRC : (!((!(Lex (!'('))) : (!s'_aRD))))","!(x_aRC : (!((!(Lex (!'('))) : (!s'_aRD))))","(!(x_aRC : (!((!(Lex (!'('))) : (!s'_aRD)))))","((!(x_aRC : (!((!(Lex (!'('))) : (!s'_aRD))))))","c_aRE","!c_aRE","(!c_aRE)","t_aRF","(!c_aRE) : t_aRF","((!c_aRE) : t_aRF)","s_aRG","!s_aRG","(!s_aRG)","p_aZM","Ast p_aZM","'='","!'='","(!'=')","Lex (!'=')","q_aZN","Ast q_aZN","s_aZO","lazydmd@!s_aZO","(!s_aZO)","Ast q_aZN : (!s_aZO)","(Ast q_aZN : (!s_aZO))","Lex (!'=') : (Ast q_aZN : (!s_aZO))","(Lex (!'=') : (Ast q_aZN : (!s_aZO)))","!(Lex (!'=') : (Ast q_aZN : (!s_aZO)))","(!(Lex (!'=') : (Ast q_aZN : (!s_aZO))))","Ast p_aZM : (!(Lex (!'=') : (Ast q_aZN : (!s_aZO))))","(Ast p_aZM : (!(Lex (!'=') : (Ast q_aZN : (!s_aZO)))))","!(Ast p_aZM : (!(Lex (!'=') : (Ast q_aZN : (!s_aZO)))))","(!(Ast p_aZM : (!(Lex (!'=') : (Ast q_aZN : (!s_aZO))))))","((!(Ast p_aZM : (!(Lex (!'=') : (Ast q_aZN : (!s_aZO)))))))","p_aZP","safebang@!p_aZP","(!p_aZP)","Ast (!p_aZP)","'>'","Lex '>'","q_aZQ","safebang@!q_aZQ","(!q_aZQ)","Ast (!q_aZQ)","(Ast (!q_aZQ))","!(Ast (!q_aZQ))","(!(Ast (!q_aZQ)))","s_aZR","lazydmd@!s_aZR","(!s_aZR)","(!(Ast (!q_aZQ))) : (!s_aZR)","((!(Ast (!q_aZQ))) : (!s_aZR))","!((!(Ast (!q_aZQ))) : (!s_aZR))","(!((!(Ast (!q_aZQ))) : (!s_aZR)))","Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR)))","(Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR))))","Ast (!p_aZP) : (Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR))))","(Ast (!p_aZP) : (Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR)))))","!(Ast (!p_aZP) : (Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR)))))","(!(Ast (!p_aZP) : (Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR))))))","((!(Ast (!p_aZP) : (Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR)))))))","!((!(Ast (!p_aZP) :\n       (Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR)))))))","(!((!(Ast (!p_aZP) :\n        (Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR))))))))","p_aZS","Ast p_aZS","'|'","!'|'","(!'|')","Lex (!'|')","q_aZT","Ast q_aZT","s_aZU","Ast q_aZT : s_aZU","(Ast q_aZT : s_aZU)","!(Ast q_aZT : s_aZU)","(!(Ast q_aZT : s_aZU))","Lex (!'|') : (!(Ast q_aZT : s_aZU))","(Lex (!'|') : (!(Ast q_aZT : s_aZU)))","!(Lex (!'|') : (!(Ast q_aZT : s_aZU)))","(!(Lex (!'|') : (!(Ast q_aZT : s_aZU))))","Ast p_aZS : (!(Lex (!'|') : (!(Ast q_aZT : s_aZU))))","(Ast p_aZS : (!(Lex (!'|') : (!(Ast q_aZT : s_aZU)))))","!(Ast p_aZS : (!(Lex (!'|') : (!(Ast q_aZT : s_aZU)))))","(!(Ast p_aZS : (!(Lex (!'|') : (!(Ast q_aZT : s_aZU))))))","((!(Ast p_aZS : (!(Lex (!'|') : (!(Ast q_aZT : s_aZU)))))))","p_aZV","Ast p_aZV","'&'","!'&'","(!'&')","Lex (!'&')","q_aZW","Ast q_aZW","(Ast q_aZW)","!(Ast q_aZW)","(!(Ast q_aZW))","s_aZX","(!(Ast q_aZW)) : s_aZX","((!(Ast q_aZW)) : s_aZX)","!((!(Ast q_aZW)) : s_aZX)","(!((!(Ast q_aZW)) : s_aZX))","Lex (!'&') : (!((!(Ast q_aZW)) : s_aZX))","(Lex (!'&') : (!((!(Ast q_aZW)) : s_aZX)))","Ast p_aZV : (Lex (!'&') : (!((!(Ast q_aZW)) : s_aZX)))","(Ast p_aZV : (Lex (!'&') : (!((!(Ast q_aZW)) : s_aZX))))","!(Ast p_aZV : (Lex (!'&') : (!((!(Ast q_aZW)) : s_aZX))))","(!(Ast p_aZV : (Lex (!'&') : (!((!(Ast q_aZW)) : s_aZX)))))","((!(Ast p_aZV : (Lex (!'&') : (!((!(Ast q_aZW)) : s_aZX))))))","p_aZY","safebang@!p_aZY","(!p_aZY)","Ast (!p_aZY)","'~'","Lex '~'","s_aZZ","safebang@!s_aZZ","(!s_aZZ)","Lex '~' : (!s_aZZ)","(Lex '~' : (!s_aZZ))","Ast (!p_aZY) : (Lex '~' : (!s_aZZ))","(Ast (!p_aZY) : (Lex '~' : (!s_aZZ)))","!(Ast (!p_aZY) : (Lex '~' : (!s_aZZ)))","(!(Ast (!p_aZY) : (Lex '~' : (!s_aZZ))))","((!(Ast (!p_aZY) : (Lex '~' : (!s_aZZ)))))","!((!(Ast (!p_aZY) : (Lex '~' : (!s_aZZ)))))","(!((!(Ast (!p_aZY) : (Lex '~' : (!s_aZZ))))))","redstar","spaces","p_a100","!p_a100","(!p_a100)","p_a102","q_a103","safebang@!q_a103","(!q_a103)","Con p_a102 (!q_a103)","(Con p_a102 (!q_a103))","!(Con p_a102 (!q_a103))","(!(Con p_a102 (!q_a103)))","((!(Con p_a102 (!q_a103))))","a_a104","safebang@!a_a104","(!a_a104)","p_a105","a_a106","!a_a106","(!a_a106)","x_a107","Ast x_a107","c_a108","!c_a108","(!c_a108)","Lex (!c_a108)","(Lex (!c_a108))","!(Lex (!c_a108))","(!(Lex (!c_a108)))","s_a109","lazydmd@!s_a109","(!s_a109)","(!(Lex (!c_a108))) : (!s_a109)","((!(Lex (!c_a108))) : (!s_a109))","Ast x_a107 : ((!(Lex (!c_a108))) : (!s_a109))","(Ast x_a107 : ((!(Lex (!c_a108))) : (!s_a109)))","!(Ast x_a107 : ((!(Lex (!c_a108))) : (!s_a109)))","(!(Ast x_a107 : ((!(Lex (!c_a108))) : (!s_a109))))","((!(Ast x_a107 : ((!(Lex (!c_a108))) : (!s_a109)))))","s_a10a","!s_a10a","(!s_a10a)","c_a10b","a_a10c","safebang@!a_a10c","(!a_a10c)","(c_a10b, (!a_a10c))","!(c_a10b, (!a_a10c))","(!(c_a10b, (!a_a10c)))","x_a10d","a_a10e","p_a10g","x_a10h","cp_a10i","p_a10j","safebang@!p_a10j","(!p_a10j)","f_a10k","safebang@!f_a10k","(!f_a10k)","x_a10l","safebang@!x_a10l","(!x_a10l)"]
module Main (main) where
import Data.Ix
import System.Environment
main
  = do ((norecord@((!n_ap3) : _))) <- getArgs
       putStr (res (read n_ap3))
res n_atA = concat (map clauses xs_atB)
  where xs_atB
          = take n_atA (repeat "(a = a = a) = (a = a = a) = (a = a = a)")
        
        {-# NOINLINE xs_atB #-}
clause (norecord@p_aD7) = clause'_aD8 p_aD7 ([], [])
  where clause'_aD8 ((norecord@(Dis (!p_aD9) (!q_aDa)))) x_aDb
          = clause'_aD8 p_aD9 (clause'_aD8 q_aDa x_aDb)
        clause'_aD8 (norecord@(Sym s_aDc)) (norecord@(c_aDd, (!a_aDe)))
          = (insert s_aDc c_aDd, a_aDe)
        clause'_aD8 (norecord@((norecord@(Not (Sym s_aDf)))))
          (c_aDg, (!a_aDh)) = (c_aDg, insert s_aDf a_aDh)
clauses
  = concat . map disp . unicl . split . disin . negin . elim . parse
conjunct (norecord@(Con (!p_aDi) (!q_aDj))) = True
conjunct (norecord@p_aDk) = False
disin
  (norecord@((norecord@(Dis (!p_aDl)
                          ((norecord@(Con q_aDm r_aDn)))))))
  = Con (disin (Dis p_aDl q_aDm)) (disin (Dis p_aDl r_aDn))
disin (Dis (norecord@(Con (!p_aDo) q_aDp)) (lazydmd@r_aDq))
  = Con (disin (Dis p_aDo r_aDq)) (disin (Dis q_aDp r_aDq))
disin (norecord@((norecord@(Dis (!p_aDr) (!q_aDs)))))
  = if conjunct dp_aDt || conjunct dq_aDu then
      disin (Dis dp_aDt dq_aDu) else (Dis dp_aDt dq_aDu)
  where dp_aDt = disin p_aDr
        (norecord@dq_aDu) = disin q_aDs
disin (Con (!p_aQW) q_aQX) = Con (disin p_aQW) (disin q_aQX)
disin (norecord@p_aQY) = p_aQY
disp (l_aQZ, (!r_aR0))
  = interleave l_aQZ spaces ++ "<=" ++ interleave spaces r_aR0 ++
      "\n"
elim (Sym (!s_aR1)) = Sym s_aR1
elim (norecord@(Not (!p_aR2))) = Not (elim p_aR2)
elim ((norecord@(Dis p_aR3 (!q_aR4))))
  = Dis (elim p_aR3) (elim q_aR4)
elim (norecord@((norecord@(Con (!p_aR5) q_aR6))))
  = Con (elim p_aR5) (elim q_aR6)
elim ((norecord@(Imp p_aR7 (!q_aR8))))
  = Dis (Not (elim p_aR7)) (elim q_aR8)
elim (Eqv (!f_aR9) (!f'_aRa))
  = Con (elim (Imp f_aR9 f'_aRa)) (elim (Imp f'_aRa f_aR9))
insert x_aRb [] = [x_aRb]
insert x_aRc p_aRd@(y_aRe : ys_aRf)
  = if x_aRc < y_aRe then x_aRc : p_aRd else
      if x_aRc > y_aRe then y_aRe : insert x_aRc ys_aRf else p_aRd
interleave ((norecord@((!x_aRg) : xs_aRh))) ys_aRi
  = x_aRg : interleave ys_aRi xs_aRh
interleave [] (norecord@_) = []
negin (norecord@(Not ((norecord@(Not p_aRj))))) = negin p_aRj
negin ((norecord@(Not (norecord@(Con p_aRk (!q_aRl))))))
  = Dis (negin (Not p_aRk)) (negin (Not q_aRl))
negin (Not ((norecord@(Dis p_aRm q_aRn))))
  = Con (negin (Not p_aRm)) (negin (Not q_aRn))
negin (norecord@((norecord@(Dis (!p_aRo) (!q_aRp)))))
  = Dis (negin p_aRo) (negin q_aRp)
negin (norecord@(Con (!p_aRq) q_aRr))
  = Con (negin p_aRq) (negin q_aRr)
negin (norecord@p_aRs) = p_aRs
opri '(' = 0
opri (norecord@'=') = 1
opri '>' = 2
opri (norecord@'|') = 3
opri '&' = 4
opri '~' = 5
parse t_aRt = f_aRu
  where [Ast f_aRu] = parse' t_aRt []
parse' [] (!s_aRv) = redstar s_aRv
parse' (norecord@(' ' : (norecord@t_aRw))) (norecord@s_aRx)
  = parse' t_aRw s_aRx
parse' ((norecord@((norecord@'(') : t_aRy))) (norecord@s_aRz)
  = parse' t_aRy (Lex '(' : s_aRz)
parse' (norecord@((norecord@((norecord@')') : t_aRA))))
  (norecord@s_aRB) = parse' t_aRA (x_aRC : s'_aRD)
  where ((norecord@(x_aRC :
                      (norecord@((norecord@(Lex (norecord@'('))) : (!s'_aRD))))))
          = redstar s_aRB
parse' ((norecord@c_aRE) : t_aRF) (norecord@s_aRG)
  = if inRange ('a', 'z') c_aRE then
      parse' t_aRF (Ast (Sym c_aRE) : s_aRG) else
      if spri s_aRG > opri c_aRE then parse' (c_aRE : t_aRF) (red s_aRG)
        else parse' t_aRF (Lex c_aRE : s_aRG)
red
  ((norecord@(Ast p_aZM :
                (norecord@(Lex (norecord@'=') : (Ast q_aZN : (lazydmd@s_aZO)))))))
  = Ast (Eqv q_aZN p_aZM) : s_aZO
red
  (norecord@((norecord@(Ast (!p_aZP) :
                          (Lex '>' :
                             (norecord@((norecord@(Ast (!q_aZQ))) : (lazydmd@s_aZR))))))))
  = Ast (Imp q_aZQ p_aZP) : s_aZR
red
  ((norecord@(Ast p_aZS :
                (norecord@(Lex (norecord@'|') : (norecord@(Ast q_aZT : s_aZU)))))))
  = Ast (Dis q_aZT p_aZS) : s_aZU
red
  ((norecord@(Ast p_aZV :
                (Lex (norecord@'&') :
                   (norecord@((norecord@(Ast q_aZW)) : s_aZX))))))
  = Ast (Con q_aZW p_aZV) : s_aZX
red (norecord@((norecord@(Ast (!p_aZY) : (Lex '~' : (!s_aZZ))))))
  = Ast (Not p_aZY) : s_aZZ
redstar = while ((/=) 0 . spri) red
spaces = repeat ' '
split (norecord@p_a100) = split'_a101 p_a100 []
  where split'_a101 ((norecord@(Con p_a102 (!q_a103)))) (!a_a104)
          = split'_a101 p_a102 (split'_a101 q_a103 a_a104)
        split'_a101 p_a105 (norecord@a_a106) = p_a105 : a_a106
spri
  ((norecord@(Ast x_a107 :
                ((norecord@(Lex (norecord@c_a108))) : (lazydmd@s_a109)))))
  = opri c_a108
spri (norecord@s_a10a) = 0
tautclause (norecord@(c_a10b, (!a_a10c)))
  = [x_a10d | x_a10d <- c_a10b, x_a10d `elem` a_a10c] /= []
unicl a_a10e = foldr unicl'_a10f [] a_a10e
  where unicl'_a10f p_a10g x_a10h
          = if tautclause cp_a10i then x_a10h else insert cp_a10i x_a10h
          where cp_a10i = clause p_a10g
while (!p_a10j) (!f_a10k) (!x_a10l)
  = if p_a10j x_a10l then while p_a10j f_a10k (f_a10k x_a10l) else
      x_a10l

data Formula = Sym Char
             | Not Formula
             | Dis Formula Formula
             | Con Formula Formula
             | Imp Formula Formula
             | Eqv Formula Formula

data StackFrame = Ast Formula
                | Lex Char

==================== Renamer ====================
infix 9 Main.<*>
infixl 9 Main..*

Main.main
  = do { (![(!arg_ay9)]) <- getArgs;
         let (!n_aya) = read arg_ay9 :: Int;
         putStr (show (take n_aya Main.test)) }
Main.test :: Main.StateStream
Main.test
  = Main.runExperiment
      Main.testforce 2.0e-2 [1.0] (Main.State [1.0] [0.0])
Main.testforce :: Main.ForceLaw [Float]
Main.testforce (!k_aGf) [] = []
Main.testforce
  (!k_aGg)
  (!((!((!(Main.State (!pos_aGh) (!vel_aGi))) : atoms_aGj))))
  = (- 1.0) Main..* k_aGg * pos_aGh : Main.testforce k_aGg atoms_aGj
Main.runExperiment ::
  Main.ForceLaw a_ay8
  -> Float -> a_ay8 -> Main.AtomState -> Main.StateStream
Main.runExperiment (!law_aGk) dt_aGl (!param_aGm) init_aGn
  = init_aGn
    : zipWith
        (Main.propagate dt_aGl) (law_aGk param_aGm stream_aGo) stream_aGo
  where
      stream_aGo = Main.runExperiment law_aGk dt_aGl param_aGm init_aGn
Main.propagate ::
  Float -> Main.Force -> Main.AtomState -> Main.AtomState
Main.propagate
  (!dt_aGp)
  (!aforce_aGq)
  (!(Main.State pos_aGr vel_aGs))
  = Main.State newpos_aGt newvel_aGu
  where
      (!newpos_aGt) = pos_aGr + (dt_aGp Main..* vel_aGs)
      (!newvel_aGu) = vel_aGs + (dt_aGp Main..* aforce_aGq)
(Main..*) :: Num a_ay7 => a_ay7 -> [a_ay7] -> [a_ay7]
c_aGv Main..* (![]) = []
c_aGw Main..* (!((!f_aGx) : (!fs_aGy)))
  = c_aGw * f_aGx : c_aGw Main..* fs_aGy
(Main.<*>) :: Num a_ay6 => [a_ay6] -> [a_ay6] -> a_ay6
f_aGz Main.<*> g_aGA = sum (f_aGz * g_aGA)

type Main.Position = [Float]
type Main.Velocity = [Float]
data Main.AtomState = Main.State Main.Position Main.Velocity
type Main.Force = [Float]
type Main.StateStream = [Main.AtomState]
type Main.ForceLaw a_axY =
    a_axY -> Main.StateStream -> [Main.Force]

instance Num a_aMx => Num [a_aMx] where
  negate (!(f_aMy : (!fs_aMz))) = (negate f_aMy) : (negate fs_aMz)
  l_aMA + [] = l_aMA
  (![]) + l_aMB = l_aMB
  ((!((!f_aMC) : (!fs_aMD)))) + (!((!g_aME) : (!gs_aMF)))
    = (f_aMC + g_aME) : fs_aMD + gs_aMF
  (!_) * [] = []
  (![]) * _ = []
  ((!((!f_aMG) : fs_aMH))) * ((!((!g_aMI) : gs_aMJ)))
    = (f_aMG * g_aMI) : (gs_aMJ * gs_aMJ)
  fromInteger (!c_aMK) = fromInteger c_aMK : [0]
instance Show Main.AtomState where
  show ((!(Main.State (!pos_aML) (!vel_aMM))))
    = concat [(show component_aMN) ++ "\t" | component_aMN <- pos_aML]
  showList states_aMO
    = showString
        (concat [(show state_aMP) ++ "\n" | (!state_aMP) <- states_aMO])



==================== Renamer ====================
Main.algb :: (Eq a_aC0) => [a_aC0] -> [a_aC0] -> [Int]
Main.algb (!xs_aC1) ys_aC2
  = 0 : algb1_aC3 xs_aC1 [(y_aDj, 0) | y_aDj <- ys_aC2]
  where
      algb1_aC3 [] (!ys'_aC4) = map snd ys'_aC4
      algb1_aC3 ((!(x_aCb : xs_aCc))) (!ys'_aCd)
        = algb1_aC3 xs_aCc (algb2_aCe 0 0 ys'_aCd)
        where
            algb2_aCe (!_) (!_) [] = []
            algb2_aCe
              k0j1_aCf
              (!k1j1_aCg)
              ((!((!((!y_aCh), (!k0j_aCi))) : ys_aCj)))
              = let
                  (!kjcurr_aCk)
                    = if x_aCb == y_aCh then k0j1_aCf + 1 else max k1j1_aCg k0j_aCi
                in (y_aCh, kjcurr_aCk) : algb2_aCe k0j_aCi kjcurr_aCk ys_aCj
Main.algc ::
  (Eq a_aBS) =>
  Int -> Int -> [a_aBS] -> [a_aBS] -> [a_aBS] -> [a_aBS]
Main.algc (!m_aDk) n_aDl (!xs_aDm) [] = id
Main.algc (!m_aDn) n_aDo (![(!x_aDp)]) (!ys_aDq)
  = if x_aDp `elem` ys_aDq then (x_aDp :) else id
Main.algc (!m_aJx) n_aJy (!xs_aJz) ys_aJA
  = Main.algc m2_aJB k_aJG xs1_aJC (take k_aJG ys_aJA)
    . Main.algc
        (m_aJx - m2_aJB) (n_aJy - k_aJG) xs2_aJD (drop k_aJG ys_aJA)
  where
      m2_aJB = m_aJx `div` 2
      xs1_aJC = take m2_aJB xs_aJz
      xs2_aJD = drop m2_aJB xs_aJz
      (!l1_aJE) = Main.algb xs1_aJC ys_aJA
      (!l2_aJF) = reverse (Main.algb (reverse xs2_aJD) (reverse ys_aJA))
      (!k_aJG) = findk_aJH 0 0 (- 1) (zip l1_aJE l2_aJF)
      findk_aJH k_aWd km_aWe m_aWf [] = km_aWe
      findk_aJH
        k_aWg
        (!km_aWh)
        m_aWi
        ((!((!((!x_aWj), (!y_aWk))) : (!xys_aWl))))
        | x_aWj + y_aWk >= m_aWi
        = findk_aJH (k_aWg + 1) k_aWg (x_aWj + y_aWk) xys_aWl
        | otherwise = findk_aJH (k_aWg + 1) km_aWh m_aWi xys_aWl
Main.lcss :: (Eq a_aoq) => [a_aoq] -> [a_aoq] -> [a_aoq]
Main.lcss xs_aWm (!ys_aWn)
  = Main.algc (length xs_aWm) (length ys_aWn) xs_aWm ys_aWn []
Main.main
  = do { (![(!a_aWo),
            b_aWp,
            (!c_aWq),
            d_aWr,
            (!e_aWs),
            (!f_aWt)]) <- getArgs;
         let a'_aWu, b'_aWv, c'_aWw, d'_aWx, e'_aWy, f'_aWz :: Int
             a'_aWu = read a_aWo
             b'_aWv = read b_aWp
             (!c'_aWw) = read c_aWq
             d'_aWx = read d_aWr
             (!e'_aWy) = read e_aWs
             (!f'_aWz) = read f_aWt;
         print
           (Main.lcss [a'_aWu, b'_aWv .. c'_aWw] [d'_aWx, e'_aWy .. f'_aWz]) }



==================== Renamer ====================
Main.main
  = do { (arg_aGb : (!_)) <- getArgs;
         let d_aGj = fromIntegral (read arg_aGb :: Int) :: Main.Z
             (n_aGk, (!m_aGl)) = (5000, 10000) :: (Main.Z, Main.Z)
             ns_aGm = [n_aGk .. (n_aGk + d_aGj)]
             (!ms_aGn) = [m_aGl .. (m_aGl + d_aGj)]
             pairs_aGo = [(x_aId, y_aIe) | x_aId <- ns_aGm, y_aIe <- ms_aGn]
             tripls_aGp
               = map
                   (\ (x_aIf, (!y_aIg)) -> (x_aIf, y_aIg, Main.gcdE x_aIf y_aIg))
                   pairs_aGo
             (!rs_aGq)
               = map
                   (\ (!((!_), (!_), (!((!g_aIh), (!u_aIi), (!v_aIj)))))
                      -> abs (g_aIh + u_aIi + v_aIj))
                   tripls_aGp
             max'_aGr [(!x_aIk)] = x_aIk
             max'_aGr (!((!((!x_aIl) : (!(y_aIm : (!xs_aIn)))))))
               = if x_aIl < y_aIm then
                     max'_aGr (y_aIm : xs_aIn)
                 else
                     max'_aGr (x_aIl : xs_aIn);
         putStr (shows (max'_aGr rs_aGq) "\n") }
Main.test (!(x_a17H, y_a17I, ((!d_a17J), (!u_a17K), v_a17L)))
  = d_a17J == (u_a17K * x_a17H + v_a17L * y_a17I)
    && d_a17J == (gcd x_a17H y_a17I)
Main.gcdE ::
  Integral a_awY => a_awY -> a_awY -> (a_awY, a_awY, a_awY)
Main.gcdE 0 y_a17M = (y_a17M, 0, 1)
Main.gcdE (!x_a17N) (!y_a17O)
  = g_a17P (1, 0, x_a17N) (0, 1, y_a17O)
  where
      g_a17P
        (u1_a17Q, u2_a17R, u3_a17S)
        ((!v1_a17T), (!v2_a17U), (!v3_a17V))
        = if v3_a17V == 0 then
              (u3_a17S, u1_a17Q, u2_a17R)
          else
              case quotRem u3_a17S v3_a17V of {
                ((!q_a17W), (!r_a17X))
                  -> g_a17P
                       (v1_a17T, v2_a17U, v3_a17V)
                       (u1_a17Q - q_a17W * v1_a17T, u2_a17R - q_a17W * v2_a17U, r_a17X) }

type Main.Z = Integer



==================== Renamer ====================
infixr 5 `Main.above`
infixr 5 `Main.beside`

Main.height, Main.width :: Main.Picture -> Int
Main.height (!p_aCN) = length p_aCN
Main.width p_aIM = length (head p_aIM)
Main.above, Main.beside ::
  Main.Picture -> Main.Picture -> Main.Picture
Main.above = (++)
Main.beside = zipWith (++)
Main.stack, Main.spread :: [Main.Picture] -> Main.Picture
Main.stack = foldr1 Main.above
Main.spread = foldr1 Main.beside
Main.emptyPic :: (Int, Int) -> Main.Picture
Main.emptyPic (h_aM5, (!w_aM6))
  = Main.copy h_aM5 (Main.copy w_aM6 ' ')
Main.block, Main.blockT :: Int -> [Main.Picture] -> Main.Picture
Main.block (!n_aM7)
  = Main.stack . map Main.spread . Main.groop n_aM7
Main.blockT n_aM8 = Main.spread . map Main.stack . Main.groop n_aM8
Main.groop :: Int -> [a_aCM] -> [[a_aCM]]
Main.groop n_aM9 [] = []
Main.groop (!n_aMa) xs_aMb
  = take n_aMa xs_aMb : Main.groop n_aMa (drop n_aMa xs_aMb)
Main.lframe :: (Int, Int) -> Main.Picture -> Main.Picture
Main.lframe (!(m_aMc, n_aMd)) p_aMe
  = (p_aMe `Main.beside` Main.emptyPic (h_aMf, n_aMd - w_aMg))
    `Main.above` Main.emptyPic (m_aMc - h_aMf, n_aMd)
  where
      (!h_aMf) = Main.height p_aMe
      (!w_aMg) = Main.width p_aMe
Main.monthLengths (!year_aNf)
  = [31, feb_aNg, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  where
      (!feb_aNg)
        | Main.leap year_aNf = 29
        | otherwise = 28
Main.leap year_aNh
  = if year_aNh `mod` 100 == 0 then
        year_aNh `mod` 400 == 0
    else
        year_aNh `mod` 4 == 0
Main.monthNames
  = ["January", "February", "March", "April", "May", "June", "July",
     "August", "September", "October", "November", "December"]
Main.jan1st year_a19P
  = (year_a19P + last_a19Q `div` 4 - last_a19Q `div` 100
     + last_a19Q `div` 400)
    `mod` 7
  where
      (!last_a19Q) = year_a19P - 1
Main.firstDays year_a19R
  = take
      12
      (map
         (`mod` 7)
         (scanl (+) (Main.jan1st year_a19R) (Main.monthLengths year_a19R)))
Main.dates fd_a19S (!ml_a19T)
  = map (date_a19U ml_a19T) [1 - fd_a19S .. 42 - fd_a19S]
  where
      date_a19U (!ml_a19V) (!d_a19W)
        | d_a19W < 1 || ml_a19V < d_a19W = ["   "]
        | otherwise = [Main.rjustify 3 (show d_a19W)]
Main.calendar :: Int -> String
Main.calendar
  = unlines . Main.block 3 . map picture_a1ii . months_a1in
  where
      picture_a1ii (mn_a1io, yr_a1ip, fd_a1iq, ml_a1ir)
        = title_a1ij mn_a1io yr_a1ip
          `Main.above` table_a1ik fd_a1iq ml_a1ir
      title_a1ij mn_a1is yr_a1it
        = Main.lframe (2, 25) [mn_a1is ++ " " ++ show yr_a1it]
      table_a1ik (!fd_a1iu) ml_a1iv
        = Main.lframe
            (8, 25) (daynames_a1il `Main.beside` entries_a1im fd_a1iu ml_a1iv)
      daynames_a1il = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
      entries_a1im (!fd_a1iw) (!ml_a1ix)
        = Main.blockT 7 (Main.dates fd_a1iw ml_a1ix)
      months_a1in (!year_a1iy)
        = zip4
            Main.monthNames
            (Main.copy 12 year_a1iy)
            (Main.firstDays year_a1iy)
            (Main.monthLengths year_a1iy)
Main.cal year_a1kM
  = unlines (banner_a1kN year_a1kM `Main.above` body_a1kO year_a1kM)
  where
      banner_a1kN yr_a1kY
        = [Main.cjustify 75 (show yr_a1kY)]
          `Main.above` Main.emptyPic (1, 75)
      body_a1kO = Main.block 3 . map (pad_a1kQ . pic_a1kP) . months_a1kX
      pic_a1kP (mn_a1kZ, fd_a1l0, ml_a1l1)
        = title_a1kT mn_a1kZ `Main.above` table_a1kU fd_a1l0 ml_a1l1
      pad_a1kQ p_a1l2
        = (side_a1kR `Main.beside` p_a1l2 `Main.beside` side_a1kR)
          `Main.above` end_a1kS
      side_a1kR = Main.emptyPic (8, 2)
      end_a1kS = Main.emptyPic (1, 25)
      title_a1kT mn_a1l3 = [Main.cjustify 21 mn_a1l3]
      table_a1kU fd_a1l4 ml_a1l5
        = daynames_a1kV `Main.above` entries_a1kW fd_a1l4 ml_a1l5
      daynames_a1kV = [" Su Mo Tu We Th Fr Sa"]
      entries_a1kW fd_a1l6 ml_a1l7
        = Main.block 7 (Main.dates fd_a1l6 ml_a1l7)
      months_a1kX year_a1l8
        = zip3
            Main.monthNames
            (Main.firstDays year_a1l8)
            (Main.monthLengths year_a1l8)
Main.main
  = do { (!((!year_a1l9) : (!(n_a1la : _)))) <- getArgs;
         replicateM_ (read n_a1la) (Main.calFor year_a1l9) }
Main.calFor year_a1lZ
  | illFormed_a1m0 = ioError (userError "Bad argument")
  | otherwise = print (length (Main.cal yr_a1m3))
  where
      illFormed_a1m0 = null ds_a1m1 || not (null rs_a1m2)
      (ds_a1m1, rs_a1m2) = span isDigit year_a1lZ
      (!yr_a1m3) = atoi_a1m4 ds_a1m1
      atoi_a1m4 (!s_a1ms)
        = foldl
            (\ (!a_a1mt) (!d_a1mu) -> 10 * a_a1mt + d_a1mu)
            0
            (map toDigit_a1m5 s_a1ms)
      toDigit_a1m5 d_a1mv = fromEnum d_a1mv - fromEnum '0'
Main.copy :: Int -> a_aCL -> [a_aCL]
Main.copy n_a1DL x_a1DM = take n_a1DL (repeat x_a1DM)
Main.cjustify, Main.ljustify, Main.rjustify ::
  Int -> String -> String
Main.cjustify (!n_a1DN) s_a1DO
  = Main.space halfm_a1DQ
    ++ s_a1DO ++ Main.space (m_a1DP - halfm_a1DQ)
  where
      m_a1DP = n_a1DN - length s_a1DO
      halfm_a1DQ = m_a1DP `div` 2
Main.ljustify (!n_a1DR) (!s_a1DS)
  = s_a1DS ++ Main.space (n_a1DR - length s_a1DS)
Main.rjustify (!n_a1DT) (!s_a1DU)
  = Main.space (n_a1DT - length s_a1DU) ++ s_a1DU
Main.space :: Int -> String
Main.space (!n_a1DV) = Main.copy n_a1DV ' '

type Main.Picture = [[Char]]


["p_aCN","!p_aCN","(!p_aCN)","p_aIM","above","beside","stack","spread","h_aM5","w_aM6","!w_aM6","(!w_aM6)","(h_aM5, (!w_aM6))","n_aM7","safebang@!n_aM7","(!n_aM7)","n_aM8","n_aM9","[]","n_aMa","!n_aMa","(!n_aMa)","xs_aMb","m_aMc","n_aMd","(m_aMc, n_aMd)","!(m_aMc, n_aMd)","(!(m_aMc, n_aMd))","p_aMe","h_aMf","!h_aMf","(!h_aMf)","w_aMg","!w_aMg","(!w_aMg)","year_aNf","safebang@!year_aNf","(!year_aNf)","feb_aNg","!feb_aNg","(!feb_aNg)","year_aNh","monthNames","year_a19P","last_a19Q","!last_a19Q","(!last_a19Q)","year_a19R","fd_a19S","ml_a19T","!ml_a19T","(!ml_a19T)","ml_a19V","!ml_a19V","(!ml_a19V)","d_a19W","!d_a19W","(!d_a19W)","calendar","mn_a1io","yr_a1ip","fd_a1iq","ml_a1ir","(mn_a1io, yr_a1ip, fd_a1iq, ml_a1ir)","mn_a1is","yr_a1it","fd_a1iu","!fd_a1iu","(!fd_a1iu)","ml_a1iv","daynames_a1il","fd_a1iw","!fd_a1iw","(!fd_a1iw)","ml_a1ix","!ml_a1ix","(!ml_a1ix)","year_a1iy","!year_a1iy","(!year_a1iy)","year_a1kM","yr_a1kY","body_a1kO","mn_a1kZ","fd_a1l0","ml_a1l1","(mn_a1kZ, fd_a1l0, ml_a1l1)","p_a1l2","side_a1kR","end_a1kS","mn_a1l3","fd_a1l4","ml_a1l5","daynames_a1kV","fd_a1l6","ml_a1l7","year_a1l8","main","year_a1l9","safebang@!year_a1l9","(!year_a1l9)","n_a1la","_","n_a1la : _","(n_a1la : _)","!(n_a1la : _)","(!(n_a1la : _))","(!year_a1l9) : (!(n_a1la : _))","((!year_a1l9) : (!(n_a1la : _)))","!((!year_a1l9) : (!(n_a1la : _)))","(!((!year_a1l9) : (!(n_a1la : _))))","year_a1lZ","illFormed_a1m0","ds_a1m1","rs_a1m2","(ds_a1m1, rs_a1m2)","yr_a1m3","lazydmd@!yr_a1m3","(!yr_a1m3)","s_a1ms","!s_a1ms","(!s_a1ms)","a_a1mt","!a_a1mt","(!a_a1mt)","d_a1mu","!d_a1mu","(!d_a1mu)","d_a1mv","n_a1DL","x_a1DM","n_a1DN","safebang@!n_a1DN","(!n_a1DN)","s_a1DO","m_a1DP","halfm_a1DQ","n_a1DR","!n_a1DR","(!n_a1DR)","s_a1DS","!s_a1DS","(!s_a1DS)","n_a1DT","!n_a1DT","(!n_a1DT)","s_a1DU","!s_a1DU","(!s_a1DU)","n_a1DV","!n_a1DV","(!n_a1DV)"]
module Main (main) where
import System.IO
import Data.List
import Data.Char
import System.Environment
import Control.Monad

infixr 5 `above`

infixr 5 `beside`

height, width :: Picture -> Int
height (norecord@p_aCN) = length p_aCN
width p_aIM = length (head p_aIM)

above, beside :: Picture -> Picture -> Picture
above = (++)
beside = zipWith (++)

stack, spread :: [Picture] -> Picture
stack = foldr1 above
spread = foldr1 beside

emptyPic :: (Int, Int) -> Picture
emptyPic (h_aM5, (norecord@w_aM6)) = copy h_aM5 (copy w_aM6 ' ')

block, blockT :: Int -> [Picture] -> Picture
block (!n_aM7) = stack . map spread . groop n_aM7
blockT n_aM8 = spread . map stack . groop n_aM8

groop :: Int -> [a_aCM] -> [[a_aCM]]
groop n_aM9 [] = []
groop (norecord@n_aMa) xs_aMb
  = take n_aMa xs_aMb : groop n_aMa (drop n_aMa xs_aMb)

lframe :: (Int, Int) -> Picture -> Picture
lframe (norecord@(m_aMc, n_aMd)) p_aMe
  = (p_aMe `beside` emptyPic (h_aMf, n_aMd - w_aMg)) `above`
      emptyPic (m_aMc - h_aMf, n_aMd)
  where (norecord@h_aMf) = height p_aMe
        (norecord@w_aMg) = width p_aMe
monthLengths (!year_aNf)
  = [31, feb_aNg, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  where (norecord@feb_aNg)
          | leap year_aNf = 29
          | otherwise = 28
leap year_aNh
  = if year_aNh `mod` 100 == 0 then year_aNh `mod` 400 == 0 else
      year_aNh `mod` 4 == 0
monthNames
  = ["January", "February", "March", "April", "May", "June", "July",
     "August", "September", "October", "November", "December"]
jan1st year_a19P
  = (year_a19P + last_a19Q `div` 4 - last_a19Q `div` 100 + last_a19Q
       `div` 400)
      `mod` 7
  where (norecord@last_a19Q) = year_a19P - 1
firstDays year_a19R
  = take 12
      (map (`mod` 7)
         (scanl (+) (jan1st year_a19R) (monthLengths year_a19R)))
dates fd_a19S (norecord@ml_a19T)
  = map (date_a19U ml_a19T) [1 - fd_a19S .. 42 - fd_a19S]
  where date_a19U (norecord@ml_a19V) (norecord@d_a19W)
          | d_a19W < 1 || ml_a19V < d_a19W = ["   "]
          | otherwise = [rjustify 3 (show d_a19W)]

calendar :: Int -> String
calendar = unlines . block 3 . map picture_a1ii . months_a1in
  where picture_a1ii (mn_a1io, yr_a1ip, fd_a1iq, ml_a1ir)
          = title_a1ij mn_a1io yr_a1ip `above` table_a1ik fd_a1iq ml_a1ir
        title_a1ij mn_a1is yr_a1it
          = lframe (2, 25) [mn_a1is ++ " " ++ show yr_a1it]
        table_a1ik (norecord@fd_a1iu) ml_a1iv
          = lframe (8, 25)
              (daynames_a1il `beside` entries_a1im fd_a1iu ml_a1iv)
        daynames_a1il = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
        entries_a1im (norecord@fd_a1iw) (norecord@ml_a1ix)
          = blockT 7 (dates fd_a1iw ml_a1ix)
        months_a1in (norecord@year_a1iy)
          = zip4 monthNames (copy 12 year_a1iy) (firstDays year_a1iy)
              (monthLengths year_a1iy)
cal year_a1kM
  = unlines (banner_a1kN year_a1kM `above` body_a1kO year_a1kM)
  where banner_a1kN yr_a1kY
          = [cjustify 75 (show yr_a1kY)] `above` emptyPic (1, 75)
        body_a1kO = block 3 . map (pad_a1kQ . pic_a1kP) . months_a1kX
        pic_a1kP (mn_a1kZ, fd_a1l0, ml_a1l1)
          = title_a1kT mn_a1kZ `above` table_a1kU fd_a1l0 ml_a1l1
        pad_a1kQ p_a1l2
          = (side_a1kR `beside` p_a1l2 `beside` side_a1kR) `above` end_a1kS
        side_a1kR = emptyPic (8, 2)
        end_a1kS = emptyPic (1, 25)
        title_a1kT mn_a1l3 = [cjustify 21 mn_a1l3]
        table_a1kU fd_a1l4 ml_a1l5
          = daynames_a1kV `above` entries_a1kW fd_a1l4 ml_a1l5
        daynames_a1kV = [" Su Mo Tu We Th Fr Sa"]
        entries_a1kW fd_a1l6 ml_a1l7 = block 7 (dates fd_a1l6 ml_a1l7)
        months_a1kX year_a1l8
          = zip3 monthNames (firstDays year_a1l8) (monthLengths year_a1l8)
main
  = do (norecord@((!year_a1l9) : (norecord@(n_a1la : _)))) <- getArgs
       replicateM_ (read n_a1la) (calFor year_a1l9)
calFor year_a1lZ
  | illFormed_a1m0 = ioError (userError "Bad argument")
  | otherwise = print (length (cal yr_a1m3))
  where illFormed_a1m0 = null ds_a1m1 || not (null rs_a1m2)
        (ds_a1m1, rs_a1m2) = span isDigit year_a1lZ
        (lazydmd@yr_a1m3) = atoi_a1m4 ds_a1m1
        atoi_a1m4 (norecord@s_a1ms)
          = foldl
              (\ (norecord@a_a1mt) (norecord@d_a1mu) -> 10 * a_a1mt + d_a1mu)
              0
              (map toDigit_a1m5 s_a1ms)
        toDigit_a1m5 d_a1mv = fromEnum d_a1mv - fromEnum '0'

copy :: Int -> a_aCL -> [a_aCL]
copy n_a1DL x_a1DM = take n_a1DL (repeat x_a1DM)

cjustify, ljustify, rjustify :: Int -> String -> String
cjustify (!n_a1DN) s_a1DO
  = space halfm_a1DQ ++ s_a1DO ++ space (m_a1DP - halfm_a1DQ)
  where m_a1DP = n_a1DN - length s_a1DO
        halfm_a1DQ = m_a1DP `div` 2
ljustify (norecord@n_a1DR) (norecord@s_a1DS)
  = s_a1DS ++ space (n_a1DR - length s_a1DS)
rjustify (norecord@n_a1DT) (norecord@s_a1DU)
  = space (n_a1DT - length s_a1DU) ++ s_a1DU

space :: Int -> String
space (norecord@n_a1DV) = copy n_a1DV ' '

type Picture = [[Char]]

==================== Renamer ====================
Main.vec_add :: Main.Vec -> Main.Vec -> Main.Vec
Main.vec_add ((!x1_anB), (!y1_anC)) (!((!x2_anD), (!y2_anE)))
  = (x1_anB + x2_anD, y1_anC + y2_anE)
Main.vec_sub :: Main.Vec -> Main.Vec -> Main.Vec
Main.vec_sub (!(x1_aoD, (!y1_aoE))) (x2_aoF, (!y2_aoG))
  = (x1_aoD - x2_aoF, y1_aoE - y2_aoG)
Main.scale_vec2 :: Main.Vec -> Int -> Int -> Main.Vec
Main.scale_vec2 (!((!x_aoH), (!y_aoI))) a_aoJ b_aoK
  = ((x_aoH * a_aoJ) `div` b_aoK, (y_aoI * a_aoJ) `div` b_aoK)
Main.p_tile :: [(Int, Int, Int, Int)]
Main.q_tile :: [(Int, Int, Int, Int)]
Main.r_tile :: [(Int, Int, Int, Int)]
Main.s_tile :: [(Int, Int, Int, Int)]
Main.p_tile
  = [(0, 3, 3, 4), (3, 4, 0, 8), (0, 8, 0, 3), (6, 0, 4, 4),
     (4, 5, 4, 10), (4, 10, 7, 6), (7, 6, 4, 5), (11, 0, 10, 4),
     (10, 4, 9, 6), (9, 6, 8, 8), (8, 8, 4, 13), (4, 13, 0, 16),
     (0, 16, 6, 15), (6, 15, 8, 16), (8, 16, 12, 12), (12, 12, 16, 12),
     (10, 16, 12, 14), (12, 14, 16, 13), (12, 16, 13, 15),
     (13, 15, 16, 14), (14, 16, 16, 15), (8, 12, 16, 10), (8, 8, 12, 9),
     (12, 9, 16, 8), (9, 6, 12, 7), (12, 7, 16, 6), (10, 4, 13, 5),
     (13, 5, 16, 4), (11, 0, 14, 2), (14, 2, 16, 2)]
Main.q_tile
  = [(0, 8, 4, 7), (4, 7, 6, 7), (6, 7, 8, 8), (8, 8, 12, 10),
     (12, 10, 16, 16), (0, 12, 3, 13), (3, 13, 5, 14), (5, 14, 7, 15),
     (7, 15, 8, 16), (2, 16, 3, 13), (4, 16, 5, 14), (6, 16, 7, 15),
     (0, 10, 7, 11), (9, 13, 8, 15), (8, 15, 11, 15), (11, 15, 9, 13),
     (10, 10, 8, 12), (8, 12, 12, 12), (12, 12, 10, 10), (2, 0, 4, 5),
     (4, 5, 4, 7), (4, 0, 6, 5), (6, 5, 6, 7), (6, 0, 8, 5),
     (8, 5, 8, 8), (10, 0, 14, 11), (12, 0, 13, 4), (13, 4, 16, 8),
     (16, 8, 15, 10), (15, 10, 16, 16), (13, 0, 16, 6), (14, 0, 16, 4),
     (15, 0, 16, 2), (0, 0, 8, 0), (12, 0, 16, 0), (0, 0, 0, 8),
     (0, 12, 0, 16)]
Main.r_tile
  = [(0, 0, 8, 8), (12, 12, 16, 16), (0, 4, 5, 10), (0, 8, 2, 12),
     (0, 12, 1, 14), (16, 6, 11, 10), (11, 10, 6, 16), (16, 4, 14, 6),
     (14, 6, 8, 8), (8, 8, 5, 10), (5, 10, 2, 12), (2, 12, 0, 16),
     (16, 8, 12, 12), (12, 12, 11, 16), (1, 1, 4, 0), (2, 2, 8, 0),
     (3, 3, 8, 2), (8, 2, 12, 0), (5, 5, 12, 3), (12, 3, 16, 0),
     (11, 16, 12, 12), (12, 12, 16, 8), (13, 13, 16, 10),
     (14, 14, 16, 12), (15, 15, 16, 14)]
Main.s_tile
  = [(0, 0, 4, 2), (4, 2, 8, 2), (8, 2, 16, 0), (0, 4, 2, 1),
     (0, 6, 7, 4), (0, 8, 8, 6), (0, 10, 7, 8), (0, 12, 7, 10),
     (0, 14, 7, 13), (13, 13, 16, 14), (14, 11, 16, 12),
     (15, 9, 16, 10), (16, 0, 10, 4), (10, 4, 8, 6), (8, 6, 7, 8),
     (7, 8, 7, 13), (7, 13, 8, 16), (12, 16, 13, 13), (13, 13, 14, 11),
     (14, 11, 15, 9), (15, 9, 16, 8), (10, 16, 11, 10), (12, 4, 10, 6),
     (10, 6, 12, 7), (12, 7, 12, 4), (15, 5, 13, 7), (13, 7, 15, 8),
     (15, 8, 15, 5)]
Main.nil a_axU b_axV c_axW = []
Main.grid ::
  Int
  -> Int
     -> [Main.Line_segment]
        -> Main.Vec -> Main.Vec -> Main.Vec -> [Main.Line_segment]
Main.grid m_axX (!n_axY) (!segments_axZ) a_ay0 b_ay1 c_ay2
  = [Main.tup2
       (a_ay0 `Main.vec_add` (Main.scale_vec2 b_ay1 x0_ay3 m_axX)
        `Main.vec_add` (Main.scale_vec2 c_ay2 y0_ay4 n_axY))
       (a_ay0 `Main.vec_add` (Main.scale_vec2 b_ay1 x1_ay5 m_axX)
        `Main.vec_add` (Main.scale_vec2 c_ay2 y1_ay6 n_axY)) |
       (!((!x0_ay3), (!y0_ay4), (!x1_ay5), y1_ay6)) <- segments_axZ]
Main.rot p_ay7 (!a_ay8) b_ay9 (!c_aya)
  = p_ay7
      (a_ay8 `Main.vec_add` b_ay9) c_aya ((0, 0) `Main.vec_sub` b_ay9)
Main.beside m_ayb n_ayc p_ayd q_aye a_ayf b_ayg (!c_ayh)
  = p_ayd a_ayf (Main.scale_vec2 b_ayg m_ayb (m_ayb + n_ayc)) c_ayh
    ++
      q_aye
        (a_ayf
         `Main.vec_add` (Main.scale_vec2 b_ayg m_ayb (m_ayb + n_ayc)))
        (Main.scale_vec2 b_ayg n_ayc (n_ayc + m_ayb))
        c_ayh
Main.above (!m_ayi) n_ayj p_ayk q_ayl (!a_aym) (!b_ayn) c_ayo
  = p_ayk
      (a_aym
       `Main.vec_add` (Main.scale_vec2 c_ayo n_ayj (m_ayi + n_ayj)))
      b_ayn
      (Main.scale_vec2 c_ayo m_ayi (n_ayj + m_ayi))
    ++ q_ayl a_aym b_ayn (Main.scale_vec2 c_ayo n_ayj (m_ayi + n_ayj))
Main.tup2 ::
  (a_anx, b_any) -> (c_anz, d_anA) -> (a_anx, b_any, c_anz, d_anA)
Main.tup2 (!((!a_ayp), b_ayq)) ((!c_ayr), (!d_ays))
  = (a_ayp, b_ayq, c_ayr, d_ays)
Main.tile_to_grid = Main.grid 16 16
Main.p = Main.tile_to_grid Main.p_tile
Main.q = Main.tile_to_grid Main.q_tile
Main.r = Main.tile_to_grid Main.r_tile
Main.s = Main.tile_to_grid Main.s_tile
Main.quartet (!a_ayt) (!b_ayu) c_ayv (!d_ayw)
  = Main.above
      1 1 (Main.beside 1 1 a_ayt b_ayu) (Main.beside 1 1 c_ayv d_ayw)
Main.t = Main.quartet Main.p Main.q Main.r Main.s
Main.cycle' p1_ayx
  = Main.quartet
      p1_ayx
      (Main.rot (Main.rot (Main.rot p1_ayx)))
      (Main.rot p1_ayx)
      (Main.rot (Main.rot p1_ayx))
Main.u = Main.cycle' (Main.rot Main.q)
Main.side1
  = Main.quartet Main.nil Main.nil (Main.rot Main.t) Main.t
Main.side2
  = Main.quartet Main.side1 Main.side1 (Main.rot Main.t) Main.t
Main.corner1 = Main.quartet Main.nil Main.nil Main.nil Main.u
Main.corner2
  = Main.quartet Main.corner1 Main.side1 (Main.rot Main.side1) Main.u
Main.pseudocorner
  = Main.quartet
      Main.corner2 Main.side2 (Main.rot Main.side2) (Main.rot Main.t)
Main.pseudolimit = Main.cycle' Main.pseudocorner
Main.nonet
  (!p1_ayy)
  p2_ayz
  (!p3_ayA)
  p4_ayB
  p5_ayC
  p6_ayD
  p7_ayE
  p8_ayF
  (!p9_ayG)
  = Main.above
      1
      2
      (Main.beside 1 2 p1_ayy (Main.beside 1 1 p2_ayz p3_ayA))
      (Main.above
         1
         1
         (Main.beside 1 2 p4_ayB (Main.beside 1 1 p5_ayC p6_ayD))
         (Main.beside 1 2 p7_ayE (Main.beside 1 1 p8_ayF p9_ayG)))
Main.corner
  = Main.nonet
      Main.corner2
      Main.side2
      Main.side2
      (Main.rot Main.side2)
      Main.u
      (Main.rot Main.t)
      (Main.rot Main.side2)
      (Main.rot Main.t)
      (Main.rot Main.q)
Main.squarelimit = Main.cycle' Main.corner
Main.fmt (![]) = "[]"
Main.fmt (x_ayH : xs_ayI)
  = (showString "[\n" . showsPrec 0 x_ayH . showl_ayJ xs_ayI) ""
  where
      showl_ayJ [] s_ayK = showChar ']' s_ayK
      showl_ayJ ((!(x_aH9 : (!xs_aHa)))) (!s_aHb)
        = (showString ",\n" . showsPrec 0 x_aH9 . showl_ayJ xs_aHa) s_aHb
Main.main
  = putStrLn (Main.fmt (Main.pseudolimit (0, 0) (640, 0) (0, 640)))

type Main.Vec = (Int, Int)
type Main.Line_segment = (Int, Int, Int, Int)
type Main.Picture =
    Main.Vec -> Main.Vec -> Main.Vec -> [Main.Line_segment]


["x1_anB","safebang@!x1_anB","(!x1_anB)","y1_anC","safebang@!y1_anC","(!y1_anC)","((!x1_anB), (!y1_anC))","x2_anD","safebang@!x2_anD","(!x2_anD)","y2_anE","safebang@!y2_anE","(!y2_anE)","((!x2_anD), (!y2_anE))","!((!x2_anD), (!y2_anE))","(!((!x2_anD), (!y2_anE)))","x1_aoD","y1_aoE","!y1_aoE","(!y1_aoE)","(x1_aoD, (!y1_aoE))","!(x1_aoD, (!y1_aoE))","(!(x1_aoD, (!y1_aoE)))","x2_aoF","y2_aoG","safebang@!y2_aoG","(!y2_aoG)","(x2_aoF, (!y2_aoG))","x_aoH","safebang@!x_aoH","(!x_aoH)","y_aoI","safebang@!y_aoI","(!y_aoI)","((!x_aoH), (!y_aoI))","!((!x_aoH), (!y_aoI))","(!((!x_aoH), (!y_aoI)))","a_aoJ","b_aoK","p_tile","q_tile","r_tile","s_tile","a_axU","b_axV","c_axW","m_axX","n_axY","!n_axY","(!n_axY)","segments_axZ","safebang@!segments_axZ","(!segments_axZ)","a_ay0","b_ay1","c_ay2","x0_ay3","safebang@!x0_ay3","(!x0_ay3)","y0_ay4","safebang@!y0_ay4","(!y0_ay4)","x1_ay5","safebang@!x1_ay5","(!x1_ay5)","y1_ay6","((!x0_ay3), (!y0_ay4), (!x1_ay5), y1_ay6)","!((!x0_ay3), (!y0_ay4), (!x1_ay5), y1_ay6)","(!((!x0_ay3), (!y0_ay4), (!x1_ay5), y1_ay6))","p_ay7","a_ay8","safebang@!a_ay8","(!a_ay8)","b_ay9","c_aya","safebang@!c_aya","(!c_aya)","m_ayb","n_ayc","p_ayd","q_aye","a_ayf","b_ayg","c_ayh","!c_ayh","(!c_ayh)","m_ayi","!m_ayi","(!m_ayi)","n_ayj","p_ayk","q_ayl","a_aym","!a_aym","(!a_aym)","b_ayn","!b_ayn","(!b_ayn)","c_ayo","a_ayp","!a_ayp","(!a_ayp)","b_ayq","((!a_ayp), b_ayq)","!((!a_ayp), b_ayq)","(!((!a_ayp), b_ayq))","c_ayr","!c_ayr","(!c_ayr)","d_ays","!d_ays","(!d_ays)","((!c_ayr), (!d_ays))","tile_to_grid","p","q","r","s","a_ayt","safebang@!a_ayt","(!a_ayt)","b_ayu","safebang@!b_ayu","(!b_ayu)","c_ayv","d_ayw","safebang@!d_ayw","(!d_ayw)","t","p1_ayx","u","side1","side2","corner1","corner2","pseudocorner","pseudolimit","p1_ayy","!p1_ayy","(!p1_ayy)","p2_ayz","p3_ayA","!p3_ayA","(!p3_ayA)","p4_ayB","p5_ayC","p6_ayD","p7_ayE","p8_ayF","p9_ayG","!p9_ayG","(!p9_ayG)","corner","squarelimit","[]","![]","(![])","x_ayH","xs_ayI","x_ayH : xs_ayI","(x_ayH : xs_ayI)","[]","s_ayK","x_aH9","xs_aHa","safebang@!xs_aHa","(!xs_aHa)","x_aH9 : (!xs_aHa)","(x_aH9 : (!xs_aHa))","!(x_aH9 : (!xs_aHa))","(!(x_aH9 : (!xs_aHa)))","((!(x_aH9 : (!xs_aHa))))","s_aHb","!s_aHb","(!s_aHb)","main"]
module Main (main) where

vec_add :: Vec -> Vec -> Vec
vec_add ((!x1_anB), (!y1_anC)) (norecord@((!x2_anD), (!y2_anE)))
  = (x1_anB + x2_anD, y1_anC + y2_anE)

vec_sub :: Vec -> Vec -> Vec
vec_sub (norecord@(x1_aoD, (norecord@y1_aoE))) (x2_aoF, (!y2_aoG))
  = (x1_aoD - x2_aoF, y1_aoE - y2_aoG)

scale_vec2 :: Vec -> Int -> Int -> Vec
scale_vec2 (norecord@((!x_aoH), (!y_aoI))) a_aoJ b_aoK
  = ((x_aoH * a_aoJ) `div` b_aoK, (y_aoI * a_aoJ) `div` b_aoK)

p_tile :: [(Int, Int, Int, Int)]

q_tile :: [(Int, Int, Int, Int)]

r_tile :: [(Int, Int, Int, Int)]

s_tile :: [(Int, Int, Int, Int)]
p_tile
  = [(0, 3, 3, 4), (3, 4, 0, 8), (0, 8, 0, 3), (6, 0, 4, 4),
     (4, 5, 4, 10), (4, 10, 7, 6), (7, 6, 4, 5), (11, 0, 10, 4),
     (10, 4, 9, 6), (9, 6, 8, 8), (8, 8, 4, 13), (4, 13, 0, 16),
     (0, 16, 6, 15), (6, 15, 8, 16), (8, 16, 12, 12), (12, 12, 16, 12),
     (10, 16, 12, 14), (12, 14, 16, 13), (12, 16, 13, 15),
     (13, 15, 16, 14), (14, 16, 16, 15), (8, 12, 16, 10), (8, 8, 12, 9),
     (12, 9, 16, 8), (9, 6, 12, 7), (12, 7, 16, 6), (10, 4, 13, 5),
     (13, 5, 16, 4), (11, 0, 14, 2), (14, 2, 16, 2)]
q_tile
  = [(0, 8, 4, 7), (4, 7, 6, 7), (6, 7, 8, 8), (8, 8, 12, 10),
     (12, 10, 16, 16), (0, 12, 3, 13), (3, 13, 5, 14), (5, 14, 7, 15),
     (7, 15, 8, 16), (2, 16, 3, 13), (4, 16, 5, 14), (6, 16, 7, 15),
     (0, 10, 7, 11), (9, 13, 8, 15), (8, 15, 11, 15), (11, 15, 9, 13),
     (10, 10, 8, 12), (8, 12, 12, 12), (12, 12, 10, 10), (2, 0, 4, 5),
     (4, 5, 4, 7), (4, 0, 6, 5), (6, 5, 6, 7), (6, 0, 8, 5),
     (8, 5, 8, 8), (10, 0, 14, 11), (12, 0, 13, 4), (13, 4, 16, 8),
     (16, 8, 15, 10), (15, 10, 16, 16), (13, 0, 16, 6), (14, 0, 16, 4),
     (15, 0, 16, 2), (0, 0, 8, 0), (12, 0, 16, 0), (0, 0, 0, 8),
     (0, 12, 0, 16)]
r_tile
  = [(0, 0, 8, 8), (12, 12, 16, 16), (0, 4, 5, 10), (0, 8, 2, 12),
     (0, 12, 1, 14), (16, 6, 11, 10), (11, 10, 6, 16), (16, 4, 14, 6),
     (14, 6, 8, 8), (8, 8, 5, 10), (5, 10, 2, 12), (2, 12, 0, 16),
     (16, 8, 12, 12), (12, 12, 11, 16), (1, 1, 4, 0), (2, 2, 8, 0),
     (3, 3, 8, 2), (8, 2, 12, 0), (5, 5, 12, 3), (12, 3, 16, 0),
     (11, 16, 12, 12), (12, 12, 16, 8), (13, 13, 16, 10),
     (14, 14, 16, 12), (15, 15, 16, 14)]
s_tile
  = [(0, 0, 4, 2), (4, 2, 8, 2), (8, 2, 16, 0), (0, 4, 2, 1),
     (0, 6, 7, 4), (0, 8, 8, 6), (0, 10, 7, 8), (0, 12, 7, 10),
     (0, 14, 7, 13), (13, 13, 16, 14), (14, 11, 16, 12),
     (15, 9, 16, 10), (16, 0, 10, 4), (10, 4, 8, 6), (8, 6, 7, 8),
     (7, 8, 7, 13), (7, 13, 8, 16), (12, 16, 13, 13), (13, 13, 14, 11),
     (14, 11, 15, 9), (15, 9, 16, 8), (10, 16, 11, 10), (12, 4, 10, 6),
     (10, 6, 12, 7), (12, 7, 12, 4), (15, 5, 13, 7), (13, 7, 15, 8),
     (15, 8, 15, 5)]
nil a_axU b_axV c_axW = []

grid ::
     Int -> Int -> [Line_segment] -> Vec -> Vec -> Vec -> [Line_segment]
grid m_axX (norecord@n_axY) (!segments_axZ) a_ay0 b_ay1 c_ay2
  = [tup2
       (a_ay0 `vec_add` (scale_vec2 b_ay1 x0_ay3 m_axX) `vec_add`
          (scale_vec2 c_ay2 y0_ay4 n_axY))
       (a_ay0 `vec_add` (scale_vec2 b_ay1 x1_ay5 m_axX) `vec_add`
          (scale_vec2 c_ay2 y1_ay6 n_axY))
     |
     (norecord@((!x0_ay3), (!y0_ay4), (!x1_ay5),
                y1_ay6)) <- segments_axZ]
rot p_ay7 (!a_ay8) b_ay9 (!c_aya)
  = p_ay7 (a_ay8 `vec_add` b_ay9) c_aya ((0, 0) `vec_sub` b_ay9)
beside m_ayb n_ayc p_ayd q_aye a_ayf b_ayg (norecord@c_ayh)
  = p_ayd a_ayf (scale_vec2 b_ayg m_ayb (m_ayb + n_ayc)) c_ayh ++
      q_aye (a_ayf `vec_add` (scale_vec2 b_ayg m_ayb (m_ayb + n_ayc)))
        (scale_vec2 b_ayg n_ayc (n_ayc + m_ayb))
        c_ayh
above (norecord@m_ayi) n_ayj p_ayk q_ayl (norecord@a_aym)
  (norecord@b_ayn) c_ayo
  = p_ayk (a_aym `vec_add` (scale_vec2 c_ayo n_ayj (m_ayi + n_ayj)))
      b_ayn
      (scale_vec2 c_ayo m_ayi (n_ayj + m_ayi))
      ++ q_ayl a_aym b_ayn (scale_vec2 c_ayo n_ayj (m_ayi + n_ayj))

tup2 ::
     (a_anx, b_any) -> (c_anz, d_anA) -> (a_anx, b_any, c_anz, d_anA)
tup2 (norecord@((norecord@a_ayp), b_ayq))
  ((norecord@c_ayr), (norecord@d_ays)) = (a_ayp, b_ayq, c_ayr, d_ays)
tile_to_grid = grid 16 16
p = tile_to_grid p_tile
q = tile_to_grid q_tile
r = tile_to_grid r_tile
s = tile_to_grid s_tile
quartet (!a_ayt) (!b_ayu) c_ayv (!d_ayw)
  = above 1 1 (beside 1 1 a_ayt b_ayu) (beside 1 1 c_ayv d_ayw)
t = quartet p q r s
cycle' p1_ayx
  = quartet p1_ayx (rot (rot (rot p1_ayx))) (rot p1_ayx)
      (rot (rot p1_ayx))
u = cycle' (rot q)
side1 = quartet nil nil (rot t) t
side2 = quartet side1 side1 (rot t) t
corner1 = quartet nil nil nil u
corner2 = quartet corner1 side1 (rot side1) u
pseudocorner = quartet corner2 side2 (rot side2) (rot t)
pseudolimit = cycle' pseudocorner
nonet (norecord@p1_ayy) p2_ayz (norecord@p3_ayA) p4_ayB p5_ayC
  p6_ayD p7_ayE p8_ayF (norecord@p9_ayG)
  = above 1 2 (beside 1 2 p1_ayy (beside 1 1 p2_ayz p3_ayA))
      (above 1 1 (beside 1 2 p4_ayB (beside 1 1 p5_ayC p6_ayD))
         (beside 1 2 p7_ayE (beside 1 1 p8_ayF p9_ayG)))
corner
  = nonet corner2 side2 side2 (rot side2) u (rot t) (rot side2)
      (rot t)
      (rot q)
squarelimit = cycle' corner
fmt (norecord@[]) = "[]"
fmt (x_ayH : xs_ayI)
  = (showString "[\n" . showsPrec 0 x_ayH . showl_ayJ xs_ayI) ""
  where showl_ayJ [] s_ayK = showChar ']' s_ayK
        showl_ayJ ((norecord@(x_aH9 : (!xs_aHa)))) (norecord@s_aHb)
          = (showString ",\n" . showsPrec 0 x_aH9 . showl_ayJ xs_aHa) s_aHb
main = putStrLn (fmt (pseudolimit (0, 0) (640, 0) (0, 640)))

type Vec = (Int, Int)

type Line_segment = (Int, Int, Int, Int)

type Picture = Vec -> Vec -> Vec -> [Line_segment]

==================== Renamer ====================
Main.start :: [[Int]]
Main.start
  = [[], [], [], [], [], [], [], [], [], [], [], [], [], [],
     [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1,
      1, 1, 1, 1, 0]]
Main.gen n_ana board_anb
  = map Main.row (Main.shift (Main.copy n_ana 0) board_anb)
Main.row (!((!last_anc), (!this_and), (!next_ane)))
  = zipWith3
      Main.elt
      (Main.shift 0 last_anc)
      (Main.shift 0 this_and)
      (Main.shift 0 next_ane)
Main.elt
  (a_aqQ, b_aqR, c_aqS)
  (d_aqT, e_aqU, f_aqV)
  (g_aqW, h_aqX, (!i_aqY))
  | tot_aqZ < 2 || tot_aqZ > 3 = 0
  | tot_aqZ == 3 = 1
  | otherwise = e_aqU
  where
      tot_aqZ
        = a_aqQ + b_aqR + c_aqS + d_aqT + f_aqV + g_aqW + h_aqX + i_aqY
Main.shiftr x_aFq xs_aFr = [x_aFq] ++ init xs_aFr
Main.shiftl x_aFs xs_aFt = tail xs_aFt ++ [x_aFs]
Main.shift (!x_aFu) xs_aFv
  = zip3 (Main.shiftr x_aFu xs_aFv) xs_aFv (Main.shiftl x_aFu xs_aFv)
Main.copy (!0) (!x_aFw) = []
Main.copy n_aFx (!x_aFy) = x_aFy : Main.copy (n_aFx - 1) x_aFy
Main.disp ((!gen_aFz), (!xss_aFA))
  = gen_aFz
    ++
      "\n\
      \\n"
      ++
        (foldr (Main.glue "\n") "" . map (concat . map Main.star)) xss_aFA
Main.star 0 = "  "
Main.star 1 = " o"
Main.glue (!s_aLx) xs_aLy (!ys_aLz) = xs_aLy ++ s_aLx ++ ys_aLz
Main.limit ((!((!x_aLA) : (!(y_aLB : xs_aLC)))))
  | x_aLA == y_aLB = [x_aLA]
  | otherwise = x_aLA : Main.limit (y_aLB : xs_aLC)
Main.main
  = putStr (last generations_aLE)
  where
      sz_aLD = 30
      (!generations_aLE)
        = (map Main.disp
           . zip (map show [0 .. ]) . Main.limit . iterate (Main.gen sz_aLD))
            (take
               sz_aLD
               (map (take sz_aLD . (++ (Main.copy sz_aLD 0))) Main.start
                ++ Main.copy sz_aLD (Main.copy sz_aLD 0)))


["start","n_ana","board_anb","last_anc","safebang@!last_anc","(!last_anc)","this_and","safebang@!this_and","(!this_and)","next_ane","safebang@!next_ane","(!next_ane)","((!last_anc), (!this_and), (!next_ane))","!((!last_anc), (!this_and), (!next_ane))","(!((!last_anc), (!this_and), (!next_ane)))","a_aqQ","b_aqR","c_aqS","(a_aqQ, b_aqR, c_aqS)","d_aqT","e_aqU","f_aqV","(d_aqT, e_aqU, f_aqV)","g_aqW","h_aqX","i_aqY","safebang@!i_aqY","(!i_aqY)","(g_aqW, h_aqX, (!i_aqY))","tot_aqZ","x_aFq","xs_aFr","x_aFs","xs_aFt","x_aFu","!x_aFu","(!x_aFu)","xs_aFv","0","!0","(!0)","x_aFw","safebang@!x_aFw","(!x_aFw)","n_aFx","x_aFy","!x_aFy","(!x_aFy)","gen_aFz","!gen_aFz","(!gen_aFz)","xss_aFA","!xss_aFA","(!xss_aFA)","((!gen_aFz), (!xss_aFA))","0","1","s_aLx","!s_aLx","(!s_aLx)","xs_aLy","ys_aLz","!ys_aLz","(!ys_aLz)","x_aLA","safebang@!x_aLA","(!x_aLA)","y_aLB","xs_aLC","y_aLB : xs_aLC","(y_aLB : xs_aLC)","!(y_aLB : xs_aLC)","(!(y_aLB : xs_aLC))","(!x_aLA) : (!(y_aLB : xs_aLC))","((!x_aLA) : (!(y_aLB : xs_aLC)))","!((!x_aLA) : (!(y_aLB : xs_aLC)))","(!((!x_aLA) : (!(y_aLB : xs_aLC))))","((!((!x_aLA) : (!(y_aLB : xs_aLC)))))","main","sz_aLD","generations_aLE","lazydmd@!generations_aLE","(!generations_aLE)"]
module Main (main) where

start :: [[Int]]
start
  = [[], [], [], [], [], [], [], [], [], [], [], [], [], [],
     [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1,
      1, 1, 1, 1, 0]]
gen n_ana board_anb = map row (shift (copy n_ana 0) board_anb)
row (norecord@((!last_anc), (!this_and), (!next_ane)))
  = zipWith3 elt (shift 0 last_anc) (shift 0 this_and)
      (shift 0 next_ane)
elt (a_aqQ, b_aqR, c_aqS) (d_aqT, e_aqU, f_aqV)
  (g_aqW, h_aqX, (!i_aqY))
  | tot_aqZ < 2 || tot_aqZ > 3 = 0
  | tot_aqZ == 3 = 1
  | otherwise = e_aqU
  where tot_aqZ
          = a_aqQ + b_aqR + c_aqS + d_aqT + f_aqV + g_aqW + h_aqX + i_aqY
shiftr x_aFq xs_aFr = [x_aFq] ++ init xs_aFr
shiftl x_aFs xs_aFt = tail xs_aFt ++ [x_aFs]
shift (norecord@x_aFu) xs_aFv
  = zip3 (shiftr x_aFu xs_aFv) xs_aFv (shiftl x_aFu xs_aFv)
copy (norecord@0) (!x_aFw) = []
copy n_aFx (norecord@x_aFy) = x_aFy : copy (n_aFx - 1) x_aFy
disp ((norecord@gen_aFz), (norecord@xss_aFA))
  = gen_aFz ++ "\n\n" ++
      (foldr (glue "\n") "" . map (concat . map star)) xss_aFA
star 0 = "  "
star 1 = " o"
glue (norecord@s_aLx) xs_aLy (norecord@ys_aLz)
  = xs_aLy ++ s_aLx ++ ys_aLz
limit ((norecord@((!x_aLA) : (norecord@(y_aLB : xs_aLC)))))
  | x_aLA == y_aLB = [x_aLA]
  | otherwise = x_aLA : limit (y_aLB : xs_aLC)
main = putStr (last generations_aLE)
  where sz_aLD = 30
        (lazydmd@generations_aLE)
          = (map disp . zip (map show [0 ..]) . limit . iterate (gen sz_aLD))
              (take sz_aLD
                 (map (take sz_aLD . (++ (copy sz_aLD 0))) start ++
                    copy sz_aLD (copy sz_aLD 0)))

==================== Renamer ====================
Main.main
  = do { stuff_azo <- getContents;
         putStr (Main.say stuff_azo) }
Main.say
  = ('\n' :) . unlines . map join_azp . transpose . map Main.picChar
  where
      join_azp = foldr1 (\ (!xs_aFt) ys_aFu -> xs_aFt ++ "  " ++ ys_aFu)
Main.picChar (!c_aHS)
  | isUpper c_aHS = Main.alphas !! (fromEnum c_aHS - fromEnum 'A')
  | isLower c_aHS = Main.alphas !! (fromEnum c_aHS - fromEnum 'a')
  | isSpace c_aHS = Main.blank
  | isDigit c_aHS = Main.digits !! (fromEnum c_aHS - fromEnum '0')
  | c_aHS == '/' = Main.slant
  | c_aHS == '\\' = reverse Main.slant
  | otherwise
  = head
      ([letter_a17a |
          (!((!c'_a179), letter_a17a)) <- Main.punct, c'_a179 == c_aHS]
       ++ [Main.nothing])
Main.blank = ["     ", "     ", "     ", "     ", "     "]
Main.slant = ["    ", "   ", "  ", " ", ""]
Main.nothing = repeat ""
Main.punct
  = [('.', ["     ", "     ", "     ", "  .. ", "  .. "]),
     ('?', [" ??? ", "?   ?", "   ? ", "  ?  ", "  .  "]),
     ('!', ["  !  ", "  !  ", "  !  ", "  !  ", "  .  "]),
     ('-', ["     ", "     ", "-----", "     ", "     "]),
     ('+', ["  +  ", "  +  ", "+++++", "  +  ", "  +  "]),
     (':', ["     ", "  :: ", "     ", "  :: ", "     "]),
     (';', ["     ", "  ;; ", "     ", "  ;; ", " ;;  "])]
Main.digits
  = [[" OOO ", "0  00", "0 0 0", "00  0", " 000 "],
     ["  1  ", " 11  ", "  1  ", "  1  ", "11111"],
     [" 222 ", "2   2", "   2 ", "  2  ", "22222"],
     ["3333 ", "    3", " 333 ", "    3", "3333 "],
     ["   4 ", "  44 ", " 4 4 ", "44444", "   4 "],
     ["55555", "5    ", "5555 ", "    5", "5555 "],
     ["   66", "  6  ", " 666 ", "6   6", " 666 "],
     ["77777", "    7", "   7 ", "   7 ", "  7  "],
     [" 888 ", "8   8", " 888 ", "8   8", " 888 "],
     [" 999 ", "9   9", " 999 ", "  9  ", "99   "]]
Main.alphas
  = [["  A  ", " A A ", "AAAAA", "A   A", "A   A"],
     ["BBBB ", "B   B", "BBBB ", "B   B", "BBBB "],
     [" CCCC", "C    ", "C    ", "C    ", " CCCC"],
     ["DDDD ", "D   D", "D   D", "D   D", "DDDD "],
     ["EEEEE", "E    ", "EEEEE", "E    ", "EEEEE"],
     ["FFFFF", "F    ", "FFFF ", "F    ", "F    "],
     [" GGGG", "G    ", "G  GG", "G   G", " GGG "],
     ["H   H", "H   H", "HHHHH", "H   H", "H   H"],
     ["IIIII", "  I  ", "  I  ", "  I  ", "IIIII"],
     ["JJJJJ", "   J ", "   J ", "J  J ", " JJ  "],
     ["K   K", "K  K ", "KKK  ", "K  K ", "K   K"],
     ["L    ", "L    ", "L    ", "L    ", "LLLLL"],
     ["M   M", "MM MM", "M M M", "M   M", "M   M"],
     ["N   N", "NN  N", "N N N", "N  NN", "N   N"],
     [" OOO ", "O   O", "O   O", "O   O", " OOO "],
     ["PPPP ", "P   P", "PPPP ", "P    ", "P    "],
     [" QQQ ", "Q   Q", "Q Q Q", "Q  Q ", " QQ Q"],
     ["RRRR ", "R   R", "RRRR ", "R  R ", "R   R"],
     [" SSSS", "S    ", " SSS ", "    S", "SSSS "],
     ["TTTTT", "  T  ", "  T  ", "  T  ", "  T  "],
     ["U   U", "U   U", "U   U", "U   U", " UUU "],
     ["V   V", "V   V", "V   V", " V V ", "  V  "],
     ["W   W", "W   W", "W   W", "W W W", " W W "],
     ["X   X", " X X ", "  X  ", " X X ", "X   X"],
     ["Y   Y", " Y Y ", "  Y  ", "  Y  ", "  Y  "],
     ["ZZZZZ", "   Z ", "  Z  ", " Z   ", "ZZZZZ"]]


["main","stuff_azo","say","join_azp","xs_aFt","safebang@!xs_aFt","(!xs_aFt)","ys_aFu","c_aHS","!c_aHS","(!c_aHS)","c'_a179","safebang@!c'_a179","(!c'_a179)","letter_a17a","((!c'_a179), letter_a17a)","!((!c'_a179), letter_a17a)","(!((!c'_a179), letter_a17a))","blank","slant","nothing","punct","digits","alphas"]
module Main (main) where
import Data.Char
import Data.List
main
  = do stuff_azo <- getContents
       putStr (say stuff_azo)
say = ('\n' :) . unlines . map join_azp . transpose . map picChar
  where join_azp
          = foldr1 (\ (!xs_aFt) ys_aFu -> xs_aFt ++ "  " ++ ys_aFu)
picChar (norecord@c_aHS)
  | isUpper c_aHS = alphas !! (fromEnum c_aHS - fromEnum 'A')
  | isLower c_aHS = alphas !! (fromEnum c_aHS - fromEnum 'a')
  | isSpace c_aHS = blank
  | isDigit c_aHS = digits !! (fromEnum c_aHS - fromEnum '0')
  | c_aHS == '/' = slant
  | c_aHS == '\\' = reverse slant
  | otherwise =
    head
      ([letter_a17a | (norecord@((!c'_a179), letter_a17a)) <- punct,
        c'_a179 == c_aHS]
         ++ [nothing])
blank = ["     ", "     ", "     ", "     ", "     "]
slant = ["    ", "   ", "  ", " ", ""]
nothing = repeat ""
punct
  = [('.', ["     ", "     ", "     ", "  .. ", "  .. "]),
     ('?', [" ??? ", "?   ?", "   ? ", "  ?  ", "  .  "]),
     ('!', ["  !  ", "  !  ", "  !  ", "  !  ", "  .  "]),
     ('-', ["     ", "     ", "-----", "     ", "     "]),
     ('+', ["  +  ", "  +  ", "+++++", "  +  ", "  +  "]),
     (':', ["     ", "  :: ", "     ", "  :: ", "     "]),
     (';', ["     ", "  ;; ", "     ", "  ;; ", " ;;  "])]
digits
  = [[" OOO ", "0  00", "0 0 0", "00  0", " 000 "],
     ["  1  ", " 11  ", "  1  ", "  1  ", "11111"],
     [" 222 ", "2   2", "   2 ", "  2  ", "22222"],
     ["3333 ", "    3", " 333 ", "    3", "3333 "],
     ["   4 ", "  44 ", " 4 4 ", "44444", "   4 "],
     ["55555", "5    ", "5555 ", "    5", "5555 "],
     ["   66", "  6  ", " 666 ", "6   6", " 666 "],
     ["77777", "    7", "   7 ", "   7 ", "  7  "],
     [" 888 ", "8   8", " 888 ", "8   8", " 888 "],
     [" 999 ", "9   9", " 999 ", "  9  ", "99   "]]
alphas
  = [["  A  ", " A A ", "AAAAA", "A   A", "A   A"],
     ["BBBB ", "B   B", "BBBB ", "B   B", "BBBB "],
     [" CCCC", "C    ", "C    ", "C    ", " CCCC"],
     ["DDDD ", "D   D", "D   D", "D   D", "DDDD "],
     ["EEEEE", "E    ", "EEEEE", "E    ", "EEEEE"],
     ["FFFFF", "F    ", "FFFF ", "F    ", "F    "],
     [" GGGG", "G    ", "G  GG", "G   G", " GGG "],
     ["H   H", "H   H", "HHHHH", "H   H", "H   H"],
     ["IIIII", "  I  ", "  I  ", "  I  ", "IIIII"],
     ["JJJJJ", "   J ", "   J ", "J  J ", " JJ  "],
     ["K   K", "K  K ", "KKK  ", "K  K ", "K   K"],
     ["L    ", "L    ", "L    ", "L    ", "LLLLL"],
     ["M   M", "MM MM", "M M M", "M   M", "M   M"],
     ["N   N", "NN  N", "N N N", "N  NN", "N   N"],
     [" OOO ", "O   O", "O   O", "O   O", " OOO "],
     ["PPPP ", "P   P", "PPPP ", "P    ", "P    "],
     [" QQQ ", "Q   Q", "Q Q Q", "Q  Q ", " QQ Q"],
     ["RRRR ", "R   R", "RRRR ", "R  R ", "R   R"],
     [" SSSS", "S    ", " SSS ", "    S", "SSSS "],
     ["TTTTT", "  T  ", "  T  ", "  T  ", "  T  "],
     ["U   U", "U   U", "U   U", "U   U", " UUU "],
     ["V   V", "V   V", "V   V", " V V ", "  V  "],
     ["W   W", "W   W", "W   W", "W W W", " W W "],
     ["X   X", " X X ", "  X  ", " X X ", "X   X"],
     ["Y   Y", " Y Y ", "  Y  ", "  Y  ", "  Y  "],
     ["ZZZZZ", "   Z ", "  Z  ", " Z   ", "ZZZZZ"]]

==================== Renamer ====================
Main.main
  = putStr ((ppShow (80 :: Int) pretty_stuff_aoL) ++ "\n")
  where
      pretty_stuff_aoL
        = ppAboves
            [ppBesides [ppInt (- 42), ppChar '@', ppStr "This is a string"],
             pp'SP,
             ppHang
               (ppStr "This is the label")
               (8 :: Int)
               (ppCat (take (50 :: Int) pp_words_aoM))]
      pp_words_aoM = pp_word_aoN : pp_words_aoM
      pp_word_aoN = ppStr "xxxxx"


["main","pretty_stuff_aoL","pp_words_aoM","pp_word_aoN"]
module Main where
import Pretty
main = putStr ((ppShow (80 :: Int) pretty_stuff_aoL) ++ "\n")
  where pretty_stuff_aoL
          = ppAboves
              [ppBesides [ppInt (-42), ppChar '@', ppStr "This is a string"],
               pp'SP,
               ppHang (ppStr "This is the label") (8 :: Int)
                 (ppCat (take (50 :: Int) pp_words_aoM))]
        pp_words_aoM = pp_word_aoN : pp_words_aoM
        pp_word_aoN = ppStr "xxxxx"

==================== Renamer ====================
Pretty.ppNil :: Pretty.Pretty
Pretty.ppSP, Pretty.pp'SP, Pretty.ppLbrack, Pretty.ppRbrack, Pretty.ppLparen, Pretty.ppRparen, Pretty.ppSemi, Pretty.ppComma ::
  Pretty.Pretty
Pretty.ppStr :: [Char] -> Pretty.Pretty
Pretty.ppChar :: Char -> Pretty.Pretty
Pretty.ppInt :: Int -> Pretty.Pretty
Pretty.ppInteger :: Integer -> Pretty.Pretty
Pretty.ppDouble :: Double -> Pretty.Pretty
Pretty.ppBeside :: Pretty.Pretty -> Pretty.Pretty -> Pretty.Pretty
Pretty.ppBesides :: [Pretty.Pretty] -> Pretty.Pretty
Pretty.ppBesideSP ::
  Pretty.Pretty -> Pretty.Pretty -> Pretty.Pretty
Pretty.ppCat :: [Pretty.Pretty] -> Pretty.Pretty
Pretty.ppAbove :: Pretty.Pretty -> Pretty.Pretty -> Pretty.Pretty
Pretty.ppAboves :: [Pretty.Pretty] -> Pretty.Pretty
Pretty.ppInterleave ::
  Pretty.Pretty -> [Pretty.Pretty] -> Pretty.Pretty
Pretty.ppSep :: [Pretty.Pretty] -> Pretty.Pretty
Pretty.ppHang ::
  Pretty.Pretty -> Int -> Pretty.Pretty -> Pretty.Pretty
Pretty.ppNest :: Int -> Pretty.Pretty -> Pretty.Pretty
Pretty.ppShow :: Int -> Pretty.Pretty -> [Char]
Pretty.ppUnformatted :: Pretty.Pretty -> [Char]
Pretty.ppShow width_awz p_awA
  = cShow seq_awB
  where
      (!(Pretty.MkPrettyRep seq_awB ll_awC (!emp_awD) sl_awE))
        = p_awA width_awz False
Pretty.ppUnformatted p_awF
  = cShow seq_awG
  where
      ((!(Pretty.MkPrettyRep seq_awG ll_awH emp_awI sl_awJ)))
        = p_awF 80 False
Pretty.ppNil width_awK is_vert_awL
  = Pretty.MkPrettyRep cNil 0 True (width_awK >= 0)
Pretty.ppStr s_aKd width_aKe (!is_vert_aKf)
  = Pretty.MkPrettyRep
      (cStr s_aKd) ls_aKg False (width_aKe >= ls_aKg)
  where
      (!ls_aKg) = length s_aKd
Pretty.ppChar (!c_aQo) (!width_aQp) is_vert_aQq
  = Pretty.MkPrettyRep (cCh c_aQo) 1 False (width_aQp >= 1)
Pretty.ppInt (!n_aQr) = Pretty.ppStr (show n_aQr)
Pretty.ppInteger (!n_aYS) = Pretty.ppStr (show n_aYS)
Pretty.ppDouble (!n_aYT) = Pretty.ppStr (show n_aYT)
Pretty.ppSP = Pretty.ppChar ' '
Pretty.pp'SP = Pretty.ppStr ", "
Pretty.ppLbrack = Pretty.ppChar '['
Pretty.ppRbrack = Pretty.ppChar ']'
Pretty.ppLparen = Pretty.ppChar '('
Pretty.ppRparen = Pretty.ppChar ')'
Pretty.ppSemi = Pretty.ppChar ';'
Pretty.ppComma = Pretty.ppChar ','
Pretty.ppInterleave sep_aYU (!ps_aYV)
  = Pretty.ppSep (pi_aYW ps_aYV)
  where
      pi_aYW (![]) = []
      pi_aYW [x_aYX] = [x_aYX]
      pi_aYW ((!((!x_aYY) : xs_aYZ)))
        = (Pretty.ppBeside x_aYY sep_aYU) : pi_aYW xs_aYZ
Pretty.ppBeside p1_aZ0 p2_aZ1 (!width_aZ2) is_vert_aZ3
  = Pretty.MkPrettyRep
      (seq1_aZ4 `cAppend` (cIndent ll1_aZ5 seq2_aZ8))
      (ll1_aZ5 + ll2_aZ9)
      (emp1_aZ6 `Pretty.andL` emp2_aZa)
      ((width_aZ2 >= 0) `Pretty.andL` (sl1_aZ7 `Pretty.andL` sl2_aZb))
  where
      (!(Pretty.MkPrettyRep (!seq1_aZ4) ll1_aZ5 emp1_aZ6 sl1_aZ7))
        = p1_aZ0 width_aZ2 False
      Pretty.MkPrettyRep seq2_aZ8 ll2_aZ9 (!emp2_aZa) sl2_aZb
        = p2_aZ1 (width_aZ2 - ll1_aZ5) False
Pretty.ppBesides [] = Pretty.ppNil
Pretty.ppBesides ps_a103 = foldr1 Pretty.ppBeside ps_a103
Pretty.ppBesideSP p1_a104 (!p2_a105) width_a106 (!is_vert_a107)
  = Pretty.MkPrettyRep
      (seq1_a108
       `cAppend` (sp_a10i `cAppend` (cIndent li_a10g seq2_a10c)))
      (li_a10g + ll2_a10d)
      (emp1_a10a `Pretty.andL` emp2_a10e)
      ((width_a106 >= wi_a10h)
       `Pretty.andL` (sl1_a10b `Pretty.andL` sl2_a10f))
  where
      Pretty.MkPrettyRep (!seq1_a108) (!ll1_a109) emp1_a10a sl1_a10b
        = p1_a104 width_a106 False
      Pretty.MkPrettyRep seq2_a10c ll2_a10d emp2_a10e sl2_a10f
        = p2_a105 (width_a106 - li_a10g) False
      li_a10g, wi_a10h :: Int
      li_a10g = if emp1_a10a then 0 else ll1_a109 + 1
      (!wi_a10h) = if emp1_a10a then 0 else 1
      sp_a10i
        = if emp1_a10a `Pretty.orL` emp2_a10e then cNil else (cCh ' ')
Pretty.ppCat [] = Pretty.ppNil
Pretty.ppCat ps_a10j = foldr1 Pretty.ppBesideSP ps_a10j
Pretty.ppAbove (!p1_a10k) (!p2_a10l) width_a10m is_vert_a10n
  = Pretty.MkPrettyRep
      (seq1_a10p `cAppend` (nl_a10o `cAppend` seq2_a10t))
      ll2_a10u
      (emp1_a10r `Pretty.andL` emp2_a10v)
      False
  where
      (!nl_a10o) = if emp1_a10r `Pretty.orL` emp2_a10v then cNil else cNL
      Pretty.MkPrettyRep seq1_a10p (!ll1_a10q) emp1_a10r (!sl1_a10s)
        = p1_a10k width_a10m True
      (!(Pretty.MkPrettyRep (!seq2_a10t) ll2_a10u emp2_a10v (!sl2_a10w)))
        = p2_a10l width_a10m True
Pretty.ppAboves [] = Pretty.ppNil
Pretty.ppAboves ps_a10x = foldr1 Pretty.ppAbove ps_a10x
Pretty.ppNest (!n_a10y) (!p_a10z) width_a10A (!False)
  = p_a10z width_a10A False
Pretty.ppNest (!n_a10B) (!p_a10C) (!width_a10D) True
  = Pretty.MkPrettyRep
      (cIndent n_a10B seq_a10E) (ll_a10F + n_a10B) emp_a10G sl_a10H
  where
      (!(Pretty.MkPrettyRep seq_a10E ll_a10F (!emp_a10G) (!sl_a10H)))
        = p_a10C (width_a10D - n_a10B) True
Pretty.ppHang (!p1_a10I) n_a10J p2_a10K (!width_a10L) is_vert_a10M
  = if emp1_a10P then
        p2_a10K width_a10L is_vert_a10M
    else
        if (ll1_a10O <= n_a10J) `Pretty.orL` sl2_a10U then
            Pretty.MkPrettyRep
              (seq1_a10N `cAppend` (cCh ' ')
               `cAppend` (cIndent (ll1_a10O + 1) seq2_a10R))
              (ll1_a10O + 1 + ll2_a10S)
              False
              (sl1_a10Q `Pretty.andL` sl2_a10U)
        else
            Pretty.MkPrettyRep
              (seq1_a10N `cAppend` (cNL `cAppend` (cIndent n_a10J seq2'_a10V)))
              ll2'_a10W
              False
              False
  where
      Pretty.MkPrettyRep seq1_a10N (!ll1_a10O) (!emp1_a10P) sl1_a10Q
        = p1_a10I width_a10L False
      (!(Pretty.MkPrettyRep seq2_a10R ll2_a10S emp2_a10T (!sl2_a10U)))
        = p2_a10K (width_a10L - (ll1_a10O + 1)) False
      Pretty.MkPrettyRep (!seq2'_a10V) ll2'_a10W emp2'_a10X sl2'_a10Y
        = p2_a10K (width_a10L - n_a10J) False
Pretty.ppSep [] width_a10Z is_vert_a110
  = Pretty.ppNil width_a10Z is_vert_a110
Pretty.ppSep (![(!p_a111)]) (!width_a112) (!is_vert_a113)
  = p_a111 width_a112 is_vert_a113
Pretty.ppSep (!ps_a114) width_a115 (!is_vert_a116)
  = if sl_a11b then
        pr_a117
    else
        Pretty.ppAboves ps_a114 width_a115 is_vert_a116
  where
      pr_a117@((!(Pretty.MkPrettyRep seq_a118
                                     (!ll_a119)
                                     emp_a11a
                                     sl_a11b)))
        = Pretty.ppCat ps_a114 width_a115 is_vert_a116
Pretty.andL :: Bool -> Bool -> Bool
Pretty.andL False x_a11c = False
Pretty.andL (!True) (!x_a11d) = x_a11d
Pretty.orL :: Bool -> Bool -> Bool
Pretty.orL True (!x_a11e) = True
Pretty.orL False x_a11f = x_a11f

data Pretty.PrettyRep = Pretty.MkPrettyRep CSeq Int Bool Bool
type Pretty.Pretty = Int -> Bool -> Pretty.PrettyRep
data Pretty.PprStyle
  = Pretty.PprForUser |
    Pretty.PprDebug |
    Pretty.PprShowAll |
    Pretty.PprInterface


["width_awz","p_awA","seq_awB","ll_awC","emp_awD","safebang@!emp_awD","(!emp_awD)","sl_awE","MkPrettyRep seq_awB ll_awC (!emp_awD) sl_awE","(MkPrettyRep seq_awB ll_awC (!emp_awD) sl_awE)","!(MkPrettyRep seq_awB ll_awC (!emp_awD) sl_awE)","(!(MkPrettyRep seq_awB ll_awC (!emp_awD) sl_awE))","p_awF","seq_awG","ll_awH","emp_awI","sl_awJ","MkPrettyRep seq_awG ll_awH emp_awI sl_awJ","(MkPrettyRep seq_awG ll_awH emp_awI sl_awJ)","!(MkPrettyRep seq_awG ll_awH emp_awI sl_awJ)","(!(MkPrettyRep seq_awG ll_awH emp_awI sl_awJ))","((!(MkPrettyRep seq_awG ll_awH emp_awI sl_awJ)))","width_awK","is_vert_awL","s_aKd","width_aKe","is_vert_aKf","safebang@!is_vert_aKf","(!is_vert_aKf)","ls_aKg","!ls_aKg","(!ls_aKg)","c_aQo","safebang@!c_aQo","(!c_aQo)","width_aQp","safebang@!width_aQp","(!width_aQp)","is_vert_aQq","n_aQr","safebang@!n_aQr","(!n_aQr)","n_aYS","safebang@!n_aYS","(!n_aYS)","n_aYT","safebang@!n_aYT","(!n_aYT)","ppSP","pp'SP","ppLbrack","ppRbrack","ppLparen","ppRparen","ppSemi","ppComma","sep_aYU","ps_aYV","safebang@!ps_aYV","(!ps_aYV)","[]","![]","(![])","x_aYX","[x_aYX]","x_aYY","!x_aYY","(!x_aYY)","xs_aYZ","(!x_aYY) : xs_aYZ","((!x_aYY) : xs_aYZ)","!((!x_aYY) : xs_aYZ)","(!((!x_aYY) : xs_aYZ))","((!((!x_aYY) : xs_aYZ)))","p1_aZ0","p2_aZ1","width_aZ2","safebang@!width_aZ2","(!width_aZ2)","is_vert_aZ3","seq1_aZ4","safebang@!seq1_aZ4","(!seq1_aZ4)","ll1_aZ5","emp1_aZ6","sl1_aZ7","MkPrettyRep (!seq1_aZ4) ll1_aZ5 emp1_aZ6 sl1_aZ7","(MkPrettyRep (!seq1_aZ4) ll1_aZ5 emp1_aZ6 sl1_aZ7)","!(MkPrettyRep (!seq1_aZ4) ll1_aZ5 emp1_aZ6 sl1_aZ7)","(!(MkPrettyRep (!seq1_aZ4) ll1_aZ5 emp1_aZ6 sl1_aZ7))","seq2_aZ8","ll2_aZ9","emp2_aZa","!emp2_aZa","(!emp2_aZa)","sl2_aZb","MkPrettyRep seq2_aZ8 ll2_aZ9 (!emp2_aZa) sl2_aZb","[]","ps_a103","p1_a104","p2_a105","safebang@!p2_a105","(!p2_a105)","width_a106","is_vert_a107","safebang@!is_vert_a107","(!is_vert_a107)","seq1_a108","!seq1_a108","(!seq1_a108)","ll1_a109","!ll1_a109","(!ll1_a109)","emp1_a10a","sl1_a10b","MkPrettyRep (!seq1_a108) (!ll1_a109) emp1_a10a sl1_a10b","seq2_a10c","ll2_a10d","emp2_a10e","sl2_a10f","MkPrettyRep seq2_a10c ll2_a10d emp2_a10e sl2_a10f","li_a10g","wi_a10h","!wi_a10h","(!wi_a10h)","sp_a10i","[]","ps_a10j","p1_a10k","safebang@!p1_a10k","(!p1_a10k)","p2_a10l","safebang@!p2_a10l","(!p2_a10l)","width_a10m","is_vert_a10n","nl_a10o","!nl_a10o","(!nl_a10o)","seq1_a10p","ll1_a10q","!ll1_a10q","(!ll1_a10q)","emp1_a10r","sl1_a10s","!sl1_a10s","(!sl1_a10s)","MkPrettyRep seq1_a10p (!ll1_a10q) emp1_a10r (!sl1_a10s)","seq2_a10t","safebang@!seq2_a10t","(!seq2_a10t)","ll2_a10u","emp2_a10v","sl2_a10w","safebang@!sl2_a10w","(!sl2_a10w)","MkPrettyRep (!seq2_a10t) ll2_a10u emp2_a10v (!sl2_a10w)","(MkPrettyRep (!seq2_a10t) ll2_a10u emp2_a10v (!sl2_a10w))","!(MkPrettyRep (!seq2_a10t) ll2_a10u emp2_a10v (!sl2_a10w))","(!(MkPrettyRep (!seq2_a10t) ll2_a10u emp2_a10v (!sl2_a10w)))","[]","ps_a10x","n_a10y","safebang@!n_a10y","(!n_a10y)","p_a10z","safebang@!p_a10z","(!p_a10z)","width_a10A","False","!False","(!False)","n_a10B","!n_a10B","(!n_a10B)","p_a10C","!p_a10C","(!p_a10C)","width_a10D","!width_a10D","(!width_a10D)","True","seq_a10E","ll_a10F","emp_a10G","safebang@!emp_a10G","(!emp_a10G)","sl_a10H","safebang@!sl_a10H","(!sl_a10H)","MkPrettyRep seq_a10E ll_a10F (!emp_a10G) (!sl_a10H)","(MkPrettyRep seq_a10E ll_a10F (!emp_a10G) (!sl_a10H))","!(MkPrettyRep seq_a10E ll_a10F (!emp_a10G) (!sl_a10H))","(!(MkPrettyRep seq_a10E ll_a10F (!emp_a10G) (!sl_a10H)))","p1_a10I","safebang@!p1_a10I","(!p1_a10I)","n_a10J","p2_a10K","width_a10L","safebang@!width_a10L","(!width_a10L)","is_vert_a10M","seq1_a10N","ll1_a10O","!ll1_a10O","(!ll1_a10O)","emp1_a10P","!emp1_a10P","(!emp1_a10P)","sl1_a10Q","MkPrettyRep seq1_a10N (!ll1_a10O) (!emp1_a10P) sl1_a10Q","seq2_a10R","ll2_a10S","emp2_a10T","sl2_a10U","safebang@!sl2_a10U","(!sl2_a10U)","MkPrettyRep seq2_a10R ll2_a10S emp2_a10T (!sl2_a10U)","(MkPrettyRep seq2_a10R ll2_a10S emp2_a10T (!sl2_a10U))","!(MkPrettyRep seq2_a10R ll2_a10S emp2_a10T (!sl2_a10U))","(!(MkPrettyRep seq2_a10R ll2_a10S emp2_a10T (!sl2_a10U)))","seq2'_a10V","!seq2'_a10V","(!seq2'_a10V)","ll2'_a10W","emp2'_a10X","sl2'_a10Y","MkPrettyRep (!seq2'_a10V) ll2'_a10W emp2'_a10X sl2'_a10Y","[]","width_a10Z","is_vert_a110","p_a111","safebang@!p_a111","(!p_a111)","[(!p_a111)]","![(!p_a111)]","(![(!p_a111)])","width_a112","!width_a112","(!width_a112)","is_vert_a113","!is_vert_a113","(!is_vert_a113)","ps_a114","!ps_a114","(!ps_a114)","width_a115","is_vert_a116","!is_vert_a116","(!is_vert_a116)","seq_a118","ll_a119","!ll_a119","(!ll_a119)","emp_a11a","sl_a11b","MkPrettyRep seq_a118 (!ll_a119) emp_a11a sl_a11b","(MkPrettyRep seq_a118 (!ll_a119) emp_a11a sl_a11b)","!(MkPrettyRep seq_a118 (!ll_a119) emp_a11a sl_a11b)","(!(MkPrettyRep seq_a118 (!ll_a119) emp_a11a sl_a11b))","((!(MkPrettyRep seq_a118 (!ll_a119) emp_a11a sl_a11b)))","pr_a117@((!(MkPrettyRep seq_a118 (!ll_a119) emp_a11a sl_a11b)))","False","x_a11c","True","!True","(!True)","x_a11d","!x_a11d","(!x_a11d)","True","x_a11e","!x_a11e","(!x_a11e)","False","x_a11f"]
module Pretty
       (Pretty, PprStyle(..), ppNil, ppStr, ppChar, ppInt, ppInteger,
        ppDouble, ppSP, pp'SP, ppLbrack, ppRbrack, ppLparen, ppRparen,
        ppSemi, ppComma, ppCat, ppBeside, ppBesides, ppAbove, ppAboves,
        ppNest, ppSep, ppHang, ppInterleave, ppShow, ppUnformatted,
        PrettyRep)
       where
import CharSeq

ppNil :: Pretty

ppSP, pp'SP, ppLbrack, ppRbrack, ppLparen, ppRparen, ppSemi,
      ppComma :: Pretty

ppStr :: [Char] -> Pretty

ppChar :: Char -> Pretty

ppInt :: Int -> Pretty

ppInteger :: Integer -> Pretty

ppDouble :: Double -> Pretty

ppBeside :: Pretty -> Pretty -> Pretty

ppBesides :: [Pretty] -> Pretty

ppBesideSP :: Pretty -> Pretty -> Pretty

ppCat :: [Pretty] -> Pretty

ppAbove :: Pretty -> Pretty -> Pretty

ppAboves :: [Pretty] -> Pretty

ppInterleave :: Pretty -> [Pretty] -> Pretty

ppSep :: [Pretty] -> Pretty

ppHang :: Pretty -> Int -> Pretty -> Pretty

ppNest :: Int -> Pretty -> Pretty

ppShow :: Int -> Pretty -> [Char]

ppUnformatted :: Pretty -> [Char]
ppShow width_awz p_awA = cShow seq_awB
  where (norecord@(MkPrettyRep seq_awB ll_awC (!emp_awD) sl_awE))
          = p_awA width_awz False
ppUnformatted p_awF = cShow seq_awG
  where ((norecord@(MkPrettyRep seq_awG ll_awH emp_awI sl_awJ)))
          = p_awF 80 False
ppNil width_awK is_vert_awL
  = MkPrettyRep cNil 0 True (width_awK >= 0)
ppStr s_aKd width_aKe (!is_vert_aKf)
  = MkPrettyRep (cStr s_aKd) ls_aKg False (width_aKe >= ls_aKg)
  where (norecord@ls_aKg) = length s_aKd
ppChar (!c_aQo) (!width_aQp) is_vert_aQq
  = MkPrettyRep (cCh c_aQo) 1 False (width_aQp >= 1)
ppInt (!n_aQr) = ppStr (show n_aQr)
ppInteger (!n_aYS) = ppStr (show n_aYS)
ppDouble (!n_aYT) = ppStr (show n_aYT)
ppSP = ppChar ' '
pp'SP = ppStr ", "
ppLbrack = ppChar '['
ppRbrack = ppChar ']'
ppLparen = ppChar '('
ppRparen = ppChar ')'
ppSemi = ppChar ';'
ppComma = ppChar ','
ppInterleave sep_aYU (!ps_aYV) = ppSep (pi_aYW ps_aYV)
  where pi_aYW (norecord@[]) = []
        pi_aYW [x_aYX] = [x_aYX]
        pi_aYW ((norecord@((norecord@x_aYY) : xs_aYZ)))
          = (ppBeside x_aYY sep_aYU) : pi_aYW xs_aYZ
ppBeside p1_aZ0 p2_aZ1 (!width_aZ2) is_vert_aZ3
  = MkPrettyRep (seq1_aZ4 `cAppend` (cIndent ll1_aZ5 seq2_aZ8))
      (ll1_aZ5 + ll2_aZ9)
      (emp1_aZ6 `andL` emp2_aZa)
      ((width_aZ2 >= 0) `andL` (sl1_aZ7 `andL` sl2_aZb))
  where (norecord@(MkPrettyRep (!seq1_aZ4) ll1_aZ5 emp1_aZ6 sl1_aZ7))
          = p1_aZ0 width_aZ2 False
        MkPrettyRep seq2_aZ8 ll2_aZ9 (norecord@emp2_aZa) sl2_aZb
          = p2_aZ1 (width_aZ2 - ll1_aZ5) False
ppBesides [] = ppNil
ppBesides ps_a103 = foldr1 ppBeside ps_a103
ppBesideSP p1_a104 (!p2_a105) width_a106 (!is_vert_a107)
  = MkPrettyRep
      (seq1_a108 `cAppend`
         (sp_a10i `cAppend` (cIndent li_a10g seq2_a10c)))
      (li_a10g + ll2_a10d)
      (emp1_a10a `andL` emp2_a10e)
      ((width_a106 >= wi_a10h) `andL` (sl1_a10b `andL` sl2_a10f))
  where MkPrettyRep (norecord@seq1_a108) (norecord@ll1_a109)
          emp1_a10a sl1_a10b
          = p1_a104 width_a106 False
        MkPrettyRep seq2_a10c ll2_a10d emp2_a10e sl2_a10f
          = p2_a105 (width_a106 - li_a10g) False
        
        li_a10g, wi_a10h :: Int
        li_a10g = if emp1_a10a then 0 else ll1_a109 + 1
        (norecord@wi_a10h) = if emp1_a10a then 0 else 1
        sp_a10i = if emp1_a10a `orL` emp2_a10e then cNil else (cCh ' ')
ppCat [] = ppNil
ppCat ps_a10j = foldr1 ppBesideSP ps_a10j
ppAbove (!p1_a10k) (!p2_a10l) width_a10m is_vert_a10n
  = MkPrettyRep (seq1_a10p `cAppend` (nl_a10o `cAppend` seq2_a10t))
      ll2_a10u
      (emp1_a10r `andL` emp2_a10v)
      False
  where (norecord@nl_a10o)
          = if emp1_a10r `orL` emp2_a10v then cNil else cNL
        MkPrettyRep seq1_a10p (norecord@ll1_a10q) emp1_a10r
          (norecord@sl1_a10s)
          = p1_a10k width_a10m True
        (norecord@(MkPrettyRep (!seq2_a10t) ll2_a10u emp2_a10v
                     (!sl2_a10w)))
          = p2_a10l width_a10m True
ppAboves [] = ppNil
ppAboves ps_a10x = foldr1 ppAbove ps_a10x
ppNest (!n_a10y) (!p_a10z) width_a10A (norecord@False)
  = p_a10z width_a10A False
ppNest (norecord@n_a10B) (norecord@p_a10C) (norecord@width_a10D)
  True
  = MkPrettyRep (cIndent n_a10B seq_a10E) (ll_a10F + n_a10B) emp_a10G
      sl_a10H
  where (norecord@(MkPrettyRep seq_a10E ll_a10F (!emp_a10G)
                     (!sl_a10H)))
          = p_a10C (width_a10D - n_a10B) True
ppHang (!p1_a10I) n_a10J p2_a10K (!width_a10L) is_vert_a10M
  = if emp1_a10P then p2_a10K width_a10L is_vert_a10M else
      if (ll1_a10O <= n_a10J) `orL` sl2_a10U then
        MkPrettyRep
          (seq1_a10N `cAppend` (cCh ' ') `cAppend`
             (cIndent (ll1_a10O + 1) seq2_a10R))
          (ll1_a10O + 1 + ll2_a10S)
          False
          (sl1_a10Q `andL` sl2_a10U)
        else
        MkPrettyRep
          (seq1_a10N `cAppend` (cNL `cAppend` (cIndent n_a10J seq2'_a10V)))
          ll2'_a10W
          False
          False
  where MkPrettyRep seq1_a10N (norecord@ll1_a10O)
          (norecord@emp1_a10P) sl1_a10Q
          = p1_a10I width_a10L False
        (norecord@(MkPrettyRep seq2_a10R ll2_a10S emp2_a10T (!sl2_a10U)))
          = p2_a10K (width_a10L - (ll1_a10O + 1)) False
        MkPrettyRep (norecord@seq2'_a10V) ll2'_a10W emp2'_a10X sl2'_a10Y
          = p2_a10K (width_a10L - n_a10J) False
ppSep [] width_a10Z is_vert_a110 = ppNil width_a10Z is_vert_a110
ppSep (norecord@[(!p_a111)]) (norecord@width_a112)
  (norecord@is_vert_a113) = p_a111 width_a112 is_vert_a113
ppSep (norecord@ps_a114) width_a115 (norecord@is_vert_a116)
  = if sl_a11b then pr_a117 else
      ppAboves ps_a114 width_a115 is_vert_a116
  where pr_a117@((norecord@(MkPrettyRep seq_a118 (norecord@ll_a119)
                              emp_a11a sl_a11b)))
          = ppCat ps_a114 width_a115 is_vert_a116

andL :: Bool -> Bool -> Bool
andL False x_a11c = False
andL (norecord@True) (norecord@x_a11d) = x_a11d

orL :: Bool -> Bool -> Bool
orL True (norecord@x_a11e) = True
orL False x_a11f = x_a11f

data PrettyRep = MkPrettyRep CSeq Int Bool Bool

type Pretty = Int -> Bool -> PrettyRep

data PprStyle = PprForUser
              | PprDebug
              | PprShowAll
              | PprInterface

==================== Renamer ====================
CharSeq.cShow :: CharSeq.CSeq -> [Char]
CharSeq.cNil :: CharSeq.CSeq
CharSeq.cAppend :: CharSeq.CSeq -> CharSeq.CSeq -> CharSeq.CSeq
CharSeq.cIndent :: Int -> CharSeq.CSeq -> CharSeq.CSeq
CharSeq.cNL :: CharSeq.CSeq
CharSeq.cStr :: [Char] -> CharSeq.CSeq
CharSeq.cCh :: Char -> CharSeq.CSeq
CharSeq.cNil = CharSeq.CNil
CharSeq.cAppend cs1_ane cs2_anf = CharSeq.CAppend cs1_ane cs2_anf
CharSeq.cIndent n_ang (!cs_anh) = CharSeq.CIndent n_ang cs_anh
CharSeq.cNL = CharSeq.CNewline
CharSeq.cStr = CharSeq.CStr
CharSeq.cCh = CharSeq.CCh
CharSeq.cShow seq_ani = CharSeq.flatten 0 True seq_ani []
CharSeq.flatten ::
  Int -> Bool -> CharSeq.CSeq -> [(Int, CharSeq.CSeq)] -> String
CharSeq.flatten n_anj nlp_ank CharSeq.CNil seqs_anl
  = CharSeq.flattenS nlp_ank seqs_anl
CharSeq.flatten
  (!n_anm)
  nlp_ann
  (CharSeq.CAppend seq1_ano seq2_anp)
  (!seqs_anq)
  = CharSeq.flatten
      n_anm nlp_ann seq1_ano ((n_anm, seq2_anp) : seqs_anq)
CharSeq.flatten
  (!n_anr)
  (!nlp_ans)
  (!((!(CharSeq.CIndent (!n'_ant) seq_anu))))
  (!seqs_anv)
  = CharSeq.flatten (n'_ant + n_anr) nlp_ans seq_anu seqs_anv
CharSeq.flatten (!n_aou) nlp_aov (!CharSeq.CNewline) seqs_aow
  = '\n' : CharSeq.flattenS True seqs_aow
CharSeq.flatten n_aox False (CharSeq.CStr s_aoy) (!seqs_aoz)
  = s_aoy ++ CharSeq.flattenS False seqs_aoz
CharSeq.flatten (!n_aoA) False ((!(CharSeq.CCh c_aoB))) (!seqs_aoC)
  = c_aoB : CharSeq.flattenS False seqs_aoC
CharSeq.flatten n_aoD True ((!(CharSeq.CStr s_aoE))) (!seqs_aoF)
  = CharSeq.mkIndent n_aoD (s_aoE ++ CharSeq.flattenS False seqs_aoF)
CharSeq.flatten n_aoG True ((!(CharSeq.CCh c_aoH))) seqs_aoI
  = CharSeq.mkIndent n_aoG (c_aoH : CharSeq.flattenS False seqs_aoI)
CharSeq.flattenS :: Bool -> [(Int, CharSeq.CSeq)] -> String
CharSeq.flattenS (!nlp_aoJ) [] = ""
CharSeq.flattenS nlp_aoK (!((col_aoL, seq_aoM) : (!seqs_aoN)))
  = CharSeq.flatten col_aoL nlp_aoK seq_aoM seqs_aoN
CharSeq.mkIndent :: Int -> String -> String
CharSeq.mkIndent (!0) (!s_aoO) = s_aoO
CharSeq.mkIndent n_aoP s_aoQ
  = if (n_aoP >= 8) then
        '\t' : CharSeq.mkIndent (n_aoP - 8) s_aoQ
    else
        ' ' : CharSeq.mkIndent (n_aoP - 1) s_aoQ

data CharSeq.CSeq
  = CharSeq.CNil |
    CharSeq.CAppend CharSeq.CSeq CharSeq.CSeq |
    CharSeq.CIndent Int CharSeq.CSeq |
    CharSeq.CNewline |
    CharSeq.CStr [Char] |
    CharSeq.CCh Char


["cNil","cs1_ane","cs2_anf","n_ang","cs_anh","safebang@!cs_anh","(!cs_anh)","cNL","cStr","cCh","seq_ani","n_anj","nlp_ank","CNil","seqs_anl","n_anm","!n_anm","(!n_anm)","nlp_ann","seq1_ano","seq2_anp","CAppend seq1_ano seq2_anp","(CAppend seq1_ano seq2_anp)","seqs_anq","!seqs_anq","(!seqs_anq)","n_anr","!n_anr","(!n_anr)","nlp_ans","!nlp_ans","(!nlp_ans)","n'_ant","safebang@!n'_ant","(!n'_ant)","seq_anu","CIndent (!n'_ant) seq_anu","(CIndent (!n'_ant) seq_anu)","!(CIndent (!n'_ant) seq_anu)","(!(CIndent (!n'_ant) seq_anu))","((!(CIndent (!n'_ant) seq_anu)))","!((!(CIndent (!n'_ant) seq_anu)))","(!((!(CIndent (!n'_ant) seq_anu))))","seqs_anv","!seqs_anv","(!seqs_anv)","n_aou","!n_aou","(!n_aou)","nlp_aov","CNewline","!CNewline","(!CNewline)","seqs_aow","n_aox","False","s_aoy","CStr s_aoy","(CStr s_aoy)","seqs_aoz","!seqs_aoz","(!seqs_aoz)","n_aoA","!n_aoA","(!n_aoA)","False","c_aoB","CCh c_aoB","(CCh c_aoB)","!(CCh c_aoB)","(!(CCh c_aoB))","((!(CCh c_aoB)))","seqs_aoC","!seqs_aoC","(!seqs_aoC)","n_aoD","True","s_aoE","CStr s_aoE","(CStr s_aoE)","!(CStr s_aoE)","(!(CStr s_aoE))","((!(CStr s_aoE)))","seqs_aoF","!seqs_aoF","(!seqs_aoF)","n_aoG","True","c_aoH","CCh c_aoH","(CCh c_aoH)","!(CCh c_aoH)","(!(CCh c_aoH))","((!(CCh c_aoH)))","seqs_aoI","nlp_aoJ","!nlp_aoJ","(!nlp_aoJ)","[]","nlp_aoK","col_aoL","seq_aoM","(col_aoL, seq_aoM)","seqs_aoN","!seqs_aoN","(!seqs_aoN)","(col_aoL, seq_aoM) : (!seqs_aoN)","((col_aoL, seq_aoM) : (!seqs_aoN))","!((col_aoL, seq_aoM) : (!seqs_aoN))","(!((col_aoL, seq_aoM) : (!seqs_aoN)))","0","!0","(!0)","s_aoO","lazydmd@!s_aoO","(!s_aoO)","n_aoP","s_aoQ"]
module CharSeq
       (CSeq, cNil, cAppend, cIndent, cNL, cStr, cCh, cShow) where

cShow :: CSeq -> [Char]

cNil :: CSeq

cAppend :: CSeq -> CSeq -> CSeq

cIndent :: Int -> CSeq -> CSeq

cNL :: CSeq

cStr :: [Char] -> CSeq

cCh :: Char -> CSeq
cNil = CNil
cAppend cs1_ane cs2_anf = CAppend cs1_ane cs2_anf
cIndent n_ang (!cs_anh) = CIndent n_ang cs_anh
cNL = CNewline
cStr = CStr
cCh = CCh
cShow seq_ani = flatten 0 True seq_ani []

flatten :: Int -> Bool -> CSeq -> [(Int, CSeq)] -> String
flatten n_anj nlp_ank CNil seqs_anl = flattenS nlp_ank seqs_anl
flatten (norecord@n_anm) nlp_ann (CAppend seq1_ano seq2_anp)
  (norecord@seqs_anq)
  = flatten n_anm nlp_ann seq1_ano ((n_anm, seq2_anp) : seqs_anq)
flatten (norecord@n_anr) (norecord@nlp_ans)
  (norecord@((norecord@(CIndent (!n'_ant) seq_anu))))
  (norecord@seqs_anv)
  = flatten (n'_ant + n_anr) nlp_ans seq_anu seqs_anv
flatten (norecord@n_aou) nlp_aov (norecord@CNewline) seqs_aow
  = '\n' : flattenS True seqs_aow
flatten n_aox False (CStr s_aoy) (norecord@seqs_aoz)
  = s_aoy ++ flattenS False seqs_aoz
flatten (norecord@n_aoA) False ((norecord@(CCh c_aoB)))
  (norecord@seqs_aoC) = c_aoB : flattenS False seqs_aoC
flatten n_aoD True ((norecord@(CStr s_aoE))) (norecord@seqs_aoF)
  = mkIndent n_aoD (s_aoE ++ flattenS False seqs_aoF)
flatten n_aoG True ((norecord@(CCh c_aoH))) seqs_aoI
  = mkIndent n_aoG (c_aoH : flattenS False seqs_aoI)

flattenS :: Bool -> [(Int, CSeq)] -> String
flattenS (norecord@nlp_aoJ) [] = ""
flattenS nlp_aoK
  (norecord@((col_aoL, seq_aoM) : (norecord@seqs_aoN)))
  = flatten col_aoL nlp_aoK seq_aoM seqs_aoN

mkIndent :: Int -> String -> String
mkIndent (norecord@0) (lazydmd@s_aoO) = s_aoO
mkIndent n_aoP s_aoQ
  = if (n_aoP >= 8) then '\t' : mkIndent (n_aoP - 8) s_aoQ else
      ' ' : mkIndent (n_aoP - 1) s_aoQ

data CSeq = CNil
          | CAppend CSeq CSeq
          | CIndent Int CSeq
          | CNewline
          | CStr [Char]
          | CCh Char

==================== Renamer ====================
Main.powers :: [[Integer]]
Main.powers
  = [2 .. ] : map (zipWith (*) (head Main.powers)) Main.powers
Main.neg_powers :: [[Integer]]
Main.neg_powers
  = map
      (zipWith
         (\ (!n_aBB) (!x_aBC) -> if n_aBB then x_aBC else - x_aBC)
         (iterate not True))
      Main.powers
Main.pascal :: [[Integer]]
Main.pascal
  = [1, 2, 1]
    : map
        (\ (!line_aP3) -> zipWith (+) (line_aP3 ++ [0]) (0 : line_aP3))
        Main.pascal
Main.bernoulli 0 = 1
Main.bernoulli 1 = - (1 % 2)
Main.bernoulli n_aY6 | odd n_aY6 = 0
Main.bernoulli n_aY7
  = (- 1) % 2
    + sum
        [fromIntegral
           ((sum $ zipWith (*) powers_aY8 (tail $ tail combs_a146))
            - fromIntegral k_a145)
         % fromIntegral (k_a145 + 1) |
           (!((!k_a145), combs_a146)) <- zip [2 .. n_aY7] Main.pascal]
  where
      (!powers_aY8) = (Main.neg_powers !! (n_aY7 - 1))
Main.main
  = do { [arg_a147] <- getArgs;
         let (!n_a148) = (read arg_a147) :: Int;
         putStr $ "Bernoulli of " ++ (show n_a148) ++ " is ";
         print (Main.bernoulli n_a148) }



==================== Renamer ====================
Main.main
  = interact
      (("Enter a generator: " ++)
       . show . Main.numchars . Main.expand . head . lines)
Main.numchars :: [String] -> Int
Main.numchars (!l_aNq) = sum $ map length l_aNq
Main.expand (![]) = [""]
Main.expand (!((!('<' : (!x_aTn))))) = Main.numericRule x_aTn
Main.expand ((!'[') : x_aTo) = Main.alphabeticRule x_aTo
Main.expand (!x_aTp) = Main.constantRule x_aTp
Main.constantRule (!((!(c_aTq : rest_aTr))))
  = [c_aTq : z_aTs | z_aTs <- Main.expand rest_aTr]
Main.alphabeticRule
  (!(a_aTt : ('-' : ((!b_aTu) : (!((!']') : rest_aTv))))))
  | a_aTt <= b_aTu
  = [c_a16X : z_a16Y |
       (!c_a16X) <- [a_aTt .. b_aTu], (!z_a16Y) <- Main.expand rest_aTv]
  | otherwise
  = [c_a16Z : z_a170 |
       c_a16Z <- reverse [b_aTu .. a_aTt], z_a170 <- Main.expand rest_aTv]
Main.numericRule x_a171
  = [pad_a179 (show i_a18e) ++ z_a18f |
       (!i_a18e) <- if u_a176 < v_a177 then
                        [u_a176 .. v_a177]
                    else
                        [u_a176, u_a176 - 1 .. v_a177],
       (!z_a18f) <- Main.expand s_a175]
  where
      (p_a172, _ : q_a173) = span (/= '-') x_a171
      ((!r_a174), _ : (!s_a175)) = span (/= '>') q_a173
      ((!u_a176), (!v_a177)) = (mknum_a178 p_a172, mknum_a178 r_a174)
      mknum_a178 (!s_a17b)
        = foldl
            (\ (!u_a17c) c_a17d -> u_a17c * 10 + (ord c_a17d - ord '0'))
            0
            s_a17b
      pad_a179 s_a18c
        = ['0' | i_a18d <- [1 .. (width_a17a - (length s_a18c))]] ++ s_a18c
      width_a17a = max (length (show u_a176)) (length (show v_a177))


["main","l_aNq","!l_aNq","(!l_aNq)","[]","![]","(![])","'<'","x_aTn","!x_aTn","(!x_aTn)","'<' : (!x_aTn)","('<' : (!x_aTn))","!('<' : (!x_aTn))","(!('<' : (!x_aTn)))","((!('<' : (!x_aTn))))","!((!('<' : (!x_aTn))))","(!((!('<' : (!x_aTn)))))","'['","!'['","(!'[')","x_aTo","(!'[') : x_aTo","((!'[') : x_aTo)","x_aTp","!x_aTp","(!x_aTp)","c_aTq","rest_aTr","c_aTq : rest_aTr","(c_aTq : rest_aTr)","!(c_aTq : rest_aTr)","(!(c_aTq : rest_aTr))","((!(c_aTq : rest_aTr)))","!((!(c_aTq : rest_aTr)))","(!((!(c_aTq : rest_aTr))))","z_aTs","a_aTt","'-'","b_aTu","safebang@!b_aTu","(!b_aTu)","']'","!']'","(!']')","rest_aTv","(!']') : rest_aTv","((!']') : rest_aTv)","!((!']') : rest_aTv)","(!((!']') : rest_aTv))","(!b_aTu) : (!((!']') : rest_aTv))","((!b_aTu) : (!((!']') : rest_aTv)))","'-' : ((!b_aTu) : (!((!']') : rest_aTv)))","('-' : ((!b_aTu) : (!((!']') : rest_aTv))))","a_aTt : ('-' : ((!b_aTu) : (!((!']') : rest_aTv))))","(a_aTt : ('-' : ((!b_aTu) : (!((!']') : rest_aTv)))))","!(a_aTt : ('-' : ((!b_aTu) : (!((!']') : rest_aTv)))))","(!(a_aTt : ('-' : ((!b_aTu) : (!((!']') : rest_aTv))))))","c_a16X","!c_a16X","(!c_a16X)","z_a16Y","!z_a16Y","(!z_a16Y)","c_a16Z","z_a170","x_a171","i_a18e","!i_a18e","(!i_a18e)","z_a18f","!z_a18f","(!z_a18f)","p_a172","_","q_a173","_ : q_a173","(p_a172, _ : q_a173)","r_a174","!r_a174","(!r_a174)","_","s_a175","!s_a175","(!s_a175)","_ : (!s_a175)","((!r_a174), _ : (!s_a175))","u_a176","!u_a176","(!u_a176)","v_a177","!v_a177","(!v_a177)","((!u_a176), (!v_a177))","s_a17b","!s_a17b","(!s_a17b)","u_a17c","safebang@!u_a17c","(!u_a17c)","c_a17d","s_a18c","i_a18d","width_a17a"]
module Main (main) where
import Data.Char
main
  = interact
      (("Enter a generator: " ++) . show . numchars . expand . head .
         lines)

numchars :: [String] -> Int
numchars (norecord@l_aNq) = sum $ map length l_aNq
expand (norecord@[]) = [""]
expand (norecord@((norecord@('<' : (norecord@x_aTn)))))
  = numericRule x_aTn
expand ((norecord@'[') : x_aTo) = alphabeticRule x_aTo
expand (norecord@x_aTp) = constantRule x_aTp
constantRule (norecord@((norecord@(c_aTq : rest_aTr))))
  = [c_aTq : z_aTs | z_aTs <- expand rest_aTr]
alphabeticRule
  (norecord@(a_aTt :
               ('-' : ((!b_aTu) : (norecord@((norecord@']') : rest_aTv))))))
  | a_aTt <= b_aTu =
    [c_a16X : z_a16Y | (norecord@c_a16X) <- [a_aTt .. b_aTu],
     (norecord@z_a16Y) <- expand rest_aTv]
  | otherwise =
    [c_a16Z : z_a170 | c_a16Z <- reverse [b_aTu .. a_aTt],
     z_a170 <- expand rest_aTv]
numericRule x_a171
  = [pad_a179 (show i_a18e) ++ z_a18f |
     (norecord@i_a18e) <- if u_a176 < v_a177 then [u_a176 .. v_a177]
                            else [u_a176, u_a176 - 1 .. v_a177],
     (norecord@z_a18f) <- expand s_a175]
  where (p_a172, _ : q_a173) = span (/= '-') x_a171
        ((norecord@r_a174), _ : (norecord@s_a175)) = span (/= '>') q_a173
        ((norecord@u_a176), (norecord@v_a177))
          = (mknum_a178 p_a172, mknum_a178 r_a174)
        mknum_a178 (norecord@s_a17b)
          = foldl
              (\ (!u_a17c) c_a17d -> u_a17c * 10 + (ord c_a17d - ord '0'))
              0
              s_a17b
        pad_a179 s_a18c
          = ['0' | i_a18d <- [1 .. (width_a17a - (length s_a18c))]] ++ s_a18c
        width_a17a = max (length (show u_a176)) (length (show v_a177))

==================== Renamer ====================
Main.main
  = do { [arg_axG] <- getArgs;
         print
           (round
              (realPart (sum [Main.f n_aRg | n_aRg <- [1 .. (read arg_axG)]]))) }
Main.f :: Int -> Complex Double
Main.f (!n_aRh) = mkPolar 1 ((2 * pi) / fromIntegral n_aRh) ^ n_aRh


["main","arg_axG","[arg_axG]","n_aRg","n_aRh","!n_aRh","(!n_aRh)"]
module Main (main) where
import Data.Complex
import System.Environment
main
  = do [arg_axG] <- getArgs
       print
         (round (realPart (sum [f n_aRg | n_aRg <- [1 .. (read arg_axG)]])))

f :: Int -> Complex Double
f (norecord@n_aRh)
  = mkPolar 1 ((2 * pi) / fromIntegral n_aRh) ^ n_aRh

==================== Renamer ====================
Main.primes :: [Int]
Main.primes = Main.spiral Main.wheels Main.primes Main.squares
Main.spiral
  ((!(Main.Wheel s_aoB ms_aoC ns_aoD)) : ws_aoE)
  ps_aoF
  qs_aoG
  = foldr turn0_aoI (roll_aoH s_aoB) ns_aoD
  where
      roll_aoH o_aoM
        = foldr
            (turn_aoJ o_aoM)
            (foldr (turn_aoJ o_aoM) (roll_aoH (o_aoM + s_aoB)) ns_aoD)
            ms_aoC
      turn0_aoI (!n_avR) rs_avS
        = if n_avR < q_aoL then n_avR : rs_avS else sp_aoK
      turn_aoJ o_aJk n_aJl rs_aJm
        = let (!n'_aJn) = o_aJk + n_aJl
          in
            if n'_aJn == 2 || n'_aJn < q_aoL then
                n'_aJn : rs_aJm
            else
                dropWhile (< n'_aJn) sp_aoK
      sp_aoK = Main.spiral ws_aoE (tail ps_aoF) (tail qs_aoG)
      q_aoL = head qs_aoG
Main.squares :: [Int]
Main.squares = [p_aMN * p_aMN | (!p_aMN) <- Main.primes]
Main.wheels :: [Main.Wheel]
Main.wheels
  = Main.Wheel 1 [1] []
    : zipWith3 Main.nextSize Main.wheels Main.primes Main.squares
Main.nextSize
  (!(Main.Wheel (!s_aMO) ms_aMP (!ns_aMQ)))
  (!p_aMR)
  q_aMS
  = Main.Wheel (s_aMO * p_aMR) ms'_aMV ns'_aMU
  where
      (xs_aMT, (!ns'_aMU))
        = span
            (<= q_aMS) (foldr turn0_aMX (roll_aMW (p_aMR - 1) s_aMO) ns_aMQ)
      ms'_aMV = foldr turn0_aMX xs_aMT ms_aMP
      roll_aMW 0 _ = []
      roll_aMW t_aMZ (!o_aN0)
        = foldr
            (turn_aMY o_aN0)
            (foldr
               (turn_aMY o_aN0) (roll_aMW (t_aMZ - 1) (o_aN0 + s_aMO)) ns_aMQ)
            ms_aMP
      turn0_aMX n_aN1 rs_aN2
        = if n_aN1 `mod` p_aMR > 0 then n_aN1 : rs_aN2 else rs_aN2
      turn_aMY o_aW9 (!n_aWa) rs_aWb
        = let (!n'_aWc) = o_aW9 + n_aWa
          in if n'_aWc `mod` p_aMR > 0 then n'_aWc : rs_aWb else rs_aWb
Main.main
  = do { (![arg_aWd]) <- getArgs;
         print (Main.primes !! ((read arg_aWd) :: Int)) }

data Main.Wheel = Main.Wheel Int [Int] [Int]


["primes","s_aoB","ms_aoC","ns_aoD","Wheel s_aoB ms_aoC ns_aoD","(Wheel s_aoB ms_aoC ns_aoD)","!(Wheel s_aoB ms_aoC ns_aoD)","(!(Wheel s_aoB ms_aoC ns_aoD))","ws_aoE","(!(Wheel s_aoB ms_aoC ns_aoD)) : ws_aoE","((!(Wheel s_aoB ms_aoC ns_aoD)) : ws_aoE)","ps_aoF","qs_aoG","o_aoM","n_avR","!n_avR","(!n_avR)","rs_avS","o_aJk","n_aJl","rs_aJm","n'_aJn","!n'_aJn","(!n'_aJn)","sp_aoK","q_aoL","squares","p_aMN","!p_aMN","(!p_aMN)","wheels","s_aMO","safebang@!s_aMO","(!s_aMO)","ms_aMP","ns_aMQ","safebang@!ns_aMQ","(!ns_aMQ)","Wheel (!s_aMO) ms_aMP (!ns_aMQ)","(Wheel (!s_aMO) ms_aMP (!ns_aMQ))","!(Wheel (!s_aMO) ms_aMP (!ns_aMQ))","(!(Wheel (!s_aMO) ms_aMP (!ns_aMQ)))","p_aMR","!p_aMR","(!p_aMR)","q_aMS","xs_aMT","ns'_aMU","!ns'_aMU","(!ns'_aMU)","(xs_aMT, (!ns'_aMU))","ms'_aMV","0","_","t_aMZ","o_aN0","!o_aN0","(!o_aN0)","n_aN1","rs_aN2","o_aW9","n_aWa","!n_aWa","(!n_aWa)","rs_aWb","n'_aWc","!n'_aWc","(!n'_aWc)","main","arg_aWd","[arg_aWd]","![arg_aWd]","(![arg_aWd])"]
module Main (main) where
import System.Environment

primes :: [Int]
primes = spiral wheels primes squares
spiral ((norecord@(Wheel s_aoB ms_aoC ns_aoD)) : ws_aoE) ps_aoF
  qs_aoG = foldr turn0_aoI (roll_aoH s_aoB) ns_aoD
  where roll_aoH o_aoM
          = foldr (turn_aoJ o_aoM)
              (foldr (turn_aoJ o_aoM) (roll_aoH (o_aoM + s_aoB)) ns_aoD)
              ms_aoC
        turn0_aoI (norecord@n_avR) rs_avS
          = if n_avR < q_aoL then n_avR : rs_avS else sp_aoK
        turn_aoJ o_aJk n_aJl rs_aJm
          = let (norecord@n'_aJn) = o_aJk + n_aJl in
              if n'_aJn == 2 || n'_aJn < q_aoL then n'_aJn : rs_aJm else
                dropWhile (< n'_aJn) sp_aoK
        sp_aoK = spiral ws_aoE (tail ps_aoF) (tail qs_aoG)
        q_aoL = head qs_aoG

squares :: [Int]
squares = [p_aMN * p_aMN | (norecord@p_aMN) <- primes]

wheels :: [Wheel]
wheels = Wheel 1 [1] [] : zipWith3 nextSize wheels primes squares
nextSize (norecord@(Wheel (!s_aMO) ms_aMP (!ns_aMQ)))
  (norecord@p_aMR) q_aMS = Wheel (s_aMO * p_aMR) ms'_aMV ns'_aMU
  where (xs_aMT, (norecord@ns'_aMU))
          = span (<= q_aMS)
              (foldr turn0_aMX (roll_aMW (p_aMR - 1) s_aMO) ns_aMQ)
        ms'_aMV = foldr turn0_aMX xs_aMT ms_aMP
        roll_aMW 0 _ = []
        roll_aMW t_aMZ (norecord@o_aN0)
          = foldr (turn_aMY o_aN0)
              (foldr (turn_aMY o_aN0) (roll_aMW (t_aMZ - 1) (o_aN0 + s_aMO))
                 ns_aMQ)
              ms_aMP
        turn0_aMX n_aN1 rs_aN2
          = if n_aN1 `mod` p_aMR > 0 then n_aN1 : rs_aN2 else rs_aN2
        turn_aMY o_aW9 (norecord@n_aWa) rs_aWb
          = let (norecord@n'_aWc) = o_aW9 + n_aWa in
              if n'_aWc `mod` p_aMR > 0 then n'_aWc : rs_aWb else rs_aWb
main
  = do (norecord@[arg_aWd]) <- getArgs
       print (primes !! ((read arg_aWd) :: Int))

data Wheel = Wheel Int [Int] [Int]

==================== Renamer ====================
Main.suCC :: Int -> Int
Main.suCC x_aoy = x_aoy + 1
Main.isdivs :: Int -> Int -> Bool
Main.isdivs (!n_apx) (!x_apy) = mod x_apy n_apx /= 0
Main.the_filter :: [Int] -> [Int]
Main.the_filter (!(n_aM6 : (!ns_aM7)))
  = filter (Main.isdivs n_aM6) ns_aM7
Main.primes :: [Int]
Main.primes
  = map head (iterate Main.the_filter (iterate Main.suCC 2))
Main.main
  = do { [(!arg_aPH)] <- getArgs;
         print $ Main.primes !! (read arg_aPH) }


["x_aoy","n_apx","!n_apx","(!n_apx)","x_apy","!x_apy","(!x_apy)","n_aM6","ns_aM7","safebang@!ns_aM7","(!ns_aM7)","n_aM6 : (!ns_aM7)","(n_aM6 : (!ns_aM7))","!(n_aM6 : (!ns_aM7))","(!(n_aM6 : (!ns_aM7)))","primes","main","arg_aPH","safebang@!arg_aPH","(!arg_aPH)","[(!arg_aPH)]"]
module Main (main) where
import System.Environment

suCC :: Int -> Int
suCC x_aoy = x_aoy + 1

isdivs :: Int -> Int -> Bool
isdivs (norecord@n_apx) (norecord@x_apy) = mod x_apy n_apx /= 0

the_filter :: [Int] -> [Int]
the_filter (norecord@(n_aM6 : (!ns_aM7)))
  = filter (isdivs n_aM6) ns_aM7

primes :: [Int]
primes = map head (iterate the_filter (iterate suCC 2))
main
  = do [(!arg_aPH)] <- getArgs
       print $ primes !! (read arg_aPH)

==================== Renamer ====================
infix 8 Main.^^^

Main.int :: Main.Nat -> Int
Main.int Main.Z = 0
Main.int (Main.S x_aLo) = 1 + Main.int x_aLo
x_aLp Main.^^^ Main.Z = Main.S Main.Z
(!x_aLq) Main.^^^ (Main.S (!y_aLr))
  = x_aLq * (x_aLq Main.^^^ y_aLr)
Main.main
  = do { [(!power_aLs)] <- getArgs;
         print $ Main.int (3 Main.^^^ (fromInteger $ read power_aLs)) }

data Main.Nat
  = Main.Z | Main.S Main.Nat
  deriving (Eq, Ord, Show)

instance Num Main.Nat where
  (!Main.Z) + y_aPZ = y_aPZ
  (Main.S (!x_aQ0)) + y_aQ1 = Main.S (x_aQ0 + y_aQ1)
  (!x_aQ2) * (!Main.Z) = Main.Z
  (!x_aQ3) * (Main.S (!y_aQ4)) = x_aQ3 * y_aQ4 + x_aQ3
  fromInteger x_aQ5
    = if x_aQ5 < 1 then Main.Z else Main.S (fromInteger (x_aQ5 - 1))


["Z","x_aLo","S x_aLo","(S x_aLo)","x_aLp","Z","x_aLq","!x_aLq","(!x_aLq)","y_aLr","!y_aLr","(!y_aLr)","S (!y_aLr)","(S (!y_aLr))","main","power_aLs","safebang@!power_aLs","(!power_aLs)","[(!power_aLs)]","Z","!Z","(!Z)","y_aPZ","x_aQ0","safebang@!x_aQ0","(!x_aQ0)","S (!x_aQ0)","(S (!x_aQ0))","y_aQ1","x_aQ2","safebang@!x_aQ2","(!x_aQ2)","Z","!Z","(!Z)","x_aQ3","!x_aQ3","(!x_aQ3)","y_aQ4","safebang@!y_aQ4","(!y_aQ4)","S (!y_aQ4)","(S (!y_aQ4))","x_aQ5"]
module Main (main) where
import System.Environment

infix 8 ^^^

int :: Nat -> Int
int Z = 0
int (S x_aLo) = 1 + int x_aLo
x_aLp ^^^ Z = S Z
(norecord@x_aLq) ^^^ (S (norecord@y_aLr))
  = x_aLq * (x_aLq ^^^ y_aLr)
main
  = do [(!power_aLs)] <- getArgs
       print $ int (3 ^^^ (fromInteger $ read power_aLs))

data Nat = Z
         | S Nat
         deriving (Eq, Ord, Show)

instance Num Nat where
        (norecord@Z) + y_aPZ = y_aPZ
        (S (!x_aQ0)) + y_aQ1 = S (x_aQ0 + y_aQ1)
        (!x_aQ2) * (norecord@Z) = Z
        (norecord@x_aQ3) * (S (!y_aQ4)) = x_aQ3 * y_aQ4 + x_aQ3
        fromInteger x_aQ5
          = if x_aQ5 < 1 then Z else S (fromInteger (x_aQ5 - 1))

==================== Renamer ====================
Main.main
  = do { (![arg_aoo]) <- getArgs;
         print $ Main.nsoln $ read arg_aoo }
Main.nsoln nq_asV
  = length (gen_asX nq_asV)
  where
      safe_asW :: Int -> Int -> [Int] -> Bool
      safe_asW x_at5 d_at6 (![]) = True
      safe_asW (!x_at7) d_at8 ((!q_at9) : l_ata)
        = x_at7 /= q_at9
          &&
            x_at7 /= q_at9 + d_at8
            && x_at7 /= q_at9 - d_at8 && safe_asW x_at7 (d_at8 + 1) l_ata
      gen_asX :: Int -> [[Int]]
      gen_asX 0 = [[]]
      gen_asX n_aHA
        = [(q_aHC : b_aHB) |
             b_aHB <- gen_asX (n_aHA - 1),
             q_aHC <- [1 .. nq_asV],
             safe_asW q_aHC 1 b_aHB]


["main","arg_aoo","[arg_aoo]","![arg_aoo]","(![arg_aoo])","nq_asV","x_at5","d_at6","[]","![]","(![])","x_at7","!x_at7","(!x_at7)","d_at8","q_at9","!q_at9","(!q_at9)","l_ata","(!q_at9) : l_ata","((!q_at9) : l_ata)","0","n_aHA","b_aHB","q_aHC"]
module Main (main) where
import System.Environment
main
  = do (norecord@[arg_aoo]) <- getArgs
       print $ nsoln $ read arg_aoo
nsoln nq_asV = length (gen_asX nq_asV)
  where safe_asW :: Int -> Int -> [Int] -> Bool
        safe_asW x_at5 d_at6 (norecord@[]) = True
        safe_asW (norecord@x_at7) d_at8 ((norecord@q_at9) : l_ata)
          = x_at7 /= q_at9 && x_at7 /= q_at9 + d_at8 && x_at7 /= q_at9 -
              d_at8
              && safe_asW x_at7 (d_at8 + 1) l_ata
        
        gen_asX :: Int -> [[Int]]
        gen_asX 0 = [[]]
        gen_asX n_aHA
          = [(q_aHC : b_aHB) | b_aHB <- gen_asX (n_aHA - 1),
             q_aHC <- [1 .. nq_asV], safe_asW q_aHC 1 b_aHB]

==================== Renamer ====================
Main.three_partitions :: Int -> [(Int, Int, Int)]
Main.three_partitions m_axy
  = [(i_aGJ, j_aHD, k_aHE) |
       (!i_aGJ) <- [0 .. (div m_axy 3)],
       j_aHD <- [i_aGJ .. (div (m_axy - i_aGJ) 2)],
       (!k_aHE) <- [m_axy - (i_aGJ + j_aHD)]]
Main.remainders (![]) = []
Main.remainders ((!(r_aHF : (!rs_aHG))))
  = (r_aHF : rs_aHG) : (Main.remainders rs_aHG)
Main.radical_generator :: Int -> Array Int [Main.Radical]
Main.radical_generator n_aHH
  = radicals_aHI
  where
      radicals_aHI
        = array
            (0, n_aHH)
            ((0, [Main.H])
             : [(j_aHJ, Main.rads_of_size_n radicals_aHI j_aHJ) |
                  (!j_aHJ) <- [1 .. n_aHH]])
Main.rads_of_size_n ::
  Array Int [Main.Radical] -> Int -> [Main.Radical]
Main.rads_of_size_n radicals_aHK n_aHL
  = [(Main.C ri_aHP rj_aUK rk_aUM) |
       (!((!i_aHM), j_aHN, (!k_aHO))) <- (Main.three_partitions
                                            (n_aHL - 1)),
       (!((!((!ri_aHP) : (!ris_aHQ))))) <- (Main.remainders
                                              (radicals_aHK ! i_aHM)),
       ((!((!rj_aUK) : (!rjs_aUL)))) <- (Main.remainders
                                           (if (i_aHM == j_aHN) then
                                                (ri_aHP : ris_aHQ)
                                            else
                                                radicals_aHK ! j_aHN)),
       (!rk_aUM) <- (if (j_aHN == k_aHO) then
                         (rj_aUK : rjs_aUL)
                     else
                         radicals_aHK ! k_aHO)]
Main.bcp_generator ::
  Array Int [Main.Radical] -> Int -> [Main.Paraffin]
Main.bcp_generator radicals_aUN n_aUO
  = if (odd n_aUO) then
        []
    else
        [(Main.BCP r1_aUP r2_aUR) |
           (!((!((!r1_aUP) : r1s_aUQ)))) <- (Main.remainders
                                               (radicals_aUN ! (div n_aUO 2))),
           r2_aUR <- (r1_aUP : r1s_aUQ)]
Main.four_partitions :: Int -> [(Int, Int, Int, Int)]
Main.four_partitions m_aUS
  = [(i_aUT, j_aUU, k_aUV, l_aUW) |
       i_aUT <- [0 .. (div m_aUS 4)],
       (!j_aUU) <- [i_aUT .. (div (m_aUS - i_aUT) 3)],
       (!k_aUV) <- [(max
                       j_aUU
                       (ceiling ((fromIntegral m_aUS) / (fromInteger 2)) - i_aUT
                        - j_aUU)) .. (div (m_aUS - i_aUT - j_aUU) 2)],
       l_aUW <- [(m_aUS - (i_aUT + j_aUU + k_aUV))]]
Main.ccp_generator ::
  Array Int [Main.Radical] -> Int -> [Main.Paraffin]
Main.ccp_generator radicals_aUX n_aUY
  = [(Main.CCP ri_aV3 rj_aV5 rk_aV7 rl_aV9) |
       (!((!i_aUZ), j_aV0, k_aV1, l_aV2)) <- (Main.four_partitions
                                                (n_aUY - 1)),
       (!((!(ri_aV3 : ris_aV4)))) <- (Main.remainders
                                        (radicals_aUX ! i_aUZ)),
       (!(rj_aV5 : (!rjs_aV6))) <- (Main.remainders
                                      (if (i_aUZ == j_aV0) then
                                           (ri_aV3 : ris_aV4)
                                       else
                                           radicals_aUX ! j_aV0)),
       (rk_aV7 : (!rks_aV8)) <- (Main.remainders
                                   (if (j_aV0 == k_aV1) then
                                        (rj_aV5 : rjs_aV6)
                                    else
                                        radicals_aUX ! k_aV1)),
       rl_aV9 <- (if (k_aV1 == l_aV2) then
                      (rk_aV7 : rks_aV8)
                  else
                      radicals_aUX ! l_aV2)]
Main.bcp_until :: Int -> [Int]
Main.bcp_until n_aVa
  = [length (Main.bcp_generator radicals_aVb j_aVc) |
       (!j_aVc) <- [1 .. n_aVa]]
  where
      (!radicals_aVb) = Main.radical_generator (div n_aVa 2)
Main.ccp_until :: Int -> [Int]
Main.ccp_until (!n_a11b)
  = [length (Main.ccp_generator radicals_a11c j_a11d) |
       j_a11d <- [1 .. n_a11b]]
  where
      (!radicals_a11c) = Main.radical_generator (div n_a11b 2)
Main.paraffins_until :: Int -> [Int]
Main.paraffins_until (!n_a11e)
  = [length (Main.bcp_generator radicals_a11f j_a11g)
     + length (Main.ccp_generator radicals_a11f j_a11g) |
       j_a11g <- [1 .. n_a11e]]
  where
      (!radicals_a11f) = Main.radical_generator (div n_a11e 2)
Main.main
  = do { (![(!arg_a11h)]) <- getArgs;
         let num_a11i = read arg_a11h;
         print
           [length (rads_a15P ! i_a15Q) |
              rads_a15P <- [(Main.radical_generator num_a11i)],
              (!i_a15Q) <- [0 .. num_a11i]];
         print (Main.bcp_until num_a11i);
         print (Main.ccp_until num_a11i);
         print (Main.paraffins_until num_a11i) }

data Main.Radical
  = Main.H | Main.C Main.Radical Main.Radical Main.Radical
data Main.Paraffin
  = Main.BCP Main.Radical Main.Radical |
    Main.CCP Main.Radical Main.Radical Main.Radical Main.Radical



==================== Renamer ====================
Main.primes :: [Int]
Main.primes = Main.sieve Main.wheels Main.primes Main.squares
Main.sieve (!(Main.Wheel s_aoC ns_aoD : ws_aoE)) ps_aoF qs_aoG
  = [n'_aGI |
       (!o_aGG) <- s_aoC
                   : [s_aoC * 2, s_aoC * 3 .. (head ps_aoF - 1) * s_aoC],
       n_aGH <- ns_aoD,
       (!n'_aGI) <- [n_aGH + o_aGG],
       noFactor_aoH n'_aGI]
    ++ Main.sieve ws_aoE (tail ps_aoF) (tail qs_aoG)
  where
      (!noFactor_aoH)
        = if s_aoC <= 2 then const True else Main.notDivBy ps_aoF qs_aoG
Main.notDivBy (p_aGJ : ps_aGK) ((!q_aGL) : qs_aGM) (!n_aGN)
  = q_aGL > n_aGN
    || n_aGN `mod` p_aGJ > 0 && Main.notDivBy ps_aGK qs_aGM n_aGN
Main.squares :: [Int]
Main.squares = [p_aPU * p_aPU | (!p_aPU) <- Main.primes]
Main.wheels :: [Main.Wheel]
Main.wheels
  = Main.Wheel 1 [1] : zipWith Main.nextSize Main.wheels Main.primes
Main.nextSize (!(Main.Wheel s_aPV ns_aPW)) (!p_aPX)
  = Main.Wheel (s_aPV * p_aPX) ns'_aPY
  where
      (!ns'_aPY)
        = [n'_aQ1 |
             o_aPZ <- [0, s_aPV .. (p_aPX - 1) * s_aPV],
             (!n_aQ0) <- ns_aPW,
             (!n'_aQ1) <- [n_aQ0 + o_aPZ],
             n'_aQ1 `mod` p_aPX > 0]
Main.main
  = do { [arg_aQ2] <- getArgs;
         print (Main.primes !! ((read arg_aQ2) :: Int)) }

data Main.Wheel = Main.Wheel Int [Int]


["primes","s_aoC","ns_aoD","Wheel s_aoC ns_aoD","ws_aoE","Wheel s_aoC ns_aoD : ws_aoE","(Wheel s_aoC ns_aoD : ws_aoE)","!(Wheel s_aoC ns_aoD : ws_aoE)","(!(Wheel s_aoC ns_aoD : ws_aoE))","ps_aoF","qs_aoG","o_aGG","!o_aGG","(!o_aGG)","n_aGH","n'_aGI","!n'_aGI","(!n'_aGI)","noFactor_aoH","lazydmd@!noFactor_aoH","(!noFactor_aoH)","p_aGJ","ps_aGK","p_aGJ : ps_aGK","(p_aGJ : ps_aGK)","q_aGL","safebang@!q_aGL","(!q_aGL)","qs_aGM","(!q_aGL) : qs_aGM","((!q_aGL) : qs_aGM)","n_aGN","safebang@!n_aGN","(!n_aGN)","squares","p_aPU","!p_aPU","(!p_aPU)","wheels","s_aPV","ns_aPW","Wheel s_aPV ns_aPW","(Wheel s_aPV ns_aPW)","!(Wheel s_aPV ns_aPW)","(!(Wheel s_aPV ns_aPW))","p_aPX","!p_aPX","(!p_aPX)","ns'_aPY","!ns'_aPY","(!ns'_aPY)","o_aPZ","n_aQ0","!n_aQ0","(!n_aQ0)","n'_aQ1","!n'_aQ1","(!n'_aQ1)","main","arg_aQ2","[arg_aQ2]"]
module Main (main) where
import System.Environment

primes :: [Int]
primes = sieve wheels primes squares
sieve (norecord@(Wheel s_aoC ns_aoD : ws_aoE)) ps_aoF qs_aoG
  = [n'_aGI |
     (norecord@o_aGG) <- s_aoC :
                           [s_aoC * 2, s_aoC * 3 .. (head ps_aoF - 1) * s_aoC],
     n_aGH <- ns_aoD, (norecord@n'_aGI) <- [n_aGH + o_aGG],
     noFactor_aoH n'_aGI]
      ++ sieve ws_aoE (tail ps_aoF) (tail qs_aoG)
  where (lazydmd@noFactor_aoH)
          = if s_aoC <= 2 then const True else notDivBy ps_aoF qs_aoG
notDivBy (p_aGJ : ps_aGK) ((!q_aGL) : qs_aGM) (!n_aGN)
  = q_aGL > n_aGN || n_aGN `mod` p_aGJ > 0 &&
      notDivBy ps_aGK qs_aGM n_aGN

squares :: [Int]
squares = [p_aPU * p_aPU | (norecord@p_aPU) <- primes]

wheels :: [Wheel]
wheels = Wheel 1 [1] : zipWith nextSize wheels primes
nextSize (norecord@(Wheel s_aPV ns_aPW)) (norecord@p_aPX)
  = Wheel (s_aPV * p_aPX) ns'_aPY
  where (norecord@ns'_aPY)
          = [n'_aQ1 | o_aPZ <- [0, s_aPV .. (p_aPX - 1) * s_aPV],
             (norecord@n_aQ0) <- ns_aPW, (norecord@n'_aQ1) <- [n_aQ0 + o_aPZ],
             n'_aQ1 `mod` p_aPX > 0]
main
  = do [arg_aQ2] <- getArgs
       print (primes !! ((read arg_aQ2) :: Int))

data Wheel = Wheel Int [Int]

==================== Renamer ====================
Main.tak :: Int -> Int -> Int -> Int
Main.tak (!x_aov) y_aow (!z_aox)
  = if not (y_aow < x_aov) then
        z_aox
    else
        Main.tak
          (Main.tak (x_aov - 1) y_aow z_aox)
          (Main.tak (y_aow - 1) z_aox x_aov)
          (Main.tak (z_aox - 1) x_aov y_aow)
Main.main
  = do { (![xs_aCX, ys_aCY, (!zs_aCZ)]) <- getArgs;
         print (Main.tak (read xs_aCX) (read ys_aCY) (read zs_aCZ)) }


["x_aov","safebang@!x_aov","(!x_aov)","y_aow","z_aox","safebang@!z_aox","(!z_aox)","main","xs_aCX","ys_aCY","zs_aCZ","safebang@!zs_aCZ","(!zs_aCZ)","[xs_aCX, ys_aCY, (!zs_aCZ)]","![xs_aCX, ys_aCY, (!zs_aCZ)]","(![xs_aCX, ys_aCY, (!zs_aCZ)])"]
module Main (main) where
import System.Environment

tak :: Int -> Int -> Int -> Int
tak (!x_aov) y_aow (!z_aox)
  = if not (y_aow < x_aov) then z_aox else
      tak (tak (x_aov - 1) y_aow z_aox) (tak (y_aow - 1) z_aox x_aov)
        (tak (z_aox - 1) x_aov y_aow)
main
  = do (norecord@[xs_aCX, ys_aCY, (!zs_aCZ)]) <- getArgs
       print (tak (read xs_aCX) (read ys_aCY) (read zs_aCZ))

==================== Renamer ====================
Main.main
  = do { [arg_aov] <- getArgs;
         print $ Main.nfib $ read arg_aov }
Main.nfib :: Double -> Double
Main.nfib n_at2
  = if n_at2 <= 1 then
        1
    else
        Main.nfib (n_at2 - 1) + Main.nfib (n_at2 - 2) + 1


["main","arg_aov","[arg_aov]","n_at2"]
module Main (main) where
import System.Environment
main
  = do [arg_aov] <- getArgs
       print $ nfib $ read arg_aov

nfib :: Double -> Double
nfib n_at2
  = if n_at2 <= 1 then 1 else nfib (n_at2 - 1) + nfib (n_at2 - 2) + 1

==================== Renamer ====================
Main.integrate1D ::
  Double -> Double -> (Double -> Double) -> Double
Main.integrate1D (!l_aoG) u_aoH (!f_aoI)
  = let (!d_aoJ) = (u_aoH - l_aoG) / 8.0
    in
      d_aoJ
      * sum
          [(f_aoI l_aoG) * 0.5, f_aoI (l_aoG + d_aoJ),
           f_aoI (l_aoG + (2.0 * d_aoJ)), f_aoI (l_aoG + (3.0 * d_aoJ)),
           f_aoI (l_aoG + (4.0 * d_aoJ)), f_aoI (u_aoH - (3.0 * d_aoJ)),
           f_aoI (u_aoH - (2.0 * d_aoJ)), f_aoI (u_aoH - d_aoJ),
           (f_aoI u_aoH) * 0.5]
Main.integrate2D l1_aEX u1_aEY (!l2_aEZ) (!u2_aF0) f_aF1
  = Main.integrate1D
      l2_aEZ
      u2_aF0
      (\ (!y_aF2)
         -> Main.integrate1D l1_aEX u1_aEY (\ x_aF3 -> f_aF1 x_aF3 y_aF2))
Main.zark u_aF4 v_aF5
  = Main.integrate2D
      0.0 u_aF4 0.0 v_aF5 (\ x_aF6 -> (\ y_aF7 -> x_aF6 * y_aF7))
Main.ints = [1.0 .. ] :: [Double]
Main.zarks = zipWith Main.zark Main.ints (map (2.0 *) Main.ints)
Main.rtotals
  = head Main.zarks : zipWith (+) (tail Main.zarks) Main.rtotals
Main.rtotal n_aIx = Main.rtotals !! n_aIx
Main.is = map (^ 4) Main.ints
Main.itotals
  = head Main.is : zipWith (+) (tail Main.is) Main.itotals
Main.itotal (!n_aIy) = Main.itotals !! n_aIy
Main.es = map (^ 2) (zipWith (-) Main.rtotals Main.itotals)
Main.etotal (!n_aIz) = sum (take n_aIz Main.es)
Main.main
  = do { [range_aIA] <- getArgs;
         putStrLn $ show $ Main.etotal $ read range_aIA }


["l_aoG","safebang@!l_aoG","(!l_aoG)","u_aoH","f_aoI","safebang@!f_aoI","(!f_aoI)","d_aoJ","!d_aoJ","(!d_aoJ)","l1_aEX","u1_aEY","l2_aEZ","!l2_aEZ","(!l2_aEZ)","u2_aF0","!u2_aF0","(!u2_aF0)","f_aF1","y_aF2","safebang@!y_aF2","(!y_aF2)","x_aF3","u_aF4","v_aF5","x_aF6","y_aF7","ints","zarks","rtotals","n_aIx","is","itotals","n_aIy","!n_aIy","(!n_aIy)","es","n_aIz","!n_aIz","(!n_aIz)","main","range_aIA","[range_aIA]"]
module Main (integrate1D, main) where
import System.Environment

integrate1D :: Double -> Double -> (Double -> Double) -> Double
integrate1D (!l_aoG) u_aoH (!f_aoI)
  = let (norecord@d_aoJ) = (u_aoH - l_aoG) / 8.0 in
      d_aoJ *
        sum
          [(f_aoI l_aoG) * 0.5, f_aoI (l_aoG + d_aoJ),
           f_aoI (l_aoG + (2.0 * d_aoJ)), f_aoI (l_aoG + (3.0 * d_aoJ)),
           f_aoI (l_aoG + (4.0 * d_aoJ)), f_aoI (u_aoH - (3.0 * d_aoJ)),
           f_aoI (u_aoH - (2.0 * d_aoJ)), f_aoI (u_aoH - d_aoJ),
           (f_aoI u_aoH) * 0.5]
integrate2D l1_aEX u1_aEY (norecord@l2_aEZ) (norecord@u2_aF0) f_aF1
  = integrate1D l2_aEZ u2_aF0
      (\ (!y_aF2) ->
         integrate1D l1_aEX u1_aEY (\ x_aF3 -> f_aF1 x_aF3 y_aF2))
zark u_aF4 v_aF5
  = integrate2D 0.0 u_aF4 0.0 v_aF5
      (\ x_aF6 -> (\ y_aF7 -> x_aF6 * y_aF7))
ints = [1.0 ..] :: [Double]
zarks = zipWith zark ints (map (2.0 *) ints)
rtotals = head zarks : zipWith (+) (tail zarks) rtotals
rtotal n_aIx = rtotals !! n_aIx
is = map (^ 4) ints
itotals = head is : zipWith (+) (tail is) itotals
itotal (norecord@n_aIy) = itotals !! n_aIy
es = map (^ 2) (zipWith (-) rtotals itotals)
etotal (norecord@n_aIz) = sum (take n_aIz es)
main
  = do [range_aIA] <- getArgs
       putStrLn $ show $ etotal $ read range_aIA
