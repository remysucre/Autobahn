[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.minN = 4
Dum.io (!s_aPv) (!n_aPw) (!t_aPx)
  = printf "%s of depth %d\t check: %d\n" s_aPv n_aPw t_aPx
Dum.depth :: Int -> Int -> [(Int, Int, Int)]
Dum.depth (!d_aPy) (!m_aPz)
  | d_aPy <= m_aPz
  = let
      (!s_a1Mn) = Dum.sumT d_aPy n_aPA 0
      (!rest_a1Mo) = Dum.depth (d_aPy + 2) m_aPz
    in s_a1Mn `par` ((2 * n_aPA, d_aPy, s_a1Mn) : rest_a1Mo)
  | otherwise = []
  where
      n_aPA = bit (m_aPz - d_aPy + Dum.minN)
Dum.sumT :: Int -> Int -> Int -> Int
Dum.sumT (!d_a1U1) 0 (!t_a1U2) = t_a1U2
Dum.sumT d_a1U3 (!i_a1U4) t_a1U5
  = a_a1U6 `par` b_a1U7 `par` Dum.sumT d_a1U3 (i_a1U4 - 1) ans_a1U8
  where
      (!a_a1U6) = Dum.check (Dum.make i_a1U4 d_a1U3)
      b_a1U7 = Dum.check (Dum.make (- i_a1U4) d_a1U3)
      (!ans_a1U8) = a_a1U6 + b_a1U7 + t_a1U5
Dum.check = Dum.check' True 0
Dum.check' :: Bool -> Int -> Dum.Tree -> Int
Dum.check' b_a1U9 !(!z_a1Ua) (!Dum.Nil) = z_a1Ua
Dum.check' b_a1Ub (!z_a1Uc) (Dum.Node i_a1Ud (!l_a1Ue) r_a1Uf)
  = Dum.check'
      (not b_a1Ub)
      (Dum.check'
         b_a1Ub
         (if b_a1Ub then z_a1Uc + i_a1Ud else z_a1Uc - i_a1Ud)
         l_a1Ue)
      r_a1Uf
Dum.make :: Int -> Int -> Dum.Tree
Dum.make (!i_a1Ug) 0 = Dum.Node i_a1Ug Dum.Nil Dum.Nil
Dum.make (!i_a1Uh) d_a1Ui
  = Dum.Node
      i_a1Uh (Dum.make (i2_a1Uj - 1) d2_a1Uk) (Dum.make i2_a1Uj d2_a1Uk)
  where
      i2_a1Uj = 2 * i_a1Uh
      d2_a1Uk = d_a1Ui - 1

data Dum.Tree = Dum.Nil | Dum.Node !Int !Dum.Tree !Dum.Tree


["minN","s_aPv","!s_aPv","(!s_aPv)","n_aPw","!n_aPw","(!n_aPw)","t_aPx","!t_aPx","(!t_aPx)","d_aPy","!d_aPy","(!d_aPy)","m_aPz","!m_aPz","(!m_aPz)","s_a1Mn","!s_a1Mn","(!s_a1Mn)","rest_a1Mo","!rest_a1Mo","(!rest_a1Mo)","n_aPA","d_a1U1","safebang@!d_a1U1","(!d_a1U1)","0","t_a1U2","safebang@!t_a1U2","(!t_a1U2)","d_a1U3","i_a1U4","!i_a1U4","(!i_a1U4)","t_a1U5","a_a1U6","!a_a1U6","(!a_a1U6)","b_a1U7","ans_a1U8","!ans_a1U8","(!ans_a1U8)","check","b_a1U9","z_a1Ua","safebang@!z_a1Ua","(!z_a1Ua)","!(!z_a1Ua)","Nil","!Nil","(!Nil)","b_a1Ub","z_a1Uc","!z_a1Uc","(!z_a1Uc)","i_a1Ud","l_a1Ue","!l_a1Ue","(!l_a1Ue)","r_a1Uf","Node i_a1Ud (!l_a1Ue) r_a1Uf","(Node i_a1Ud (!l_a1Ue) r_a1Uf)","i_a1Ug","!i_a1Ug","(!i_a1Ug)","0","i_a1Uh","!i_a1Uh","(!i_a1Uh)","d_a1Ui","i2_a1Uj","d2_a1Uk"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.Environment
import Control.Monad
import System.Mem
import Data.Bits
import Text.Printf
import GHC.Conc
minN = 4
io (investigate@s_aPv) (investigate@n_aPw) (investigate@t_aPx)
  = printf "%s of depth %d\t check: %d\n" s_aPv n_aPw t_aPx

depth :: Int -> Int -> [(Int, Int, Int)]
depth (investigate@d_aPy) (investigate@m_aPz)
  | d_aPy <= m_aPz =
    let (investigate@s_a1Mn) = sumT d_aPy n_aPA 0
        (investigate@rest_a1Mo) = depth (d_aPy + 2) m_aPz
      in s_a1Mn `par` ((2 * n_aPA, d_aPy, s_a1Mn) : rest_a1Mo)
  | otherwise = []
  where n_aPA = bit (m_aPz - d_aPy + minN)

sumT :: Int -> Int -> Int -> Int
sumT (!d_a1U1) 0 (!t_a1U2) = t_a1U2
sumT d_a1U3 (investigate@i_a1U4) t_a1U5
  = a_a1U6 `par` b_a1U7 `par` sumT d_a1U3 (i_a1U4 - 1) ans_a1U8
  where (investigate@a_a1U6) = check (make i_a1U4 d_a1U3)
        b_a1U7 = check (make (-i_a1U4) d_a1U3)
        (investigate@ans_a1U8) = a_a1U6 + b_a1U7 + t_a1U5
check = check' True 0

check' :: Bool -> Int -> Tree -> Int
check' b_a1U9 investigate@(!z_a1Ua) (investigate@Nil) = z_a1Ua
check' b_a1Ub (investigate@z_a1Uc)
  (Node i_a1Ud (investigate@l_a1Ue) r_a1Uf)
  = check' (not b_a1Ub)
      (check' b_a1Ub
         (if b_a1Ub then z_a1Uc + i_a1Ud else z_a1Uc - i_a1Ud)
         l_a1Ue)
      r_a1Uf

make :: Int -> Int -> Tree
make (investigate@i_a1Ug) 0 = Node i_a1Ug Nil Nil
make (investigate@i_a1Uh) d_a1Ui
  = Node i_a1Uh (make (i2_a1Uj - 1) d2_a1Uk) (make i2_a1Uj d2_a1Uk)
  where i2_a1Uj = 2 * i_a1Uh
        d2_a1Uk = d_a1Ui - 1

data Tree = Nil
          | Node !Int !Tree !Tree
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.minN = 4
Dum.io (!s_aPv) (!n_aPw) (!t_aPx)
  = printf "%s of depth %d\t check: %d\n" s_aPv n_aPw t_aPx
Dum.depth :: Int -> Int -> [(Int, Int, Int)]
Dum.depth (!d_aPy) (!m_aPz)
  | d_aPy <= m_aPz
  = let
      (!s_a1Mn) = Dum.sumT d_aPy n_aPA 0
      (!rest_a1Mo) = Dum.depth (d_aPy + 2) m_aPz
    in s_a1Mn `par` ((2 * n_aPA, d_aPy, s_a1Mn) : rest_a1Mo)
  | otherwise = []
  where
      n_aPA = bit (m_aPz - d_aPy + Dum.minN)
Dum.sumT :: Int -> Int -> Int -> Int
Dum.sumT (!d_a1U1) 0 (!t_a1U2) = t_a1U2
Dum.sumT d_a1U3 (!i_a1U4) t_a1U5
  = a_a1U6 `par` b_a1U7 `par` Dum.sumT d_a1U3 (i_a1U4 - 1) ans_a1U8
  where
      (!a_a1U6) = Dum.check (Dum.make i_a1U4 d_a1U3)
      b_a1U7 = Dum.check (Dum.make (- i_a1U4) d_a1U3)
      (!ans_a1U8) = a_a1U6 + b_a1U7 + t_a1U5
Dum.check = Dum.check' True 0
Dum.check' :: Bool -> Int -> Dum.Tree -> Int
Dum.check' b_a1U9 !(!z_a1Ua) (!Dum.Nil) = z_a1Ua
Dum.check' b_a1Ub (!z_a1Uc) (Dum.Node i_a1Ud (!l_a1Ue) r_a1Uf)
  = Dum.check'
      (not b_a1Ub)
      (Dum.check'
         b_a1Ub
         (if b_a1Ub then z_a1Uc + i_a1Ud else z_a1Uc - i_a1Ud)
         l_a1Ue)
      r_a1Uf
Dum.make :: Int -> Int -> Dum.Tree
Dum.make (!i_a1Ug) 0 = Dum.Node i_a1Ug Dum.Nil Dum.Nil
Dum.make (!i_a1Uh) d_a1Ui
  = Dum.Node
      i_a1Uh (Dum.make (i2_a1Uj - 1) d2_a1Uk) (Dum.make i2_a1Uj d2_a1Uk)
  where
      i2_a1Uj = 2 * i_a1Uh
      d2_a1Uk = d_a1Ui - 1

data Dum.Tree = Dum.Nil | Dum.Node !Int !Dum.Tree !Dum.Tree


["minN","s_aPv","!s_aPv","(!s_aPv)","n_aPw","!n_aPw","(!n_aPw)","t_aPx","!t_aPx","(!t_aPx)","d_aPy","!d_aPy","(!d_aPy)","m_aPz","!m_aPz","(!m_aPz)","s_a1Mn","!s_a1Mn","(!s_a1Mn)","rest_a1Mo","!rest_a1Mo","(!rest_a1Mo)","n_aPA","d_a1U1","safebang@!d_a1U1","(!d_a1U1)","0","t_a1U2","safebang@!t_a1U2","(!t_a1U2)","d_a1U3","i_a1U4","!i_a1U4","(!i_a1U4)","t_a1U5","a_a1U6","!a_a1U6","(!a_a1U6)","b_a1U7","ans_a1U8","!ans_a1U8","(!ans_a1U8)","check","b_a1U9","z_a1Ua","safebang@!z_a1Ua","(!z_a1Ua)","!(!z_a1Ua)","Nil","!Nil","(!Nil)","b_a1Ub","z_a1Uc","!z_a1Uc","(!z_a1Uc)","i_a1Ud","l_a1Ue","!l_a1Ue","(!l_a1Ue)","r_a1Uf","Node i_a1Ud (!l_a1Ue) r_a1Uf","(Node i_a1Ud (!l_a1Ue) r_a1Uf)","i_a1Ug","!i_a1Ug","(!i_a1Ug)","0","i_a1Uh","!i_a1Uh","(!i_a1Uh)","d_a1Ui","i2_a1Uj","d2_a1Uk"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Mgrfuns
import Drawfuns
minN = 4
io (investigate@s_aPv) (investigate@n_aPw) (investigate@t_aPx)
  = printf "%s of depth %d\t check: %d\n" s_aPv n_aPw t_aPx

depth :: Int -> Int -> [(Int, Int, Int)]
depth (investigate@d_aPy) (investigate@m_aPz)
  | d_aPy <= m_aPz =
    let (investigate@s_a1Mn) = sumT d_aPy n_aPA 0
        (investigate@rest_a1Mo) = depth (d_aPy + 2) m_aPz
      in s_a1Mn `par` ((2 * n_aPA, d_aPy, s_a1Mn) : rest_a1Mo)
  | otherwise = []
  where n_aPA = bit (m_aPz - d_aPy + minN)

sumT :: Int -> Int -> Int -> Int
sumT (!d_a1U1) 0 (!t_a1U2) = t_a1U2
sumT d_a1U3 (investigate@i_a1U4) t_a1U5
  = a_a1U6 `par` b_a1U7 `par` sumT d_a1U3 (i_a1U4 - 1) ans_a1U8
  where (investigate@a_a1U6) = check (make i_a1U4 d_a1U3)
        b_a1U7 = check (make (-i_a1U4) d_a1U3)
        (investigate@ans_a1U8) = a_a1U6 + b_a1U7 + t_a1U5
check = check' True 0

check' :: Bool -> Int -> Tree -> Int
check' b_a1U9 investigate@(!z_a1Ua) (investigate@Nil) = z_a1Ua
check' b_a1Ub (investigate@z_a1Uc)
  (Node i_a1Ud (investigate@l_a1Ue) r_a1Uf)
  = check' (not b_a1Ub)
      (check' b_a1Ub
         (if b_a1Ub then z_a1Uc + i_a1Ud else z_a1Uc - i_a1Ud)
         l_a1Ue)
      r_a1Uf

make :: Int -> Int -> Tree
make (investigate@i_a1Ug) 0 = Node i_a1Ug Nil Nil
make (investigate@i_a1Uh) d_a1Ui
  = Node i_a1Uh (make (i2_a1Uj - 1) d2_a1Uk) (make i2_a1Uj d2_a1Uk)
  where i2_a1Uj = 2 * i_a1Uh
        d2_a1Uk = d_a1Ui - 1

data Tree = Nil
          | Node !Int !Tree !Tree
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.minN = 4
Dum.io (!s_aPv) (!n_aPw) (!t_aPx)
  = printf "%s of depth %d\t check: %d\n" s_aPv n_aPw t_aPx
Dum.depth :: Int -> Int -> [(Int, Int, Int)]
Dum.depth (!d_aPy) (!m_aPz)
  | d_aPy <= m_aPz
  = let
      (!s_a1Mn) = Dum.sumT d_aPy n_aPA 0
      (!rest_a1Mo) = Dum.depth (d_aPy + 2) m_aPz
    in s_a1Mn `par` ((2 * n_aPA, d_aPy, s_a1Mn) : rest_a1Mo)
  | otherwise = []
  where
      n_aPA = bit (m_aPz - d_aPy + Dum.minN)
Dum.sumT :: Int -> Int -> Int -> Int
Dum.sumT (!d_a1U1) 0 (!t_a1U2) = t_a1U2
Dum.sumT d_a1U3 (!i_a1U4) t_a1U5
  = a_a1U6 `par` b_a1U7 `par` Dum.sumT d_a1U3 (i_a1U4 - 1) ans_a1U8
  where
      (!a_a1U6) = Dum.check (Dum.make i_a1U4 d_a1U3)
      b_a1U7 = Dum.check (Dum.make (- i_a1U4) d_a1U3)
      (!ans_a1U8) = a_a1U6 + b_a1U7 + t_a1U5
Dum.check = Dum.check' True 0
Dum.check' :: Bool -> Int -> Dum.Tree -> Int
Dum.check' b_a1U9 !(!z_a1Ua) (!Dum.Nil) = z_a1Ua
Dum.check' b_a1Ub (!z_a1Uc) (Dum.Node i_a1Ud (!l_a1Ue) r_a1Uf)
  = Dum.check'
      (not b_a1Ub)
      (Dum.check'
         b_a1Ub
         (if b_a1Ub then z_a1Uc + i_a1Ud else z_a1Uc - i_a1Ud)
         l_a1Ue)
      r_a1Uf
Dum.make :: Int -> Int -> Dum.Tree
Dum.make (!i_a1Ug) 0 = Dum.Node i_a1Ug Dum.Nil Dum.Nil
Dum.make (!i_a1Uh) d_a1Ui
  = Dum.Node
      i_a1Uh (Dum.make (i2_a1Uj - 1) d2_a1Uk) (Dum.make i2_a1Uj d2_a1Uk)
  where
      i2_a1Uj = 2 * i_a1Uh
      d2_a1Uk = d_a1Ui - 1

data Dum.Tree = Dum.Nil | Dum.Node !Int !Dum.Tree !Dum.Tree


["minN","s_aPv","!s_aPv","(!s_aPv)","n_aPw","!n_aPw","(!n_aPw)","t_aPx","!t_aPx","(!t_aPx)","d_aPy","!d_aPy","(!d_aPy)","m_aPz","!m_aPz","(!m_aPz)","s_a1Mn","!s_a1Mn","(!s_a1Mn)","rest_a1Mo","!rest_a1Mo","(!rest_a1Mo)","n_aPA","d_a1U1","safebang@!d_a1U1","(!d_a1U1)","0","t_a1U2","safebang@!t_a1U2","(!t_a1U2)","d_a1U3","i_a1U4","!i_a1U4","(!i_a1U4)","t_a1U5","a_a1U6","!a_a1U6","(!a_a1U6)","b_a1U7","ans_a1U8","!ans_a1U8","(!ans_a1U8)","check","b_a1U9","z_a1Ua","safebang@!z_a1Ua","(!z_a1Ua)","!(!z_a1Ua)","Nil","!Nil","(!Nil)","b_a1Ub","z_a1Uc","!z_a1Uc","(!z_a1Uc)","i_a1Ud","l_a1Ue","!l_a1Ue","(!l_a1Ue)","r_a1Uf","Node i_a1Ud (!l_a1Ue) r_a1Uf","(Node i_a1Ud (!l_a1Ue) r_a1Uf)","i_a1Ug","!i_a1Ug","(!i_a1Ug)","0","i_a1Uh","!i_a1Uh","(!i_a1Uh)","d_a1Ui","i2_a1Uj","d2_a1Uk"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Mgrfuns
import Drawfuns
import Diff
minN = 4
io (investigate@s_aPv) (investigate@n_aPw) (investigate@t_aPx)
  = printf "%s of depth %d\t check: %d\n" s_aPv n_aPw t_aPx

depth :: Int -> Int -> [(Int, Int, Int)]
depth (investigate@d_aPy) (investigate@m_aPz)
  | d_aPy <= m_aPz =
    let (investigate@s_a1Mn) = sumT d_aPy n_aPA 0
        (investigate@rest_a1Mo) = depth (d_aPy + 2) m_aPz
      in s_a1Mn `par` ((2 * n_aPA, d_aPy, s_a1Mn) : rest_a1Mo)
  | otherwise = []
  where n_aPA = bit (m_aPz - d_aPy + minN)

sumT :: Int -> Int -> Int -> Int
sumT (!d_a1U1) 0 (!t_a1U2) = t_a1U2
sumT d_a1U3 (investigate@i_a1U4) t_a1U5
  = a_a1U6 `par` b_a1U7 `par` sumT d_a1U3 (i_a1U4 - 1) ans_a1U8
  where (investigate@a_a1U6) = check (make i_a1U4 d_a1U3)
        b_a1U7 = check (make (-i_a1U4) d_a1U3)
        (investigate@ans_a1U8) = a_a1U6 + b_a1U7 + t_a1U5
check = check' True 0

check' :: Bool -> Int -> Tree -> Int
check' b_a1U9 investigate@(!z_a1Ua) (investigate@Nil) = z_a1Ua
check' b_a1Ub (investigate@z_a1Uc)
  (Node i_a1Ud (investigate@l_a1Ue) r_a1Uf)
  = check' (not b_a1Ub)
      (check' b_a1Ub
         (if b_a1Ub then z_a1Uc + i_a1Ud else z_a1Uc - i_a1Ud)
         l_a1Ue)
      r_a1Uf

make :: Int -> Int -> Tree
make (investigate@i_a1Ug) 0 = Node i_a1Ug Nil Nil
make (investigate@i_a1Uh) d_a1Ui
  = Node i_a1Uh (make (i2_a1Uj - 1) d2_a1Uk) (make i2_a1Uj d2_a1Uk)
  where i2_a1Uj = 2 * i_a1Uh
        d2_a1Uk = d_a1Ui - 1

data Tree = Nil
          | Node !Int !Tree !Tree
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.minN = 4
Dum.io (!s_aPv) (!n_aPw) (!t_aPx)
  = printf "%s of depth %d\t check: %d\n" s_aPv n_aPw t_aPx
Dum.depth :: Int -> Int -> [(Int, Int, Int)]
Dum.depth (!d_aPy) (!m_aPz)
  | d_aPy <= m_aPz
  = let
      (!s_a1Mn) = Dum.sumT d_aPy n_aPA 0
      (!rest_a1Mo) = Dum.depth (d_aPy + 2) m_aPz
    in s_a1Mn `par` ((2 * n_aPA, d_aPy, s_a1Mn) : rest_a1Mo)
  | otherwise = []
  where
      n_aPA = bit (m_aPz - d_aPy + Dum.minN)
Dum.sumT :: Int -> Int -> Int -> Int
Dum.sumT (!d_a1U1) 0 (!t_a1U2) = t_a1U2
Dum.sumT d_a1U3 (!i_a1U4) t_a1U5
  = a_a1U6 `par` b_a1U7 `par` Dum.sumT d_a1U3 (i_a1U4 - 1) ans_a1U8
  where
      (!a_a1U6) = Dum.check (Dum.make i_a1U4 d_a1U3)
      b_a1U7 = Dum.check (Dum.make (- i_a1U4) d_a1U3)
      (!ans_a1U8) = a_a1U6 + b_a1U7 + t_a1U5
Dum.check = Dum.check' True 0
Dum.check' :: Bool -> Int -> Dum.Tree -> Int
Dum.check' b_a1U9 !(!z_a1Ua) (!Dum.Nil) = z_a1Ua
Dum.check' b_a1Ub (!z_a1Uc) (Dum.Node i_a1Ud (!l_a1Ue) r_a1Uf)
  = Dum.check'
      (not b_a1Ub)
      (Dum.check'
         b_a1Ub
         (if b_a1Ub then z_a1Uc + i_a1Ud else z_a1Uc - i_a1Ud)
         l_a1Ue)
      r_a1Uf
Dum.make :: Int -> Int -> Dum.Tree
Dum.make (!i_a1Ug) 0 = Dum.Node i_a1Ug Dum.Nil Dum.Nil
Dum.make (!i_a1Uh) d_a1Ui
  = Dum.Node
      i_a1Uh (Dum.make (i2_a1Uj - 1) d2_a1Uk) (Dum.make i2_a1Uj d2_a1Uk)
  where
      i2_a1Uj = 2 * i_a1Uh
      d2_a1Uk = d_a1Ui - 1

data Dum.Tree = Dum.Nil | Dum.Node !Int !Dum.Tree !Dum.Tree


["minN","s_aPv","!s_aPv","(!s_aPv)","n_aPw","!n_aPw","(!n_aPw)","t_aPx","!t_aPx","(!t_aPx)","d_aPy","!d_aPy","(!d_aPy)","m_aPz","!m_aPz","(!m_aPz)","s_a1Mn","!s_a1Mn","(!s_a1Mn)","rest_a1Mo","!rest_a1Mo","(!rest_a1Mo)","n_aPA","d_a1U1","safebang@!d_a1U1","(!d_a1U1)","0","t_a1U2","safebang@!t_a1U2","(!t_a1U2)","d_a1U3","i_a1U4","!i_a1U4","(!i_a1U4)","t_a1U5","a_a1U6","!a_a1U6","(!a_a1U6)","b_a1U7","ans_a1U8","!ans_a1U8","(!ans_a1U8)","check","b_a1U9","z_a1Ua","safebang@!z_a1Ua","(!z_a1Ua)","!(!z_a1Ua)","Nil","!Nil","(!Nil)","b_a1Ub","z_a1Uc","!z_a1Uc","(!z_a1Uc)","i_a1Ud","l_a1Ue","!l_a1Ue","(!l_a1Ue)","r_a1Uf","Node i_a1Ud (!l_a1Ue) r_a1Uf","(Node i_a1Ud (!l_a1Ue) r_a1Uf)","i_a1Ug","!i_a1Ug","(!i_a1Ug)","0","i_a1Uh","!i_a1Uh","(!i_a1Uh)","d_a1Ui","i2_a1Uj","d2_a1Uk"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Mgrfuns
import Progfuns
import Auxprogfuns
import Layout
import Tilefuns
minN = 4
io (investigate@s_aPv) (investigate@n_aPw) (investigate@t_aPx)
  = printf "%s of depth %d\t check: %d\n" s_aPv n_aPw t_aPx

depth :: Int -> Int -> [(Int, Int, Int)]
depth (investigate@d_aPy) (investigate@m_aPz)
  | d_aPy <= m_aPz =
    let (investigate@s_a1Mn) = sumT d_aPy n_aPA 0
        (investigate@rest_a1Mo) = depth (d_aPy + 2) m_aPz
      in s_a1Mn `par` ((2 * n_aPA, d_aPy, s_a1Mn) : rest_a1Mo)
  | otherwise = []
  where n_aPA = bit (m_aPz - d_aPy + minN)

sumT :: Int -> Int -> Int -> Int
sumT (!d_a1U1) 0 (!t_a1U2) = t_a1U2
sumT d_a1U3 (investigate@i_a1U4) t_a1U5
  = a_a1U6 `par` b_a1U7 `par` sumT d_a1U3 (i_a1U4 - 1) ans_a1U8
  where (investigate@a_a1U6) = check (make i_a1U4 d_a1U3)
        b_a1U7 = check (make (-i_a1U4) d_a1U3)
        (investigate@ans_a1U8) = a_a1U6 + b_a1U7 + t_a1U5
check = check' True 0

check' :: Bool -> Int -> Tree -> Int
check' b_a1U9 investigate@(!z_a1Ua) (investigate@Nil) = z_a1Ua
check' b_a1Ub (investigate@z_a1Uc)
  (Node i_a1Ud (investigate@l_a1Ue) r_a1Uf)
  = check' (not b_a1Ub)
      (check' b_a1Ub
         (if b_a1Ub then z_a1Uc + i_a1Ud else z_a1Uc - i_a1Ud)
         l_a1Ue)
      r_a1Uf

make :: Int -> Int -> Tree
make (investigate@i_a1Ug) 0 = Node i_a1Ug Nil Nil
make (investigate@i_a1Uh) d_a1Ui
  = Node i_a1Uh (make (i2_a1Uj - 1) d2_a1Uk) (make i2_a1Uj d2_a1Uk)
  where i2_a1Uj = 2 * i_a1Uh
        d2_a1Uk = d_a1Ui - 1

data Tree = Nil
          | Node !Int !Tree !Tree
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.minN = 4
Dum.io (!s_aPv) (!n_aPw) (!t_aPx)
  = printf "%s of depth %d\t check: %d\n" s_aPv n_aPw t_aPx
Dum.depth :: Int -> Int -> [(Int, Int, Int)]
Dum.depth (!d_aPy) (!m_aPz)
  | d_aPy <= m_aPz
  = let
      (!s_a1Mn) = Dum.sumT d_aPy n_aPA 0
      (!rest_a1Mo) = Dum.depth (d_aPy + 2) m_aPz
    in s_a1Mn `par` ((2 * n_aPA, d_aPy, s_a1Mn) : rest_a1Mo)
  | otherwise = []
  where
      n_aPA = bit (m_aPz - d_aPy + Dum.minN)
Dum.sumT :: Int -> Int -> Int -> Int
Dum.sumT (!d_a1U1) 0 (!t_a1U2) = t_a1U2
Dum.sumT d_a1U3 (!i_a1U4) t_a1U5
  = a_a1U6 `par` b_a1U7 `par` Dum.sumT d_a1U3 (i_a1U4 - 1) ans_a1U8
  where
      (!a_a1U6) = Dum.check (Dum.make i_a1U4 d_a1U3)
      b_a1U7 = Dum.check (Dum.make (- i_a1U4) d_a1U3)
      (!ans_a1U8) = a_a1U6 + b_a1U7 + t_a1U5
Dum.check = Dum.check' True 0
Dum.check' :: Bool -> Int -> Dum.Tree -> Int
Dum.check' b_a1U9 !(!z_a1Ua) (!Dum.Nil) = z_a1Ua
Dum.check' b_a1Ub (!z_a1Uc) (Dum.Node i_a1Ud (!l_a1Ue) r_a1Uf)
  = Dum.check'
      (not b_a1Ub)
      (Dum.check'
         b_a1Ub
         (if b_a1Ub then z_a1Uc + i_a1Ud else z_a1Uc - i_a1Ud)
         l_a1Ue)
      r_a1Uf
Dum.make :: Int -> Int -> Dum.Tree
Dum.make (!i_a1Ug) 0 = Dum.Node i_a1Ug Dum.Nil Dum.Nil
Dum.make (!i_a1Uh) d_a1Ui
  = Dum.Node
      i_a1Uh (Dum.make (i2_a1Uj - 1) d2_a1Uk) (Dum.make i2_a1Uj d2_a1Uk)
  where
      i2_a1Uj = 2 * i_a1Uh
      d2_a1Uk = d_a1Ui - 1

data Dum.Tree = Dum.Nil | Dum.Node !Int !Dum.Tree !Dum.Tree


["minN","s_aPv","!s_aPv","(!s_aPv)","n_aPw","!n_aPw","(!n_aPw)","t_aPx","!t_aPx","(!t_aPx)","d_aPy","!d_aPy","(!d_aPy)","m_aPz","!m_aPz","(!m_aPz)","s_a1Mn","!s_a1Mn","(!s_a1Mn)","rest_a1Mo","!rest_a1Mo","(!rest_a1Mo)","n_aPA","d_a1U1","safebang@!d_a1U1","(!d_a1U1)","0","t_a1U2","safebang@!t_a1U2","(!t_a1U2)","d_a1U3","i_a1U4","!i_a1U4","(!i_a1U4)","t_a1U5","a_a1U6","!a_a1U6","(!a_a1U6)","b_a1U7","ans_a1U8","!ans_a1U8","(!ans_a1U8)","check","b_a1U9","z_a1Ua","safebang@!z_a1Ua","(!z_a1Ua)","!(!z_a1Ua)","Nil","!Nil","(!Nil)","b_a1Ub","z_a1Uc","!z_a1Uc","(!z_a1Uc)","i_a1Ud","l_a1Ue","!l_a1Ue","(!l_a1Ue)","r_a1Uf","Node i_a1Ud (!l_a1Ue) r_a1Uf","(Node i_a1Ud (!l_a1Ue) r_a1Uf)","i_a1Ug","!i_a1Ug","(!i_a1Ug)","0","i_a1Uh","!i_a1Uh","(!i_a1Uh)","d_a1Ui","i2_a1Uj","d2_a1Uk"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Mgrfuns
import Diff
minN = 4
io (investigate@s_aPv) (investigate@n_aPw) (investigate@t_aPx)
  = printf "%s of depth %d\t check: %d\n" s_aPv n_aPw t_aPx

depth :: Int -> Int -> [(Int, Int, Int)]
depth (investigate@d_aPy) (investigate@m_aPz)
  | d_aPy <= m_aPz =
    let (investigate@s_a1Mn) = sumT d_aPy n_aPA 0
        (investigate@rest_a1Mo) = depth (d_aPy + 2) m_aPz
      in s_a1Mn `par` ((2 * n_aPA, d_aPy, s_a1Mn) : rest_a1Mo)
  | otherwise = []
  where n_aPA = bit (m_aPz - d_aPy + minN)

sumT :: Int -> Int -> Int -> Int
sumT (!d_a1U1) 0 (!t_a1U2) = t_a1U2
sumT d_a1U3 (investigate@i_a1U4) t_a1U5
  = a_a1U6 `par` b_a1U7 `par` sumT d_a1U3 (i_a1U4 - 1) ans_a1U8
  where (investigate@a_a1U6) = check (make i_a1U4 d_a1U3)
        b_a1U7 = check (make (-i_a1U4) d_a1U3)
        (investigate@ans_a1U8) = a_a1U6 + b_a1U7 + t_a1U5
check = check' True 0

check' :: Bool -> Int -> Tree -> Int
check' b_a1U9 investigate@(!z_a1Ua) (investigate@Nil) = z_a1Ua
check' b_a1Ub (investigate@z_a1Uc)
  (Node i_a1Ud (investigate@l_a1Ue) r_a1Uf)
  = check' (not b_a1Ub)
      (check' b_a1Ub
         (if b_a1Ub then z_a1Uc + i_a1Ud else z_a1Uc - i_a1Ud)
         l_a1Ue)
      r_a1Uf

make :: Int -> Int -> Tree
make (investigate@i_a1Ug) 0 = Node i_a1Ug Nil Nil
make (investigate@i_a1Uh) d_a1Ui
  = Node i_a1Uh (make (i2_a1Uj - 1) d2_a1Uk) (make i2_a1Uj d2_a1Uk)
  where i2_a1Uj = 2 * i_a1Uh
        d2_a1Uk = d_a1Ui - 1

data Tree = Nil
          | Node !Int !Tree !Tree
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.norm :: (Int, Int) -> (Int, Int)
Dum.norm (!(x_axZ, y_ay0))
  = (u_ay1 `div` d_ay3, v_ay2 `div` d_ay3)
  where
      u_ay1 = if y_ay0 > 0 then x_axZ else - x_axZ
      v_ay2 = abs y_ay0
      d_ay3 = gcd_ay4 (abs u_ay1) v_ay2
      gcd_ay4 :: Int -> Int -> Int
      gcd_ay4 0 n2_a1v0 = n2_a1v0
      gcd_ay4 n1_a1v1 (!0) = n1_a1v1
      gcd_ay4 n1_a1v2 n2_a1v3
        = if n1_a1v2 < n2_a1v3 then
              gcd_ay4 n1_a1v2 (n2_a1v3 `mod` n1_a1v2)
          else
              gcd_ay4 (n1_a1v2 `mod` n2_a1v3) n2_a1v3
Dum.radd, Dum.rsub, Dum.rmul, Dum.rdiv ::
  (Int, Int) -> (Int, Int) -> (Int, Int)
Dum.radd (!((!x_a1EH), (!y_a1EI))) (!((!u_a1EJ), (!v_a1EK)))
  = Dum.norm (x_a1EH * v_a1EK + u_a1EJ * y_a1EI, y_a1EI * v_a1EK)
Dum.rsub (x_a1EL, (!y_a1EM)) (!((!u_a1EN), (!v_a1EO)))
  = Dum.norm (x_a1EL * v_a1EO - u_a1EN * y_a1EM, y_a1EM * v_a1EO)
Dum.rmul (!(x_a1EP, y_a1EQ)) (u_a1ER, (!v_a1ES))
  = Dum.norm (x_a1EP * u_a1ER, y_a1EQ * v_a1ES)
Dum.rdiv (x_a1ET, (!y_a1EU)) (u_a1EV, (!v_a1EW))
  = Dum.norm (x_a1ET * v_a1EW, y_a1EU * u_a1EV)
Dum.rmin (x_a1EX, (!y_a1EY)) (u_a1EZ, v_a1F0)
  = if a_a1F1 > 0 then (u_a1EZ, v_a1F0) else (x_a1EX, y_a1EY)
  where
      (!(a_a1F1, b_a1F2)) = Dum.rsub (x_a1EX, y_a1EY) (u_a1EZ, v_a1F0)
Dum.rabs :: (Int, Int) -> (Int, Int)
Dum.rabs (x_a1F3, y_a1F4)
  = if x_a1F3 < 0 then (- x_a1F3, y_a1F4) else (x_a1F3, y_a1F4)
Dum.intval :: (Int, Int) -> Int
Dum.intval (!((!x_a1F5), y_a1F6)) = x_a1F5 `div` y_a1F6
Dum.show_rat :: (Int, Int) -> [Char]
Dum.show_rat ((!x_a1F7), (!y_a1F8))
  = show x_a1F7 ++ "/" ++ show y_a1F8
Dum.torat :: Int -> (Int, Int)
Dum.torat n_a1Pg = (n_a1Pg, 1)


["x_axZ","y_ay0","(x_axZ, y_ay0)","!(x_axZ, y_ay0)","(!(x_axZ, y_ay0))","u_ay1","v_ay2","d_ay3","0","n2_a1v0","n1_a1v1","0","!0","(!0)","n1_a1v2","n2_a1v3","x_a1EH","safebang@!x_a1EH","(!x_a1EH)","y_a1EI","safebang@!y_a1EI","(!y_a1EI)","((!x_a1EH), (!y_a1EI))","!((!x_a1EH), (!y_a1EI))","(!((!x_a1EH), (!y_a1EI)))","u_a1EJ","safebang@!u_a1EJ","(!u_a1EJ)","v_a1EK","safebang@!v_a1EK","(!v_a1EK)","((!u_a1EJ), (!v_a1EK))","!((!u_a1EJ), (!v_a1EK))","(!((!u_a1EJ), (!v_a1EK)))","x_a1EL","y_a1EM","safebang@!y_a1EM","(!y_a1EM)","(x_a1EL, (!y_a1EM))","u_a1EN","safebang@!u_a1EN","(!u_a1EN)","v_a1EO","safebang@!v_a1EO","(!v_a1EO)","((!u_a1EN), (!v_a1EO))","!((!u_a1EN), (!v_a1EO))","(!((!u_a1EN), (!v_a1EO)))","x_a1EP","y_a1EQ","(x_a1EP, y_a1EQ)","!(x_a1EP, y_a1EQ)","(!(x_a1EP, y_a1EQ))","u_a1ER","v_a1ES","safebang@!v_a1ES","(!v_a1ES)","(u_a1ER, (!v_a1ES))","x_a1ET","y_a1EU","safebang@!y_a1EU","(!y_a1EU)","(x_a1ET, (!y_a1EU))","u_a1EV","v_a1EW","safebang@!v_a1EW","(!v_a1EW)","(u_a1EV, (!v_a1EW))","x_a1EX","y_a1EY","safebang@!y_a1EY","(!y_a1EY)","(x_a1EX, (!y_a1EY))","u_a1EZ","v_a1F0","(u_a1EZ, v_a1F0)","a_a1F1","b_a1F2","(a_a1F1, b_a1F2)","!(a_a1F1, b_a1F2)","(!(a_a1F1, b_a1F2))","x_a1F3","y_a1F4","(x_a1F3, y_a1F4)","x_a1F5","!x_a1F5","(!x_a1F5)","y_a1F6","((!x_a1F5), y_a1F6)","!((!x_a1F5), y_a1F6)","(!((!x_a1F5), y_a1F6))","x_a1F7","!x_a1F7","(!x_a1F7)","y_a1F8","safebang@!y_a1F8","(!y_a1F8)","((!x_a1F7), (!y_a1F8))","n_a1Pg"]
{-# LANGUAGE BangPatterns #-}
module Dum where

norm :: (Int, Int) -> (Int, Int)
norm (investigate@(x_axZ, y_ay0))
  = (u_ay1 `div` d_ay3, v_ay2 `div` d_ay3)
  where u_ay1 = if y_ay0 > 0 then x_axZ else -x_axZ
        v_ay2 = abs y_ay0
        d_ay3 = gcd_ay4 (abs u_ay1) v_ay2
        
        gcd_ay4 :: Int -> Int -> Int
        gcd_ay4 0 n2_a1v0 = n2_a1v0
        gcd_ay4 n1_a1v1 (investigate@0) = n1_a1v1
        gcd_ay4 n1_a1v2 n2_a1v3
          = if n1_a1v2 < n2_a1v3 then gcd_ay4 n1_a1v2 (n2_a1v3 `mod` n1_a1v2)
              else gcd_ay4 (n1_a1v2 `mod` n2_a1v3) n2_a1v3

radd, rsub, rmul, rdiv :: (Int, Int) -> (Int, Int) -> (Int, Int)
radd (investigate@((!x_a1EH), (!y_a1EI)))
  (investigate@((!u_a1EJ), (!v_a1EK)))
  = norm (x_a1EH * v_a1EK + u_a1EJ * y_a1EI, y_a1EI * v_a1EK)
rsub (x_a1EL, (!y_a1EM)) (investigate@((!u_a1EN), (!v_a1EO)))
  = norm (x_a1EL * v_a1EO - u_a1EN * y_a1EM, y_a1EM * v_a1EO)
rmul (investigate@(x_a1EP, y_a1EQ)) (u_a1ER, (!v_a1ES))
  = norm (x_a1EP * u_a1ER, y_a1EQ * v_a1ES)
rdiv (x_a1ET, (!y_a1EU)) (u_a1EV, (!v_a1EW))
  = norm (x_a1ET * v_a1EW, y_a1EU * u_a1EV)
rmin (x_a1EX, (!y_a1EY)) (u_a1EZ, v_a1F0)
  = if a_a1F1 > 0 then (u_a1EZ, v_a1F0) else (x_a1EX, y_a1EY)
  where (investigate@(a_a1F1, b_a1F2))
          = rsub (x_a1EX, y_a1EY) (u_a1EZ, v_a1F0)

rabs :: (Int, Int) -> (Int, Int)
rabs (x_a1F3, y_a1F4)
  = if x_a1F3 < 0 then (-x_a1F3, y_a1F4) else (x_a1F3, y_a1F4)

intval :: (Int, Int) -> Int
intval (investigate@((investigate@x_a1F5), y_a1F6))
  = x_a1F5 `div` y_a1F6

show_rat :: (Int, Int) -> [Char]
show_rat ((investigate@x_a1F7), (!y_a1F8))
  = show x_a1F7 ++ "/" ++ show y_a1F8

torat :: Int -> (Int, Int)
torat n_a1Pg = (n_a1Pg, 1)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.inter ::
  (a_aqz -> [b_aqA])
  -> (a_aqz -> c_aqB -> Bool)
     -> (a_aqz -> c_aqB -> ([b_aqA], a_aqz, c_aqB))
        -> (a_aqz -> c_aqB -> [b_aqA])
Dum.inter prompt_axG endp_axH (!transact_axI)
  = interprog_axJ
  where
      interprog_axJ state_axK inpt_axL
        = prompt_axG state_axK
          ++
            if endp_axH state_axK inpt_axL then
                []
            else
                response_axM ++ interprog_axJ newstate_axN restofinput_axO
        where
            (response_axM, newstate_axN, restofinput_axO)
              = transact_axI state_axK inpt_axL


["prompt_axG","endp_axH","transact_axI","safebang@!transact_axI","(!transact_axI)","state_axK","inpt_axL","response_axM","newstate_axN","restofinput_axO","(response_axM, newstate_axN, restofinput_axO)"]
{-# LANGUAGE BangPatterns #-}
module Dum where

inter ::
      (a_aqz -> [b_aqA]) ->
        (a_aqz -> c_aqB -> Bool) ->
          (a_aqz -> c_aqB -> ([b_aqA], a_aqz, c_aqB)) ->
            (a_aqz -> c_aqB -> [b_aqA])
inter prompt_axG endp_axH (!transact_axI) = interprog_axJ
  where interprog_axJ state_axK inpt_axL
          = prompt_axG state_axK ++
              if endp_axH state_axK inpt_axL then [] else
                response_axM ++ interprog_axJ newstate_axN restofinput_axO
          where (response_axM, newstate_axN, restofinput_axO)
                  = transact_axI state_axK inpt_axL
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.inter ::
  (a_aqz -> [b_aqA])
  -> (a_aqz -> c_aqB -> Bool)
     -> (a_aqz -> c_aqB -> ([b_aqA], a_aqz, c_aqB))
        -> (a_aqz -> c_aqB -> [b_aqA])
Dum.inter prompt_axG endp_axH (!transact_axI)
  = interprog_axJ
  where
      interprog_axJ state_axK inpt_axL
        = prompt_axG state_axK
          ++
            if endp_axH state_axK inpt_axL then
                []
            else
                response_axM ++ interprog_axJ newstate_axN restofinput_axO
        where
            (response_axM, newstate_axN, restofinput_axO)
              = transact_axI state_axK inpt_axL


["prompt_axG","endp_axH","transact_axI","safebang@!transact_axI","(!transact_axI)","state_axK","inpt_axL","response_axM","newstate_axN","restofinput_axO","(response_axM, newstate_axN, restofinput_axO)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Layout
import Mgrfuns

inter ::
      (a_aqz -> [b_aqA]) ->
        (a_aqz -> c_aqB -> Bool) ->
          (a_aqz -> c_aqB -> ([b_aqA], a_aqz, c_aqB)) ->
            (a_aqz -> c_aqB -> [b_aqA])
inter prompt_axG endp_axH (!transact_axI) = interprog_axJ
  where interprog_axJ state_axK inpt_axL
          = prompt_axG state_axK ++
              if endp_axH state_axK inpt_axL then [] else
                response_axM ++ interprog_axJ newstate_axN restofinput_axO
          where (response_axM, newstate_axN, restofinput_axO)
                  = transact_axI state_axK inpt_axL
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.inter ::
  (a_aqz -> [b_aqA])
  -> (a_aqz -> c_aqB -> Bool)
     -> (a_aqz -> c_aqB -> ([b_aqA], a_aqz, c_aqB))
        -> (a_aqz -> c_aqB -> [b_aqA])
Dum.inter prompt_axG endp_axH (!transact_axI)
  = interprog_axJ
  where
      interprog_axJ state_axK inpt_axL
        = prompt_axG state_axK
          ++
            if endp_axH state_axK inpt_axL then
                []
            else
                response_axM ++ interprog_axJ newstate_axN restofinput_axO
        where
            (response_axM, newstate_axN, restofinput_axO)
              = transact_axI state_axK inpt_axL


["prompt_axG","endp_axH","transact_axI","safebang@!transact_axI","(!transact_axI)","state_axK","inpt_axL","response_axM","newstate_axN","restofinput_axO","(response_axM, newstate_axN, restofinput_axO)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.List ((\\))
import Mgrfuns
import Diff
import Drawfuns
import Geomfuns
import Layout
import Rational

inter ::
      (a_aqz -> [b_aqA]) ->
        (a_aqz -> c_aqB -> Bool) ->
          (a_aqz -> c_aqB -> ([b_aqA], a_aqz, c_aqB)) ->
            (a_aqz -> c_aqB -> [b_aqA])
inter prompt_axG endp_axH (!transact_axI) = interprog_axJ
  where interprog_axJ state_axK inpt_axL
          = prompt_axG state_axK ++
              if endp_axH state_axK inpt_axL then [] else
                response_axM ++ interprog_axJ newstate_axN restofinput_axO
          where (response_axM, newstate_axN, restofinput_axO)
                  = transact_axI state_axK inpt_axL
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.square :: Int -> Int
Dum.square n_axp = n_axp * n_axp
Dum.diff :: Int -> Int -> Int
Dum.diff a_ayC (!b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC
Dum.bcroot :: Int -> Int
Dum.bcroot n_a1un
  = root'_a1uo 0 n_a1un
  where
      root'_a1uo a_a1up b_a1uq
        = if a_a1up + 1 >= b_a1uq then
              b_a1uq
          else
              if s_a1us < n_a1un then
                  root'_a1uo m_a1ur b_a1uq
              else
                  if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
        where
            m_a1ur = (a_a1up + b_a1uq) `div` 2
            s_a1us = m_a1ur * m_a1ur


["n_axp","a_ayC","b_ayD","!b_ayD","(!b_ayD)","n_a1un","a_a1up","b_a1uq","m_a1ur","s_a1us"]
{-# LANGUAGE BangPatterns #-}
module Dum where

square :: Int -> Int
square n_axp = n_axp * n_axp

diff :: Int -> Int -> Int
diff a_ayC (investigate@b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC

bcroot :: Int -> Int
bcroot n_a1un = root'_a1uo 0 n_a1un
  where root'_a1uo a_a1up b_a1uq
          = if a_a1up + 1 >= b_a1uq then b_a1uq else
              if s_a1us < n_a1un then root'_a1uo m_a1ur b_a1uq else
                if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
          where m_a1ur = (a_a1up + b_a1uq) `div` 2
                s_a1us = m_a1ur * m_a1ur
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.square :: Int -> Int
Dum.square n_axp = n_axp * n_axp
Dum.diff :: Int -> Int -> Int
Dum.diff a_ayC (!b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC
Dum.bcroot :: Int -> Int
Dum.bcroot n_a1un
  = root'_a1uo 0 n_a1un
  where
      root'_a1uo a_a1up b_a1uq
        = if a_a1up + 1 >= b_a1uq then
              b_a1uq
          else
              if s_a1us < n_a1un then
                  root'_a1uo m_a1ur b_a1uq
              else
                  if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
        where
            m_a1ur = (a_a1up + b_a1uq) `div` 2
            s_a1us = m_a1ur * m_a1ur


["n_axp","a_ayC","b_ayD","!b_ayD","(!b_ayD)","n_a1un","a_a1up","b_a1uq","m_a1ur","s_a1us"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Mgrfuns
import Drawfuns
import Geomfuns
import Psfuns
import Interstate
import Auxprogfuns
import Layout
import Tilefuns
import Help

square :: Int -> Int
square n_axp = n_axp * n_axp

diff :: Int -> Int -> Int
diff a_ayC (investigate@b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC

bcroot :: Int -> Int
bcroot n_a1un = root'_a1uo 0 n_a1un
  where root'_a1uo a_a1up b_a1uq
          = if a_a1up + 1 >= b_a1uq then b_a1uq else
              if s_a1us < n_a1un then root'_a1uo m_a1ur b_a1uq else
                if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
          where m_a1ur = (a_a1up + b_a1uq) `div` 2
                s_a1us = m_a1ur * m_a1ur
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.square :: Int -> Int
Dum.square n_axp = n_axp * n_axp
Dum.diff :: Int -> Int -> Int
Dum.diff a_ayC (!b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC
Dum.bcroot :: Int -> Int
Dum.bcroot n_a1un
  = root'_a1uo 0 n_a1un
  where
      root'_a1uo a_a1up b_a1uq
        = if a_a1up + 1 >= b_a1uq then
              b_a1uq
          else
              if s_a1us < n_a1un then
                  root'_a1uo m_a1ur b_a1uq
              else
                  if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
        where
            m_a1ur = (a_a1up + b_a1uq) `div` 2
            s_a1us = m_a1ur * m_a1ur


["n_axp","a_ayC","b_ayD","!b_ayD","(!b_ayD)","n_a1un","a_a1up","b_a1uq","m_a1ur","s_a1us"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Diff

square :: Int -> Int
square n_axp = n_axp * n_axp

diff :: Int -> Int -> Int
diff a_ayC (investigate@b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC

bcroot :: Int -> Int
bcroot n_a1un = root'_a1uo 0 n_a1un
  where root'_a1uo a_a1up b_a1uq
          = if a_a1up + 1 >= b_a1uq then b_a1uq else
              if s_a1us < n_a1un then root'_a1uo m_a1ur b_a1uq else
                if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
          where m_a1ur = (a_a1up + b_a1uq) `div` 2
                s_a1us = m_a1ur * m_a1ur
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.square :: Int -> Int
Dum.square n_axp = n_axp * n_axp
Dum.diff :: Int -> Int -> Int
Dum.diff a_ayC (!b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC
Dum.bcroot :: Int -> Int
Dum.bcroot n_a1un
  = root'_a1uo 0 n_a1un
  where
      root'_a1uo a_a1up b_a1uq
        = if a_a1up + 1 >= b_a1uq then
              b_a1uq
          else
              if s_a1us < n_a1un then
                  root'_a1uo m_a1ur b_a1uq
              else
                  if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
        where
            m_a1ur = (a_a1up + b_a1uq) `div` 2
            s_a1us = m_a1ur * m_a1ur


["n_axp","a_ayC","b_ayD","!b_ayD","(!b_ayD)","n_a1un","a_a1up","b_a1uq","m_a1ur","s_a1us"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Geomfuns
import Auxprogfuns

square :: Int -> Int
square n_axp = n_axp * n_axp

diff :: Int -> Int -> Int
diff a_ayC (investigate@b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC

bcroot :: Int -> Int
bcroot n_a1un = root'_a1uo 0 n_a1un
  where root'_a1uo a_a1up b_a1uq
          = if a_a1up + 1 >= b_a1uq then b_a1uq else
              if s_a1us < n_a1un then root'_a1uo m_a1ur b_a1uq else
                if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
          where m_a1ur = (a_a1up + b_a1uq) `div` 2
                s_a1us = m_a1ur * m_a1ur
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.square :: Int -> Int
Dum.square n_axp = n_axp * n_axp
Dum.diff :: Int -> Int -> Int
Dum.diff a_ayC (!b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC
Dum.bcroot :: Int -> Int
Dum.bcroot n_a1un
  = root'_a1uo 0 n_a1un
  where
      root'_a1uo a_a1up b_a1uq
        = if a_a1up + 1 >= b_a1uq then
              b_a1uq
          else
              if s_a1us < n_a1un then
                  root'_a1uo m_a1ur b_a1uq
              else
                  if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
        where
            m_a1ur = (a_a1up + b_a1uq) `div` 2
            s_a1us = m_a1ur * m_a1ur


["n_axp","a_ayC","b_ayD","!b_ayD","(!b_ayD)","n_a1un","a_a1up","b_a1uq","m_a1ur","s_a1us"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Layout
import Drawfuns
import Geomfuns

square :: Int -> Int
square n_axp = n_axp * n_axp

diff :: Int -> Int -> Int
diff a_ayC (investigate@b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC

bcroot :: Int -> Int
bcroot n_a1un = root'_a1uo 0 n_a1un
  where root'_a1uo a_a1up b_a1uq
          = if a_a1up + 1 >= b_a1uq then b_a1uq else
              if s_a1us < n_a1un then root'_a1uo m_a1ur b_a1uq else
                if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
          where m_a1ur = (a_a1up + b_a1uq) `div` 2
                s_a1us = m_a1ur * m_a1ur
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.square :: Int -> Int
Dum.square n_axp = n_axp * n_axp
Dum.diff :: Int -> Int -> Int
Dum.diff a_ayC (!b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC
Dum.bcroot :: Int -> Int
Dum.bcroot n_a1un
  = root'_a1uo 0 n_a1un
  where
      root'_a1uo a_a1up b_a1uq
        = if a_a1up + 1 >= b_a1uq then
              b_a1uq
          else
              if s_a1us < n_a1un then
                  root'_a1uo m_a1ur b_a1uq
              else
                  if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
        where
            m_a1ur = (a_a1up + b_a1uq) `div` 2
            s_a1us = m_a1ur * m_a1ur


["n_axp","a_ayC","b_ayD","!b_ayD","(!b_ayD)","n_a1un","a_a1up","b_a1uq","m_a1ur","s_a1us"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Database
import Vector
import Displacement
import Elemforce
import PrintSource
import Printuvwforce

square :: Int -> Int
square n_axp = n_axp * n_axp

diff :: Int -> Int -> Int
diff a_ayC (investigate@b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC

bcroot :: Int -> Int
bcroot n_a1un = root'_a1uo 0 n_a1un
  where root'_a1uo a_a1up b_a1uq
          = if a_a1up + 1 >= b_a1uq then b_a1uq else
              if s_a1us < n_a1un then root'_a1uo m_a1ur b_a1uq else
                if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
          where m_a1ur = (a_a1up + b_a1uq) `div` 2
                s_a1us = m_a1ur * m_a1ur
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.square :: Int -> Int
Dum.square n_axp = n_axp * n_axp
Dum.diff :: Int -> Int -> Int
Dum.diff a_ayC (!b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC
Dum.bcroot :: Int -> Int
Dum.bcroot n_a1un
  = root'_a1uo 0 n_a1un
  where
      root'_a1uo a_a1up b_a1uq
        = if a_a1up + 1 >= b_a1uq then
              b_a1uq
          else
              if s_a1us < n_a1un then
                  root'_a1uo m_a1ur b_a1uq
              else
                  if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
        where
            m_a1ur = (a_a1up + b_a1uq) `div` 2
            s_a1us = m_a1ur * m_a1ur


["n_axp","a_ayC","b_ayD","!b_ayD","(!b_ayD)","n_a1un","a_a1up","b_a1uq","m_a1ur","s_a1us"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Basics
import Vector

square :: Int -> Int
square n_axp = n_axp * n_axp

diff :: Int -> Int -> Int
diff a_ayC (investigate@b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC

bcroot :: Int -> Int
bcroot n_a1un = root'_a1uo 0 n_a1un
  where root'_a1uo a_a1up b_a1uq
          = if a_a1up + 1 >= b_a1uq then b_a1uq else
              if s_a1us < n_a1un then root'_a1uo m_a1ur b_a1uq else
                if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
          where m_a1ur = (a_a1up + b_a1uq) `div` 2
                s_a1us = m_a1ur * m_a1ur
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.square :: Int -> Int
Dum.square n_axp = n_axp * n_axp
Dum.diff :: Int -> Int -> Int
Dum.diff a_ayC (!b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC
Dum.bcroot :: Int -> Int
Dum.bcroot n_a1un
  = root'_a1uo 0 n_a1un
  where
      root'_a1uo a_a1up b_a1uq
        = if a_a1up + 1 >= b_a1uq then
              b_a1uq
          else
              if s_a1us < n_a1un then
                  root'_a1uo m_a1ur b_a1uq
              else
                  if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
        where
            m_a1ur = (a_a1up + b_a1uq) `div` 2
            s_a1us = m_a1ur * m_a1ur


["n_axp","a_ayC","b_ayD","!b_ayD","(!b_ayD)","n_a1un","a_a1up","b_a1uq","m_a1ur","s_a1us"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Basics
import Vector
import VBmatrix

square :: Int -> Int
square n_axp = n_axp * n_axp

diff :: Int -> Int -> Int
diff a_ayC (investigate@b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC

bcroot :: Int -> Int
bcroot n_a1un = root'_a1uo 0 n_a1un
  where root'_a1uo a_a1up b_a1uq
          = if a_a1up + 1 >= b_a1uq then b_a1uq else
              if s_a1us < n_a1un then root'_a1uo m_a1ur b_a1uq else
                if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
          where m_a1ur = (a_a1up + b_a1uq) `div` 2
                s_a1us = m_a1ur * m_a1ur
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.square :: Int -> Int
Dum.square n_axp = n_axp * n_axp
Dum.diff :: Int -> Int -> Int
Dum.diff a_ayC (!b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC
Dum.bcroot :: Int -> Int
Dum.bcroot n_a1un
  = root'_a1uo 0 n_a1un
  where
      root'_a1uo a_a1up b_a1uq
        = if a_a1up + 1 >= b_a1uq then
              b_a1uq
          else
              if s_a1us < n_a1un then
                  root'_a1uo m_a1ur b_a1uq
              else
                  if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
        where
            m_a1ur = (a_a1up + b_a1uq) `div` 2
            s_a1us = m_a1ur * m_a1ur


["n_axp","a_ayC","b_ayD","!b_ayD","(!b_ayD)","n_a1un","a_a1up","b_a1uq","m_a1ur","s_a1us"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Ix
import Basics
import Vector

square :: Int -> Int
square n_axp = n_axp * n_axp

diff :: Int -> Int -> Int
diff a_ayC (investigate@b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC

bcroot :: Int -> Int
bcroot n_a1un = root'_a1uo 0 n_a1un
  where root'_a1uo a_a1up b_a1uq
          = if a_a1up + 1 >= b_a1uq then b_a1uq else
              if s_a1us < n_a1un then root'_a1uo m_a1ur b_a1uq else
                if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
          where m_a1ur = (a_a1up + b_a1uq) `div` 2
                s_a1us = m_a1ur * m_a1ur
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.square :: Int -> Int
Dum.square n_axp = n_axp * n_axp
Dum.diff :: Int -> Int -> Int
Dum.diff a_ayC (!b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC
Dum.bcroot :: Int -> Int
Dum.bcroot n_a1un
  = root'_a1uo 0 n_a1un
  where
      root'_a1uo a_a1up b_a1uq
        = if a_a1up + 1 >= b_a1uq then
              b_a1uq
          else
              if s_a1us < n_a1un then
                  root'_a1uo m_a1ur b_a1uq
              else
                  if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
        where
            m_a1ur = (a_a1up + b_a1uq) `div` 2
            s_a1us = m_a1ur * m_a1ur


["n_axp","a_ayC","b_ayD","!b_ayD","(!b_ayD)","n_a1un","a_a1up","b_a1uq","m_a1ur","s_a1us"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Array
import Database

square :: Int -> Int
square n_axp = n_axp * n_axp

diff :: Int -> Int -> Int
diff a_ayC (investigate@b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC

bcroot :: Int -> Int
bcroot n_a1un = root'_a1uo 0 n_a1un
  where root'_a1uo a_a1up b_a1uq
          = if a_a1up + 1 >= b_a1uq then b_a1uq else
              if s_a1us < n_a1un then root'_a1uo m_a1ur b_a1uq else
                if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
          where m_a1ur = (a_a1up + b_a1uq) `div` 2
                s_a1us = m_a1ur * m_a1ur
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.square :: Int -> Int
Dum.square n_axp = n_axp * n_axp
Dum.diff :: Int -> Int -> Int
Dum.diff a_ayC (!b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC
Dum.bcroot :: Int -> Int
Dum.bcroot n_a1un
  = root'_a1uo 0 n_a1un
  where
      root'_a1uo a_a1up b_a1uq
        = if a_a1up + 1 >= b_a1uq then
              b_a1uq
          else
              if s_a1us < n_a1un then
                  root'_a1uo m_a1ur b_a1uq
              else
                  if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
        where
            m_a1ur = (a_a1up + b_a1uq) `div` 2
            s_a1us = m_a1ur * m_a1ur


["n_axp","a_ayC","b_ayD","!b_ayD","(!b_ayD)","n_a1un","a_a1up","b_a1uq","m_a1ur","s_a1us"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Basics
import Vector
import Matrix
import VBmatrix
import DB_interface
import Degrees
import Pre_assemble
import Elemstif

square :: Int -> Int
square n_axp = n_axp * n_axp

diff :: Int -> Int -> Int
diff a_ayC (investigate@b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC

bcroot :: Int -> Int
bcroot n_a1un = root'_a1uo 0 n_a1un
  where root'_a1uo a_a1up b_a1uq
          = if a_a1up + 1 >= b_a1uq then b_a1uq else
              if s_a1us < n_a1un then root'_a1uo m_a1ur b_a1uq else
                if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
          where m_a1ur = (a_a1up + b_a1uq) `div` 2
                s_a1us = m_a1ur * m_a1ur
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.square :: Int -> Int
Dum.square n_axp = n_axp * n_axp
Dum.diff :: Int -> Int -> Int
Dum.diff a_ayC (!b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC
Dum.bcroot :: Int -> Int
Dum.bcroot n_a1un
  = root'_a1uo 0 n_a1un
  where
      root'_a1uo a_a1up b_a1uq
        = if a_a1up + 1 >= b_a1uq then
              b_a1uq
          else
              if s_a1us < n_a1un then
                  root'_a1uo m_a1ur b_a1uq
              else
                  if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
        where
            m_a1ur = (a_a1up + b_a1uq) `div` 2
            s_a1us = m_a1ur * m_a1ur


["n_axp","a_ayC","b_ayD","!b_ayD","(!b_ayD)","n_a1un","a_a1up","b_a1uq","m_a1ur","s_a1us"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Database
import DB_interface
import Basics

square :: Int -> Int
square n_axp = n_axp * n_axp

diff :: Int -> Int -> Int
diff a_ayC (investigate@b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC

bcroot :: Int -> Int
bcroot n_a1un = root'_a1uo 0 n_a1un
  where root'_a1uo a_a1up b_a1uq
          = if a_a1up + 1 >= b_a1uq then b_a1uq else
              if s_a1us < n_a1un then root'_a1uo m_a1ur b_a1uq else
                if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
          where m_a1ur = (a_a1up + b_a1uq) `div` 2
                s_a1us = m_a1ur * m_a1ur
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.square :: Int -> Int
Dum.square n_axp = n_axp * n_axp
Dum.diff :: Int -> Int -> Int
Dum.diff a_ayC (!b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC
Dum.bcroot :: Int -> Int
Dum.bcroot n_a1un
  = root'_a1uo 0 n_a1un
  where
      root'_a1uo a_a1up b_a1uq
        = if a_a1up + 1 >= b_a1uq then
              b_a1uq
          else
              if s_a1us < n_a1un then
                  root'_a1uo m_a1ur b_a1uq
              else
                  if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
        where
            m_a1ur = (a_a1up + b_a1uq) `div` 2
            s_a1us = m_a1ur * m_a1ur


["n_axp","a_ayC","b_ayD","!b_ayD","(!b_ayD)","n_a1un","a_a1up","b_a1uq","m_a1ur","s_a1us"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Basics
import Vector
import DB_interface
import Degrees

square :: Int -> Int
square n_axp = n_axp * n_axp

diff :: Int -> Int -> Int
diff a_ayC (investigate@b_ayD)
  = if a_ayC > b_ayD then a_ayC - b_ayD else b_ayD - a_ayC

bcroot :: Int -> Int
bcroot n_a1un = root'_a1uo 0 n_a1un
  where root'_a1uo a_a1up b_a1uq
          = if a_a1up + 1 >= b_a1uq then b_a1uq else
              if s_a1us < n_a1un then root'_a1uo m_a1ur b_a1uq else
                if n_a1un < s_a1us then root'_a1uo a_a1up m_a1ur else m_a1ur
          where m_a1ur = (a_a1up + b_a1uq) `div` 2
                s_a1us = m_a1ur * m_a1ur
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.idatabase :: [Char] -> Array Int Int
Dum.idatabase (!s_aIU)
  = listArray (0, n_aIW - 1) il_aIV
  where
      il_aIV = Dum.isource s_aIU
      n_aIW = length il_aIV
Dum.rdatabase :: [Char] -> Array Int Float
Dum.rdatabase (!s_a12Q)
  = listArray (0, n_a12S - 1) rl_a12R
  where
      (!rl_a12R) = Dum.rsource s_a12Q
      (!n_a12S) = length rl_a12R
Dum.isource :: [Char] -> [Int]
Dum.isource s_a12T = fst (Dum.irsource s_a12T)
Dum.rsource :: [Char] -> [Float]
Dum.rsource s_a136 = snd (Dum.irsource s_a136)
Dum.irsource s_a137 = Dum.intreal (words s_a137)
Dum.intreal (![]) = ([], [])
Dum.intreal ((!x_a16D) : ls_a16E)
  = if (elem '.' x_a16D) then
        (idb_a16F, (Dum.realreal x_a16D) : rdb_a16G)
    else
        ((Dum.intint x_a16D) : idb_a16F, rdb_a16G)
  where
      (idb_a16F, rdb_a16G) = Dum.intreal ls_a16E
Dum.intint :: [Char] -> Int
Dum.intint ((!((!c_a16H) : x_a16I)))
  = if (c_a16H == '-') then
        (- 1) * (Dum.stoi x_a16I)
    else
        if (c_a16H == '+') then
            Dum.stoi x_a16I
        else
            Dum.stoi (c_a16H : x_a16I)
Dum.stoi :: [Char] -> Int
Dum.stoi (!s_a21S) = Dum.stoi' (reverse s_a21S)
Dum.stoi' [] = 0
Dum.stoi' (!((!c_a25o) : (!ls_a25p)))
  = (Dum.stoi' ls_a25p) * 10 + Dum.ctoi c_a25o
Dum.ctoi c_a25q
  = if (c_a25q == '0') then
        0
    else
        if (c_a25q == '1') then
            1
        else
            if (c_a25q == '2') then
                2
            else
                if (c_a25q == '3') then
                    3
                else
                    if (c_a25q == '4') then
                        4
                    else
                        if (c_a25q == '5') then
                            5
                        else
                            if (c_a25q == '6') then
                                6
                            else
                                if (c_a25q == '7') then 7 else if (c_a25q == '8') then 8 else 9
Dum.realreal :: [Char] -> Float
Dum.realreal ((!c_a25r) : (!x_a25s))
  = if (c_a25r == '-') then
        (- 1.0) * (Dum.stor x_a25s)
    else
        if (c_a25r == '+') then
            Dum.stor x_a25s
        else
            Dum.stor (c_a25r : x_a25s)
Dum.stor :: [Char] -> Float
Dum.stor s_a25t = (Dum.intpart s_a25t) + (Dum.floatpart s_a25t)
Dum.intpart :: [Char] -> Float
Dum.intpart (!x_a25u) = Dum.intpart' (takeWhile isDigit x_a25u)
Dum.intpart' :: [Char] -> Float
Dum.intpart' s_a2a2 = Dum.intparts (reverse s_a2a2)
Dum.intparts (![]) = 0.0
Dum.intparts ((!(c_a2a3 : s_a2a4)))
  = (Dum.intparts s_a2a4) * 10.0 + Dum.intpartss c_a2a3
Dum.intpartss c_a2a5
  = if (c_a2a5 == '0') then
        0.0
    else
        if (c_a2a5 == '1') then
            1.0
        else
            if (c_a2a5 == '2') then
                2.0
            else
                if (c_a2a5 == '3') then
                    3.0
                else
                    if (c_a2a5 == '4') then
                        4.0
                    else
                        if (c_a2a5 == '5') then
                            5.0
                        else
                            if (c_a2a5 == '6') then
                                6.0
                            else
                                if (c_a2a5 == '7') then
                                    7.0
                                else
                                    if (c_a2a5 == '8') then 8.0 else 9.0
Dum.floatpart :: [Char] -> Float
Dum.floatpart (!x_a2a6)
  = Dum.floatpart' (drop 1 (dropWhile isDigit x_a2a6))
Dum.floatpart' :: [Char] -> Float
Dum.floatpart' s_a2a7
  = (Dum.intpart' s_a2a7) / (Dum.e10 (length s_a2a7))
Dum.e10 0 = 1.0
Dum.e10 (!i_a2jJ) = 10.0 * (Dum.e10 (i_a2jJ - 1))


["s_aIU","safebang@!s_aIU","(!s_aIU)","il_aIV","n_aIW","s_a12Q","safebang@!s_a12Q","(!s_a12Q)","rl_a12R","!rl_a12R","(!rl_a12R)","n_a12S","!n_a12S","(!n_a12S)","s_a12T","s_a136","s_a137","[]","![]","(![])","x_a16D","safebang@!x_a16D","(!x_a16D)","ls_a16E","(!x_a16D) : ls_a16E","((!x_a16D) : ls_a16E)","idb_a16F","rdb_a16G","(idb_a16F, rdb_a16G)","c_a16H","!c_a16H","(!c_a16H)","x_a16I","(!c_a16H) : x_a16I","((!c_a16H) : x_a16I)","!((!c_a16H) : x_a16I)","(!((!c_a16H) : x_a16I))","((!((!c_a16H) : x_a16I)))","s_a21S","safebang@!s_a21S","(!s_a21S)","[]","c_a25o","safebang@!c_a25o","(!c_a25o)","ls_a25p","safebang@!ls_a25p","(!ls_a25p)","(!c_a25o) : (!ls_a25p)","((!c_a25o) : (!ls_a25p))","!((!c_a25o) : (!ls_a25p))","(!((!c_a25o) : (!ls_a25p)))","c_a25q","c_a25r","!c_a25r","(!c_a25r)","x_a25s","safebang@!x_a25s","(!x_a25s)","(!c_a25r) : (!x_a25s)","((!c_a25r) : (!x_a25s))","s_a25t","x_a25u","safebang@!x_a25u","(!x_a25u)","s_a2a2","[]","![]","(![])","c_a2a3","s_a2a4","c_a2a3 : s_a2a4","(c_a2a3 : s_a2a4)","!(c_a2a3 : s_a2a4)","(!(c_a2a3 : s_a2a4))","((!(c_a2a3 : s_a2a4)))","c_a2a5","x_a2a6","safebang@!x_a2a6","(!x_a2a6)","s_a2a7","0","i_a2jJ","!i_a2jJ","(!i_a2jJ)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Array
import Data.Char (isDigit)

idatabase :: [Char] -> Array Int Int
idatabase (!s_aIU) = listArray (0, n_aIW - 1) il_aIV
  where il_aIV = isource s_aIU
        n_aIW = length il_aIV

rdatabase :: [Char] -> Array Int Float
rdatabase (!s_a12Q) = listArray (0, n_a12S - 1) rl_a12R
  where (investigate@rl_a12R) = rsource s_a12Q
        (investigate@n_a12S) = length rl_a12R

isource :: [Char] -> [Int]
isource s_a12T = fst (irsource s_a12T)

rsource :: [Char] -> [Float]
rsource s_a136 = snd (irsource s_a136)
irsource s_a137 = intreal (words s_a137)
intreal (investigate@[]) = ([], [])
intreal ((!x_a16D) : ls_a16E)
  = if (elem '.' x_a16D) then
      (idb_a16F, (realreal x_a16D) : rdb_a16G) else
      ((intint x_a16D) : idb_a16F, rdb_a16G)
  where (idb_a16F, rdb_a16G) = intreal ls_a16E

intint :: [Char] -> Int
intint ((investigate@((investigate@c_a16H) : x_a16I)))
  = if (c_a16H == '-') then (-1) * (stoi x_a16I) else
      if (c_a16H == '+') then stoi x_a16I else stoi (c_a16H : x_a16I)

stoi :: [Char] -> Int
stoi (!s_a21S) = stoi' (reverse s_a21S)
stoi' [] = 0
stoi' (investigate@((!c_a25o) : (!ls_a25p)))
  = (stoi' ls_a25p) * 10 + ctoi c_a25o
ctoi c_a25q
  = if (c_a25q == '0') then 0 else
      if (c_a25q == '1') then 1 else
        if (c_a25q == '2') then 2 else
          if (c_a25q == '3') then 3 else
            if (c_a25q == '4') then 4 else
              if (c_a25q == '5') then 5 else
                if (c_a25q == '6') then 6 else
                  if (c_a25q == '7') then 7 else if (c_a25q == '8') then 8 else 9

realreal :: [Char] -> Float
realreal ((investigate@c_a25r) : (!x_a25s))
  = if (c_a25r == '-') then (-1.0) * (stor x_a25s) else
      if (c_a25r == '+') then stor x_a25s else stor (c_a25r : x_a25s)

stor :: [Char] -> Float
stor s_a25t = (intpart s_a25t) + (floatpart s_a25t)

intpart :: [Char] -> Float
intpart (!x_a25u) = intpart' (takeWhile isDigit x_a25u)

intpart' :: [Char] -> Float
intpart' s_a2a2 = intparts (reverse s_a2a2)
intparts (investigate@[]) = 0.0
intparts ((investigate@(c_a2a3 : s_a2a4)))
  = (intparts s_a2a4) * 10.0 + intpartss c_a2a3
intpartss c_a2a5
  = if (c_a2a5 == '0') then 0.0 else
      if (c_a2a5 == '1') then 1.0 else
        if (c_a2a5 == '2') then 2.0 else
          if (c_a2a5 == '3') then 3.0 else
            if (c_a2a5 == '4') then 4.0 else
              if (c_a2a5 == '5') then 5.0 else
                if (c_a2a5 == '6') then 6.0 else
                  if (c_a2a5 == '7') then 7.0 else
                    if (c_a2a5 == '8') then 8.0 else 9.0

floatpart :: [Char] -> Float
floatpart (!x_a2a6)
  = floatpart' (drop 1 (dropWhile isDigit x_a2a6))

floatpart' :: [Char] -> Float
floatpart' s_a2a7 = (intpart' s_a2a7) / (e10 (length s_a2a7))
e10 0 = 1.0
e10 (investigate@i_a2jJ) = 10.0 * (e10 (i_a2jJ - 1))
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.idatabase :: [Char] -> Array Int Int
Dum.idatabase (!s_aIU)
  = listArray (0, n_aIW - 1) il_aIV
  where
      il_aIV = Dum.isource s_aIU
      n_aIW = length il_aIV
Dum.rdatabase :: [Char] -> Array Int Float
Dum.rdatabase (!s_a12Q)
  = listArray (0, n_a12S - 1) rl_a12R
  where
      (!rl_a12R) = Dum.rsource s_a12Q
      (!n_a12S) = length rl_a12R
Dum.isource :: [Char] -> [Int]
Dum.isource s_a12T = fst (Dum.irsource s_a12T)
Dum.rsource :: [Char] -> [Float]
Dum.rsource s_a136 = snd (Dum.irsource s_a136)
Dum.irsource s_a137 = Dum.intreal (words s_a137)
Dum.intreal (![]) = ([], [])
Dum.intreal ((!x_a16D) : ls_a16E)
  = if (elem '.' x_a16D) then
        (idb_a16F, (Dum.realreal x_a16D) : rdb_a16G)
    else
        ((Dum.intint x_a16D) : idb_a16F, rdb_a16G)
  where
      (idb_a16F, rdb_a16G) = Dum.intreal ls_a16E
Dum.intint :: [Char] -> Int
Dum.intint ((!((!c_a16H) : x_a16I)))
  = if (c_a16H == '-') then
        (- 1) * (Dum.stoi x_a16I)
    else
        if (c_a16H == '+') then
            Dum.stoi x_a16I
        else
            Dum.stoi (c_a16H : x_a16I)
Dum.stoi :: [Char] -> Int
Dum.stoi (!s_a21S) = Dum.stoi' (reverse s_a21S)
Dum.stoi' [] = 0
Dum.stoi' (!((!c_a25o) : (!ls_a25p)))
  = (Dum.stoi' ls_a25p) * 10 + Dum.ctoi c_a25o
Dum.ctoi c_a25q
  = if (c_a25q == '0') then
        0
    else
        if (c_a25q == '1') then
            1
        else
            if (c_a25q == '2') then
                2
            else
                if (c_a25q == '3') then
                    3
                else
                    if (c_a25q == '4') then
                        4
                    else
                        if (c_a25q == '5') then
                            5
                        else
                            if (c_a25q == '6') then
                                6
                            else
                                if (c_a25q == '7') then 7 else if (c_a25q == '8') then 8 else 9
Dum.realreal :: [Char] -> Float
Dum.realreal ((!c_a25r) : (!x_a25s))
  = if (c_a25r == '-') then
        (- 1.0) * (Dum.stor x_a25s)
    else
        if (c_a25r == '+') then
            Dum.stor x_a25s
        else
            Dum.stor (c_a25r : x_a25s)
Dum.stor :: [Char] -> Float
Dum.stor s_a25t = (Dum.intpart s_a25t) + (Dum.floatpart s_a25t)
Dum.intpart :: [Char] -> Float
Dum.intpart (!x_a25u) = Dum.intpart' (takeWhile isDigit x_a25u)
Dum.intpart' :: [Char] -> Float
Dum.intpart' s_a2a2 = Dum.intparts (reverse s_a2a2)
Dum.intparts (![]) = 0.0
Dum.intparts ((!(c_a2a3 : s_a2a4)))
  = (Dum.intparts s_a2a4) * 10.0 + Dum.intpartss c_a2a3
Dum.intpartss c_a2a5
  = if (c_a2a5 == '0') then
        0.0
    else
        if (c_a2a5 == '1') then
            1.0
        else
            if (c_a2a5 == '2') then
                2.0
            else
                if (c_a2a5 == '3') then
                    3.0
                else
                    if (c_a2a5 == '4') then
                        4.0
                    else
                        if (c_a2a5 == '5') then
                            5.0
                        else
                            if (c_a2a5 == '6') then
                                6.0
                            else
                                if (c_a2a5 == '7') then
                                    7.0
                                else
                                    if (c_a2a5 == '8') then 8.0 else 9.0
Dum.floatpart :: [Char] -> Float
Dum.floatpart (!x_a2a6)
  = Dum.floatpart' (drop 1 (dropWhile isDigit x_a2a6))
Dum.floatpart' :: [Char] -> Float
Dum.floatpart' s_a2a7
  = (Dum.intpart' s_a2a7) / (Dum.e10 (length s_a2a7))
Dum.e10 0 = 1.0
Dum.e10 (!i_a2jJ) = 10.0 * (Dum.e10 (i_a2jJ - 1))


["s_aIU","safebang@!s_aIU","(!s_aIU)","il_aIV","n_aIW","s_a12Q","safebang@!s_a12Q","(!s_a12Q)","rl_a12R","!rl_a12R","(!rl_a12R)","n_a12S","!n_a12S","(!n_a12S)","s_a12T","s_a136","s_a137","[]","![]","(![])","x_a16D","safebang@!x_a16D","(!x_a16D)","ls_a16E","(!x_a16D) : ls_a16E","((!x_a16D) : ls_a16E)","idb_a16F","rdb_a16G","(idb_a16F, rdb_a16G)","c_a16H","!c_a16H","(!c_a16H)","x_a16I","(!c_a16H) : x_a16I","((!c_a16H) : x_a16I)","!((!c_a16H) : x_a16I)","(!((!c_a16H) : x_a16I))","((!((!c_a16H) : x_a16I)))","s_a21S","safebang@!s_a21S","(!s_a21S)","[]","c_a25o","safebang@!c_a25o","(!c_a25o)","ls_a25p","safebang@!ls_a25p","(!ls_a25p)","(!c_a25o) : (!ls_a25p)","((!c_a25o) : (!ls_a25p))","!((!c_a25o) : (!ls_a25p))","(!((!c_a25o) : (!ls_a25p)))","c_a25q","c_a25r","!c_a25r","(!c_a25r)","x_a25s","safebang@!x_a25s","(!x_a25s)","(!c_a25r) : (!x_a25s)","((!c_a25r) : (!x_a25s))","s_a25t","x_a25u","safebang@!x_a25u","(!x_a25u)","s_a2a2","[]","![]","(![])","c_a2a3","s_a2a4","c_a2a3 : s_a2a4","(c_a2a3 : s_a2a4)","!(c_a2a3 : s_a2a4)","(!(c_a2a3 : s_a2a4))","((!(c_a2a3 : s_a2a4)))","c_a2a5","x_a2a6","safebang@!x_a2a6","(!x_a2a6)","s_a2a7","0","i_a2jJ","!i_a2jJ","(!i_a2jJ)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Basics
import Vector
import DB_interface
import Displacement

idatabase :: [Char] -> Array Int Int
idatabase (!s_aIU) = listArray (0, n_aIW - 1) il_aIV
  where il_aIV = isource s_aIU
        n_aIW = length il_aIV

rdatabase :: [Char] -> Array Int Float
rdatabase (!s_a12Q) = listArray (0, n_a12S - 1) rl_a12R
  where (investigate@rl_a12R) = rsource s_a12Q
        (investigate@n_a12S) = length rl_a12R

isource :: [Char] -> [Int]
isource s_a12T = fst (irsource s_a12T)

rsource :: [Char] -> [Float]
rsource s_a136 = snd (irsource s_a136)
irsource s_a137 = intreal (words s_a137)
intreal (investigate@[]) = ([], [])
intreal ((!x_a16D) : ls_a16E)
  = if (elem '.' x_a16D) then
      (idb_a16F, (realreal x_a16D) : rdb_a16G) else
      ((intint x_a16D) : idb_a16F, rdb_a16G)
  where (idb_a16F, rdb_a16G) = intreal ls_a16E

intint :: [Char] -> Int
intint ((investigate@((investigate@c_a16H) : x_a16I)))
  = if (c_a16H == '-') then (-1) * (stoi x_a16I) else
      if (c_a16H == '+') then stoi x_a16I else stoi (c_a16H : x_a16I)

stoi :: [Char] -> Int
stoi (!s_a21S) = stoi' (reverse s_a21S)
stoi' [] = 0
stoi' (investigate@((!c_a25o) : (!ls_a25p)))
  = (stoi' ls_a25p) * 10 + ctoi c_a25o
ctoi c_a25q
  = if (c_a25q == '0') then 0 else
      if (c_a25q == '1') then 1 else
        if (c_a25q == '2') then 2 else
          if (c_a25q == '3') then 3 else
            if (c_a25q == '4') then 4 else
              if (c_a25q == '5') then 5 else
                if (c_a25q == '6') then 6 else
                  if (c_a25q == '7') then 7 else if (c_a25q == '8') then 8 else 9

realreal :: [Char] -> Float
realreal ((investigate@c_a25r) : (!x_a25s))
  = if (c_a25r == '-') then (-1.0) * (stor x_a25s) else
      if (c_a25r == '+') then stor x_a25s else stor (c_a25r : x_a25s)

stor :: [Char] -> Float
stor s_a25t = (intpart s_a25t) + (floatpart s_a25t)

intpart :: [Char] -> Float
intpart (!x_a25u) = intpart' (takeWhile isDigit x_a25u)

intpart' :: [Char] -> Float
intpart' s_a2a2 = intparts (reverse s_a2a2)
intparts (investigate@[]) = 0.0
intparts ((investigate@(c_a2a3 : s_a2a4)))
  = (intparts s_a2a4) * 10.0 + intpartss c_a2a3
intpartss c_a2a5
  = if (c_a2a5 == '0') then 0.0 else
      if (c_a2a5 == '1') then 1.0 else
        if (c_a2a5 == '2') then 2.0 else
          if (c_a2a5 == '3') then 3.0 else
            if (c_a2a5 == '4') then 4.0 else
              if (c_a2a5 == '5') then 5.0 else
                if (c_a2a5 == '6') then 6.0 else
                  if (c_a2a5 == '7') then 7.0 else
                    if (c_a2a5 == '8') then 8.0 else 9.0

floatpart :: [Char] -> Float
floatpart (!x_a2a6)
  = floatpart' (drop 1 (dropWhile isDigit x_a2a6))

floatpart' :: [Char] -> Float
floatpart' s_a2a7 = (intpart' s_a2a7) / (e10 (length s_a2a7))
e10 0 = 1.0
e10 (investigate@i_a2jJ) = 10.0 * (e10 (i_a2jJ - 1))
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.idatabase :: [Char] -> Array Int Int
Dum.idatabase (!s_aIU)
  = listArray (0, n_aIW - 1) il_aIV
  where
      il_aIV = Dum.isource s_aIU
      n_aIW = length il_aIV
Dum.rdatabase :: [Char] -> Array Int Float
Dum.rdatabase (!s_a12Q)
  = listArray (0, n_a12S - 1) rl_a12R
  where
      (!rl_a12R) = Dum.rsource s_a12Q
      (!n_a12S) = length rl_a12R
Dum.isource :: [Char] -> [Int]
Dum.isource s_a12T = fst (Dum.irsource s_a12T)
Dum.rsource :: [Char] -> [Float]
Dum.rsource s_a136 = snd (Dum.irsource s_a136)
Dum.irsource s_a137 = Dum.intreal (words s_a137)
Dum.intreal (![]) = ([], [])
Dum.intreal ((!x_a16D) : ls_a16E)
  = if (elem '.' x_a16D) then
        (idb_a16F, (Dum.realreal x_a16D) : rdb_a16G)
    else
        ((Dum.intint x_a16D) : idb_a16F, rdb_a16G)
  where
      (idb_a16F, rdb_a16G) = Dum.intreal ls_a16E
Dum.intint :: [Char] -> Int
Dum.intint ((!((!c_a16H) : x_a16I)))
  = if (c_a16H == '-') then
        (- 1) * (Dum.stoi x_a16I)
    else
        if (c_a16H == '+') then
            Dum.stoi x_a16I
        else
            Dum.stoi (c_a16H : x_a16I)
Dum.stoi :: [Char] -> Int
Dum.stoi (!s_a21S) = Dum.stoi' (reverse s_a21S)
Dum.stoi' [] = 0
Dum.stoi' (!((!c_a25o) : (!ls_a25p)))
  = (Dum.stoi' ls_a25p) * 10 + Dum.ctoi c_a25o
Dum.ctoi c_a25q
  = if (c_a25q == '0') then
        0
    else
        if (c_a25q == '1') then
            1
        else
            if (c_a25q == '2') then
                2
            else
                if (c_a25q == '3') then
                    3
                else
                    if (c_a25q == '4') then
                        4
                    else
                        if (c_a25q == '5') then
                            5
                        else
                            if (c_a25q == '6') then
                                6
                            else
                                if (c_a25q == '7') then 7 else if (c_a25q == '8') then 8 else 9
Dum.realreal :: [Char] -> Float
Dum.realreal ((!c_a25r) : (!x_a25s))
  = if (c_a25r == '-') then
        (- 1.0) * (Dum.stor x_a25s)
    else
        if (c_a25r == '+') then
            Dum.stor x_a25s
        else
            Dum.stor (c_a25r : x_a25s)
Dum.stor :: [Char] -> Float
Dum.stor s_a25t = (Dum.intpart s_a25t) + (Dum.floatpart s_a25t)
Dum.intpart :: [Char] -> Float
Dum.intpart (!x_a25u) = Dum.intpart' (takeWhile isDigit x_a25u)
Dum.intpart' :: [Char] -> Float
Dum.intpart' s_a2a2 = Dum.intparts (reverse s_a2a2)
Dum.intparts (![]) = 0.0
Dum.intparts ((!(c_a2a3 : s_a2a4)))
  = (Dum.intparts s_a2a4) * 10.0 + Dum.intpartss c_a2a3
Dum.intpartss c_a2a5
  = if (c_a2a5 == '0') then
        0.0
    else
        if (c_a2a5 == '1') then
            1.0
        else
            if (c_a2a5 == '2') then
                2.0
            else
                if (c_a2a5 == '3') then
                    3.0
                else
                    if (c_a2a5 == '4') then
                        4.0
                    else
                        if (c_a2a5 == '5') then
                            5.0
                        else
                            if (c_a2a5 == '6') then
                                6.0
                            else
                                if (c_a2a5 == '7') then
                                    7.0
                                else
                                    if (c_a2a5 == '8') then 8.0 else 9.0
Dum.floatpart :: [Char] -> Float
Dum.floatpart (!x_a2a6)
  = Dum.floatpart' (drop 1 (dropWhile isDigit x_a2a6))
Dum.floatpart' :: [Char] -> Float
Dum.floatpart' s_a2a7
  = (Dum.intpart' s_a2a7) / (Dum.e10 (length s_a2a7))
Dum.e10 0 = 1.0
Dum.e10 (!i_a2jJ) = 10.0 * (Dum.e10 (i_a2jJ - 1))


["s_aIU","safebang@!s_aIU","(!s_aIU)","il_aIV","n_aIW","s_a12Q","safebang@!s_a12Q","(!s_a12Q)","rl_a12R","!rl_a12R","(!rl_a12R)","n_a12S","!n_a12S","(!n_a12S)","s_a12T","s_a136","s_a137","[]","![]","(![])","x_a16D","safebang@!x_a16D","(!x_a16D)","ls_a16E","(!x_a16D) : ls_a16E","((!x_a16D) : ls_a16E)","idb_a16F","rdb_a16G","(idb_a16F, rdb_a16G)","c_a16H","!c_a16H","(!c_a16H)","x_a16I","(!c_a16H) : x_a16I","((!c_a16H) : x_a16I)","!((!c_a16H) : x_a16I)","(!((!c_a16H) : x_a16I))","((!((!c_a16H) : x_a16I)))","s_a21S","safebang@!s_a21S","(!s_a21S)","[]","c_a25o","safebang@!c_a25o","(!c_a25o)","ls_a25p","safebang@!ls_a25p","(!ls_a25p)","(!c_a25o) : (!ls_a25p)","((!c_a25o) : (!ls_a25p))","!((!c_a25o) : (!ls_a25p))","(!((!c_a25o) : (!ls_a25p)))","c_a25q","c_a25r","!c_a25r","(!c_a25r)","x_a25s","safebang@!x_a25s","(!x_a25s)","(!c_a25r) : (!x_a25s)","((!c_a25r) : (!x_a25s))","s_a25t","x_a25u","safebang@!x_a25u","(!x_a25u)","s_a2a2","[]","![]","(![])","c_a2a3","s_a2a4","c_a2a3 : s_a2a4","(c_a2a3 : s_a2a4)","!(c_a2a3 : s_a2a4)","(!(c_a2a3 : s_a2a4))","((!(c_a2a3 : s_a2a4)))","c_a2a5","x_a2a6","safebang@!x_a2a6","(!x_a2a6)","s_a2a7","0","i_a2jJ","!i_a2jJ","(!i_a2jJ)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Basics
import Vector
import DB_interface
import Displacement
import Elemforce

idatabase :: [Char] -> Array Int Int
idatabase (!s_aIU) = listArray (0, n_aIW - 1) il_aIV
  where il_aIV = isource s_aIU
        n_aIW = length il_aIV

rdatabase :: [Char] -> Array Int Float
rdatabase (!s_a12Q) = listArray (0, n_a12S - 1) rl_a12R
  where (investigate@rl_a12R) = rsource s_a12Q
        (investigate@n_a12S) = length rl_a12R

isource :: [Char] -> [Int]
isource s_a12T = fst (irsource s_a12T)

rsource :: [Char] -> [Float]
rsource s_a136 = snd (irsource s_a136)
irsource s_a137 = intreal (words s_a137)
intreal (investigate@[]) = ([], [])
intreal ((!x_a16D) : ls_a16E)
  = if (elem '.' x_a16D) then
      (idb_a16F, (realreal x_a16D) : rdb_a16G) else
      ((intint x_a16D) : idb_a16F, rdb_a16G)
  where (idb_a16F, rdb_a16G) = intreal ls_a16E

intint :: [Char] -> Int
intint ((investigate@((investigate@c_a16H) : x_a16I)))
  = if (c_a16H == '-') then (-1) * (stoi x_a16I) else
      if (c_a16H == '+') then stoi x_a16I else stoi (c_a16H : x_a16I)

stoi :: [Char] -> Int
stoi (!s_a21S) = stoi' (reverse s_a21S)
stoi' [] = 0
stoi' (investigate@((!c_a25o) : (!ls_a25p)))
  = (stoi' ls_a25p) * 10 + ctoi c_a25o
ctoi c_a25q
  = if (c_a25q == '0') then 0 else
      if (c_a25q == '1') then 1 else
        if (c_a25q == '2') then 2 else
          if (c_a25q == '3') then 3 else
            if (c_a25q == '4') then 4 else
              if (c_a25q == '5') then 5 else
                if (c_a25q == '6') then 6 else
                  if (c_a25q == '7') then 7 else if (c_a25q == '8') then 8 else 9

realreal :: [Char] -> Float
realreal ((investigate@c_a25r) : (!x_a25s))
  = if (c_a25r == '-') then (-1.0) * (stor x_a25s) else
      if (c_a25r == '+') then stor x_a25s else stor (c_a25r : x_a25s)

stor :: [Char] -> Float
stor s_a25t = (intpart s_a25t) + (floatpart s_a25t)

intpart :: [Char] -> Float
intpart (!x_a25u) = intpart' (takeWhile isDigit x_a25u)

intpart' :: [Char] -> Float
intpart' s_a2a2 = intparts (reverse s_a2a2)
intparts (investigate@[]) = 0.0
intparts ((investigate@(c_a2a3 : s_a2a4)))
  = (intparts s_a2a4) * 10.0 + intpartss c_a2a3
intpartss c_a2a5
  = if (c_a2a5 == '0') then 0.0 else
      if (c_a2a5 == '1') then 1.0 else
        if (c_a2a5 == '2') then 2.0 else
          if (c_a2a5 == '3') then 3.0 else
            if (c_a2a5 == '4') then 4.0 else
              if (c_a2a5 == '5') then 5.0 else
                if (c_a2a5 == '6') then 6.0 else
                  if (c_a2a5 == '7') then 7.0 else
                    if (c_a2a5 == '8') then 8.0 else 9.0

floatpart :: [Char] -> Float
floatpart (!x_a2a6)
  = floatpart' (drop 1 (dropWhile isDigit x_a2a6))

floatpart' :: [Char] -> Float
floatpart' s_a2a7 = (intpart' s_a2a7) / (e10 (length s_a2a7))
e10 0 = 1.0
e10 (investigate@i_a2jJ) = 10.0 * (e10 (i_a2jJ - 1))
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.idatabase :: [Char] -> Array Int Int
Dum.idatabase (!s_aIU)
  = listArray (0, n_aIW - 1) il_aIV
  where
      il_aIV = Dum.isource s_aIU
      n_aIW = length il_aIV
Dum.rdatabase :: [Char] -> Array Int Float
Dum.rdatabase (!s_a12Q)
  = listArray (0, n_a12S - 1) rl_a12R
  where
      (!rl_a12R) = Dum.rsource s_a12Q
      (!n_a12S) = length rl_a12R
Dum.isource :: [Char] -> [Int]
Dum.isource s_a12T = fst (Dum.irsource s_a12T)
Dum.rsource :: [Char] -> [Float]
Dum.rsource s_a136 = snd (Dum.irsource s_a136)
Dum.irsource s_a137 = Dum.intreal (words s_a137)
Dum.intreal (![]) = ([], [])
Dum.intreal ((!x_a16D) : ls_a16E)
  = if (elem '.' x_a16D) then
        (idb_a16F, (Dum.realreal x_a16D) : rdb_a16G)
    else
        ((Dum.intint x_a16D) : idb_a16F, rdb_a16G)
  where
      (idb_a16F, rdb_a16G) = Dum.intreal ls_a16E
Dum.intint :: [Char] -> Int
Dum.intint ((!((!c_a16H) : x_a16I)))
  = if (c_a16H == '-') then
        (- 1) * (Dum.stoi x_a16I)
    else
        if (c_a16H == '+') then
            Dum.stoi x_a16I
        else
            Dum.stoi (c_a16H : x_a16I)
Dum.stoi :: [Char] -> Int
Dum.stoi (!s_a21S) = Dum.stoi' (reverse s_a21S)
Dum.stoi' [] = 0
Dum.stoi' (!((!c_a25o) : (!ls_a25p)))
  = (Dum.stoi' ls_a25p) * 10 + Dum.ctoi c_a25o
Dum.ctoi c_a25q
  = if (c_a25q == '0') then
        0
    else
        if (c_a25q == '1') then
            1
        else
            if (c_a25q == '2') then
                2
            else
                if (c_a25q == '3') then
                    3
                else
                    if (c_a25q == '4') then
                        4
                    else
                        if (c_a25q == '5') then
                            5
                        else
                            if (c_a25q == '6') then
                                6
                            else
                                if (c_a25q == '7') then 7 else if (c_a25q == '8') then 8 else 9
Dum.realreal :: [Char] -> Float
Dum.realreal ((!c_a25r) : (!x_a25s))
  = if (c_a25r == '-') then
        (- 1.0) * (Dum.stor x_a25s)
    else
        if (c_a25r == '+') then
            Dum.stor x_a25s
        else
            Dum.stor (c_a25r : x_a25s)
Dum.stor :: [Char] -> Float
Dum.stor s_a25t = (Dum.intpart s_a25t) + (Dum.floatpart s_a25t)
Dum.intpart :: [Char] -> Float
Dum.intpart (!x_a25u) = Dum.intpart' (takeWhile isDigit x_a25u)
Dum.intpart' :: [Char] -> Float
Dum.intpart' s_a2a2 = Dum.intparts (reverse s_a2a2)
Dum.intparts (![]) = 0.0
Dum.intparts ((!(c_a2a3 : s_a2a4)))
  = (Dum.intparts s_a2a4) * 10.0 + Dum.intpartss c_a2a3
Dum.intpartss c_a2a5
  = if (c_a2a5 == '0') then
        0.0
    else
        if (c_a2a5 == '1') then
            1.0
        else
            if (c_a2a5 == '2') then
                2.0
            else
                if (c_a2a5 == '3') then
                    3.0
                else
                    if (c_a2a5 == '4') then
                        4.0
                    else
                        if (c_a2a5 == '5') then
                            5.0
                        else
                            if (c_a2a5 == '6') then
                                6.0
                            else
                                if (c_a2a5 == '7') then
                                    7.0
                                else
                                    if (c_a2a5 == '8') then 8.0 else 9.0
Dum.floatpart :: [Char] -> Float
Dum.floatpart (!x_a2a6)
  = Dum.floatpart' (drop 1 (dropWhile isDigit x_a2a6))
Dum.floatpart' :: [Char] -> Float
Dum.floatpart' s_a2a7
  = (Dum.intpart' s_a2a7) / (Dum.e10 (length s_a2a7))
Dum.e10 0 = 1.0
Dum.e10 (!i_a2jJ) = 10.0 * (Dum.e10 (i_a2jJ - 1))


["s_aIU","safebang@!s_aIU","(!s_aIU)","il_aIV","n_aIW","s_a12Q","safebang@!s_a12Q","(!s_a12Q)","rl_a12R","!rl_a12R","(!rl_a12R)","n_a12S","!n_a12S","(!n_a12S)","s_a12T","s_a136","s_a137","[]","![]","(![])","x_a16D","safebang@!x_a16D","(!x_a16D)","ls_a16E","(!x_a16D) : ls_a16E","((!x_a16D) : ls_a16E)","idb_a16F","rdb_a16G","(idb_a16F, rdb_a16G)","c_a16H","!c_a16H","(!c_a16H)","x_a16I","(!c_a16H) : x_a16I","((!c_a16H) : x_a16I)","!((!c_a16H) : x_a16I)","(!((!c_a16H) : x_a16I))","((!((!c_a16H) : x_a16I)))","s_a21S","safebang@!s_a21S","(!s_a21S)","[]","c_a25o","safebang@!c_a25o","(!c_a25o)","ls_a25p","safebang@!ls_a25p","(!ls_a25p)","(!c_a25o) : (!ls_a25p)","((!c_a25o) : (!ls_a25p))","!((!c_a25o) : (!ls_a25p))","(!((!c_a25o) : (!ls_a25p)))","c_a25q","c_a25r","!c_a25r","(!c_a25r)","x_a25s","safebang@!x_a25s","(!x_a25s)","(!c_a25r) : (!x_a25s)","((!c_a25r) : (!x_a25s))","s_a25t","x_a25u","safebang@!x_a25u","(!x_a25u)","s_a2a2","[]","![]","(![])","c_a2a3","s_a2a4","c_a2a3 : s_a2a4","(c_a2a3 : s_a2a4)","!(c_a2a3 : s_a2a4)","(!(c_a2a3 : s_a2a4))","((!(c_a2a3 : s_a2a4)))","c_a2a5","x_a2a6","safebang@!x_a2a6","(!x_a2a6)","s_a2a7","0","i_a2jJ","!i_a2jJ","(!i_a2jJ)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Array
import Basics

idatabase :: [Char] -> Array Int Int
idatabase (!s_aIU) = listArray (0, n_aIW - 1) il_aIV
  where il_aIV = isource s_aIU
        n_aIW = length il_aIV

rdatabase :: [Char] -> Array Int Float
rdatabase (!s_a12Q) = listArray (0, n_a12S - 1) rl_a12R
  where (investigate@rl_a12R) = rsource s_a12Q
        (investigate@n_a12S) = length rl_a12R

isource :: [Char] -> [Int]
isource s_a12T = fst (irsource s_a12T)

rsource :: [Char] -> [Float]
rsource s_a136 = snd (irsource s_a136)
irsource s_a137 = intreal (words s_a137)
intreal (investigate@[]) = ([], [])
intreal ((!x_a16D) : ls_a16E)
  = if (elem '.' x_a16D) then
      (idb_a16F, (realreal x_a16D) : rdb_a16G) else
      ((intint x_a16D) : idb_a16F, rdb_a16G)
  where (idb_a16F, rdb_a16G) = intreal ls_a16E

intint :: [Char] -> Int
intint ((investigate@((investigate@c_a16H) : x_a16I)))
  = if (c_a16H == '-') then (-1) * (stoi x_a16I) else
      if (c_a16H == '+') then stoi x_a16I else stoi (c_a16H : x_a16I)

stoi :: [Char] -> Int
stoi (!s_a21S) = stoi' (reverse s_a21S)
stoi' [] = 0
stoi' (investigate@((!c_a25o) : (!ls_a25p)))
  = (stoi' ls_a25p) * 10 + ctoi c_a25o
ctoi c_a25q
  = if (c_a25q == '0') then 0 else
      if (c_a25q == '1') then 1 else
        if (c_a25q == '2') then 2 else
          if (c_a25q == '3') then 3 else
            if (c_a25q == '4') then 4 else
              if (c_a25q == '5') then 5 else
                if (c_a25q == '6') then 6 else
                  if (c_a25q == '7') then 7 else if (c_a25q == '8') then 8 else 9

realreal :: [Char] -> Float
realreal ((investigate@c_a25r) : (!x_a25s))
  = if (c_a25r == '-') then (-1.0) * (stor x_a25s) else
      if (c_a25r == '+') then stor x_a25s else stor (c_a25r : x_a25s)

stor :: [Char] -> Float
stor s_a25t = (intpart s_a25t) + (floatpart s_a25t)

intpart :: [Char] -> Float
intpart (!x_a25u) = intpart' (takeWhile isDigit x_a25u)

intpart' :: [Char] -> Float
intpart' s_a2a2 = intparts (reverse s_a2a2)
intparts (investigate@[]) = 0.0
intparts ((investigate@(c_a2a3 : s_a2a4)))
  = (intparts s_a2a4) * 10.0 + intpartss c_a2a3
intpartss c_a2a5
  = if (c_a2a5 == '0') then 0.0 else
      if (c_a2a5 == '1') then 1.0 else
        if (c_a2a5 == '2') then 2.0 else
          if (c_a2a5 == '3') then 3.0 else
            if (c_a2a5 == '4') then 4.0 else
              if (c_a2a5 == '5') then 5.0 else
                if (c_a2a5 == '6') then 6.0 else
                  if (c_a2a5 == '7') then 7.0 else
                    if (c_a2a5 == '8') then 8.0 else 9.0

floatpart :: [Char] -> Float
floatpart (!x_a2a6)
  = floatpart' (drop 1 (dropWhile isDigit x_a2a6))

floatpart' :: [Char] -> Float
floatpart' s_a2a7 = (intpart' s_a2a7) / (e10 (length s_a2a7))
e10 0 = 1.0
e10 (investigate@i_a2jJ) = 10.0 * (e10 (i_a2jJ - 1))
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.idatabase :: [Char] -> Array Int Int
Dum.idatabase (!s_aIU)
  = listArray (0, n_aIW - 1) il_aIV
  where
      il_aIV = Dum.isource s_aIU
      n_aIW = length il_aIV
Dum.rdatabase :: [Char] -> Array Int Float
Dum.rdatabase (!s_a12Q)
  = listArray (0, n_a12S - 1) rl_a12R
  where
      (!rl_a12R) = Dum.rsource s_a12Q
      (!n_a12S) = length rl_a12R
Dum.isource :: [Char] -> [Int]
Dum.isource s_a12T = fst (Dum.irsource s_a12T)
Dum.rsource :: [Char] -> [Float]
Dum.rsource s_a136 = snd (Dum.irsource s_a136)
Dum.irsource s_a137 = Dum.intreal (words s_a137)
Dum.intreal (![]) = ([], [])
Dum.intreal ((!x_a16D) : ls_a16E)
  = if (elem '.' x_a16D) then
        (idb_a16F, (Dum.realreal x_a16D) : rdb_a16G)
    else
        ((Dum.intint x_a16D) : idb_a16F, rdb_a16G)
  where
      (idb_a16F, rdb_a16G) = Dum.intreal ls_a16E
Dum.intint :: [Char] -> Int
Dum.intint ((!((!c_a16H) : x_a16I)))
  = if (c_a16H == '-') then
        (- 1) * (Dum.stoi x_a16I)
    else
        if (c_a16H == '+') then
            Dum.stoi x_a16I
        else
            Dum.stoi (c_a16H : x_a16I)
Dum.stoi :: [Char] -> Int
Dum.stoi (!s_a21S) = Dum.stoi' (reverse s_a21S)
Dum.stoi' [] = 0
Dum.stoi' (!((!c_a25o) : (!ls_a25p)))
  = (Dum.stoi' ls_a25p) * 10 + Dum.ctoi c_a25o
Dum.ctoi c_a25q
  = if (c_a25q == '0') then
        0
    else
        if (c_a25q == '1') then
            1
        else
            if (c_a25q == '2') then
                2
            else
                if (c_a25q == '3') then
                    3
                else
                    if (c_a25q == '4') then
                        4
                    else
                        if (c_a25q == '5') then
                            5
                        else
                            if (c_a25q == '6') then
                                6
                            else
                                if (c_a25q == '7') then 7 else if (c_a25q == '8') then 8 else 9
Dum.realreal :: [Char] -> Float
Dum.realreal ((!c_a25r) : (!x_a25s))
  = if (c_a25r == '-') then
        (- 1.0) * (Dum.stor x_a25s)
    else
        if (c_a25r == '+') then
            Dum.stor x_a25s
        else
            Dum.stor (c_a25r : x_a25s)
Dum.stor :: [Char] -> Float
Dum.stor s_a25t = (Dum.intpart s_a25t) + (Dum.floatpart s_a25t)
Dum.intpart :: [Char] -> Float
Dum.intpart (!x_a25u) = Dum.intpart' (takeWhile isDigit x_a25u)
Dum.intpart' :: [Char] -> Float
Dum.intpart' s_a2a2 = Dum.intparts (reverse s_a2a2)
Dum.intparts (![]) = 0.0
Dum.intparts ((!(c_a2a3 : s_a2a4)))
  = (Dum.intparts s_a2a4) * 10.0 + Dum.intpartss c_a2a3
Dum.intpartss c_a2a5
  = if (c_a2a5 == '0') then
        0.0
    else
        if (c_a2a5 == '1') then
            1.0
        else
            if (c_a2a5 == '2') then
                2.0
            else
                if (c_a2a5 == '3') then
                    3.0
                else
                    if (c_a2a5 == '4') then
                        4.0
                    else
                        if (c_a2a5 == '5') then
                            5.0
                        else
                            if (c_a2a5 == '6') then
                                6.0
                            else
                                if (c_a2a5 == '7') then
                                    7.0
                                else
                                    if (c_a2a5 == '8') then 8.0 else 9.0
Dum.floatpart :: [Char] -> Float
Dum.floatpart (!x_a2a6)
  = Dum.floatpart' (drop 1 (dropWhile isDigit x_a2a6))
Dum.floatpart' :: [Char] -> Float
Dum.floatpart' s_a2a7
  = (Dum.intpart' s_a2a7) / (Dum.e10 (length s_a2a7))
Dum.e10 0 = 1.0
Dum.e10 (!i_a2jJ) = 10.0 * (Dum.e10 (i_a2jJ - 1))


["s_aIU","safebang@!s_aIU","(!s_aIU)","il_aIV","n_aIW","s_a12Q","safebang@!s_a12Q","(!s_a12Q)","rl_a12R","!rl_a12R","(!rl_a12R)","n_a12S","!n_a12S","(!n_a12S)","s_a12T","s_a136","s_a137","[]","![]","(![])","x_a16D","safebang@!x_a16D","(!x_a16D)","ls_a16E","(!x_a16D) : ls_a16E","((!x_a16D) : ls_a16E)","idb_a16F","rdb_a16G","(idb_a16F, rdb_a16G)","c_a16H","!c_a16H","(!c_a16H)","x_a16I","(!c_a16H) : x_a16I","((!c_a16H) : x_a16I)","!((!c_a16H) : x_a16I)","(!((!c_a16H) : x_a16I))","((!((!c_a16H) : x_a16I)))","s_a21S","safebang@!s_a21S","(!s_a21S)","[]","c_a25o","safebang@!c_a25o","(!c_a25o)","ls_a25p","safebang@!ls_a25p","(!ls_a25p)","(!c_a25o) : (!ls_a25p)","((!c_a25o) : (!ls_a25p))","!((!c_a25o) : (!ls_a25p))","(!((!c_a25o) : (!ls_a25p)))","c_a25q","c_a25r","!c_a25r","(!c_a25r)","x_a25s","safebang@!x_a25s","(!x_a25s)","(!c_a25r) : (!x_a25s)","((!c_a25r) : (!x_a25s))","s_a25t","x_a25u","safebang@!x_a25u","(!x_a25u)","s_a2a2","[]","![]","(![])","c_a2a3","s_a2a4","c_a2a3 : s_a2a4","(c_a2a3 : s_a2a4)","!(c_a2a3 : s_a2a4)","(!(c_a2a3 : s_a2a4))","((!(c_a2a3 : s_a2a4)))","c_a2a5","x_a2a6","safebang@!x_a2a6","(!x_a2a6)","s_a2a7","0","i_a2jJ","!i_a2jJ","(!i_a2jJ)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Basics
import Vector
import DB_interface
import Degrees

idatabase :: [Char] -> Array Int Int
idatabase (!s_aIU) = listArray (0, n_aIW - 1) il_aIV
  where il_aIV = isource s_aIU
        n_aIW = length il_aIV

rdatabase :: [Char] -> Array Int Float
rdatabase (!s_a12Q) = listArray (0, n_a12S - 1) rl_a12R
  where (investigate@rl_a12R) = rsource s_a12Q
        (investigate@n_a12S) = length rl_a12R

isource :: [Char] -> [Int]
isource s_a12T = fst (irsource s_a12T)

rsource :: [Char] -> [Float]
rsource s_a136 = snd (irsource s_a136)
irsource s_a137 = intreal (words s_a137)
intreal (investigate@[]) = ([], [])
intreal ((!x_a16D) : ls_a16E)
  = if (elem '.' x_a16D) then
      (idb_a16F, (realreal x_a16D) : rdb_a16G) else
      ((intint x_a16D) : idb_a16F, rdb_a16G)
  where (idb_a16F, rdb_a16G) = intreal ls_a16E

intint :: [Char] -> Int
intint ((investigate@((investigate@c_a16H) : x_a16I)))
  = if (c_a16H == '-') then (-1) * (stoi x_a16I) else
      if (c_a16H == '+') then stoi x_a16I else stoi (c_a16H : x_a16I)

stoi :: [Char] -> Int
stoi (!s_a21S) = stoi' (reverse s_a21S)
stoi' [] = 0
stoi' (investigate@((!c_a25o) : (!ls_a25p)))
  = (stoi' ls_a25p) * 10 + ctoi c_a25o
ctoi c_a25q
  = if (c_a25q == '0') then 0 else
      if (c_a25q == '1') then 1 else
        if (c_a25q == '2') then 2 else
          if (c_a25q == '3') then 3 else
            if (c_a25q == '4') then 4 else
              if (c_a25q == '5') then 5 else
                if (c_a25q == '6') then 6 else
                  if (c_a25q == '7') then 7 else if (c_a25q == '8') then 8 else 9

realreal :: [Char] -> Float
realreal ((investigate@c_a25r) : (!x_a25s))
  = if (c_a25r == '-') then (-1.0) * (stor x_a25s) else
      if (c_a25r == '+') then stor x_a25s else stor (c_a25r : x_a25s)

stor :: [Char] -> Float
stor s_a25t = (intpart s_a25t) + (floatpart s_a25t)

intpart :: [Char] -> Float
intpart (!x_a25u) = intpart' (takeWhile isDigit x_a25u)

intpart' :: [Char] -> Float
intpart' s_a2a2 = intparts (reverse s_a2a2)
intparts (investigate@[]) = 0.0
intparts ((investigate@(c_a2a3 : s_a2a4)))
  = (intparts s_a2a4) * 10.0 + intpartss c_a2a3
intpartss c_a2a5
  = if (c_a2a5 == '0') then 0.0 else
      if (c_a2a5 == '1') then 1.0 else
        if (c_a2a5 == '2') then 2.0 else
          if (c_a2a5 == '3') then 3.0 else
            if (c_a2a5 == '4') then 4.0 else
              if (c_a2a5 == '5') then 5.0 else
                if (c_a2a5 == '6') then 6.0 else
                  if (c_a2a5 == '7') then 7.0 else
                    if (c_a2a5 == '8') then 8.0 else 9.0

floatpart :: [Char] -> Float
floatpart (!x_a2a6)
  = floatpart' (drop 1 (dropWhile isDigit x_a2a6))

floatpart' :: [Char] -> Float
floatpart' s_a2a7 = (intpart' s_a2a7) / (e10 (length s_a2a7))
e10 0 = 1.0
e10 (investigate@i_a2jJ) = 10.0 * (e10 (i_a2jJ - 1))
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showlj, Dum.showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]
Dum.rep :: Int -> a_arH -> [a_arH]
Dum.rep (!0) x_aIV = []
Dum.rep n_aIW (!x_aIX) = x_aIX : (Dum.rep (n_aIW - 1) x_aIX)
Dum.showrj (!l_aKa) (!x_aKb)
  = (Dum.rep bs_aKd ' ') ++ ns_aKc
  where
      ns_aKc = dropWhile ((==) ' ') (show x_aKb)
      bs_aKd
        | l_aKa <= length ns_aKc = 1
        | otherwise = l_aKa - length ns_aKc
Dum.showlj l_a22r (!x_a22s)
  = ns_a22t ++ (Dum.rep bs_a22u ' ')
  where
      (!ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
      bs_a22u
        | l_a22r <= length ns_a22t = 1
        | otherwise = l_a22r - length ns_a22t
Dum.azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
Dum.azip [] [] = []
Dum.azip (!(x_a22v : ls_a22w)) (!(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (Dum.azip ls_a22w ls'_a22y)


["0","!0","(!0)","x_aIV","n_aIW","x_aIX","!x_aIX","(!x_aIX)","l_aKa","!l_aKa","(!l_aKa)","x_aKb","safebang@!x_aKb","(!x_aKb)","ns_aKc","bs_aKd","l_a22r","x_a22s","safebang@!x_a22s","(!x_a22s)","ns_a22t","!ns_a22t","(!ns_a22t)","bs_a22u","[]","[]","x_a22v","ls_a22w","x_a22v : ls_a22w","(x_a22v : ls_a22w)","!(x_a22v : ls_a22w)","(!(x_a22v : ls_a22w))","x'_a22x","ls'_a22y","safebang@!ls'_a22y","(!ls'_a22y)","x'_a22x : (!ls'_a22y)","(x'_a22x : (!ls'_a22y))","!(x'_a22x : (!ls'_a22y))","(!(x'_a22x : (!ls'_a22y)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Array

showlj, showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]

rep :: Int -> a_arH -> [a_arH]
rep (investigate@0) x_aIV = []
rep n_aIW (investigate@x_aIX) = x_aIX : (rep (n_aIW - 1) x_aIX)
showrj (investigate@l_aKa) (!x_aKb) = (rep bs_aKd ' ') ++ ns_aKc
  where ns_aKc = dropWhile ((==) ' ') (show x_aKb)
        bs_aKd
          | l_aKa <= length ns_aKc = 1
          | otherwise = l_aKa - length ns_aKc
showlj l_a22r (!x_a22s) = ns_a22t ++ (rep bs_a22u ' ')
  where (investigate@ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
        bs_a22u
          | l_a22r <= length ns_a22t = 1
          | otherwise = l_a22r - length ns_a22t

azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
azip [] [] = []
azip (investigate@(x_a22v : ls_a22w))
  (investigate@(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (azip ls_a22w ls'_a22y)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showlj, Dum.showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]
Dum.rep :: Int -> a_arH -> [a_arH]
Dum.rep (!0) x_aIV = []
Dum.rep n_aIW (!x_aIX) = x_aIX : (Dum.rep (n_aIW - 1) x_aIX)
Dum.showrj (!l_aKa) (!x_aKb)
  = (Dum.rep bs_aKd ' ') ++ ns_aKc
  where
      ns_aKc = dropWhile ((==) ' ') (show x_aKb)
      bs_aKd
        | l_aKa <= length ns_aKc = 1
        | otherwise = l_aKa - length ns_aKc
Dum.showlj l_a22r (!x_a22s)
  = ns_a22t ++ (Dum.rep bs_a22u ' ')
  where
      (!ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
      bs_a22u
        | l_a22r <= length ns_a22t = 1
        | otherwise = l_a22r - length ns_a22t
Dum.azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
Dum.azip [] [] = []
Dum.azip (!(x_a22v : ls_a22w)) (!(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (Dum.azip ls_a22w ls'_a22y)


["0","!0","(!0)","x_aIV","n_aIW","x_aIX","!x_aIX","(!x_aIX)","l_aKa","!l_aKa","(!l_aKa)","x_aKb","safebang@!x_aKb","(!x_aKb)","ns_aKc","bs_aKd","l_a22r","x_a22s","safebang@!x_a22s","(!x_a22s)","ns_a22t","!ns_a22t","(!ns_a22t)","bs_a22u","[]","[]","x_a22v","ls_a22w","x_a22v : ls_a22w","(x_a22v : ls_a22w)","!(x_a22v : ls_a22w)","(!(x_a22v : ls_a22w))","x'_a22x","ls'_a22y","safebang@!ls'_a22y","(!ls'_a22y)","x'_a22x : (!ls'_a22y)","(x'_a22x : (!ls'_a22y))","!(x'_a22x : (!ls'_a22y))","(!(x'_a22x : (!ls'_a22y)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Basics
import Vector
import Matrix
import VBmatrix
import VBlldecomp
import DB_interface
import Degrees
import Pre_assemble
import Assemble_stiffness
import Assemble_loadvec

showlj, showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]

rep :: Int -> a_arH -> [a_arH]
rep (investigate@0) x_aIV = []
rep n_aIW (investigate@x_aIX) = x_aIX : (rep (n_aIW - 1) x_aIX)
showrj (investigate@l_aKa) (!x_aKb) = (rep bs_aKd ' ') ++ ns_aKc
  where ns_aKc = dropWhile ((==) ' ') (show x_aKb)
        bs_aKd
          | l_aKa <= length ns_aKc = 1
          | otherwise = l_aKa - length ns_aKc
showlj l_a22r (!x_a22s) = ns_a22t ++ (rep bs_a22u ' ')
  where (investigate@ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
        bs_a22u
          | l_a22r <= length ns_a22t = 1
          | otherwise = l_a22r - length ns_a22t

azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
azip [] [] = []
azip (investigate@(x_a22v : ls_a22w))
  (investigate@(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (azip ls_a22w ls'_a22y)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showlj, Dum.showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]
Dum.rep :: Int -> a_arH -> [a_arH]
Dum.rep (!0) x_aIV = []
Dum.rep n_aIW (!x_aIX) = x_aIX : (Dum.rep (n_aIW - 1) x_aIX)
Dum.showrj (!l_aKa) (!x_aKb)
  = (Dum.rep bs_aKd ' ') ++ ns_aKc
  where
      ns_aKc = dropWhile ((==) ' ') (show x_aKb)
      bs_aKd
        | l_aKa <= length ns_aKc = 1
        | otherwise = l_aKa - length ns_aKc
Dum.showlj l_a22r (!x_a22s)
  = ns_a22t ++ (Dum.rep bs_a22u ' ')
  where
      (!ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
      bs_a22u
        | l_a22r <= length ns_a22t = 1
        | otherwise = l_a22r - length ns_a22t
Dum.azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
Dum.azip [] [] = []
Dum.azip (!(x_a22v : ls_a22w)) (!(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (Dum.azip ls_a22w ls'_a22y)


["0","!0","(!0)","x_aIV","n_aIW","x_aIX","!x_aIX","(!x_aIX)","l_aKa","!l_aKa","(!l_aKa)","x_aKb","safebang@!x_aKb","(!x_aKb)","ns_aKc","bs_aKd","l_a22r","x_a22s","safebang@!x_a22s","(!x_a22s)","ns_a22t","!ns_a22t","(!ns_a22t)","bs_a22u","[]","[]","x_a22v","ls_a22w","x_a22v : ls_a22w","(x_a22v : ls_a22w)","!(x_a22v : ls_a22w)","(!(x_a22v : ls_a22w))","x'_a22x","ls'_a22y","safebang@!ls'_a22y","(!ls'_a22y)","x'_a22x : (!ls'_a22y)","(x'_a22x : (!ls'_a22y))","!(x'_a22x : (!ls'_a22y))","(!(x'_a22x : (!ls'_a22y)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Array
import Basics
import Vector
import DB_interface

showlj, showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]

rep :: Int -> a_arH -> [a_arH]
rep (investigate@0) x_aIV = []
rep n_aIW (investigate@x_aIX) = x_aIX : (rep (n_aIW - 1) x_aIX)
showrj (investigate@l_aKa) (!x_aKb) = (rep bs_aKd ' ') ++ ns_aKc
  where ns_aKc = dropWhile ((==) ' ') (show x_aKb)
        bs_aKd
          | l_aKa <= length ns_aKc = 1
          | otherwise = l_aKa - length ns_aKc
showlj l_a22r (!x_a22s) = ns_a22t ++ (rep bs_a22u ' ')
  where (investigate@ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
        bs_a22u
          | l_a22r <= length ns_a22t = 1
          | otherwise = l_a22r - length ns_a22t

azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
azip [] [] = []
azip (investigate@(x_a22v : ls_a22w))
  (investigate@(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (azip ls_a22w ls'_a22y)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showlj, Dum.showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]
Dum.rep :: Int -> a_arH -> [a_arH]
Dum.rep (!0) x_aIV = []
Dum.rep n_aIW (!x_aIX) = x_aIX : (Dum.rep (n_aIW - 1) x_aIX)
Dum.showrj (!l_aKa) (!x_aKb)
  = (Dum.rep bs_aKd ' ') ++ ns_aKc
  where
      ns_aKc = dropWhile ((==) ' ') (show x_aKb)
      bs_aKd
        | l_aKa <= length ns_aKc = 1
        | otherwise = l_aKa - length ns_aKc
Dum.showlj l_a22r (!x_a22s)
  = ns_a22t ++ (Dum.rep bs_a22u ' ')
  where
      (!ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
      bs_a22u
        | l_a22r <= length ns_a22t = 1
        | otherwise = l_a22r - length ns_a22t
Dum.azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
Dum.azip [] [] = []
Dum.azip (!(x_a22v : ls_a22w)) (!(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (Dum.azip ls_a22w ls'_a22y)


["0","!0","(!0)","x_aIV","n_aIW","x_aIX","!x_aIX","(!x_aIX)","l_aKa","!l_aKa","(!l_aKa)","x_aKb","safebang@!x_aKb","(!x_aKb)","ns_aKc","bs_aKd","l_a22r","x_a22s","safebang@!x_a22s","(!x_a22s)","ns_a22t","!ns_a22t","(!ns_a22t)","bs_a22u","[]","[]","x_a22v","ls_a22w","x_a22v : ls_a22w","(x_a22v : ls_a22w)","!(x_a22v : ls_a22w)","(!(x_a22v : ls_a22w))","x'_a22x","ls'_a22y","safebang@!ls'_a22y","(!ls'_a22y)","x'_a22x : (!ls'_a22y)","(x'_a22x : (!ls'_a22y))","!(x'_a22x : (!ls'_a22y))","(!(x'_a22x : (!ls'_a22y)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Basics
import Vector
import Matrix
import DB_interface

showlj, showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]

rep :: Int -> a_arH -> [a_arH]
rep (investigate@0) x_aIV = []
rep n_aIW (investigate@x_aIX) = x_aIX : (rep (n_aIW - 1) x_aIX)
showrj (investigate@l_aKa) (!x_aKb) = (rep bs_aKd ' ') ++ ns_aKc
  where ns_aKc = dropWhile ((==) ' ') (show x_aKb)
        bs_aKd
          | l_aKa <= length ns_aKc = 1
          | otherwise = l_aKa - length ns_aKc
showlj l_a22r (!x_a22s) = ns_a22t ++ (rep bs_a22u ' ')
  where (investigate@ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
        bs_a22u
          | l_a22r <= length ns_a22t = 1
          | otherwise = l_a22r - length ns_a22t

azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
azip [] [] = []
azip (investigate@(x_a22v : ls_a22w))
  (investigate@(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (azip ls_a22w ls'_a22y)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showlj, Dum.showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]
Dum.rep :: Int -> a_arH -> [a_arH]
Dum.rep (!0) x_aIV = []
Dum.rep n_aIW (!x_aIX) = x_aIX : (Dum.rep (n_aIW - 1) x_aIX)
Dum.showrj (!l_aKa) (!x_aKb)
  = (Dum.rep bs_aKd ' ') ++ ns_aKc
  where
      ns_aKc = dropWhile ((==) ' ') (show x_aKb)
      bs_aKd
        | l_aKa <= length ns_aKc = 1
        | otherwise = l_aKa - length ns_aKc
Dum.showlj l_a22r (!x_a22s)
  = ns_a22t ++ (Dum.rep bs_a22u ' ')
  where
      (!ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
      bs_a22u
        | l_a22r <= length ns_a22t = 1
        | otherwise = l_a22r - length ns_a22t
Dum.azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
Dum.azip [] [] = []
Dum.azip (!(x_a22v : ls_a22w)) (!(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (Dum.azip ls_a22w ls'_a22y)


["0","!0","(!0)","x_aIV","n_aIW","x_aIX","!x_aIX","(!x_aIX)","l_aKa","!l_aKa","(!l_aKa)","x_aKb","safebang@!x_aKb","(!x_aKb)","ns_aKc","bs_aKd","l_a22r","x_a22s","safebang@!x_a22s","(!x_a22s)","ns_a22t","!ns_a22t","(!ns_a22t)","bs_a22u","[]","[]","x_a22v","ls_a22w","x_a22v : ls_a22w","(x_a22v : ls_a22w)","!(x_a22v : ls_a22w)","(!(x_a22v : ls_a22w))","x'_a22x","ls'_a22y","safebang@!ls'_a22y","(!ls'_a22y)","x'_a22x : (!ls'_a22y)","(x'_a22x : (!ls'_a22y))","!(x'_a22x : (!ls'_a22y))","(!(x'_a22x : (!ls'_a22y)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Numbers
import Vectors
import Hide
import MyIO
import EdgePlate (Input(..))
import Postscript (Output(..))
import System.IO

showlj, showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]

rep :: Int -> a_arH -> [a_arH]
rep (investigate@0) x_aIV = []
rep n_aIW (investigate@x_aIX) = x_aIX : (rep (n_aIW - 1) x_aIX)
showrj (investigate@l_aKa) (!x_aKb) = (rep bs_aKd ' ') ++ ns_aKc
  where ns_aKc = dropWhile ((==) ' ') (show x_aKb)
        bs_aKd
          | l_aKa <= length ns_aKc = 1
          | otherwise = l_aKa - length ns_aKc
showlj l_a22r (!x_a22s) = ns_a22t ++ (rep bs_a22u ' ')
  where (investigate@ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
        bs_a22u
          | l_a22r <= length ns_a22t = 1
          | otherwise = l_a22r - length ns_a22t

azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
azip [] [] = []
azip (investigate@(x_a22v : ls_a22w))
  (investigate@(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (azip ls_a22w ls'_a22y)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showlj, Dum.showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]
Dum.rep :: Int -> a_arH -> [a_arH]
Dum.rep (!0) x_aIV = []
Dum.rep n_aIW (!x_aIX) = x_aIX : (Dum.rep (n_aIW - 1) x_aIX)
Dum.showrj (!l_aKa) (!x_aKb)
  = (Dum.rep bs_aKd ' ') ++ ns_aKc
  where
      ns_aKc = dropWhile ((==) ' ') (show x_aKb)
      bs_aKd
        | l_aKa <= length ns_aKc = 1
        | otherwise = l_aKa - length ns_aKc
Dum.showlj l_a22r (!x_a22s)
  = ns_a22t ++ (Dum.rep bs_a22u ' ')
  where
      (!ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
      bs_a22u
        | l_a22r <= length ns_a22t = 1
        | otherwise = l_a22r - length ns_a22t
Dum.azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
Dum.azip [] [] = []
Dum.azip (!(x_a22v : ls_a22w)) (!(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (Dum.azip ls_a22w ls'_a22y)


["0","!0","(!0)","x_aIV","n_aIW","x_aIX","!x_aIX","(!x_aIX)","l_aKa","!l_aKa","(!l_aKa)","x_aKb","safebang@!x_aKb","(!x_aKb)","ns_aKc","bs_aKd","l_a22r","x_a22s","safebang@!x_a22s","(!x_a22s)","ns_a22t","!ns_a22t","(!ns_a22t)","bs_a22u","[]","[]","x_a22v","ls_a22w","x_a22v : ls_a22w","(x_a22v : ls_a22w)","!(x_a22v : ls_a22w)","(!(x_a22v : ls_a22w))","x'_a22x","ls'_a22y","safebang@!ls'_a22y","(!ls'_a22y)","x'_a22x : (!ls'_a22y)","(x'_a22x : (!ls'_a22y))","!(x'_a22x : (!ls'_a22y))","(!(x'_a22x : (!ls'_a22y)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Numbers
import Vectors

showlj, showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]

rep :: Int -> a_arH -> [a_arH]
rep (investigate@0) x_aIV = []
rep n_aIW (investigate@x_aIX) = x_aIX : (rep (n_aIW - 1) x_aIX)
showrj (investigate@l_aKa) (!x_aKb) = (rep bs_aKd ' ') ++ ns_aKc
  where ns_aKc = dropWhile ((==) ' ') (show x_aKb)
        bs_aKd
          | l_aKa <= length ns_aKc = 1
          | otherwise = l_aKa - length ns_aKc
showlj l_a22r (!x_a22s) = ns_a22t ++ (rep bs_a22u ' ')
  where (investigate@ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
        bs_a22u
          | l_a22r <= length ns_a22t = 1
          | otherwise = l_a22r - length ns_a22t

azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
azip [] [] = []
azip (investigate@(x_a22v : ls_a22w))
  (investigate@(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (azip ls_a22w ls'_a22y)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showlj, Dum.showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]
Dum.rep :: Int -> a_arH -> [a_arH]
Dum.rep (!0) x_aIV = []
Dum.rep n_aIW (!x_aIX) = x_aIX : (Dum.rep (n_aIW - 1) x_aIX)
Dum.showrj (!l_aKa) (!x_aKb)
  = (Dum.rep bs_aKd ' ') ++ ns_aKc
  where
      ns_aKc = dropWhile ((==) ' ') (show x_aKb)
      bs_aKd
        | l_aKa <= length ns_aKc = 1
        | otherwise = l_aKa - length ns_aKc
Dum.showlj l_a22r (!x_a22s)
  = ns_a22t ++ (Dum.rep bs_a22u ' ')
  where
      (!ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
      bs_a22u
        | l_a22r <= length ns_a22t = 1
        | otherwise = l_a22r - length ns_a22t
Dum.azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
Dum.azip [] [] = []
Dum.azip (!(x_a22v : ls_a22w)) (!(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (Dum.azip ls_a22w ls'_a22y)


["0","!0","(!0)","x_aIV","n_aIW","x_aIX","!x_aIX","(!x_aIX)","l_aKa","!l_aKa","(!l_aKa)","x_aKb","safebang@!x_aKb","(!x_aKb)","ns_aKc","bs_aKd","l_a22r","x_a22s","safebang@!x_a22s","(!x_a22s)","ns_a22t","!ns_a22t","(!ns_a22t)","bs_a22u","[]","[]","x_a22v","ls_a22w","x_a22v : ls_a22w","(x_a22v : ls_a22w)","!(x_a22v : ls_a22w)","(!(x_a22v : ls_a22w))","x'_a22x","ls'_a22y","safebang@!ls'_a22y","(!ls'_a22y)","x'_a22x : (!ls'_a22y)","(x'_a22x : (!ls'_a22y))","!(x'_a22x : (!ls'_a22y))","(!(x'_a22x : (!ls'_a22y)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Numbers
import Vectors
import EdgePlate
import Solve
import Preds
import Data.List (nub)

showlj, showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]

rep :: Int -> a_arH -> [a_arH]
rep (investigate@0) x_aIV = []
rep n_aIW (investigate@x_aIX) = x_aIX : (rep (n_aIW - 1) x_aIX)
showrj (investigate@l_aKa) (!x_aKb) = (rep bs_aKd ' ') ++ ns_aKc
  where ns_aKc = dropWhile ((==) ' ') (show x_aKb)
        bs_aKd
          | l_aKa <= length ns_aKc = 1
          | otherwise = l_aKa - length ns_aKc
showlj l_a22r (!x_a22s) = ns_a22t ++ (rep bs_a22u ' ')
  where (investigate@ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
        bs_a22u
          | l_a22r <= length ns_a22t = 1
          | otherwise = l_a22r - length ns_a22t

azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
azip [] [] = []
azip (investigate@(x_a22v : ls_a22w))
  (investigate@(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (azip ls_a22w ls'_a22y)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showlj, Dum.showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]
Dum.rep :: Int -> a_arH -> [a_arH]
Dum.rep (!0) x_aIV = []
Dum.rep n_aIW (!x_aIX) = x_aIX : (Dum.rep (n_aIW - 1) x_aIX)
Dum.showrj (!l_aKa) (!x_aKb)
  = (Dum.rep bs_aKd ' ') ++ ns_aKc
  where
      ns_aKc = dropWhile ((==) ' ') (show x_aKb)
      bs_aKd
        | l_aKa <= length ns_aKc = 1
        | otherwise = l_aKa - length ns_aKc
Dum.showlj l_a22r (!x_a22s)
  = ns_a22t ++ (Dum.rep bs_a22u ' ')
  where
      (!ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
      bs_a22u
        | l_a22r <= length ns_a22t = 1
        | otherwise = l_a22r - length ns_a22t
Dum.azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
Dum.azip [] [] = []
Dum.azip (!(x_a22v : ls_a22w)) (!(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (Dum.azip ls_a22w ls'_a22y)


["0","!0","(!0)","x_aIV","n_aIW","x_aIX","!x_aIX","(!x_aIX)","l_aKa","!l_aKa","(!l_aKa)","x_aKb","safebang@!x_aKb","(!x_aKb)","ns_aKc","bs_aKd","l_a22r","x_a22s","safebang@!x_a22s","(!x_a22s)","ns_a22t","!ns_a22t","(!ns_a22t)","bs_a22u","[]","[]","x_a22v","ls_a22w","x_a22v : ls_a22w","(x_a22v : ls_a22w)","!(x_a22v : ls_a22w)","(!(x_a22v : ls_a22w))","x'_a22x","ls'_a22y","safebang@!ls'_a22y","(!ls'_a22y)","x'_a22x : (!ls'_a22y)","(x'_a22x : (!ls'_a22y))","!(x'_a22x : (!ls'_a22y))","(!(x'_a22x : (!ls'_a22y)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Numbers
import Vectors
import EdgePlate

showlj, showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]

rep :: Int -> a_arH -> [a_arH]
rep (investigate@0) x_aIV = []
rep n_aIW (investigate@x_aIX) = x_aIX : (rep (n_aIW - 1) x_aIX)
showrj (investigate@l_aKa) (!x_aKb) = (rep bs_aKd ' ') ++ ns_aKc
  where ns_aKc = dropWhile ((==) ' ') (show x_aKb)
        bs_aKd
          | l_aKa <= length ns_aKc = 1
          | otherwise = l_aKa - length ns_aKc
showlj l_a22r (!x_a22s) = ns_a22t ++ (rep bs_a22u ' ')
  where (investigate@ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
        bs_a22u
          | l_a22r <= length ns_a22t = 1
          | otherwise = l_a22r - length ns_a22t

azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
azip [] [] = []
azip (investigate@(x_a22v : ls_a22w))
  (investigate@(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (azip ls_a22w ls'_a22y)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showlj, Dum.showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]
Dum.rep :: Int -> a_arH -> [a_arH]
Dum.rep (!0) x_aIV = []
Dum.rep n_aIW (!x_aIX) = x_aIX : (Dum.rep (n_aIW - 1) x_aIX)
Dum.showrj (!l_aKa) (!x_aKb)
  = (Dum.rep bs_aKd ' ') ++ ns_aKc
  where
      ns_aKc = dropWhile ((==) ' ') (show x_aKb)
      bs_aKd
        | l_aKa <= length ns_aKc = 1
        | otherwise = l_aKa - length ns_aKc
Dum.showlj l_a22r (!x_a22s)
  = ns_a22t ++ (Dum.rep bs_a22u ' ')
  where
      (!ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
      bs_a22u
        | l_a22r <= length ns_a22t = 1
        | otherwise = l_a22r - length ns_a22t
Dum.azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
Dum.azip [] [] = []
Dum.azip (!(x_a22v : ls_a22w)) (!(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (Dum.azip ls_a22w ls'_a22y)


["0","!0","(!0)","x_aIV","n_aIW","x_aIX","!x_aIX","(!x_aIX)","l_aKa","!l_aKa","(!l_aKa)","x_aKb","safebang@!x_aKb","(!x_aKb)","ns_aKc","bs_aKd","l_a22r","x_a22s","safebang@!x_a22s","(!x_a22s)","ns_a22t","!ns_a22t","(!ns_a22t)","bs_a22u","[]","[]","x_a22v","ls_a22w","x_a22v : ls_a22w","(x_a22v : ls_a22w)","!(x_a22v : ls_a22w)","(!(x_a22v : ls_a22w))","x'_a22x","ls'_a22y","safebang@!ls'_a22y","(!ls'_a22y)","x'_a22x : (!ls'_a22y)","(x'_a22x : (!ls'_a22y))","!(x'_a22x : (!ls'_a22y))","(!(x'_a22x : (!ls'_a22y)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Numbers
import Vectors
import EdgePlate
import Rotate

showlj, showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]

rep :: Int -> a_arH -> [a_arH]
rep (investigate@0) x_aIV = []
rep n_aIW (investigate@x_aIX) = x_aIX : (rep (n_aIW - 1) x_aIX)
showrj (investigate@l_aKa) (!x_aKb) = (rep bs_aKd ' ') ++ ns_aKc
  where ns_aKc = dropWhile ((==) ' ') (show x_aKb)
        bs_aKd
          | l_aKa <= length ns_aKc = 1
          | otherwise = l_aKa - length ns_aKc
showlj l_a22r (!x_a22s) = ns_a22t ++ (rep bs_a22u ' ')
  where (investigate@ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
        bs_a22u
          | l_a22r <= length ns_a22t = 1
          | otherwise = l_a22r - length ns_a22t

azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
azip [] [] = []
azip (investigate@(x_a22v : ls_a22w))
  (investigate@(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (azip ls_a22w ls'_a22y)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showlj, Dum.showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]
Dum.rep :: Int -> a_arH -> [a_arH]
Dum.rep (!0) x_aIV = []
Dum.rep n_aIW (!x_aIX) = x_aIX : (Dum.rep (n_aIW - 1) x_aIX)
Dum.showrj (!l_aKa) (!x_aKb)
  = (Dum.rep bs_aKd ' ') ++ ns_aKc
  where
      ns_aKc = dropWhile ((==) ' ') (show x_aKb)
      bs_aKd
        | l_aKa <= length ns_aKc = 1
        | otherwise = l_aKa - length ns_aKc
Dum.showlj l_a22r (!x_a22s)
  = ns_a22t ++ (Dum.rep bs_a22u ' ')
  where
      (!ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
      bs_a22u
        | l_a22r <= length ns_a22t = 1
        | otherwise = l_a22r - length ns_a22t
Dum.azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
Dum.azip [] [] = []
Dum.azip (!(x_a22v : ls_a22w)) (!(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (Dum.azip ls_a22w ls'_a22y)


["0","!0","(!0)","x_aIV","n_aIW","x_aIX","!x_aIX","(!x_aIX)","l_aKa","!l_aKa","(!l_aKa)","x_aKb","safebang@!x_aKb","(!x_aKb)","ns_aKc","bs_aKd","l_a22r","x_a22s","safebang@!x_a22s","(!x_a22s)","ns_a22t","!ns_a22t","(!ns_a22t)","bs_a22u","[]","[]","x_a22v","ls_a22w","x_a22v : ls_a22w","(x_a22v : ls_a22w)","!(x_a22v : ls_a22w)","(!(x_a22v : ls_a22w))","x'_a22x","ls'_a22y","safebang@!ls'_a22y","(!ls'_a22y)","x'_a22x : (!ls'_a22y)","(x'_a22x : (!ls'_a22y))","!(x'_a22x : (!ls'_a22y))","(!(x'_a22x : (!ls'_a22y)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Numbers
import Vectors
import EdgePlate
import Comparing (above)
import Data.Ix
import Data.Array

showlj, showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]

rep :: Int -> a_arH -> [a_arH]
rep (investigate@0) x_aIV = []
rep n_aIW (investigate@x_aIX) = x_aIX : (rep (n_aIW - 1) x_aIX)
showrj (investigate@l_aKa) (!x_aKb) = (rep bs_aKd ' ') ++ ns_aKc
  where ns_aKc = dropWhile ((==) ' ') (show x_aKb)
        bs_aKd
          | l_aKa <= length ns_aKc = 1
          | otherwise = l_aKa - length ns_aKc
showlj l_a22r (!x_a22s) = ns_a22t ++ (rep bs_a22u ' ')
  where (investigate@ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
        bs_a22u
          | l_a22r <= length ns_a22t = 1
          | otherwise = l_a22r - length ns_a22t

azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
azip [] [] = []
azip (investigate@(x_a22v : ls_a22w))
  (investigate@(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (azip ls_a22w ls'_a22y)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showlj, Dum.showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]
Dum.rep :: Int -> a_arH -> [a_arH]
Dum.rep (!0) x_aIV = []
Dum.rep n_aIW (!x_aIX) = x_aIX : (Dum.rep (n_aIW - 1) x_aIX)
Dum.showrj (!l_aKa) (!x_aKb)
  = (Dum.rep bs_aKd ' ') ++ ns_aKc
  where
      ns_aKc = dropWhile ((==) ' ') (show x_aKb)
      bs_aKd
        | l_aKa <= length ns_aKc = 1
        | otherwise = l_aKa - length ns_aKc
Dum.showlj l_a22r (!x_a22s)
  = ns_a22t ++ (Dum.rep bs_a22u ' ')
  where
      (!ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
      bs_a22u
        | l_a22r <= length ns_a22t = 1
        | otherwise = l_a22r - length ns_a22t
Dum.azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
Dum.azip [] [] = []
Dum.azip (!(x_a22v : ls_a22w)) (!(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (Dum.azip ls_a22w ls'_a22y)


["0","!0","(!0)","x_aIV","n_aIW","x_aIX","!x_aIX","(!x_aIX)","l_aKa","!l_aKa","(!l_aKa)","x_aKb","safebang@!x_aKb","(!x_aKb)","ns_aKc","bs_aKd","l_a22r","x_a22s","safebang@!x_a22s","(!x_a22s)","ns_a22t","!ns_a22t","(!ns_a22t)","bs_a22u","[]","[]","x_a22v","ls_a22w","x_a22v : ls_a22w","(x_a22v : ls_a22w)","!(x_a22v : ls_a22w)","(!(x_a22v : ls_a22w))","x'_a22x","ls'_a22y","safebang@!ls'_a22y","(!ls'_a22y)","x'_a22x : (!ls'_a22y)","(x'_a22x : (!ls'_a22y))","!(x'_a22x : (!ls'_a22y))","(!(x'_a22x : (!ls'_a22y)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Numbers
import Vectors
import EdgePlate
import Geometric

showlj, showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]

rep :: Int -> a_arH -> [a_arH]
rep (investigate@0) x_aIV = []
rep n_aIW (investigate@x_aIX) = x_aIX : (rep (n_aIW - 1) x_aIX)
showrj (investigate@l_aKa) (!x_aKb) = (rep bs_aKd ' ') ++ ns_aKc
  where ns_aKc = dropWhile ((==) ' ') (show x_aKb)
        bs_aKd
          | l_aKa <= length ns_aKc = 1
          | otherwise = l_aKa - length ns_aKc
showlj l_a22r (!x_a22s) = ns_a22t ++ (rep bs_a22u ' ')
  where (investigate@ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
        bs_a22u
          | l_a22r <= length ns_a22t = 1
          | otherwise = l_a22r - length ns_a22t

azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
azip [] [] = []
azip (investigate@(x_a22v : ls_a22w))
  (investigate@(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (azip ls_a22w ls'_a22y)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showlj, Dum.showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]
Dum.rep :: Int -> a_arH -> [a_arH]
Dum.rep (!0) x_aIV = []
Dum.rep n_aIW (!x_aIX) = x_aIX : (Dum.rep (n_aIW - 1) x_aIX)
Dum.showrj (!l_aKa) (!x_aKb)
  = (Dum.rep bs_aKd ' ') ++ ns_aKc
  where
      ns_aKc = dropWhile ((==) ' ') (show x_aKb)
      bs_aKd
        | l_aKa <= length ns_aKc = 1
        | otherwise = l_aKa - length ns_aKc
Dum.showlj l_a22r (!x_a22s)
  = ns_a22t ++ (Dum.rep bs_a22u ' ')
  where
      (!ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
      bs_a22u
        | l_a22r <= length ns_a22t = 1
        | otherwise = l_a22r - length ns_a22t
Dum.azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
Dum.azip [] [] = []
Dum.azip (!(x_a22v : ls_a22w)) (!(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (Dum.azip ls_a22w ls'_a22y)


["0","!0","(!0)","x_aIV","n_aIW","x_aIX","!x_aIX","(!x_aIX)","l_aKa","!l_aKa","(!l_aKa)","x_aKb","safebang@!x_aKb","(!x_aKb)","ns_aKc","bs_aKd","l_a22r","x_a22s","safebang@!x_a22s","(!x_a22s)","ns_a22t","!ns_a22t","(!ns_a22t)","bs_a22u","[]","[]","x_a22v","ls_a22w","x_a22v : ls_a22w","(x_a22v : ls_a22w)","!(x_a22v : ls_a22w)","(!(x_a22v : ls_a22w))","x'_a22x","ls'_a22y","safebang@!ls'_a22y","(!ls'_a22y)","x'_a22x : (!ls'_a22y)","(x'_a22x : (!ls'_a22y))","!(x'_a22x : (!ls'_a22y))","(!(x'_a22x : (!ls'_a22y)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Numbers
import Vectors
import System.IO
import System.Environment (getArgs)

showlj, showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]

rep :: Int -> a_arH -> [a_arH]
rep (investigate@0) x_aIV = []
rep n_aIW (investigate@x_aIX) = x_aIX : (rep (n_aIW - 1) x_aIX)
showrj (investigate@l_aKa) (!x_aKb) = (rep bs_aKd ' ') ++ ns_aKc
  where ns_aKc = dropWhile ((==) ' ') (show x_aKb)
        bs_aKd
          | l_aKa <= length ns_aKc = 1
          | otherwise = l_aKa - length ns_aKc
showlj l_a22r (!x_a22s) = ns_a22t ++ (rep bs_a22u ' ')
  where (investigate@ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
        bs_a22u
          | l_a22r <= length ns_a22t = 1
          | otherwise = l_a22r - length ns_a22t

azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
azip [] [] = []
azip (investigate@(x_a22v : ls_a22w))
  (investigate@(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (azip ls_a22w ls'_a22y)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showlj, Dum.showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]
Dum.rep :: Int -> a_arH -> [a_arH]
Dum.rep (!0) x_aIV = []
Dum.rep n_aIW (!x_aIX) = x_aIX : (Dum.rep (n_aIW - 1) x_aIX)
Dum.showrj (!l_aKa) (!x_aKb)
  = (Dum.rep bs_aKd ' ') ++ ns_aKc
  where
      ns_aKc = dropWhile ((==) ' ') (show x_aKb)
      bs_aKd
        | l_aKa <= length ns_aKc = 1
        | otherwise = l_aKa - length ns_aKc
Dum.showlj l_a22r (!x_a22s)
  = ns_a22t ++ (Dum.rep bs_a22u ' ')
  where
      (!ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
      bs_a22u
        | l_a22r <= length ns_a22t = 1
        | otherwise = l_a22r - length ns_a22t
Dum.azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
Dum.azip [] [] = []
Dum.azip (!(x_a22v : ls_a22w)) (!(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (Dum.azip ls_a22w ls'_a22y)


["0","!0","(!0)","x_aIV","n_aIW","x_aIX","!x_aIX","(!x_aIX)","l_aKa","!l_aKa","(!l_aKa)","x_aKb","safebang@!x_aKb","(!x_aKb)","ns_aKc","bs_aKd","l_a22r","x_a22s","safebang@!x_a22s","(!x_a22s)","ns_a22t","!ns_a22t","(!ns_a22t)","bs_a22u","[]","[]","x_a22v","ls_a22w","x_a22v : ls_a22w","(x_a22v : ls_a22w)","!(x_a22v : ls_a22w)","(!(x_a22v : ls_a22w))","x'_a22x","ls'_a22y","safebang@!ls'_a22y","(!ls'_a22y)","x'_a22x : (!ls'_a22y)","(x'_a22x : (!ls'_a22y))","!(x'_a22x : (!ls'_a22y))","(!(x'_a22x : (!ls'_a22y)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Numbers
import Vectors
import EdgePlate
import Preds
import Solve
import Geometric
import Cross
import Data.List (nub)

showlj, showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]

rep :: Int -> a_arH -> [a_arH]
rep (investigate@0) x_aIV = []
rep n_aIW (investigate@x_aIX) = x_aIX : (rep (n_aIW - 1) x_aIX)
showrj (investigate@l_aKa) (!x_aKb) = (rep bs_aKd ' ') ++ ns_aKc
  where ns_aKc = dropWhile ((==) ' ') (show x_aKb)
        bs_aKd
          | l_aKa <= length ns_aKc = 1
          | otherwise = l_aKa - length ns_aKc
showlj l_a22r (!x_a22s) = ns_a22t ++ (rep bs_a22u ' ')
  where (investigate@ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
        bs_a22u
          | l_a22r <= length ns_a22t = 1
          | otherwise = l_a22r - length ns_a22t

azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
azip [] [] = []
azip (investigate@(x_a22v : ls_a22w))
  (investigate@(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (azip ls_a22w ls'_a22y)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showlj, Dum.showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]
Dum.rep :: Int -> a_arH -> [a_arH]
Dum.rep (!0) x_aIV = []
Dum.rep n_aIW (!x_aIX) = x_aIX : (Dum.rep (n_aIW - 1) x_aIX)
Dum.showrj (!l_aKa) (!x_aKb)
  = (Dum.rep bs_aKd ' ') ++ ns_aKc
  where
      ns_aKc = dropWhile ((==) ' ') (show x_aKb)
      bs_aKd
        | l_aKa <= length ns_aKc = 1
        | otherwise = l_aKa - length ns_aKc
Dum.showlj l_a22r (!x_a22s)
  = ns_a22t ++ (Dum.rep bs_a22u ' ')
  where
      (!ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
      bs_a22u
        | l_a22r <= length ns_a22t = 1
        | otherwise = l_a22r - length ns_a22t
Dum.azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
Dum.azip [] [] = []
Dum.azip (!(x_a22v : ls_a22w)) (!(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (Dum.azip ls_a22w ls'_a22y)


["0","!0","(!0)","x_aIV","n_aIW","x_aIX","!x_aIX","(!x_aIX)","l_aKa","!l_aKa","(!l_aKa)","x_aKb","safebang@!x_aKb","(!x_aKb)","ns_aKc","bs_aKd","l_a22r","x_a22s","safebang@!x_a22s","(!x_a22s)","ns_a22t","!ns_a22t","(!ns_a22t)","bs_a22u","[]","[]","x_a22v","ls_a22w","x_a22v : ls_a22w","(x_a22v : ls_a22w)","!(x_a22v : ls_a22w)","(!(x_a22v : ls_a22w))","x'_a22x","ls'_a22y","safebang@!ls'_a22y","(!ls'_a22y)","x'_a22x : (!ls'_a22y)","(x'_a22x : (!ls'_a22y))","!(x'_a22x : (!ls'_a22y))","(!(x'_a22x : (!ls'_a22y)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Numbers
import Vectors

showlj, showrj :: (Show a_ayM) => Int -> a_ayM -> [Char]

rep :: Int -> a_arH -> [a_arH]
rep (investigate@0) x_aIV = []
rep n_aIW (investigate@x_aIX) = x_aIX : (rep (n_aIW - 1) x_aIX)
showrj (investigate@l_aKa) (!x_aKb) = (rep bs_aKd ' ') ++ ns_aKc
  where ns_aKc = dropWhile ((==) ' ') (show x_aKb)
        bs_aKd
          | l_aKa <= length ns_aKc = 1
          | otherwise = l_aKa - length ns_aKc
showlj l_a22r (!x_a22s) = ns_a22t ++ (rep bs_a22u ' ')
  where (investigate@ns_a22t) = dropWhile ((==) ' ') (show x_a22s)
        bs_a22u
          | l_a22r <= length ns_a22t = 1
          | otherwise = l_a22r - length ns_a22t

azip :: [a_arF] -> [b_arG] -> [(a_arF, b_arG)]
azip [] [] = []
azip (investigate@(x_a22v : ls_a22w))
  (investigate@(x'_a22x : (!ls'_a22y)))
  = (x_a22v, x'_a22x) : (azip ls_a22w ls'_a22y)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.eps = 1.0e-4 :: Float

data Dum.Number = Dum.Tolerant Float

instance Show Dum.Number where
  showsPrec (!p_a20Z) ((!(Dum.Tolerant x_a210)))
    = showsPrec p_a20Z x_a210
instance Read Dum.Number where
  readsPrec p_a211 s_a212
    = [(Dum.Tolerant n_a213, t_a214) |
         (n_a213, (!t_a214)) <- readsPrec p_a211 s_a212]
instance Floating Dum.Number where
  sqrt (!(Dum.Tolerant (!a_a215))) = Dum.Tolerant (sqrt a_a215)
instance Fractional Dum.Number where
  (!(Dum.Tolerant a_a216)) / (Dum.Tolerant (!b_a217))
    = Dum.Tolerant (a_a216 / b_a217)
instance Num Dum.Number where
  (Dum.Tolerant a_a218) + (Dum.Tolerant (!b_a219))
    = Dum.Tolerant (a_a218 + b_a219)
  (Dum.Tolerant a_a21a) - (Dum.Tolerant (!b_a21b))
    = Dum.Tolerant (a_a21a - b_a21b)
  (!(Dum.Tolerant (!a_a21c))) * (Dum.Tolerant (!b_a21d))
    = Dum.Tolerant (a_a21c * b_a21d)
  negate (!(Dum.Tolerant (!a_a21e))) = Dum.Tolerant (- a_a21e)
  fromInteger n_a21f = Dum.Tolerant (fromInteger n_a21f)
instance Ord Dum.Number where
  (!(Dum.Tolerant (!a_a21g))) <= (Dum.Tolerant (!b_a21h))
    = a_a21g - Dum.eps < b_a21h
  (Dum.Tolerant (!a_a21i)) < (!(Dum.Tolerant (!b_a21j)))
    = a_a21i < b_a21j - Dum.eps
instance Eq Dum.Number where
  (Dum.Tolerant (!a_a21k)) == (Dum.Tolerant (!b_a21l))
    = abs (a_a21k - b_a21l) < Dum.eps
  (Dum.Tolerant (!a_a21m)) /= (Dum.Tolerant b_a21n)
    = abs (a_a21m - b_a21n) > Dum.eps


["eps","p_a20Z","safebang@!p_a20Z","(!p_a20Z)","x_a210","Tolerant x_a210","(Tolerant x_a210)","!(Tolerant x_a210)","(!(Tolerant x_a210))","((!(Tolerant x_a210)))","p_a211","s_a212","n_a213","t_a214","safebang@!t_a214","(!t_a214)","(n_a213, (!t_a214))","a_a215","safebang@!a_a215","(!a_a215)","Tolerant (!a_a215)","(Tolerant (!a_a215))","!(Tolerant (!a_a215))","(!(Tolerant (!a_a215)))","a_a216","Tolerant a_a216","(Tolerant a_a216)","!(Tolerant a_a216)","(!(Tolerant a_a216))","b_a217","safebang@!b_a217","(!b_a217)","Tolerant (!b_a217)","(Tolerant (!b_a217))","a_a218","Tolerant a_a218","(Tolerant a_a218)","b_a219","safebang@!b_a219","(!b_a219)","Tolerant (!b_a219)","(Tolerant (!b_a219))","a_a21a","Tolerant a_a21a","(Tolerant a_a21a)","b_a21b","safebang@!b_a21b","(!b_a21b)","Tolerant (!b_a21b)","(Tolerant (!b_a21b))","a_a21c","safebang@!a_a21c","(!a_a21c)","Tolerant (!a_a21c)","(Tolerant (!a_a21c))","!(Tolerant (!a_a21c))","(!(Tolerant (!a_a21c)))","b_a21d","safebang@!b_a21d","(!b_a21d)","Tolerant (!b_a21d)","(Tolerant (!b_a21d))","a_a21e","safebang@!a_a21e","(!a_a21e)","Tolerant (!a_a21e)","(Tolerant (!a_a21e))","!(Tolerant (!a_a21e))","(!(Tolerant (!a_a21e)))","n_a21f","a_a21g","!a_a21g","(!a_a21g)","Tolerant (!a_a21g)","(Tolerant (!a_a21g))","!(Tolerant (!a_a21g))","(!(Tolerant (!a_a21g)))","b_a21h","!b_a21h","(!b_a21h)","Tolerant (!b_a21h)","(Tolerant (!b_a21h))","a_a21i","!a_a21i","(!a_a21i)","Tolerant (!a_a21i)","(Tolerant (!a_a21i))","b_a21j","!b_a21j","(!b_a21j)","Tolerant (!b_a21j)","(Tolerant (!b_a21j))","!(Tolerant (!b_a21j))","(!(Tolerant (!b_a21j)))","a_a21k","!a_a21k","(!a_a21k)","Tolerant (!a_a21k)","(Tolerant (!a_a21k))","b_a21l","!b_a21l","(!b_a21l)","Tolerant (!b_a21l)","(Tolerant (!b_a21l))","a_a21m","!a_a21m","(!a_a21m)","Tolerant (!a_a21m)","(Tolerant (!a_a21m))","b_a21n","Tolerant b_a21n","(Tolerant b_a21n)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
eps = 1.0e-4 :: Float

data Number = Tolerant Float

instance Show Number where
        showsPrec (!p_a20Z) ((investigate@(Tolerant x_a210)))
          = showsPrec p_a20Z x_a210

instance Read Number where
        readsPrec p_a211 s_a212
          = [(Tolerant n_a213, t_a214) |
             (n_a213, (!t_a214)) <- readsPrec p_a211 s_a212]

instance Floating Number where
        sqrt (investigate@(Tolerant (!a_a215))) = Tolerant (sqrt a_a215)

instance Fractional Number where
        (investigate@(Tolerant a_a216)) / (Tolerant (!b_a217))
          = Tolerant (a_a216 / b_a217)

instance Num Number where
        (Tolerant a_a218) + (Tolerant (!b_a219))
          = Tolerant (a_a218 + b_a219)
        (Tolerant a_a21a) - (Tolerant (!b_a21b))
          = Tolerant (a_a21a - b_a21b)
        (investigate@(Tolerant (!a_a21c))) * (Tolerant (!b_a21d))
          = Tolerant (a_a21c * b_a21d)
        negate (investigate@(Tolerant (!a_a21e))) = Tolerant (-a_a21e)
        fromInteger n_a21f = Tolerant (fromInteger n_a21f)

instance Ord Number where
        (investigate@(Tolerant (investigate@a_a21g))) <=
          (Tolerant (investigate@b_a21h)) = a_a21g - eps < b_a21h
        (Tolerant (investigate@a_a21i)) <
          (investigate@(Tolerant (investigate@b_a21j)))
          = a_a21i < b_a21j - eps

instance Eq Number where
        (Tolerant (investigate@a_a21k)) == (Tolerant (investigate@b_a21l))
          = abs (a_a21k - b_a21l) < eps
        (Tolerant (investigate@a_a21m)) /= (Tolerant b_a21n)
          = abs (a_a21m - b_a21n) > eps
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.eps = 1.0e-4 :: Float

data Dum.Number = Dum.Tolerant Float

instance Show Dum.Number where
  showsPrec (!p_a20Z) ((!(Dum.Tolerant x_a210)))
    = showsPrec p_a20Z x_a210
instance Read Dum.Number where
  readsPrec p_a211 s_a212
    = [(Dum.Tolerant n_a213, t_a214) |
         (n_a213, (!t_a214)) <- readsPrec p_a211 s_a212]
instance Floating Dum.Number where
  sqrt (!(Dum.Tolerant (!a_a215))) = Dum.Tolerant (sqrt a_a215)
instance Fractional Dum.Number where
  (!(Dum.Tolerant a_a216)) / (Dum.Tolerant (!b_a217))
    = Dum.Tolerant (a_a216 / b_a217)
instance Num Dum.Number where
  (Dum.Tolerant a_a218) + (Dum.Tolerant (!b_a219))
    = Dum.Tolerant (a_a218 + b_a219)
  (Dum.Tolerant a_a21a) - (Dum.Tolerant (!b_a21b))
    = Dum.Tolerant (a_a21a - b_a21b)
  (!(Dum.Tolerant (!a_a21c))) * (Dum.Tolerant (!b_a21d))
    = Dum.Tolerant (a_a21c * b_a21d)
  negate (!(Dum.Tolerant (!a_a21e))) = Dum.Tolerant (- a_a21e)
  fromInteger n_a21f = Dum.Tolerant (fromInteger n_a21f)
instance Ord Dum.Number where
  (!(Dum.Tolerant (!a_a21g))) <= (Dum.Tolerant (!b_a21h))
    = a_a21g - Dum.eps < b_a21h
  (Dum.Tolerant (!a_a21i)) < (!(Dum.Tolerant (!b_a21j)))
    = a_a21i < b_a21j - Dum.eps
instance Eq Dum.Number where
  (Dum.Tolerant (!a_a21k)) == (Dum.Tolerant (!b_a21l))
    = abs (a_a21k - b_a21l) < Dum.eps
  (Dum.Tolerant (!a_a21m)) /= (Dum.Tolerant b_a21n)
    = abs (a_a21m - b_a21n) > Dum.eps


["eps","p_a20Z","safebang@!p_a20Z","(!p_a20Z)","x_a210","Tolerant x_a210","(Tolerant x_a210)","!(Tolerant x_a210)","(!(Tolerant x_a210))","((!(Tolerant x_a210)))","p_a211","s_a212","n_a213","t_a214","safebang@!t_a214","(!t_a214)","(n_a213, (!t_a214))","a_a215","safebang@!a_a215","(!a_a215)","Tolerant (!a_a215)","(Tolerant (!a_a215))","!(Tolerant (!a_a215))","(!(Tolerant (!a_a215)))","a_a216","Tolerant a_a216","(Tolerant a_a216)","!(Tolerant a_a216)","(!(Tolerant a_a216))","b_a217","safebang@!b_a217","(!b_a217)","Tolerant (!b_a217)","(Tolerant (!b_a217))","a_a218","Tolerant a_a218","(Tolerant a_a218)","b_a219","safebang@!b_a219","(!b_a219)","Tolerant (!b_a219)","(Tolerant (!b_a219))","a_a21a","Tolerant a_a21a","(Tolerant a_a21a)","b_a21b","safebang@!b_a21b","(!b_a21b)","Tolerant (!b_a21b)","(Tolerant (!b_a21b))","a_a21c","safebang@!a_a21c","(!a_a21c)","Tolerant (!a_a21c)","(Tolerant (!a_a21c))","!(Tolerant (!a_a21c))","(!(Tolerant (!a_a21c)))","b_a21d","safebang@!b_a21d","(!b_a21d)","Tolerant (!b_a21d)","(Tolerant (!b_a21d))","a_a21e","safebang@!a_a21e","(!a_a21e)","Tolerant (!a_a21e)","(Tolerant (!a_a21e))","!(Tolerant (!a_a21e))","(!(Tolerant (!a_a21e)))","n_a21f","a_a21g","!a_a21g","(!a_a21g)","Tolerant (!a_a21g)","(Tolerant (!a_a21g))","!(Tolerant (!a_a21g))","(!(Tolerant (!a_a21g)))","b_a21h","!b_a21h","(!b_a21h)","Tolerant (!b_a21h)","(Tolerant (!b_a21h))","a_a21i","!a_a21i","(!a_a21i)","Tolerant (!a_a21i)","(Tolerant (!a_a21i))","b_a21j","!b_a21j","(!b_a21j)","Tolerant (!b_a21j)","(Tolerant (!b_a21j))","!(Tolerant (!b_a21j))","(!(Tolerant (!b_a21j)))","a_a21k","!a_a21k","(!a_a21k)","Tolerant (!a_a21k)","(Tolerant (!a_a21k))","b_a21l","!b_a21l","(!b_a21l)","Tolerant (!b_a21l)","(Tolerant (!b_a21l))","a_a21m","!a_a21m","(!a_a21m)","Tolerant (!a_a21m)","(Tolerant (!a_a21m))","b_a21n","Tolerant b_a21n","(Tolerant b_a21n)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Numbers
eps = 1.0e-4 :: Float

data Number = Tolerant Float

instance Show Number where
        showsPrec (!p_a20Z) ((investigate@(Tolerant x_a210)))
          = showsPrec p_a20Z x_a210

instance Read Number where
        readsPrec p_a211 s_a212
          = [(Tolerant n_a213, t_a214) |
             (n_a213, (!t_a214)) <- readsPrec p_a211 s_a212]

instance Floating Number where
        sqrt (investigate@(Tolerant (!a_a215))) = Tolerant (sqrt a_a215)

instance Fractional Number where
        (investigate@(Tolerant a_a216)) / (Tolerant (!b_a217))
          = Tolerant (a_a216 / b_a217)

instance Num Number where
        (Tolerant a_a218) + (Tolerant (!b_a219))
          = Tolerant (a_a218 + b_a219)
        (Tolerant a_a21a) - (Tolerant (!b_a21b))
          = Tolerant (a_a21a - b_a21b)
        (investigate@(Tolerant (!a_a21c))) * (Tolerant (!b_a21d))
          = Tolerant (a_a21c * b_a21d)
        negate (investigate@(Tolerant (!a_a21e))) = Tolerant (-a_a21e)
        fromInteger n_a21f = Tolerant (fromInteger n_a21f)

instance Ord Number where
        (investigate@(Tolerant (investigate@a_a21g))) <=
          (Tolerant (investigate@b_a21h)) = a_a21g - eps < b_a21h
        (Tolerant (investigate@a_a21i)) <
          (investigate@(Tolerant (investigate@b_a21j)))
          = a_a21i < b_a21j - eps

instance Eq Number where
        (Tolerant (investigate@a_a21k)) == (Tolerant (investigate@b_a21l))
          = abs (a_a21k - b_a21l) < eps
        (Tolerant (investigate@a_a21m)) /= (Tolerant b_a21n)
          = abs (a_a21m - b_a21n) > eps
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.eps = 1.0e-4 :: Float

data Dum.Number = Dum.Tolerant Float

instance Show Dum.Number where
  showsPrec (!p_a20Z) ((!(Dum.Tolerant x_a210)))
    = showsPrec p_a20Z x_a210
instance Read Dum.Number where
  readsPrec p_a211 s_a212
    = [(Dum.Tolerant n_a213, t_a214) |
         (n_a213, (!t_a214)) <- readsPrec p_a211 s_a212]
instance Floating Dum.Number where
  sqrt (!(Dum.Tolerant (!a_a215))) = Dum.Tolerant (sqrt a_a215)
instance Fractional Dum.Number where
  (!(Dum.Tolerant a_a216)) / (Dum.Tolerant (!b_a217))
    = Dum.Tolerant (a_a216 / b_a217)
instance Num Dum.Number where
  (Dum.Tolerant a_a218) + (Dum.Tolerant (!b_a219))
    = Dum.Tolerant (a_a218 + b_a219)
  (Dum.Tolerant a_a21a) - (Dum.Tolerant (!b_a21b))
    = Dum.Tolerant (a_a21a - b_a21b)
  (!(Dum.Tolerant (!a_a21c))) * (Dum.Tolerant (!b_a21d))
    = Dum.Tolerant (a_a21c * b_a21d)
  negate (!(Dum.Tolerant (!a_a21e))) = Dum.Tolerant (- a_a21e)
  fromInteger n_a21f = Dum.Tolerant (fromInteger n_a21f)
instance Ord Dum.Number where
  (!(Dum.Tolerant (!a_a21g))) <= (Dum.Tolerant (!b_a21h))
    = a_a21g - Dum.eps < b_a21h
  (Dum.Tolerant (!a_a21i)) < (!(Dum.Tolerant (!b_a21j)))
    = a_a21i < b_a21j - Dum.eps
instance Eq Dum.Number where
  (Dum.Tolerant (!a_a21k)) == (Dum.Tolerant (!b_a21l))
    = abs (a_a21k - b_a21l) < Dum.eps
  (Dum.Tolerant (!a_a21m)) /= (Dum.Tolerant b_a21n)
    = abs (a_a21m - b_a21n) > Dum.eps


["eps","p_a20Z","safebang@!p_a20Z","(!p_a20Z)","x_a210","Tolerant x_a210","(Tolerant x_a210)","!(Tolerant x_a210)","(!(Tolerant x_a210))","((!(Tolerant x_a210)))","p_a211","s_a212","n_a213","t_a214","safebang@!t_a214","(!t_a214)","(n_a213, (!t_a214))","a_a215","safebang@!a_a215","(!a_a215)","Tolerant (!a_a215)","(Tolerant (!a_a215))","!(Tolerant (!a_a215))","(!(Tolerant (!a_a215)))","a_a216","Tolerant a_a216","(Tolerant a_a216)","!(Tolerant a_a216)","(!(Tolerant a_a216))","b_a217","safebang@!b_a217","(!b_a217)","Tolerant (!b_a217)","(Tolerant (!b_a217))","a_a218","Tolerant a_a218","(Tolerant a_a218)","b_a219","safebang@!b_a219","(!b_a219)","Tolerant (!b_a219)","(Tolerant (!b_a219))","a_a21a","Tolerant a_a21a","(Tolerant a_a21a)","b_a21b","safebang@!b_a21b","(!b_a21b)","Tolerant (!b_a21b)","(Tolerant (!b_a21b))","a_a21c","safebang@!a_a21c","(!a_a21c)","Tolerant (!a_a21c)","(Tolerant (!a_a21c))","!(Tolerant (!a_a21c))","(!(Tolerant (!a_a21c)))","b_a21d","safebang@!b_a21d","(!b_a21d)","Tolerant (!b_a21d)","(Tolerant (!b_a21d))","a_a21e","safebang@!a_a21e","(!a_a21e)","Tolerant (!a_a21e)","(Tolerant (!a_a21e))","!(Tolerant (!a_a21e))","(!(Tolerant (!a_a21e)))","n_a21f","a_a21g","!a_a21g","(!a_a21g)","Tolerant (!a_a21g)","(Tolerant (!a_a21g))","!(Tolerant (!a_a21g))","(!(Tolerant (!a_a21g)))","b_a21h","!b_a21h","(!b_a21h)","Tolerant (!b_a21h)","(Tolerant (!b_a21h))","a_a21i","!a_a21i","(!a_a21i)","Tolerant (!a_a21i)","(Tolerant (!a_a21i))","b_a21j","!b_a21j","(!b_a21j)","Tolerant (!b_a21j)","(Tolerant (!b_a21j))","!(Tolerant (!b_a21j))","(!(Tolerant (!b_a21j)))","a_a21k","!a_a21k","(!a_a21k)","Tolerant (!a_a21k)","(Tolerant (!a_a21k))","b_a21l","!b_a21l","(!b_a21l)","Tolerant (!b_a21l)","(Tolerant (!b_a21l))","a_a21m","!a_a21m","(!a_a21m)","Tolerant (!a_a21m)","(Tolerant (!a_a21m))","b_a21n","Tolerant b_a21n","(Tolerant b_a21n)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Numbers
import Vectors
import EdgePlate
import Geometric
import Comparing
import Memo
import Postscript
import Data.Array
eps = 1.0e-4 :: Float

data Number = Tolerant Float

instance Show Number where
        showsPrec (!p_a20Z) ((investigate@(Tolerant x_a210)))
          = showsPrec p_a20Z x_a210

instance Read Number where
        readsPrec p_a211 s_a212
          = [(Tolerant n_a213, t_a214) |
             (n_a213, (!t_a214)) <- readsPrec p_a211 s_a212]

instance Floating Number where
        sqrt (investigate@(Tolerant (!a_a215))) = Tolerant (sqrt a_a215)

instance Fractional Number where
        (investigate@(Tolerant a_a216)) / (Tolerant (!b_a217))
          = Tolerant (a_a216 / b_a217)

instance Num Number where
        (Tolerant a_a218) + (Tolerant (!b_a219))
          = Tolerant (a_a218 + b_a219)
        (Tolerant a_a21a) - (Tolerant (!b_a21b))
          = Tolerant (a_a21a - b_a21b)
        (investigate@(Tolerant (!a_a21c))) * (Tolerant (!b_a21d))
          = Tolerant (a_a21c * b_a21d)
        negate (investigate@(Tolerant (!a_a21e))) = Tolerant (-a_a21e)
        fromInteger n_a21f = Tolerant (fromInteger n_a21f)

instance Ord Number where
        (investigate@(Tolerant (investigate@a_a21g))) <=
          (Tolerant (investigate@b_a21h)) = a_a21g - eps < b_a21h
        (Tolerant (investigate@a_a21i)) <
          (investigate@(Tolerant (investigate@b_a21j)))
          = a_a21i < b_a21j - eps

instance Eq Number where
        (Tolerant (investigate@a_a21k)) == (Tolerant (investigate@b_a21l))
          = abs (a_a21k - b_a21l) < eps
        (Tolerant (investigate@a_a21m)) /= (Tolerant b_a21n)
          = abs (a_a21m - b_a21n) > eps
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.eps = 1.0e-4 :: Float

data Dum.Number = Dum.Tolerant Float

instance Show Dum.Number where
  showsPrec (!p_a20Z) ((!(Dum.Tolerant x_a210)))
    = showsPrec p_a20Z x_a210
instance Read Dum.Number where
  readsPrec p_a211 s_a212
    = [(Dum.Tolerant n_a213, t_a214) |
         (n_a213, (!t_a214)) <- readsPrec p_a211 s_a212]
instance Floating Dum.Number where
  sqrt (!(Dum.Tolerant (!a_a215))) = Dum.Tolerant (sqrt a_a215)
instance Fractional Dum.Number where
  (!(Dum.Tolerant a_a216)) / (Dum.Tolerant (!b_a217))
    = Dum.Tolerant (a_a216 / b_a217)
instance Num Dum.Number where
  (Dum.Tolerant a_a218) + (Dum.Tolerant (!b_a219))
    = Dum.Tolerant (a_a218 + b_a219)
  (Dum.Tolerant a_a21a) - (Dum.Tolerant (!b_a21b))
    = Dum.Tolerant (a_a21a - b_a21b)
  (!(Dum.Tolerant (!a_a21c))) * (Dum.Tolerant (!b_a21d))
    = Dum.Tolerant (a_a21c * b_a21d)
  negate (!(Dum.Tolerant (!a_a21e))) = Dum.Tolerant (- a_a21e)
  fromInteger n_a21f = Dum.Tolerant (fromInteger n_a21f)
instance Ord Dum.Number where
  (!(Dum.Tolerant (!a_a21g))) <= (Dum.Tolerant (!b_a21h))
    = a_a21g - Dum.eps < b_a21h
  (Dum.Tolerant (!a_a21i)) < (!(Dum.Tolerant (!b_a21j)))
    = a_a21i < b_a21j - Dum.eps
instance Eq Dum.Number where
  (Dum.Tolerant (!a_a21k)) == (Dum.Tolerant (!b_a21l))
    = abs (a_a21k - b_a21l) < Dum.eps
  (Dum.Tolerant (!a_a21m)) /= (Dum.Tolerant b_a21n)
    = abs (a_a21m - b_a21n) > Dum.eps


["eps","p_a20Z","safebang@!p_a20Z","(!p_a20Z)","x_a210","Tolerant x_a210","(Tolerant x_a210)","!(Tolerant x_a210)","(!(Tolerant x_a210))","((!(Tolerant x_a210)))","p_a211","s_a212","n_a213","t_a214","safebang@!t_a214","(!t_a214)","(n_a213, (!t_a214))","a_a215","safebang@!a_a215","(!a_a215)","Tolerant (!a_a215)","(Tolerant (!a_a215))","!(Tolerant (!a_a215))","(!(Tolerant (!a_a215)))","a_a216","Tolerant a_a216","(Tolerant a_a216)","!(Tolerant a_a216)","(!(Tolerant a_a216))","b_a217","safebang@!b_a217","(!b_a217)","Tolerant (!b_a217)","(Tolerant (!b_a217))","a_a218","Tolerant a_a218","(Tolerant a_a218)","b_a219","safebang@!b_a219","(!b_a219)","Tolerant (!b_a219)","(Tolerant (!b_a219))","a_a21a","Tolerant a_a21a","(Tolerant a_a21a)","b_a21b","safebang@!b_a21b","(!b_a21b)","Tolerant (!b_a21b)","(Tolerant (!b_a21b))","a_a21c","safebang@!a_a21c","(!a_a21c)","Tolerant (!a_a21c)","(Tolerant (!a_a21c))","!(Tolerant (!a_a21c))","(!(Tolerant (!a_a21c)))","b_a21d","safebang@!b_a21d","(!b_a21d)","Tolerant (!b_a21d)","(Tolerant (!b_a21d))","a_a21e","safebang@!a_a21e","(!a_a21e)","Tolerant (!a_a21e)","(Tolerant (!a_a21e))","!(Tolerant (!a_a21e))","(!(Tolerant (!a_a21e)))","n_a21f","a_a21g","!a_a21g","(!a_a21g)","Tolerant (!a_a21g)","(Tolerant (!a_a21g))","!(Tolerant (!a_a21g))","(!(Tolerant (!a_a21g)))","b_a21h","!b_a21h","(!b_a21h)","Tolerant (!b_a21h)","(Tolerant (!b_a21h))","a_a21i","!a_a21i","(!a_a21i)","Tolerant (!a_a21i)","(Tolerant (!a_a21i))","b_a21j","!b_a21j","(!b_a21j)","Tolerant (!b_a21j)","(Tolerant (!b_a21j))","!(Tolerant (!b_a21j))","(!(Tolerant (!b_a21j)))","a_a21k","!a_a21k","(!a_a21k)","Tolerant (!a_a21k)","(Tolerant (!a_a21k))","b_a21l","!b_a21l","(!b_a21l)","Tolerant (!b_a21l)","(Tolerant (!b_a21l))","a_a21m","!a_a21m","(!a_a21m)","Tolerant (!a_a21m)","(Tolerant (!a_a21m))","b_a21n","Tolerant b_a21n","(Tolerant b_a21n)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Numbers
import Vectors
import EdgePlate
eps = 1.0e-4 :: Float

data Number = Tolerant Float

instance Show Number where
        showsPrec (!p_a20Z) ((investigate@(Tolerant x_a210)))
          = showsPrec p_a20Z x_a210

instance Read Number where
        readsPrec p_a211 s_a212
          = [(Tolerant n_a213, t_a214) |
             (n_a213, (!t_a214)) <- readsPrec p_a211 s_a212]

instance Floating Number where
        sqrt (investigate@(Tolerant (!a_a215))) = Tolerant (sqrt a_a215)

instance Fractional Number where
        (investigate@(Tolerant a_a216)) / (Tolerant (!b_a217))
          = Tolerant (a_a216 / b_a217)

instance Num Number where
        (Tolerant a_a218) + (Tolerant (!b_a219))
          = Tolerant (a_a218 + b_a219)
        (Tolerant a_a21a) - (Tolerant (!b_a21b))
          = Tolerant (a_a21a - b_a21b)
        (investigate@(Tolerant (!a_a21c))) * (Tolerant (!b_a21d))
          = Tolerant (a_a21c * b_a21d)
        negate (investigate@(Tolerant (!a_a21e))) = Tolerant (-a_a21e)
        fromInteger n_a21f = Tolerant (fromInteger n_a21f)

instance Ord Number where
        (investigate@(Tolerant (investigate@a_a21g))) <=
          (Tolerant (investigate@b_a21h)) = a_a21g - eps < b_a21h
        (Tolerant (investigate@a_a21i)) <
          (investigate@(Tolerant (investigate@b_a21j)))
          = a_a21i < b_a21j - eps

instance Eq Number where
        (Tolerant (investigate@a_a21k)) == (Tolerant (investigate@b_a21l))
          = abs (a_a21k - b_a21l) < eps
        (Tolerant (investigate@a_a21m)) /= (Tolerant b_a21n)
          = abs (a_a21m - b_a21n) > eps
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.eps = 1.0e-4 :: Float

data Dum.Number = Dum.Tolerant Float

instance Show Dum.Number where
  showsPrec (!p_a20Z) ((!(Dum.Tolerant x_a210)))
    = showsPrec p_a20Z x_a210
instance Read Dum.Number where
  readsPrec p_a211 s_a212
    = [(Dum.Tolerant n_a213, t_a214) |
         (n_a213, (!t_a214)) <- readsPrec p_a211 s_a212]
instance Floating Dum.Number where
  sqrt (!(Dum.Tolerant (!a_a215))) = Dum.Tolerant (sqrt a_a215)
instance Fractional Dum.Number where
  (!(Dum.Tolerant a_a216)) / (Dum.Tolerant (!b_a217))
    = Dum.Tolerant (a_a216 / b_a217)
instance Num Dum.Number where
  (Dum.Tolerant a_a218) + (Dum.Tolerant (!b_a219))
    = Dum.Tolerant (a_a218 + b_a219)
  (Dum.Tolerant a_a21a) - (Dum.Tolerant (!b_a21b))
    = Dum.Tolerant (a_a21a - b_a21b)
  (!(Dum.Tolerant (!a_a21c))) * (Dum.Tolerant (!b_a21d))
    = Dum.Tolerant (a_a21c * b_a21d)
  negate (!(Dum.Tolerant (!a_a21e))) = Dum.Tolerant (- a_a21e)
  fromInteger n_a21f = Dum.Tolerant (fromInteger n_a21f)
instance Ord Dum.Number where
  (!(Dum.Tolerant (!a_a21g))) <= (Dum.Tolerant (!b_a21h))
    = a_a21g - Dum.eps < b_a21h
  (Dum.Tolerant (!a_a21i)) < (!(Dum.Tolerant (!b_a21j)))
    = a_a21i < b_a21j - Dum.eps
instance Eq Dum.Number where
  (Dum.Tolerant (!a_a21k)) == (Dum.Tolerant (!b_a21l))
    = abs (a_a21k - b_a21l) < Dum.eps
  (Dum.Tolerant (!a_a21m)) /= (Dum.Tolerant b_a21n)
    = abs (a_a21m - b_a21n) > Dum.eps


["eps","p_a20Z","safebang@!p_a20Z","(!p_a20Z)","x_a210","Tolerant x_a210","(Tolerant x_a210)","!(Tolerant x_a210)","(!(Tolerant x_a210))","((!(Tolerant x_a210)))","p_a211","s_a212","n_a213","t_a214","safebang@!t_a214","(!t_a214)","(n_a213, (!t_a214))","a_a215","safebang@!a_a215","(!a_a215)","Tolerant (!a_a215)","(Tolerant (!a_a215))","!(Tolerant (!a_a215))","(!(Tolerant (!a_a215)))","a_a216","Tolerant a_a216","(Tolerant a_a216)","!(Tolerant a_a216)","(!(Tolerant a_a216))","b_a217","safebang@!b_a217","(!b_a217)","Tolerant (!b_a217)","(Tolerant (!b_a217))","a_a218","Tolerant a_a218","(Tolerant a_a218)","b_a219","safebang@!b_a219","(!b_a219)","Tolerant (!b_a219)","(Tolerant (!b_a219))","a_a21a","Tolerant a_a21a","(Tolerant a_a21a)","b_a21b","safebang@!b_a21b","(!b_a21b)","Tolerant (!b_a21b)","(Tolerant (!b_a21b))","a_a21c","safebang@!a_a21c","(!a_a21c)","Tolerant (!a_a21c)","(Tolerant (!a_a21c))","!(Tolerant (!a_a21c))","(!(Tolerant (!a_a21c)))","b_a21d","safebang@!b_a21d","(!b_a21d)","Tolerant (!b_a21d)","(Tolerant (!b_a21d))","a_a21e","safebang@!a_a21e","(!a_a21e)","Tolerant (!a_a21e)","(Tolerant (!a_a21e))","!(Tolerant (!a_a21e))","(!(Tolerant (!a_a21e)))","n_a21f","a_a21g","!a_a21g","(!a_a21g)","Tolerant (!a_a21g)","(Tolerant (!a_a21g))","!(Tolerant (!a_a21g))","(!(Tolerant (!a_a21g)))","b_a21h","!b_a21h","(!b_a21h)","Tolerant (!b_a21h)","(Tolerant (!b_a21h))","a_a21i","!a_a21i","(!a_a21i)","Tolerant (!a_a21i)","(Tolerant (!a_a21i))","b_a21j","!b_a21j","(!b_a21j)","Tolerant (!b_a21j)","(Tolerant (!b_a21j))","!(Tolerant (!b_a21j))","(!(Tolerant (!b_a21j)))","a_a21k","!a_a21k","(!a_a21k)","Tolerant (!a_a21k)","(Tolerant (!a_a21k))","b_a21l","!b_a21l","(!b_a21l)","Tolerant (!b_a21l)","(Tolerant (!b_a21l))","a_a21m","!a_a21m","(!a_a21m)","Tolerant (!a_a21m)","(Tolerant (!a_a21m))","b_a21n","Tolerant b_a21n","(Tolerant b_a21n)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Char
import Data.List
import System.IO
import System.Environment
import System.Exit
import Arch_x86
import Generics
eps = 1.0e-4 :: Float

data Number = Tolerant Float

instance Show Number where
        showsPrec (!p_a20Z) ((investigate@(Tolerant x_a210)))
          = showsPrec p_a20Z x_a210

instance Read Number where
        readsPrec p_a211 s_a212
          = [(Tolerant n_a213, t_a214) |
             (n_a213, (!t_a214)) <- readsPrec p_a211 s_a212]

instance Floating Number where
        sqrt (investigate@(Tolerant (!a_a215))) = Tolerant (sqrt a_a215)

instance Fractional Number where
        (investigate@(Tolerant a_a216)) / (Tolerant (!b_a217))
          = Tolerant (a_a216 / b_a217)

instance Num Number where
        (Tolerant a_a218) + (Tolerant (!b_a219))
          = Tolerant (a_a218 + b_a219)
        (Tolerant a_a21a) - (Tolerant (!b_a21b))
          = Tolerant (a_a21a - b_a21b)
        (investigate@(Tolerant (!a_a21c))) * (Tolerant (!b_a21d))
          = Tolerant (a_a21c * b_a21d)
        negate (investigate@(Tolerant (!a_a21e))) = Tolerant (-a_a21e)
        fromInteger n_a21f = Tolerant (fromInteger n_a21f)

instance Ord Number where
        (investigate@(Tolerant (investigate@a_a21g))) <=
          (Tolerant (investigate@b_a21h)) = a_a21g - eps < b_a21h
        (Tolerant (investigate@a_a21i)) <
          (investigate@(Tolerant (investigate@b_a21j)))
          = a_a21i < b_a21j - eps

instance Eq Number where
        (Tolerant (investigate@a_a21k)) == (Tolerant (investigate@b_a21l))
          = abs (a_a21k - b_a21l) < eps
        (Tolerant (investigate@a_a21m)) /= (Tolerant b_a21n)
          = abs (a_a21m - b_a21n) > eps
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.x86info :: [(Dum.Opcode, Dum.OperandInfo)]
Dum.x86info
  = [(Dum.O_movl, Dum.OI [Dum.OE_RW 4 4]),
     (Dum.O_movw, Dum.OI [Dum.OE_RW 2 2]),
     (Dum.O_movb, Dum.OI [Dum.OE_RW 1 1]),
     (Dum.O_movzbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movzbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movzwl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_movsbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movsbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movswl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_pushl, Dum.OI_Special), (Dum.O_popl, Dum.OI_Special),
     (Dum.O_pushfl, Dum.OI_Error), (Dum.O_popfl, Dum.OI_Error),
     (Dum.O_sall, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_salw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_salb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sarl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_sarw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_sarb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shrl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_shrw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_shrb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_roll, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rolw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rolb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_rorl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rorw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shldl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_shrdl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_addl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_addw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_addb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_adcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_subb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sbbl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_imull, 
      Dum.OI [Dum.OE_M 4, Dum.OE_RM 4 4, Dum.OE_RRM 4 4 4]),
     (Dum.O_imulb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_imulw, Dum.OI [Dum.OE_M 2, Dum.OE_RM 2 2]),
     (Dum.O_mull, Dum.OI [Dum.OE_M 4]),
     (Dum.O_idivl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_divb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_xorl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_xorw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_xorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_andl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_andw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_andb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_orl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_orw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_orb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_incl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_incw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_incb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_decl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_decw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_decb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_negl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_negw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_negb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_notl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_notw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_notb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_testl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_testw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_testb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_leal, Dum.OI [Dum.OE_nW 4]),
     (Dum.O_cmpl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_cmpw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_cmpb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_cmpsb, Dum.OI_Special), (Dum.O_scasb, Dum.OI_Special),
     (Dum.O_movsl, Dum.OI_Special), (Dum.O_movsw, Dum.OI_Special),
     (Dum.O_movsb, Dum.OI_Special), (Dum.O_stosl, Dum.OI_Special),
     (Dum.O_stosw, Dum.OI_Special), (Dum.O_stosb, Dum.OI_Special),
     (Dum.O_leave, Dum.OI_Error), (Dum.O_ret, Dum.OI_Special),
     (Dum.O_call, Dum.OI_Special), (Dum.O_jmp, Dum.OI_Jumpy),
     (Dum.O_je, Dum.OI_Jumpy), (Dum.O_jne, Dum.OI_Jumpy),
     (Dum.O_jl, Dum.OI_Jumpy), (Dum.O_jle, Dum.OI_Jumpy),
     (Dum.O_jg, Dum.OI_Jumpy), (Dum.O_jge, Dum.OI_Jumpy),
     (Dum.O_js, Dum.OI_Jumpy), (Dum.O_jns, Dum.OI_Jumpy),
     (Dum.O_jz, Dum.OI_Jumpy), (Dum.O_jnz, Dum.OI_Jumpy),
     (Dum.O_jc, Dum.OI_Jumpy), (Dum.O_jnc, Dum.OI_Jumpy),
     (Dum.O_jo, Dum.OI_Jumpy), (Dum.O_jno, Dum.OI_Jumpy),
     (Dum.O_ja, Dum.OI_Jumpy), (Dum.O_jae, Dum.OI_Jumpy),
     (Dum.O_jb, Dum.OI_Jumpy), (Dum.O_jbe, Dum.OI_Jumpy),
     (Dum.O_jp, Dum.OI_Jumpy), (Dum.O_seta, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setae, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setbe, Dum.OI [Dum.OE_W 1]),
     (Dum.O_sete, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setne, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setl, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setle, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setg, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setge, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setc, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setcb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_btl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_btsl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btrl, Dum.OI [Dum.OE_RM 4 4]), (Dum.O_cld, Dum.OI_NoEffect),
     (Dum.O_cltd, Dum.OI_NoEffect), (Dum.O_cwtl, Dum.OI_NoEffect),
     (Dum.O_cbtw, Dum.OI_NoEffect), (Dum.O_rep, Dum.OI_Error),
     (Dum.O_repz, Dum.OI_Error), (Dum.O_repnz, Dum.OI_Error),
     (Dum.O_fld, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldt, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_flds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fild, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildll, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fstl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstpl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstp, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstps, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fsts, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fstpt, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fistl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpll, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fst, Dum.OI [Dum.OE_W 8]), (Dum.O_fldz, Dum.OI_NoEffect),
     (Dum.O_fld1, Dum.OI_NoEffect), (Dum.O_fldl2e, Dum.OI_NoEffect),
     (Dum.O_fldln2, Dum.OI_NoEffect), (Dum.O_fchs, Dum.OI_NoEffect),
     (Dum.O_fsin, Dum.OI_NoEffect), (Dum.O_fcos, Dum.OI_NoEffect),
     (Dum.O_fptan, Dum.OI_NoEffect), (Dum.O_fsqrt, Dum.OI_NoEffect),
     (Dum.O_fpatan, Dum.OI_NoEffect), (Dum.O_fabs, Dum.OI_NoEffect),
     (Dum.O_f2xm1, Dum.OI_NoEffect), (Dum.O_fscale, Dum.OI_NoEffect),
     (Dum.O_fyl2x, Dum.OI_NoEffect),
     (Dum.O_faddp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fadds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_faddl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fiaddl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fadd, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsubrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsub, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubr, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmul, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmuls, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fmull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fmulp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fimull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdiv, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivr, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fidivrl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fidivl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivs, Dum.OI [Dum.OE_R 4]), (Dum.O_fprem, Dum.OI_NoEffect),
     (Dum.O_fucom, Dum.OI_NoEffect), (Dum.O_fucomp, Dum.OI_NoEffect),
     (Dum.O_fucompp, Dum.OI_NoEffect), (Dum.O_fcomp, Dum.OI_NoEffect),
     (Dum.O_fcompp, Dum.OI_NoEffect),
     (Dum.O_fcoms, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcoml, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcom, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcomps, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcompl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_ficompl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fnstsw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fnstcw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fldcw, Dum.OI [Dum.OE_R 2]), (Dum.O_fxch, Dum.OI_NoEffect),
     (Dum.O_frndint, Dum.OI_NoEffect), (Dum.O_sahf, Dum.OI_NoEffect),
     (Dum.O_nop, Dum.OI_NoEffect)]
Dum.nonJumpyOpcodes :: [Dum.Opcode]
Dum.nonJumpyOpcodes
  = [Dum.O_pushl, Dum.O_popl, Dum.O_movl, Dum.O_movw, Dum.O_movb,
     Dum.O_andl, Dum.O_andw, Dum.O_andb, Dum.O_orl, Dum.O_orw,
     Dum.O_orb, Dum.O_xorl, Dum.O_xorw, Dum.O_xorb, Dum.O_addl,
     Dum.O_addw, Dum.O_addb, Dum.O_subl, Dum.O_subw, Dum.O_subb,
     Dum.O_incl, Dum.O_incw, Dum.O_incb, Dum.O_decl, Dum.O_decw,
     Dum.O_decb, Dum.O_cmpl, Dum.O_cmpw, Dum.O_cmpb, Dum.O_sall,
     Dum.O_salw, Dum.O_salb, Dum.O_shrl, Dum.O_shrw, Dum.O_shrb,
     Dum.O_sarl, Dum.O_leal, Dum.O_movzbw, Dum.O_movzbl, Dum.O_movzwl,
     Dum.O_movsbw, Dum.O_movsbl, Dum.O_movswl, Dum.O_seta, Dum.O_setae,
     Dum.O_setb, Dum.O_setbe, Dum.O_sete, Dum.O_setne, Dum.O_setl,
     Dum.O_setle, Dum.O_setg, Dum.O_setge, Dum.O_setc, Dum.O_setcb,
     Dum.O_testl, Dum.O_testw, Dum.O_testb, Dum.O_fld1, Dum.O_fcoml,
     Dum.O_fnstsw, Dum.O_fstpl, Dum.O_fstp, Dum.O_fsubrl, Dum.O_fldl,
     Dum.O_faddl, Dum.O_fsubl]

data Dum.Opcode
  = Dum.O_movl |
    Dum.O_movw |
    Dum.O_movb |
    Dum.O_movzbw |
    Dum.O_movzbl |
    Dum.O_movzwl |
    Dum.O_movsbw |
    Dum.O_movsbl |
    Dum.O_movswl |
    Dum.O_pushl |
    Dum.O_popl |
    Dum.O_pushfl |
    Dum.O_popfl |
    Dum.O_notl |
    Dum.O_notw |
    Dum.O_notb |
    Dum.O_sall |
    Dum.O_salw |
    Dum.O_salb |
    Dum.O_sarl |
    Dum.O_sarw |
    Dum.O_sarb |
    Dum.O_shrl |
    Dum.O_shrw |
    Dum.O_shrb |
    Dum.O_roll |
    Dum.O_rolw |
    Dum.O_rolb |
    Dum.O_rorl |
    Dum.O_rorw |
    Dum.O_rorb |
    Dum.O_shldl |
    Dum.O_shrdl |
    Dum.O_addl |
    Dum.O_addw |
    Dum.O_addb |
    Dum.O_adcl |
    Dum.O_subl |
    Dum.O_subw |
    Dum.O_subb |
    Dum.O_sbbl |
    Dum.O_imull |
    Dum.O_imulw |
    Dum.O_imulb |
    Dum.O_mull |
    Dum.O_divl |
    Dum.O_divw |
    Dum.O_divb |
    Dum.O_idivl |
    Dum.O_xorl |
    Dum.O_xorw |
    Dum.O_xorb |
    Dum.O_andl |
    Dum.O_andw |
    Dum.O_andb |
    Dum.O_orl |
    Dum.O_orw |
    Dum.O_orb |
    Dum.O_incl |
    Dum.O_incw |
    Dum.O_incb |
    Dum.O_decl |
    Dum.O_decw |
    Dum.O_decb |
    Dum.O_negl |
    Dum.O_negw |
    Dum.O_negb |
    Dum.O_testl |
    Dum.O_testw |
    Dum.O_testb |
    Dum.O_leal |
    Dum.O_cmpl |
    Dum.O_cmpw |
    Dum.O_cmpb |
    Dum.O_cmpsb |
    Dum.O_scasb |
    Dum.O_movsl |
    Dum.O_movsw |
    Dum.O_movsb |
    Dum.O_stosl |
    Dum.O_stosw |
    Dum.O_stosb |
    Dum.O_leave |
    Dum.O_ret |
    Dum.O_call |
    Dum.O_jmp |
    Dum.O_je |
    Dum.O_jne |
    Dum.O_jl |
    Dum.O_jle |
    Dum.O_jg |
    Dum.O_jge |
    Dum.O_js |
    Dum.O_jns |
    Dum.O_jz |
    Dum.O_jnz |
    Dum.O_jc |
    Dum.O_jnc |
    Dum.O_jo |
    Dum.O_jno |
    Dum.O_ja |
    Dum.O_jae |
    Dum.O_jb |
    Dum.O_jbe |
    Dum.O_jp |
    Dum.O_seta |
    Dum.O_setae |
    Dum.O_setb |
    Dum.O_setbe |
    Dum.O_sete |
    Dum.O_setne |
    Dum.O_setl |
    Dum.O_setle |
    Dum.O_setg |
    Dum.O_setge |
    Dum.O_setc |
    Dum.O_setcb |
    Dum.O_btl |
    Dum.O_btsl |
    Dum.O_btrl |
    Dum.O_btcl |
    Dum.O_cld |
    Dum.O_cltd |
    Dum.O_cwtl |
    Dum.O_cbtw |
    Dum.O_rep |
    Dum.O_repz |
    Dum.O_repnz |
    Dum.O_fild |
    Dum.O_fildl |
    Dum.O_fildll |
    Dum.O_fsubp |
    Dum.O_fsubr |
    Dum.O_fsubrp |
    Dum.O_fsubrl |
    Dum.O_fsubrs |
    Dum.O_fsubs |
    Dum.O_fsubl |
    Dum.O_fsub |
    Dum.O_faddp |
    Dum.O_fadds |
    Dum.O_faddl |
    Dum.O_fadd |
    Dum.O_fiaddl |
    Dum.O_fmul |
    Dum.O_fmuls |
    Dum.O_fmull |
    Dum.O_fmulp |
    Dum.O_fimull |
    Dum.O_fdiv |
    Dum.O_fdivp |
    Dum.O_fdivr |
    Dum.O_fdivrs |
    Dum.O_fdivrl |
    Dum.O_fdivrp |
    Dum.O_fidivl |
    Dum.O_fidivrl |
    Dum.O_fdivl |
    Dum.O_fdivs |
    Dum.O_fprem |
    Dum.O_fstp |
    Dum.O_fsts |
    Dum.O_fstps |
    Dum.O_fstl |
    Dum.O_fstpl |
    Dum.O_fstpt |
    Dum.O_fst |
    Dum.O_fistl |
    Dum.O_fistpl |
    Dum.O_fistpll |
    Dum.O_fld |
    Dum.O_flds |
    Dum.O_fldl |
    Dum.O_fldt |
    Dum.O_fldz |
    Dum.O_fld1 |
    Dum.O_fldl2e |
    Dum.O_fldln2 |
    Dum.O_fchs |
    Dum.O_fsin |
    Dum.O_fcos |
    Dum.O_fptan |
    Dum.O_fsqrt |
    Dum.O_fpatan |
    Dum.O_fabs |
    Dum.O_f2xm1 |
    Dum.O_fscale |
    Dum.O_fyl2x |
    Dum.O_fucom |
    Dum.O_fucomp |
    Dum.O_fucompp |
    Dum.O_fcomp |
    Dum.O_fcompp |
    Dum.O_fcoml |
    Dum.O_fcompl |
    Dum.O_ficompl |
    Dum.O_fcoms |
    Dum.O_fcom |
    Dum.O_fcomps |
    Dum.O_fnstsw |
    Dum.O_fnstcw |
    Dum.O_fldcw |
    Dum.O_frndint |
    Dum.O_fxch |
    Dum.O_sahf |
    Dum.O_nop
  deriving (Show, Eq)
data Dum.OperandEffect
  = Dum.OE_RR Int Int |
    Dum.OE_RM Int Int |
    Dum.OE_RW Int Int |
    Dum.OE_nW Int |
    Dum.OE_RRM Int Int Int |
    Dum.OE_R Int |
    Dum.OE_M Int |
    Dum.OE_W Int
  deriving (Show, Eq)
data Dum.OperandInfo
  = Dum.OI_Special |
    Dum.OI_Jumpy |
    Dum.OI_NoEffect |
    Dum.OI_Error |
    Dum.OI [Dum.OperandEffect]
  deriving (Show, Eq)


["x86info","nonJumpyOpcodes"]
{-# LANGUAGE BangPatterns #-}
module Dum where

x86info :: [(Opcode, OperandInfo)]
x86info
  = [(O_movl, OI [OE_RW 4 4]), (O_movw, OI [OE_RW 2 2]),
     (O_movb, OI [OE_RW 1 1]), (O_movzbw, OI [OE_RW 1 2]),
     (O_movzbl, OI [OE_RW 1 4]), (O_movzwl, OI [OE_RW 2 4]),
     (O_movsbw, OI [OE_RW 1 2]), (O_movsbl, OI [OE_RW 1 4]),
     (O_movswl, OI [OE_RW 2 4]), (O_pushl, OI_Special),
     (O_popl, OI_Special), (O_pushfl, OI_Error), (O_popfl, OI_Error),
     (O_sall, OI [OE_RM 1 4]), (O_salw, OI [OE_RM 1 2]),
     (O_salb, OI [OE_RM 1 1]), (O_sarl, OI [OE_RM 1 4]),
     (O_sarw, OI [OE_RM 1 2]), (O_sarb, OI [OE_RM 1 1]),
     (O_shrl, OI [OE_RM 1 4]), (O_shrw, OI [OE_RM 1 2]),
     (O_shrb, OI [OE_RM 1 1]), (O_roll, OI [OE_RM 1 4]),
     (O_rolw, OI [OE_RM 1 2]), (O_rolb, OI [OE_RM 1 1]),
     (O_rorl, OI [OE_RM 1 4]), (O_rorw, OI [OE_RM 1 2]),
     (O_rorb, OI [OE_RM 1 1]), (O_shldl, OI [OE_RRM 4 4 4, OE_RM 4 4]),
     (O_shrdl, OI [OE_RRM 4 4 4, OE_RM 4 4]), (O_addl, OI [OE_RM 4 4]),
     (O_addw, OI [OE_RM 2 2]), (O_addb, OI [OE_RM 1 1]),
     (O_adcl, OI [OE_RM 4 4]), (O_subl, OI [OE_RM 4 4]),
     (O_subw, OI [OE_RM 2 2]), (O_subb, OI [OE_RM 1 1]),
     (O_sbbl, OI [OE_RM 4 4]),
     (O_imull, OI [OE_M 4, OE_RM 4 4, OE_RRM 4 4 4]),
     (O_imulb, OI [OE_M 1]), (O_imulw, OI [OE_M 2, OE_RM 2 2]),
     (O_mull, OI [OE_M 4]), (O_idivl, OI [OE_M 4]),
     (O_divl, OI [OE_M 4]), (O_divw, OI [OE_M 2]),
     (O_divb, OI [OE_M 1]), (O_xorl, OI [OE_RM 4 4]),
     (O_xorw, OI [OE_RM 2 2]), (O_xorb, OI [OE_RM 1 1]),
     (O_andl, OI [OE_RM 4 4]), (O_andw, OI [OE_RM 2 2]),
     (O_andb, OI [OE_RM 1 1]), (O_orl, OI [OE_RM 4 4]),
     (O_orw, OI [OE_RM 2 2]), (O_orb, OI [OE_RM 1 1]),
     (O_incl, OI [OE_M 4]), (O_incw, OI [OE_M 2]),
     (O_incb, OI [OE_M 1]), (O_decl, OI [OE_M 4]),
     (O_decw, OI [OE_M 2]), (O_decb, OI [OE_M 1]),
     (O_negl, OI [OE_M 4]), (O_negw, OI [OE_M 2]),
     (O_negb, OI [OE_M 1]), (O_notl, OI [OE_M 4]),
     (O_notw, OI [OE_M 2]), (O_notb, OI [OE_M 1]),
     (O_testl, OI [OE_RR 4 4]), (O_testw, OI [OE_RR 2 2]),
     (O_testb, OI [OE_RR 1 1]), (O_leal, OI [OE_nW 4]),
     (O_cmpl, OI [OE_RR 4 4]), (O_cmpw, OI [OE_RR 2 2]),
     (O_cmpb, OI [OE_RR 1 1]), (O_cmpsb, OI_Special),
     (O_scasb, OI_Special), (O_movsl, OI_Special),
     (O_movsw, OI_Special), (O_movsb, OI_Special),
     (O_stosl, OI_Special), (O_stosw, OI_Special),
     (O_stosb, OI_Special), (O_leave, OI_Error), (O_ret, OI_Special),
     (O_call, OI_Special), (O_jmp, OI_Jumpy), (O_je, OI_Jumpy),
     (O_jne, OI_Jumpy), (O_jl, OI_Jumpy), (O_jle, OI_Jumpy),
     (O_jg, OI_Jumpy), (O_jge, OI_Jumpy), (O_js, OI_Jumpy),
     (O_jns, OI_Jumpy), (O_jz, OI_Jumpy), (O_jnz, OI_Jumpy),
     (O_jc, OI_Jumpy), (O_jnc, OI_Jumpy), (O_jo, OI_Jumpy),
     (O_jno, OI_Jumpy), (O_ja, OI_Jumpy), (O_jae, OI_Jumpy),
     (O_jb, OI_Jumpy), (O_jbe, OI_Jumpy), (O_jp, OI_Jumpy),
     (O_seta, OI [OE_W 1]), (O_setae, OI [OE_W 1]),
     (O_setb, OI [OE_W 1]), (O_setbe, OI [OE_W 1]),
     (O_sete, OI [OE_W 1]), (O_setne, OI [OE_W 1]),
     (O_setl, OI [OE_W 1]), (O_setle, OI [OE_W 1]),
     (O_setg, OI [OE_W 1]), (O_setge, OI [OE_W 1]),
     (O_setc, OI [OE_W 1]), (O_setcb, OI [OE_W 1]),
     (O_btl, OI [OE_RR 4 4]), (O_btsl, OI [OE_RM 4 4]),
     (O_btcl, OI [OE_RM 4 4]), (O_btrl, OI [OE_RM 4 4]),
     (O_cld, OI_NoEffect), (O_cltd, OI_NoEffect), (O_cwtl, OI_NoEffect),
     (O_cbtw, OI_NoEffect), (O_rep, OI_Error), (O_repz, OI_Error),
     (O_repnz, OI_Error), (O_fld, OI [OE_R 8]), (O_fldt, OI [OE_R 8]),
     (O_fldl, OI [OE_R 8]), (O_flds, OI [OE_R 4]),
     (O_fild, OI [OE_R 4]), (O_fildl, OI [OE_R 4]),
     (O_fildll, OI [OE_R 8]), (O_fstl, OI [OE_W 8]),
     (O_fstpl, OI [OE_W 8]), (O_fstp, OI [OE_W 8]),
     (O_fstps, OI [OE_W 4]), (O_fsts, OI [OE_W 4]),
     (O_fstpt, OI [OE_W 8]), (O_fistl, OI [OE_W 4]),
     (O_fistpl, OI [OE_W 4]), (O_fistpll, OI [OE_W 8]),
     (O_fst, OI [OE_W 8]), (O_fldz, OI_NoEffect), (O_fld1, OI_NoEffect),
     (O_fldl2e, OI_NoEffect), (O_fldln2, OI_NoEffect),
     (O_fchs, OI_NoEffect), (O_fsin, OI_NoEffect),
     (O_fcos, OI_NoEffect), (O_fptan, OI_NoEffect),
     (O_fsqrt, OI_NoEffect), (O_fpatan, OI_NoEffect),
     (O_fabs, OI_NoEffect), (O_f2xm1, OI_NoEffect),
     (O_fscale, OI_NoEffect), (O_fyl2x, OI_NoEffect),
     (O_faddp, OI [OE_R 8, OE_RM 8 8]), (O_fadds, OI [OE_R 4]),
     (O_faddl, OI [OE_R 8]), (O_fiaddl, OI [OE_R 4]),
     (O_fadd, OI [OE_R 8, OE_RM 8 8]), (O_fsubp, OI [OE_RM 8 8]),
     (O_fsubrp, OI [OE_RM 8 8]), (O_fsubrl, OI [OE_R 8]),
     (O_fsubrs, OI [OE_R 4]), (O_fsubs, OI [OE_R 4]),
     (O_fsubl, OI [OE_R 8]), (O_fsub, OI [OE_R 8, OE_RM 8 8]),
     (O_fsubr, OI [OE_R 8, OE_RM 8 8]),
     (O_fmul, OI [OE_R 8, OE_RM 8 8]), (O_fmuls, OI [OE_R 4]),
     (O_fmull, OI [OE_R 8]), (O_fmulp, OI [OE_R 8, OE_RM 8 8]),
     (O_fimull, OI [OE_R 8]), (O_fdiv, OI [OE_RM 8 8]),
     (O_fdivp, OI [OE_RM 8 8]), (O_fdivr, OI [OE_RM 8 8]),
     (O_fdivrl, OI [OE_R 8]), (O_fdivrs, OI [OE_R 4]),
     (O_fdivrp, OI [OE_RM 8 8]), (O_fidivrl, OI [OE_R 4]),
     (O_fidivl, OI [OE_R 4]), (O_fdivl, OI [OE_R 8]),
     (O_fdivs, OI [OE_R 4]), (O_fprem, OI_NoEffect),
     (O_fucom, OI_NoEffect), (O_fucomp, OI_NoEffect),
     (O_fucompp, OI_NoEffect), (O_fcomp, OI_NoEffect),
     (O_fcompp, OI_NoEffect), (O_fcoms, OI [OE_R 4]),
     (O_fcoml, OI [OE_R 8]), (O_fcom, OI [OE_R 8]),
     (O_fcomps, OI [OE_R 4]), (O_fcompl, OI [OE_R 8]),
     (O_ficompl, OI [OE_R 4]), (O_fnstsw, OI [OE_W 2]),
     (O_fnstcw, OI [OE_W 2]), (O_fldcw, OI [OE_R 2]),
     (O_fxch, OI_NoEffect), (O_frndint, OI_NoEffect),
     (O_sahf, OI_NoEffect), (O_nop, OI_NoEffect)]

nonJumpyOpcodes :: [Opcode]
nonJumpyOpcodes
  = [O_pushl, O_popl, O_movl, O_movw, O_movb, O_andl, O_andw, O_andb,
     O_orl, O_orw, O_orb, O_xorl, O_xorw, O_xorb, O_addl, O_addw,
     O_addb, O_subl, O_subw, O_subb, O_incl, O_incw, O_incb, O_decl,
     O_decw, O_decb, O_cmpl, O_cmpw, O_cmpb, O_sall, O_salw, O_salb,
     O_shrl, O_shrw, O_shrb, O_sarl, O_leal, O_movzbw, O_movzbl,
     O_movzwl, O_movsbw, O_movsbl, O_movswl, O_seta, O_setae, O_setb,
     O_setbe, O_sete, O_setne, O_setl, O_setle, O_setg, O_setge, O_setc,
     O_setcb, O_testl, O_testw, O_testb, O_fld1, O_fcoml, O_fnstsw,
     O_fstpl, O_fstp, O_fsubrl, O_fldl, O_faddl, O_fsubl]

data Opcode = O_movl
            | O_movw
            | O_movb
            | O_movzbw
            | O_movzbl
            | O_movzwl
            | O_movsbw
            | O_movsbl
            | O_movswl
            | O_pushl
            | O_popl
            | O_pushfl
            | O_popfl
            | O_notl
            | O_notw
            | O_notb
            | O_sall
            | O_salw
            | O_salb
            | O_sarl
            | O_sarw
            | O_sarb
            | O_shrl
            | O_shrw
            | O_shrb
            | O_roll
            | O_rolw
            | O_rolb
            | O_rorl
            | O_rorw
            | O_rorb
            | O_shldl
            | O_shrdl
            | O_addl
            | O_addw
            | O_addb
            | O_adcl
            | O_subl
            | O_subw
            | O_subb
            | O_sbbl
            | O_imull
            | O_imulw
            | O_imulb
            | O_mull
            | O_divl
            | O_divw
            | O_divb
            | O_idivl
            | O_xorl
            | O_xorw
            | O_xorb
            | O_andl
            | O_andw
            | O_andb
            | O_orl
            | O_orw
            | O_orb
            | O_incl
            | O_incw
            | O_incb
            | O_decl
            | O_decw
            | O_decb
            | O_negl
            | O_negw
            | O_negb
            | O_testl
            | O_testw
            | O_testb
            | O_leal
            | O_cmpl
            | O_cmpw
            | O_cmpb
            | O_cmpsb
            | O_scasb
            | O_movsl
            | O_movsw
            | O_movsb
            | O_stosl
            | O_stosw
            | O_stosb
            | O_leave
            | O_ret
            | O_call
            | O_jmp
            | O_je
            | O_jne
            | O_jl
            | O_jle
            | O_jg
            | O_jge
            | O_js
            | O_jns
            | O_jz
            | O_jnz
            | O_jc
            | O_jnc
            | O_jo
            | O_jno
            | O_ja
            | O_jae
            | O_jb
            | O_jbe
            | O_jp
            | O_seta
            | O_setae
            | O_setb
            | O_setbe
            | O_sete
            | O_setne
            | O_setl
            | O_setle
            | O_setg
            | O_setge
            | O_setc
            | O_setcb
            | O_btl
            | O_btsl
            | O_btrl
            | O_btcl
            | O_cld
            | O_cltd
            | O_cwtl
            | O_cbtw
            | O_rep
            | O_repz
            | O_repnz
            | O_fild
            | O_fildl
            | O_fildll
            | O_fsubp
            | O_fsubr
            | O_fsubrp
            | O_fsubrl
            | O_fsubrs
            | O_fsubs
            | O_fsubl
            | O_fsub
            | O_faddp
            | O_fadds
            | O_faddl
            | O_fadd
            | O_fiaddl
            | O_fmul
            | O_fmuls
            | O_fmull
            | O_fmulp
            | O_fimull
            | O_fdiv
            | O_fdivp
            | O_fdivr
            | O_fdivrs
            | O_fdivrl
            | O_fdivrp
            | O_fidivl
            | O_fidivrl
            | O_fdivl
            | O_fdivs
            | O_fprem
            | O_fstp
            | O_fsts
            | O_fstps
            | O_fstl
            | O_fstpl
            | O_fstpt
            | O_fst
            | O_fistl
            | O_fistpl
            | O_fistpll
            | O_fld
            | O_flds
            | O_fldl
            | O_fldt
            | O_fldz
            | O_fld1
            | O_fldl2e
            | O_fldln2
            | O_fchs
            | O_fsin
            | O_fcos
            | O_fptan
            | O_fsqrt
            | O_fpatan
            | O_fabs
            | O_f2xm1
            | O_fscale
            | O_fyl2x
            | O_fucom
            | O_fucomp
            | O_fucompp
            | O_fcomp
            | O_fcompp
            | O_fcoml
            | O_fcompl
            | O_ficompl
            | O_fcoms
            | O_fcom
            | O_fcomps
            | O_fnstsw
            | O_fnstcw
            | O_fldcw
            | O_frndint
            | O_fxch
            | O_sahf
            | O_nop
            deriving (Show, Eq)

data OperandEffect = OE_RR Int Int
                   | OE_RM Int Int
                   | OE_RW Int Int
                   | OE_nW Int
                   | OE_RRM Int Int Int
                   | OE_R Int
                   | OE_M Int
                   | OE_W Int
                   deriving (Show, Eq)

data OperandInfo = OI_Special
                 | OI_Jumpy
                 | OI_NoEffect
                 | OI_Error
                 | OI [OperandEffect]
                 deriving (Show, Eq)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.x86info :: [(Dum.Opcode, Dum.OperandInfo)]
Dum.x86info
  = [(Dum.O_movl, Dum.OI [Dum.OE_RW 4 4]),
     (Dum.O_movw, Dum.OI [Dum.OE_RW 2 2]),
     (Dum.O_movb, Dum.OI [Dum.OE_RW 1 1]),
     (Dum.O_movzbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movzbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movzwl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_movsbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movsbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movswl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_pushl, Dum.OI_Special), (Dum.O_popl, Dum.OI_Special),
     (Dum.O_pushfl, Dum.OI_Error), (Dum.O_popfl, Dum.OI_Error),
     (Dum.O_sall, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_salw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_salb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sarl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_sarw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_sarb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shrl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_shrw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_shrb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_roll, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rolw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rolb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_rorl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rorw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shldl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_shrdl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_addl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_addw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_addb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_adcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_subb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sbbl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_imull, 
      Dum.OI [Dum.OE_M 4, Dum.OE_RM 4 4, Dum.OE_RRM 4 4 4]),
     (Dum.O_imulb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_imulw, Dum.OI [Dum.OE_M 2, Dum.OE_RM 2 2]),
     (Dum.O_mull, Dum.OI [Dum.OE_M 4]),
     (Dum.O_idivl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_divb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_xorl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_xorw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_xorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_andl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_andw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_andb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_orl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_orw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_orb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_incl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_incw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_incb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_decl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_decw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_decb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_negl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_negw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_negb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_notl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_notw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_notb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_testl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_testw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_testb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_leal, Dum.OI [Dum.OE_nW 4]),
     (Dum.O_cmpl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_cmpw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_cmpb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_cmpsb, Dum.OI_Special), (Dum.O_scasb, Dum.OI_Special),
     (Dum.O_movsl, Dum.OI_Special), (Dum.O_movsw, Dum.OI_Special),
     (Dum.O_movsb, Dum.OI_Special), (Dum.O_stosl, Dum.OI_Special),
     (Dum.O_stosw, Dum.OI_Special), (Dum.O_stosb, Dum.OI_Special),
     (Dum.O_leave, Dum.OI_Error), (Dum.O_ret, Dum.OI_Special),
     (Dum.O_call, Dum.OI_Special), (Dum.O_jmp, Dum.OI_Jumpy),
     (Dum.O_je, Dum.OI_Jumpy), (Dum.O_jne, Dum.OI_Jumpy),
     (Dum.O_jl, Dum.OI_Jumpy), (Dum.O_jle, Dum.OI_Jumpy),
     (Dum.O_jg, Dum.OI_Jumpy), (Dum.O_jge, Dum.OI_Jumpy),
     (Dum.O_js, Dum.OI_Jumpy), (Dum.O_jns, Dum.OI_Jumpy),
     (Dum.O_jz, Dum.OI_Jumpy), (Dum.O_jnz, Dum.OI_Jumpy),
     (Dum.O_jc, Dum.OI_Jumpy), (Dum.O_jnc, Dum.OI_Jumpy),
     (Dum.O_jo, Dum.OI_Jumpy), (Dum.O_jno, Dum.OI_Jumpy),
     (Dum.O_ja, Dum.OI_Jumpy), (Dum.O_jae, Dum.OI_Jumpy),
     (Dum.O_jb, Dum.OI_Jumpy), (Dum.O_jbe, Dum.OI_Jumpy),
     (Dum.O_jp, Dum.OI_Jumpy), (Dum.O_seta, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setae, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setbe, Dum.OI [Dum.OE_W 1]),
     (Dum.O_sete, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setne, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setl, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setle, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setg, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setge, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setc, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setcb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_btl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_btsl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btrl, Dum.OI [Dum.OE_RM 4 4]), (Dum.O_cld, Dum.OI_NoEffect),
     (Dum.O_cltd, Dum.OI_NoEffect), (Dum.O_cwtl, Dum.OI_NoEffect),
     (Dum.O_cbtw, Dum.OI_NoEffect), (Dum.O_rep, Dum.OI_Error),
     (Dum.O_repz, Dum.OI_Error), (Dum.O_repnz, Dum.OI_Error),
     (Dum.O_fld, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldt, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_flds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fild, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildll, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fstl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstpl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstp, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstps, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fsts, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fstpt, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fistl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpll, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fst, Dum.OI [Dum.OE_W 8]), (Dum.O_fldz, Dum.OI_NoEffect),
     (Dum.O_fld1, Dum.OI_NoEffect), (Dum.O_fldl2e, Dum.OI_NoEffect),
     (Dum.O_fldln2, Dum.OI_NoEffect), (Dum.O_fchs, Dum.OI_NoEffect),
     (Dum.O_fsin, Dum.OI_NoEffect), (Dum.O_fcos, Dum.OI_NoEffect),
     (Dum.O_fptan, Dum.OI_NoEffect), (Dum.O_fsqrt, Dum.OI_NoEffect),
     (Dum.O_fpatan, Dum.OI_NoEffect), (Dum.O_fabs, Dum.OI_NoEffect),
     (Dum.O_f2xm1, Dum.OI_NoEffect), (Dum.O_fscale, Dum.OI_NoEffect),
     (Dum.O_fyl2x, Dum.OI_NoEffect),
     (Dum.O_faddp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fadds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_faddl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fiaddl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fadd, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsubrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsub, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubr, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmul, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmuls, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fmull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fmulp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fimull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdiv, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivr, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fidivrl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fidivl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivs, Dum.OI [Dum.OE_R 4]), (Dum.O_fprem, Dum.OI_NoEffect),
     (Dum.O_fucom, Dum.OI_NoEffect), (Dum.O_fucomp, Dum.OI_NoEffect),
     (Dum.O_fucompp, Dum.OI_NoEffect), (Dum.O_fcomp, Dum.OI_NoEffect),
     (Dum.O_fcompp, Dum.OI_NoEffect),
     (Dum.O_fcoms, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcoml, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcom, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcomps, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcompl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_ficompl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fnstsw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fnstcw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fldcw, Dum.OI [Dum.OE_R 2]), (Dum.O_fxch, Dum.OI_NoEffect),
     (Dum.O_frndint, Dum.OI_NoEffect), (Dum.O_sahf, Dum.OI_NoEffect),
     (Dum.O_nop, Dum.OI_NoEffect)]
Dum.nonJumpyOpcodes :: [Dum.Opcode]
Dum.nonJumpyOpcodes
  = [Dum.O_pushl, Dum.O_popl, Dum.O_movl, Dum.O_movw, Dum.O_movb,
     Dum.O_andl, Dum.O_andw, Dum.O_andb, Dum.O_orl, Dum.O_orw,
     Dum.O_orb, Dum.O_xorl, Dum.O_xorw, Dum.O_xorb, Dum.O_addl,
     Dum.O_addw, Dum.O_addb, Dum.O_subl, Dum.O_subw, Dum.O_subb,
     Dum.O_incl, Dum.O_incw, Dum.O_incb, Dum.O_decl, Dum.O_decw,
     Dum.O_decb, Dum.O_cmpl, Dum.O_cmpw, Dum.O_cmpb, Dum.O_sall,
     Dum.O_salw, Dum.O_salb, Dum.O_shrl, Dum.O_shrw, Dum.O_shrb,
     Dum.O_sarl, Dum.O_leal, Dum.O_movzbw, Dum.O_movzbl, Dum.O_movzwl,
     Dum.O_movsbw, Dum.O_movsbl, Dum.O_movswl, Dum.O_seta, Dum.O_setae,
     Dum.O_setb, Dum.O_setbe, Dum.O_sete, Dum.O_setne, Dum.O_setl,
     Dum.O_setle, Dum.O_setg, Dum.O_setge, Dum.O_setc, Dum.O_setcb,
     Dum.O_testl, Dum.O_testw, Dum.O_testb, Dum.O_fld1, Dum.O_fcoml,
     Dum.O_fnstsw, Dum.O_fstpl, Dum.O_fstp, Dum.O_fsubrl, Dum.O_fldl,
     Dum.O_faddl, Dum.O_fsubl]

data Dum.Opcode
  = Dum.O_movl |
    Dum.O_movw |
    Dum.O_movb |
    Dum.O_movzbw |
    Dum.O_movzbl |
    Dum.O_movzwl |
    Dum.O_movsbw |
    Dum.O_movsbl |
    Dum.O_movswl |
    Dum.O_pushl |
    Dum.O_popl |
    Dum.O_pushfl |
    Dum.O_popfl |
    Dum.O_notl |
    Dum.O_notw |
    Dum.O_notb |
    Dum.O_sall |
    Dum.O_salw |
    Dum.O_salb |
    Dum.O_sarl |
    Dum.O_sarw |
    Dum.O_sarb |
    Dum.O_shrl |
    Dum.O_shrw |
    Dum.O_shrb |
    Dum.O_roll |
    Dum.O_rolw |
    Dum.O_rolb |
    Dum.O_rorl |
    Dum.O_rorw |
    Dum.O_rorb |
    Dum.O_shldl |
    Dum.O_shrdl |
    Dum.O_addl |
    Dum.O_addw |
    Dum.O_addb |
    Dum.O_adcl |
    Dum.O_subl |
    Dum.O_subw |
    Dum.O_subb |
    Dum.O_sbbl |
    Dum.O_imull |
    Dum.O_imulw |
    Dum.O_imulb |
    Dum.O_mull |
    Dum.O_divl |
    Dum.O_divw |
    Dum.O_divb |
    Dum.O_idivl |
    Dum.O_xorl |
    Dum.O_xorw |
    Dum.O_xorb |
    Dum.O_andl |
    Dum.O_andw |
    Dum.O_andb |
    Dum.O_orl |
    Dum.O_orw |
    Dum.O_orb |
    Dum.O_incl |
    Dum.O_incw |
    Dum.O_incb |
    Dum.O_decl |
    Dum.O_decw |
    Dum.O_decb |
    Dum.O_negl |
    Dum.O_negw |
    Dum.O_negb |
    Dum.O_testl |
    Dum.O_testw |
    Dum.O_testb |
    Dum.O_leal |
    Dum.O_cmpl |
    Dum.O_cmpw |
    Dum.O_cmpb |
    Dum.O_cmpsb |
    Dum.O_scasb |
    Dum.O_movsl |
    Dum.O_movsw |
    Dum.O_movsb |
    Dum.O_stosl |
    Dum.O_stosw |
    Dum.O_stosb |
    Dum.O_leave |
    Dum.O_ret |
    Dum.O_call |
    Dum.O_jmp |
    Dum.O_je |
    Dum.O_jne |
    Dum.O_jl |
    Dum.O_jle |
    Dum.O_jg |
    Dum.O_jge |
    Dum.O_js |
    Dum.O_jns |
    Dum.O_jz |
    Dum.O_jnz |
    Dum.O_jc |
    Dum.O_jnc |
    Dum.O_jo |
    Dum.O_jno |
    Dum.O_ja |
    Dum.O_jae |
    Dum.O_jb |
    Dum.O_jbe |
    Dum.O_jp |
    Dum.O_seta |
    Dum.O_setae |
    Dum.O_setb |
    Dum.O_setbe |
    Dum.O_sete |
    Dum.O_setne |
    Dum.O_setl |
    Dum.O_setle |
    Dum.O_setg |
    Dum.O_setge |
    Dum.O_setc |
    Dum.O_setcb |
    Dum.O_btl |
    Dum.O_btsl |
    Dum.O_btrl |
    Dum.O_btcl |
    Dum.O_cld |
    Dum.O_cltd |
    Dum.O_cwtl |
    Dum.O_cbtw |
    Dum.O_rep |
    Dum.O_repz |
    Dum.O_repnz |
    Dum.O_fild |
    Dum.O_fildl |
    Dum.O_fildll |
    Dum.O_fsubp |
    Dum.O_fsubr |
    Dum.O_fsubrp |
    Dum.O_fsubrl |
    Dum.O_fsubrs |
    Dum.O_fsubs |
    Dum.O_fsubl |
    Dum.O_fsub |
    Dum.O_faddp |
    Dum.O_fadds |
    Dum.O_faddl |
    Dum.O_fadd |
    Dum.O_fiaddl |
    Dum.O_fmul |
    Dum.O_fmuls |
    Dum.O_fmull |
    Dum.O_fmulp |
    Dum.O_fimull |
    Dum.O_fdiv |
    Dum.O_fdivp |
    Dum.O_fdivr |
    Dum.O_fdivrs |
    Dum.O_fdivrl |
    Dum.O_fdivrp |
    Dum.O_fidivl |
    Dum.O_fidivrl |
    Dum.O_fdivl |
    Dum.O_fdivs |
    Dum.O_fprem |
    Dum.O_fstp |
    Dum.O_fsts |
    Dum.O_fstps |
    Dum.O_fstl |
    Dum.O_fstpl |
    Dum.O_fstpt |
    Dum.O_fst |
    Dum.O_fistl |
    Dum.O_fistpl |
    Dum.O_fistpll |
    Dum.O_fld |
    Dum.O_flds |
    Dum.O_fldl |
    Dum.O_fldt |
    Dum.O_fldz |
    Dum.O_fld1 |
    Dum.O_fldl2e |
    Dum.O_fldln2 |
    Dum.O_fchs |
    Dum.O_fsin |
    Dum.O_fcos |
    Dum.O_fptan |
    Dum.O_fsqrt |
    Dum.O_fpatan |
    Dum.O_fabs |
    Dum.O_f2xm1 |
    Dum.O_fscale |
    Dum.O_fyl2x |
    Dum.O_fucom |
    Dum.O_fucomp |
    Dum.O_fucompp |
    Dum.O_fcomp |
    Dum.O_fcompp |
    Dum.O_fcoml |
    Dum.O_fcompl |
    Dum.O_ficompl |
    Dum.O_fcoms |
    Dum.O_fcom |
    Dum.O_fcomps |
    Dum.O_fnstsw |
    Dum.O_fnstcw |
    Dum.O_fldcw |
    Dum.O_frndint |
    Dum.O_fxch |
    Dum.O_sahf |
    Dum.O_nop
  deriving (Show, Eq)
data Dum.OperandEffect
  = Dum.OE_RR Int Int |
    Dum.OE_RM Int Int |
    Dum.OE_RW Int Int |
    Dum.OE_nW Int |
    Dum.OE_RRM Int Int Int |
    Dum.OE_R Int |
    Dum.OE_M Int |
    Dum.OE_W Int
  deriving (Show, Eq)
data Dum.OperandInfo
  = Dum.OI_Special |
    Dum.OI_Jumpy |
    Dum.OI_NoEffect |
    Dum.OI_Error |
    Dum.OI [Dum.OperandEffect]
  deriving (Show, Eq)


["x86info","nonJumpyOpcodes"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Shapes
import Raster
import Quad
import Oct
import Csg
import Interval
import Types
import Vector
import Kolor
import Matrix
import Patchlevel
import System.Environment
import System.IO

x86info :: [(Opcode, OperandInfo)]
x86info
  = [(O_movl, OI [OE_RW 4 4]), (O_movw, OI [OE_RW 2 2]),
     (O_movb, OI [OE_RW 1 1]), (O_movzbw, OI [OE_RW 1 2]),
     (O_movzbl, OI [OE_RW 1 4]), (O_movzwl, OI [OE_RW 2 4]),
     (O_movsbw, OI [OE_RW 1 2]), (O_movsbl, OI [OE_RW 1 4]),
     (O_movswl, OI [OE_RW 2 4]), (O_pushl, OI_Special),
     (O_popl, OI_Special), (O_pushfl, OI_Error), (O_popfl, OI_Error),
     (O_sall, OI [OE_RM 1 4]), (O_salw, OI [OE_RM 1 2]),
     (O_salb, OI [OE_RM 1 1]), (O_sarl, OI [OE_RM 1 4]),
     (O_sarw, OI [OE_RM 1 2]), (O_sarb, OI [OE_RM 1 1]),
     (O_shrl, OI [OE_RM 1 4]), (O_shrw, OI [OE_RM 1 2]),
     (O_shrb, OI [OE_RM 1 1]), (O_roll, OI [OE_RM 1 4]),
     (O_rolw, OI [OE_RM 1 2]), (O_rolb, OI [OE_RM 1 1]),
     (O_rorl, OI [OE_RM 1 4]), (O_rorw, OI [OE_RM 1 2]),
     (O_rorb, OI [OE_RM 1 1]), (O_shldl, OI [OE_RRM 4 4 4, OE_RM 4 4]),
     (O_shrdl, OI [OE_RRM 4 4 4, OE_RM 4 4]), (O_addl, OI [OE_RM 4 4]),
     (O_addw, OI [OE_RM 2 2]), (O_addb, OI [OE_RM 1 1]),
     (O_adcl, OI [OE_RM 4 4]), (O_subl, OI [OE_RM 4 4]),
     (O_subw, OI [OE_RM 2 2]), (O_subb, OI [OE_RM 1 1]),
     (O_sbbl, OI [OE_RM 4 4]),
     (O_imull, OI [OE_M 4, OE_RM 4 4, OE_RRM 4 4 4]),
     (O_imulb, OI [OE_M 1]), (O_imulw, OI [OE_M 2, OE_RM 2 2]),
     (O_mull, OI [OE_M 4]), (O_idivl, OI [OE_M 4]),
     (O_divl, OI [OE_M 4]), (O_divw, OI [OE_M 2]),
     (O_divb, OI [OE_M 1]), (O_xorl, OI [OE_RM 4 4]),
     (O_xorw, OI [OE_RM 2 2]), (O_xorb, OI [OE_RM 1 1]),
     (O_andl, OI [OE_RM 4 4]), (O_andw, OI [OE_RM 2 2]),
     (O_andb, OI [OE_RM 1 1]), (O_orl, OI [OE_RM 4 4]),
     (O_orw, OI [OE_RM 2 2]), (O_orb, OI [OE_RM 1 1]),
     (O_incl, OI [OE_M 4]), (O_incw, OI [OE_M 2]),
     (O_incb, OI [OE_M 1]), (O_decl, OI [OE_M 4]),
     (O_decw, OI [OE_M 2]), (O_decb, OI [OE_M 1]),
     (O_negl, OI [OE_M 4]), (O_negw, OI [OE_M 2]),
     (O_negb, OI [OE_M 1]), (O_notl, OI [OE_M 4]),
     (O_notw, OI [OE_M 2]), (O_notb, OI [OE_M 1]),
     (O_testl, OI [OE_RR 4 4]), (O_testw, OI [OE_RR 2 2]),
     (O_testb, OI [OE_RR 1 1]), (O_leal, OI [OE_nW 4]),
     (O_cmpl, OI [OE_RR 4 4]), (O_cmpw, OI [OE_RR 2 2]),
     (O_cmpb, OI [OE_RR 1 1]), (O_cmpsb, OI_Special),
     (O_scasb, OI_Special), (O_movsl, OI_Special),
     (O_movsw, OI_Special), (O_movsb, OI_Special),
     (O_stosl, OI_Special), (O_stosw, OI_Special),
     (O_stosb, OI_Special), (O_leave, OI_Error), (O_ret, OI_Special),
     (O_call, OI_Special), (O_jmp, OI_Jumpy), (O_je, OI_Jumpy),
     (O_jne, OI_Jumpy), (O_jl, OI_Jumpy), (O_jle, OI_Jumpy),
     (O_jg, OI_Jumpy), (O_jge, OI_Jumpy), (O_js, OI_Jumpy),
     (O_jns, OI_Jumpy), (O_jz, OI_Jumpy), (O_jnz, OI_Jumpy),
     (O_jc, OI_Jumpy), (O_jnc, OI_Jumpy), (O_jo, OI_Jumpy),
     (O_jno, OI_Jumpy), (O_ja, OI_Jumpy), (O_jae, OI_Jumpy),
     (O_jb, OI_Jumpy), (O_jbe, OI_Jumpy), (O_jp, OI_Jumpy),
     (O_seta, OI [OE_W 1]), (O_setae, OI [OE_W 1]),
     (O_setb, OI [OE_W 1]), (O_setbe, OI [OE_W 1]),
     (O_sete, OI [OE_W 1]), (O_setne, OI [OE_W 1]),
     (O_setl, OI [OE_W 1]), (O_setle, OI [OE_W 1]),
     (O_setg, OI [OE_W 1]), (O_setge, OI [OE_W 1]),
     (O_setc, OI [OE_W 1]), (O_setcb, OI [OE_W 1]),
     (O_btl, OI [OE_RR 4 4]), (O_btsl, OI [OE_RM 4 4]),
     (O_btcl, OI [OE_RM 4 4]), (O_btrl, OI [OE_RM 4 4]),
     (O_cld, OI_NoEffect), (O_cltd, OI_NoEffect), (O_cwtl, OI_NoEffect),
     (O_cbtw, OI_NoEffect), (O_rep, OI_Error), (O_repz, OI_Error),
     (O_repnz, OI_Error), (O_fld, OI [OE_R 8]), (O_fldt, OI [OE_R 8]),
     (O_fldl, OI [OE_R 8]), (O_flds, OI [OE_R 4]),
     (O_fild, OI [OE_R 4]), (O_fildl, OI [OE_R 4]),
     (O_fildll, OI [OE_R 8]), (O_fstl, OI [OE_W 8]),
     (O_fstpl, OI [OE_W 8]), (O_fstp, OI [OE_W 8]),
     (O_fstps, OI [OE_W 4]), (O_fsts, OI [OE_W 4]),
     (O_fstpt, OI [OE_W 8]), (O_fistl, OI [OE_W 4]),
     (O_fistpl, OI [OE_W 4]), (O_fistpll, OI [OE_W 8]),
     (O_fst, OI [OE_W 8]), (O_fldz, OI_NoEffect), (O_fld1, OI_NoEffect),
     (O_fldl2e, OI_NoEffect), (O_fldln2, OI_NoEffect),
     (O_fchs, OI_NoEffect), (O_fsin, OI_NoEffect),
     (O_fcos, OI_NoEffect), (O_fptan, OI_NoEffect),
     (O_fsqrt, OI_NoEffect), (O_fpatan, OI_NoEffect),
     (O_fabs, OI_NoEffect), (O_f2xm1, OI_NoEffect),
     (O_fscale, OI_NoEffect), (O_fyl2x, OI_NoEffect),
     (O_faddp, OI [OE_R 8, OE_RM 8 8]), (O_fadds, OI [OE_R 4]),
     (O_faddl, OI [OE_R 8]), (O_fiaddl, OI [OE_R 4]),
     (O_fadd, OI [OE_R 8, OE_RM 8 8]), (O_fsubp, OI [OE_RM 8 8]),
     (O_fsubrp, OI [OE_RM 8 8]), (O_fsubrl, OI [OE_R 8]),
     (O_fsubrs, OI [OE_R 4]), (O_fsubs, OI [OE_R 4]),
     (O_fsubl, OI [OE_R 8]), (O_fsub, OI [OE_R 8, OE_RM 8 8]),
     (O_fsubr, OI [OE_R 8, OE_RM 8 8]),
     (O_fmul, OI [OE_R 8, OE_RM 8 8]), (O_fmuls, OI [OE_R 4]),
     (O_fmull, OI [OE_R 8]), (O_fmulp, OI [OE_R 8, OE_RM 8 8]),
     (O_fimull, OI [OE_R 8]), (O_fdiv, OI [OE_RM 8 8]),
     (O_fdivp, OI [OE_RM 8 8]), (O_fdivr, OI [OE_RM 8 8]),
     (O_fdivrl, OI [OE_R 8]), (O_fdivrs, OI [OE_R 4]),
     (O_fdivrp, OI [OE_RM 8 8]), (O_fidivrl, OI [OE_R 4]),
     (O_fidivl, OI [OE_R 4]), (O_fdivl, OI [OE_R 8]),
     (O_fdivs, OI [OE_R 4]), (O_fprem, OI_NoEffect),
     (O_fucom, OI_NoEffect), (O_fucomp, OI_NoEffect),
     (O_fucompp, OI_NoEffect), (O_fcomp, OI_NoEffect),
     (O_fcompp, OI_NoEffect), (O_fcoms, OI [OE_R 4]),
     (O_fcoml, OI [OE_R 8]), (O_fcom, OI [OE_R 8]),
     (O_fcomps, OI [OE_R 4]), (O_fcompl, OI [OE_R 8]),
     (O_ficompl, OI [OE_R 4]), (O_fnstsw, OI [OE_W 2]),
     (O_fnstcw, OI [OE_W 2]), (O_fldcw, OI [OE_R 2]),
     (O_fxch, OI_NoEffect), (O_frndint, OI_NoEffect),
     (O_sahf, OI_NoEffect), (O_nop, OI_NoEffect)]

nonJumpyOpcodes :: [Opcode]
nonJumpyOpcodes
  = [O_pushl, O_popl, O_movl, O_movw, O_movb, O_andl, O_andw, O_andb,
     O_orl, O_orw, O_orb, O_xorl, O_xorw, O_xorb, O_addl, O_addw,
     O_addb, O_subl, O_subw, O_subb, O_incl, O_incw, O_incb, O_decl,
     O_decw, O_decb, O_cmpl, O_cmpw, O_cmpb, O_sall, O_salw, O_salb,
     O_shrl, O_shrw, O_shrb, O_sarl, O_leal, O_movzbw, O_movzbl,
     O_movzwl, O_movsbw, O_movsbl, O_movswl, O_seta, O_setae, O_setb,
     O_setbe, O_sete, O_setne, O_setl, O_setle, O_setg, O_setge, O_setc,
     O_setcb, O_testl, O_testw, O_testb, O_fld1, O_fcoml, O_fnstsw,
     O_fstpl, O_fstp, O_fsubrl, O_fldl, O_faddl, O_fsubl]

data Opcode = O_movl
            | O_movw
            | O_movb
            | O_movzbw
            | O_movzbl
            | O_movzwl
            | O_movsbw
            | O_movsbl
            | O_movswl
            | O_pushl
            | O_popl
            | O_pushfl
            | O_popfl
            | O_notl
            | O_notw
            | O_notb
            | O_sall
            | O_salw
            | O_salb
            | O_sarl
            | O_sarw
            | O_sarb
            | O_shrl
            | O_shrw
            | O_shrb
            | O_roll
            | O_rolw
            | O_rolb
            | O_rorl
            | O_rorw
            | O_rorb
            | O_shldl
            | O_shrdl
            | O_addl
            | O_addw
            | O_addb
            | O_adcl
            | O_subl
            | O_subw
            | O_subb
            | O_sbbl
            | O_imull
            | O_imulw
            | O_imulb
            | O_mull
            | O_divl
            | O_divw
            | O_divb
            | O_idivl
            | O_xorl
            | O_xorw
            | O_xorb
            | O_andl
            | O_andw
            | O_andb
            | O_orl
            | O_orw
            | O_orb
            | O_incl
            | O_incw
            | O_incb
            | O_decl
            | O_decw
            | O_decb
            | O_negl
            | O_negw
            | O_negb
            | O_testl
            | O_testw
            | O_testb
            | O_leal
            | O_cmpl
            | O_cmpw
            | O_cmpb
            | O_cmpsb
            | O_scasb
            | O_movsl
            | O_movsw
            | O_movsb
            | O_stosl
            | O_stosw
            | O_stosb
            | O_leave
            | O_ret
            | O_call
            | O_jmp
            | O_je
            | O_jne
            | O_jl
            | O_jle
            | O_jg
            | O_jge
            | O_js
            | O_jns
            | O_jz
            | O_jnz
            | O_jc
            | O_jnc
            | O_jo
            | O_jno
            | O_ja
            | O_jae
            | O_jb
            | O_jbe
            | O_jp
            | O_seta
            | O_setae
            | O_setb
            | O_setbe
            | O_sete
            | O_setne
            | O_setl
            | O_setle
            | O_setg
            | O_setge
            | O_setc
            | O_setcb
            | O_btl
            | O_btsl
            | O_btrl
            | O_btcl
            | O_cld
            | O_cltd
            | O_cwtl
            | O_cbtw
            | O_rep
            | O_repz
            | O_repnz
            | O_fild
            | O_fildl
            | O_fildll
            | O_fsubp
            | O_fsubr
            | O_fsubrp
            | O_fsubrl
            | O_fsubrs
            | O_fsubs
            | O_fsubl
            | O_fsub
            | O_faddp
            | O_fadds
            | O_faddl
            | O_fadd
            | O_fiaddl
            | O_fmul
            | O_fmuls
            | O_fmull
            | O_fmulp
            | O_fimull
            | O_fdiv
            | O_fdivp
            | O_fdivr
            | O_fdivrs
            | O_fdivrl
            | O_fdivrp
            | O_fidivl
            | O_fidivrl
            | O_fdivl
            | O_fdivs
            | O_fprem
            | O_fstp
            | O_fsts
            | O_fstps
            | O_fstl
            | O_fstpl
            | O_fstpt
            | O_fst
            | O_fistl
            | O_fistpl
            | O_fistpll
            | O_fld
            | O_flds
            | O_fldl
            | O_fldt
            | O_fldz
            | O_fld1
            | O_fldl2e
            | O_fldln2
            | O_fchs
            | O_fsin
            | O_fcos
            | O_fptan
            | O_fsqrt
            | O_fpatan
            | O_fabs
            | O_f2xm1
            | O_fscale
            | O_fyl2x
            | O_fucom
            | O_fucomp
            | O_fucompp
            | O_fcomp
            | O_fcompp
            | O_fcoml
            | O_fcompl
            | O_ficompl
            | O_fcoms
            | O_fcom
            | O_fcomps
            | O_fnstsw
            | O_fnstcw
            | O_fldcw
            | O_frndint
            | O_fxch
            | O_sahf
            | O_nop
            deriving (Show, Eq)

data OperandEffect = OE_RR Int Int
                   | OE_RM Int Int
                   | OE_RW Int Int
                   | OE_nW Int
                   | OE_RRM Int Int Int
                   | OE_R Int
                   | OE_M Int
                   | OE_W Int
                   deriving (Show, Eq)

data OperandInfo = OI_Special
                 | OI_Jumpy
                 | OI_NoEffect
                 | OI_Error
                 | OI [OperandEffect]
                 deriving (Show, Eq)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.x86info :: [(Dum.Opcode, Dum.OperandInfo)]
Dum.x86info
  = [(Dum.O_movl, Dum.OI [Dum.OE_RW 4 4]),
     (Dum.O_movw, Dum.OI [Dum.OE_RW 2 2]),
     (Dum.O_movb, Dum.OI [Dum.OE_RW 1 1]),
     (Dum.O_movzbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movzbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movzwl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_movsbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movsbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movswl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_pushl, Dum.OI_Special), (Dum.O_popl, Dum.OI_Special),
     (Dum.O_pushfl, Dum.OI_Error), (Dum.O_popfl, Dum.OI_Error),
     (Dum.O_sall, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_salw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_salb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sarl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_sarw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_sarb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shrl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_shrw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_shrb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_roll, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rolw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rolb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_rorl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rorw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shldl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_shrdl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_addl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_addw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_addb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_adcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_subb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sbbl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_imull, 
      Dum.OI [Dum.OE_M 4, Dum.OE_RM 4 4, Dum.OE_RRM 4 4 4]),
     (Dum.O_imulb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_imulw, Dum.OI [Dum.OE_M 2, Dum.OE_RM 2 2]),
     (Dum.O_mull, Dum.OI [Dum.OE_M 4]),
     (Dum.O_idivl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_divb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_xorl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_xorw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_xorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_andl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_andw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_andb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_orl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_orw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_orb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_incl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_incw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_incb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_decl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_decw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_decb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_negl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_negw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_negb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_notl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_notw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_notb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_testl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_testw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_testb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_leal, Dum.OI [Dum.OE_nW 4]),
     (Dum.O_cmpl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_cmpw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_cmpb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_cmpsb, Dum.OI_Special), (Dum.O_scasb, Dum.OI_Special),
     (Dum.O_movsl, Dum.OI_Special), (Dum.O_movsw, Dum.OI_Special),
     (Dum.O_movsb, Dum.OI_Special), (Dum.O_stosl, Dum.OI_Special),
     (Dum.O_stosw, Dum.OI_Special), (Dum.O_stosb, Dum.OI_Special),
     (Dum.O_leave, Dum.OI_Error), (Dum.O_ret, Dum.OI_Special),
     (Dum.O_call, Dum.OI_Special), (Dum.O_jmp, Dum.OI_Jumpy),
     (Dum.O_je, Dum.OI_Jumpy), (Dum.O_jne, Dum.OI_Jumpy),
     (Dum.O_jl, Dum.OI_Jumpy), (Dum.O_jle, Dum.OI_Jumpy),
     (Dum.O_jg, Dum.OI_Jumpy), (Dum.O_jge, Dum.OI_Jumpy),
     (Dum.O_js, Dum.OI_Jumpy), (Dum.O_jns, Dum.OI_Jumpy),
     (Dum.O_jz, Dum.OI_Jumpy), (Dum.O_jnz, Dum.OI_Jumpy),
     (Dum.O_jc, Dum.OI_Jumpy), (Dum.O_jnc, Dum.OI_Jumpy),
     (Dum.O_jo, Dum.OI_Jumpy), (Dum.O_jno, Dum.OI_Jumpy),
     (Dum.O_ja, Dum.OI_Jumpy), (Dum.O_jae, Dum.OI_Jumpy),
     (Dum.O_jb, Dum.OI_Jumpy), (Dum.O_jbe, Dum.OI_Jumpy),
     (Dum.O_jp, Dum.OI_Jumpy), (Dum.O_seta, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setae, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setbe, Dum.OI [Dum.OE_W 1]),
     (Dum.O_sete, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setne, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setl, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setle, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setg, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setge, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setc, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setcb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_btl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_btsl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btrl, Dum.OI [Dum.OE_RM 4 4]), (Dum.O_cld, Dum.OI_NoEffect),
     (Dum.O_cltd, Dum.OI_NoEffect), (Dum.O_cwtl, Dum.OI_NoEffect),
     (Dum.O_cbtw, Dum.OI_NoEffect), (Dum.O_rep, Dum.OI_Error),
     (Dum.O_repz, Dum.OI_Error), (Dum.O_repnz, Dum.OI_Error),
     (Dum.O_fld, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldt, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_flds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fild, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildll, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fstl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstpl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstp, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstps, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fsts, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fstpt, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fistl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpll, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fst, Dum.OI [Dum.OE_W 8]), (Dum.O_fldz, Dum.OI_NoEffect),
     (Dum.O_fld1, Dum.OI_NoEffect), (Dum.O_fldl2e, Dum.OI_NoEffect),
     (Dum.O_fldln2, Dum.OI_NoEffect), (Dum.O_fchs, Dum.OI_NoEffect),
     (Dum.O_fsin, Dum.OI_NoEffect), (Dum.O_fcos, Dum.OI_NoEffect),
     (Dum.O_fptan, Dum.OI_NoEffect), (Dum.O_fsqrt, Dum.OI_NoEffect),
     (Dum.O_fpatan, Dum.OI_NoEffect), (Dum.O_fabs, Dum.OI_NoEffect),
     (Dum.O_f2xm1, Dum.OI_NoEffect), (Dum.O_fscale, Dum.OI_NoEffect),
     (Dum.O_fyl2x, Dum.OI_NoEffect),
     (Dum.O_faddp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fadds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_faddl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fiaddl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fadd, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsubrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsub, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubr, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmul, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmuls, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fmull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fmulp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fimull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdiv, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivr, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fidivrl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fidivl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivs, Dum.OI [Dum.OE_R 4]), (Dum.O_fprem, Dum.OI_NoEffect),
     (Dum.O_fucom, Dum.OI_NoEffect), (Dum.O_fucomp, Dum.OI_NoEffect),
     (Dum.O_fucompp, Dum.OI_NoEffect), (Dum.O_fcomp, Dum.OI_NoEffect),
     (Dum.O_fcompp, Dum.OI_NoEffect),
     (Dum.O_fcoms, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcoml, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcom, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcomps, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcompl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_ficompl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fnstsw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fnstcw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fldcw, Dum.OI [Dum.OE_R 2]), (Dum.O_fxch, Dum.OI_NoEffect),
     (Dum.O_frndint, Dum.OI_NoEffect), (Dum.O_sahf, Dum.OI_NoEffect),
     (Dum.O_nop, Dum.OI_NoEffect)]
Dum.nonJumpyOpcodes :: [Dum.Opcode]
Dum.nonJumpyOpcodes
  = [Dum.O_pushl, Dum.O_popl, Dum.O_movl, Dum.O_movw, Dum.O_movb,
     Dum.O_andl, Dum.O_andw, Dum.O_andb, Dum.O_orl, Dum.O_orw,
     Dum.O_orb, Dum.O_xorl, Dum.O_xorw, Dum.O_xorb, Dum.O_addl,
     Dum.O_addw, Dum.O_addb, Dum.O_subl, Dum.O_subw, Dum.O_subb,
     Dum.O_incl, Dum.O_incw, Dum.O_incb, Dum.O_decl, Dum.O_decw,
     Dum.O_decb, Dum.O_cmpl, Dum.O_cmpw, Dum.O_cmpb, Dum.O_sall,
     Dum.O_salw, Dum.O_salb, Dum.O_shrl, Dum.O_shrw, Dum.O_shrb,
     Dum.O_sarl, Dum.O_leal, Dum.O_movzbw, Dum.O_movzbl, Dum.O_movzwl,
     Dum.O_movsbw, Dum.O_movsbl, Dum.O_movswl, Dum.O_seta, Dum.O_setae,
     Dum.O_setb, Dum.O_setbe, Dum.O_sete, Dum.O_setne, Dum.O_setl,
     Dum.O_setle, Dum.O_setg, Dum.O_setge, Dum.O_setc, Dum.O_setcb,
     Dum.O_testl, Dum.O_testw, Dum.O_testb, Dum.O_fld1, Dum.O_fcoml,
     Dum.O_fnstsw, Dum.O_fstpl, Dum.O_fstp, Dum.O_fsubrl, Dum.O_fldl,
     Dum.O_faddl, Dum.O_fsubl]

data Dum.Opcode
  = Dum.O_movl |
    Dum.O_movw |
    Dum.O_movb |
    Dum.O_movzbw |
    Dum.O_movzbl |
    Dum.O_movzwl |
    Dum.O_movsbw |
    Dum.O_movsbl |
    Dum.O_movswl |
    Dum.O_pushl |
    Dum.O_popl |
    Dum.O_pushfl |
    Dum.O_popfl |
    Dum.O_notl |
    Dum.O_notw |
    Dum.O_notb |
    Dum.O_sall |
    Dum.O_salw |
    Dum.O_salb |
    Dum.O_sarl |
    Dum.O_sarw |
    Dum.O_sarb |
    Dum.O_shrl |
    Dum.O_shrw |
    Dum.O_shrb |
    Dum.O_roll |
    Dum.O_rolw |
    Dum.O_rolb |
    Dum.O_rorl |
    Dum.O_rorw |
    Dum.O_rorb |
    Dum.O_shldl |
    Dum.O_shrdl |
    Dum.O_addl |
    Dum.O_addw |
    Dum.O_addb |
    Dum.O_adcl |
    Dum.O_subl |
    Dum.O_subw |
    Dum.O_subb |
    Dum.O_sbbl |
    Dum.O_imull |
    Dum.O_imulw |
    Dum.O_imulb |
    Dum.O_mull |
    Dum.O_divl |
    Dum.O_divw |
    Dum.O_divb |
    Dum.O_idivl |
    Dum.O_xorl |
    Dum.O_xorw |
    Dum.O_xorb |
    Dum.O_andl |
    Dum.O_andw |
    Dum.O_andb |
    Dum.O_orl |
    Dum.O_orw |
    Dum.O_orb |
    Dum.O_incl |
    Dum.O_incw |
    Dum.O_incb |
    Dum.O_decl |
    Dum.O_decw |
    Dum.O_decb |
    Dum.O_negl |
    Dum.O_negw |
    Dum.O_negb |
    Dum.O_testl |
    Dum.O_testw |
    Dum.O_testb |
    Dum.O_leal |
    Dum.O_cmpl |
    Dum.O_cmpw |
    Dum.O_cmpb |
    Dum.O_cmpsb |
    Dum.O_scasb |
    Dum.O_movsl |
    Dum.O_movsw |
    Dum.O_movsb |
    Dum.O_stosl |
    Dum.O_stosw |
    Dum.O_stosb |
    Dum.O_leave |
    Dum.O_ret |
    Dum.O_call |
    Dum.O_jmp |
    Dum.O_je |
    Dum.O_jne |
    Dum.O_jl |
    Dum.O_jle |
    Dum.O_jg |
    Dum.O_jge |
    Dum.O_js |
    Dum.O_jns |
    Dum.O_jz |
    Dum.O_jnz |
    Dum.O_jc |
    Dum.O_jnc |
    Dum.O_jo |
    Dum.O_jno |
    Dum.O_ja |
    Dum.O_jae |
    Dum.O_jb |
    Dum.O_jbe |
    Dum.O_jp |
    Dum.O_seta |
    Dum.O_setae |
    Dum.O_setb |
    Dum.O_setbe |
    Dum.O_sete |
    Dum.O_setne |
    Dum.O_setl |
    Dum.O_setle |
    Dum.O_setg |
    Dum.O_setge |
    Dum.O_setc |
    Dum.O_setcb |
    Dum.O_btl |
    Dum.O_btsl |
    Dum.O_btrl |
    Dum.O_btcl |
    Dum.O_cld |
    Dum.O_cltd |
    Dum.O_cwtl |
    Dum.O_cbtw |
    Dum.O_rep |
    Dum.O_repz |
    Dum.O_repnz |
    Dum.O_fild |
    Dum.O_fildl |
    Dum.O_fildll |
    Dum.O_fsubp |
    Dum.O_fsubr |
    Dum.O_fsubrp |
    Dum.O_fsubrl |
    Dum.O_fsubrs |
    Dum.O_fsubs |
    Dum.O_fsubl |
    Dum.O_fsub |
    Dum.O_faddp |
    Dum.O_fadds |
    Dum.O_faddl |
    Dum.O_fadd |
    Dum.O_fiaddl |
    Dum.O_fmul |
    Dum.O_fmuls |
    Dum.O_fmull |
    Dum.O_fmulp |
    Dum.O_fimull |
    Dum.O_fdiv |
    Dum.O_fdivp |
    Dum.O_fdivr |
    Dum.O_fdivrs |
    Dum.O_fdivrl |
    Dum.O_fdivrp |
    Dum.O_fidivl |
    Dum.O_fidivrl |
    Dum.O_fdivl |
    Dum.O_fdivs |
    Dum.O_fprem |
    Dum.O_fstp |
    Dum.O_fsts |
    Dum.O_fstps |
    Dum.O_fstl |
    Dum.O_fstpl |
    Dum.O_fstpt |
    Dum.O_fst |
    Dum.O_fistl |
    Dum.O_fistpl |
    Dum.O_fistpll |
    Dum.O_fld |
    Dum.O_flds |
    Dum.O_fldl |
    Dum.O_fldt |
    Dum.O_fldz |
    Dum.O_fld1 |
    Dum.O_fldl2e |
    Dum.O_fldln2 |
    Dum.O_fchs |
    Dum.O_fsin |
    Dum.O_fcos |
    Dum.O_fptan |
    Dum.O_fsqrt |
    Dum.O_fpatan |
    Dum.O_fabs |
    Dum.O_f2xm1 |
    Dum.O_fscale |
    Dum.O_fyl2x |
    Dum.O_fucom |
    Dum.O_fucomp |
    Dum.O_fucompp |
    Dum.O_fcomp |
    Dum.O_fcompp |
    Dum.O_fcoml |
    Dum.O_fcompl |
    Dum.O_ficompl |
    Dum.O_fcoms |
    Dum.O_fcom |
    Dum.O_fcomps |
    Dum.O_fnstsw |
    Dum.O_fnstcw |
    Dum.O_fldcw |
    Dum.O_frndint |
    Dum.O_fxch |
    Dum.O_sahf |
    Dum.O_nop
  deriving (Show, Eq)
data Dum.OperandEffect
  = Dum.OE_RR Int Int |
    Dum.OE_RM Int Int |
    Dum.OE_RW Int Int |
    Dum.OE_nW Int |
    Dum.OE_RRM Int Int Int |
    Dum.OE_R Int |
    Dum.OE_M Int |
    Dum.OE_W Int
  deriving (Show, Eq)
data Dum.OperandInfo
  = Dum.OI_Special |
    Dum.OI_Jumpy |
    Dum.OI_NoEffect |
    Dum.OI_Error |
    Dum.OI [Dum.OperandEffect]
  deriving (Show, Eq)


["x86info","nonJumpyOpcodes"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Types
import Interval

x86info :: [(Opcode, OperandInfo)]
x86info
  = [(O_movl, OI [OE_RW 4 4]), (O_movw, OI [OE_RW 2 2]),
     (O_movb, OI [OE_RW 1 1]), (O_movzbw, OI [OE_RW 1 2]),
     (O_movzbl, OI [OE_RW 1 4]), (O_movzwl, OI [OE_RW 2 4]),
     (O_movsbw, OI [OE_RW 1 2]), (O_movsbl, OI [OE_RW 1 4]),
     (O_movswl, OI [OE_RW 2 4]), (O_pushl, OI_Special),
     (O_popl, OI_Special), (O_pushfl, OI_Error), (O_popfl, OI_Error),
     (O_sall, OI [OE_RM 1 4]), (O_salw, OI [OE_RM 1 2]),
     (O_salb, OI [OE_RM 1 1]), (O_sarl, OI [OE_RM 1 4]),
     (O_sarw, OI [OE_RM 1 2]), (O_sarb, OI [OE_RM 1 1]),
     (O_shrl, OI [OE_RM 1 4]), (O_shrw, OI [OE_RM 1 2]),
     (O_shrb, OI [OE_RM 1 1]), (O_roll, OI [OE_RM 1 4]),
     (O_rolw, OI [OE_RM 1 2]), (O_rolb, OI [OE_RM 1 1]),
     (O_rorl, OI [OE_RM 1 4]), (O_rorw, OI [OE_RM 1 2]),
     (O_rorb, OI [OE_RM 1 1]), (O_shldl, OI [OE_RRM 4 4 4, OE_RM 4 4]),
     (O_shrdl, OI [OE_RRM 4 4 4, OE_RM 4 4]), (O_addl, OI [OE_RM 4 4]),
     (O_addw, OI [OE_RM 2 2]), (O_addb, OI [OE_RM 1 1]),
     (O_adcl, OI [OE_RM 4 4]), (O_subl, OI [OE_RM 4 4]),
     (O_subw, OI [OE_RM 2 2]), (O_subb, OI [OE_RM 1 1]),
     (O_sbbl, OI [OE_RM 4 4]),
     (O_imull, OI [OE_M 4, OE_RM 4 4, OE_RRM 4 4 4]),
     (O_imulb, OI [OE_M 1]), (O_imulw, OI [OE_M 2, OE_RM 2 2]),
     (O_mull, OI [OE_M 4]), (O_idivl, OI [OE_M 4]),
     (O_divl, OI [OE_M 4]), (O_divw, OI [OE_M 2]),
     (O_divb, OI [OE_M 1]), (O_xorl, OI [OE_RM 4 4]),
     (O_xorw, OI [OE_RM 2 2]), (O_xorb, OI [OE_RM 1 1]),
     (O_andl, OI [OE_RM 4 4]), (O_andw, OI [OE_RM 2 2]),
     (O_andb, OI [OE_RM 1 1]), (O_orl, OI [OE_RM 4 4]),
     (O_orw, OI [OE_RM 2 2]), (O_orb, OI [OE_RM 1 1]),
     (O_incl, OI [OE_M 4]), (O_incw, OI [OE_M 2]),
     (O_incb, OI [OE_M 1]), (O_decl, OI [OE_M 4]),
     (O_decw, OI [OE_M 2]), (O_decb, OI [OE_M 1]),
     (O_negl, OI [OE_M 4]), (O_negw, OI [OE_M 2]),
     (O_negb, OI [OE_M 1]), (O_notl, OI [OE_M 4]),
     (O_notw, OI [OE_M 2]), (O_notb, OI [OE_M 1]),
     (O_testl, OI [OE_RR 4 4]), (O_testw, OI [OE_RR 2 2]),
     (O_testb, OI [OE_RR 1 1]), (O_leal, OI [OE_nW 4]),
     (O_cmpl, OI [OE_RR 4 4]), (O_cmpw, OI [OE_RR 2 2]),
     (O_cmpb, OI [OE_RR 1 1]), (O_cmpsb, OI_Special),
     (O_scasb, OI_Special), (O_movsl, OI_Special),
     (O_movsw, OI_Special), (O_movsb, OI_Special),
     (O_stosl, OI_Special), (O_stosw, OI_Special),
     (O_stosb, OI_Special), (O_leave, OI_Error), (O_ret, OI_Special),
     (O_call, OI_Special), (O_jmp, OI_Jumpy), (O_je, OI_Jumpy),
     (O_jne, OI_Jumpy), (O_jl, OI_Jumpy), (O_jle, OI_Jumpy),
     (O_jg, OI_Jumpy), (O_jge, OI_Jumpy), (O_js, OI_Jumpy),
     (O_jns, OI_Jumpy), (O_jz, OI_Jumpy), (O_jnz, OI_Jumpy),
     (O_jc, OI_Jumpy), (O_jnc, OI_Jumpy), (O_jo, OI_Jumpy),
     (O_jno, OI_Jumpy), (O_ja, OI_Jumpy), (O_jae, OI_Jumpy),
     (O_jb, OI_Jumpy), (O_jbe, OI_Jumpy), (O_jp, OI_Jumpy),
     (O_seta, OI [OE_W 1]), (O_setae, OI [OE_W 1]),
     (O_setb, OI [OE_W 1]), (O_setbe, OI [OE_W 1]),
     (O_sete, OI [OE_W 1]), (O_setne, OI [OE_W 1]),
     (O_setl, OI [OE_W 1]), (O_setle, OI [OE_W 1]),
     (O_setg, OI [OE_W 1]), (O_setge, OI [OE_W 1]),
     (O_setc, OI [OE_W 1]), (O_setcb, OI [OE_W 1]),
     (O_btl, OI [OE_RR 4 4]), (O_btsl, OI [OE_RM 4 4]),
     (O_btcl, OI [OE_RM 4 4]), (O_btrl, OI [OE_RM 4 4]),
     (O_cld, OI_NoEffect), (O_cltd, OI_NoEffect), (O_cwtl, OI_NoEffect),
     (O_cbtw, OI_NoEffect), (O_rep, OI_Error), (O_repz, OI_Error),
     (O_repnz, OI_Error), (O_fld, OI [OE_R 8]), (O_fldt, OI [OE_R 8]),
     (O_fldl, OI [OE_R 8]), (O_flds, OI [OE_R 4]),
     (O_fild, OI [OE_R 4]), (O_fildl, OI [OE_R 4]),
     (O_fildll, OI [OE_R 8]), (O_fstl, OI [OE_W 8]),
     (O_fstpl, OI [OE_W 8]), (O_fstp, OI [OE_W 8]),
     (O_fstps, OI [OE_W 4]), (O_fsts, OI [OE_W 4]),
     (O_fstpt, OI [OE_W 8]), (O_fistl, OI [OE_W 4]),
     (O_fistpl, OI [OE_W 4]), (O_fistpll, OI [OE_W 8]),
     (O_fst, OI [OE_W 8]), (O_fldz, OI_NoEffect), (O_fld1, OI_NoEffect),
     (O_fldl2e, OI_NoEffect), (O_fldln2, OI_NoEffect),
     (O_fchs, OI_NoEffect), (O_fsin, OI_NoEffect),
     (O_fcos, OI_NoEffect), (O_fptan, OI_NoEffect),
     (O_fsqrt, OI_NoEffect), (O_fpatan, OI_NoEffect),
     (O_fabs, OI_NoEffect), (O_f2xm1, OI_NoEffect),
     (O_fscale, OI_NoEffect), (O_fyl2x, OI_NoEffect),
     (O_faddp, OI [OE_R 8, OE_RM 8 8]), (O_fadds, OI [OE_R 4]),
     (O_faddl, OI [OE_R 8]), (O_fiaddl, OI [OE_R 4]),
     (O_fadd, OI [OE_R 8, OE_RM 8 8]), (O_fsubp, OI [OE_RM 8 8]),
     (O_fsubrp, OI [OE_RM 8 8]), (O_fsubrl, OI [OE_R 8]),
     (O_fsubrs, OI [OE_R 4]), (O_fsubs, OI [OE_R 4]),
     (O_fsubl, OI [OE_R 8]), (O_fsub, OI [OE_R 8, OE_RM 8 8]),
     (O_fsubr, OI [OE_R 8, OE_RM 8 8]),
     (O_fmul, OI [OE_R 8, OE_RM 8 8]), (O_fmuls, OI [OE_R 4]),
     (O_fmull, OI [OE_R 8]), (O_fmulp, OI [OE_R 8, OE_RM 8 8]),
     (O_fimull, OI [OE_R 8]), (O_fdiv, OI [OE_RM 8 8]),
     (O_fdivp, OI [OE_RM 8 8]), (O_fdivr, OI [OE_RM 8 8]),
     (O_fdivrl, OI [OE_R 8]), (O_fdivrs, OI [OE_R 4]),
     (O_fdivrp, OI [OE_RM 8 8]), (O_fidivrl, OI [OE_R 4]),
     (O_fidivl, OI [OE_R 4]), (O_fdivl, OI [OE_R 8]),
     (O_fdivs, OI [OE_R 4]), (O_fprem, OI_NoEffect),
     (O_fucom, OI_NoEffect), (O_fucomp, OI_NoEffect),
     (O_fucompp, OI_NoEffect), (O_fcomp, OI_NoEffect),
     (O_fcompp, OI_NoEffect), (O_fcoms, OI [OE_R 4]),
     (O_fcoml, OI [OE_R 8]), (O_fcom, OI [OE_R 8]),
     (O_fcomps, OI [OE_R 4]), (O_fcompl, OI [OE_R 8]),
     (O_ficompl, OI [OE_R 4]), (O_fnstsw, OI [OE_W 2]),
     (O_fnstcw, OI [OE_W 2]), (O_fldcw, OI [OE_R 2]),
     (O_fxch, OI_NoEffect), (O_frndint, OI_NoEffect),
     (O_sahf, OI_NoEffect), (O_nop, OI_NoEffect)]

nonJumpyOpcodes :: [Opcode]
nonJumpyOpcodes
  = [O_pushl, O_popl, O_movl, O_movw, O_movb, O_andl, O_andw, O_andb,
     O_orl, O_orw, O_orb, O_xorl, O_xorw, O_xorb, O_addl, O_addw,
     O_addb, O_subl, O_subw, O_subb, O_incl, O_incw, O_incb, O_decl,
     O_decw, O_decb, O_cmpl, O_cmpw, O_cmpb, O_sall, O_salw, O_salb,
     O_shrl, O_shrw, O_shrb, O_sarl, O_leal, O_movzbw, O_movzbl,
     O_movzwl, O_movsbw, O_movsbl, O_movswl, O_seta, O_setae, O_setb,
     O_setbe, O_sete, O_setne, O_setl, O_setle, O_setg, O_setge, O_setc,
     O_setcb, O_testl, O_testw, O_testb, O_fld1, O_fcoml, O_fnstsw,
     O_fstpl, O_fstp, O_fsubrl, O_fldl, O_faddl, O_fsubl]

data Opcode = O_movl
            | O_movw
            | O_movb
            | O_movzbw
            | O_movzbl
            | O_movzwl
            | O_movsbw
            | O_movsbl
            | O_movswl
            | O_pushl
            | O_popl
            | O_pushfl
            | O_popfl
            | O_notl
            | O_notw
            | O_notb
            | O_sall
            | O_salw
            | O_salb
            | O_sarl
            | O_sarw
            | O_sarb
            | O_shrl
            | O_shrw
            | O_shrb
            | O_roll
            | O_rolw
            | O_rolb
            | O_rorl
            | O_rorw
            | O_rorb
            | O_shldl
            | O_shrdl
            | O_addl
            | O_addw
            | O_addb
            | O_adcl
            | O_subl
            | O_subw
            | O_subb
            | O_sbbl
            | O_imull
            | O_imulw
            | O_imulb
            | O_mull
            | O_divl
            | O_divw
            | O_divb
            | O_idivl
            | O_xorl
            | O_xorw
            | O_xorb
            | O_andl
            | O_andw
            | O_andb
            | O_orl
            | O_orw
            | O_orb
            | O_incl
            | O_incw
            | O_incb
            | O_decl
            | O_decw
            | O_decb
            | O_negl
            | O_negw
            | O_negb
            | O_testl
            | O_testw
            | O_testb
            | O_leal
            | O_cmpl
            | O_cmpw
            | O_cmpb
            | O_cmpsb
            | O_scasb
            | O_movsl
            | O_movsw
            | O_movsb
            | O_stosl
            | O_stosw
            | O_stosb
            | O_leave
            | O_ret
            | O_call
            | O_jmp
            | O_je
            | O_jne
            | O_jl
            | O_jle
            | O_jg
            | O_jge
            | O_js
            | O_jns
            | O_jz
            | O_jnz
            | O_jc
            | O_jnc
            | O_jo
            | O_jno
            | O_ja
            | O_jae
            | O_jb
            | O_jbe
            | O_jp
            | O_seta
            | O_setae
            | O_setb
            | O_setbe
            | O_sete
            | O_setne
            | O_setl
            | O_setle
            | O_setg
            | O_setge
            | O_setc
            | O_setcb
            | O_btl
            | O_btsl
            | O_btrl
            | O_btcl
            | O_cld
            | O_cltd
            | O_cwtl
            | O_cbtw
            | O_rep
            | O_repz
            | O_repnz
            | O_fild
            | O_fildl
            | O_fildll
            | O_fsubp
            | O_fsubr
            | O_fsubrp
            | O_fsubrl
            | O_fsubrs
            | O_fsubs
            | O_fsubl
            | O_fsub
            | O_faddp
            | O_fadds
            | O_faddl
            | O_fadd
            | O_fiaddl
            | O_fmul
            | O_fmuls
            | O_fmull
            | O_fmulp
            | O_fimull
            | O_fdiv
            | O_fdivp
            | O_fdivr
            | O_fdivrs
            | O_fdivrl
            | O_fdivrp
            | O_fidivl
            | O_fidivrl
            | O_fdivl
            | O_fdivs
            | O_fprem
            | O_fstp
            | O_fsts
            | O_fstps
            | O_fstl
            | O_fstpl
            | O_fstpt
            | O_fst
            | O_fistl
            | O_fistpl
            | O_fistpll
            | O_fld
            | O_flds
            | O_fldl
            | O_fldt
            | O_fldz
            | O_fld1
            | O_fldl2e
            | O_fldln2
            | O_fchs
            | O_fsin
            | O_fcos
            | O_fptan
            | O_fsqrt
            | O_fpatan
            | O_fabs
            | O_f2xm1
            | O_fscale
            | O_fyl2x
            | O_fucom
            | O_fucomp
            | O_fucompp
            | O_fcomp
            | O_fcompp
            | O_fcoml
            | O_fcompl
            | O_ficompl
            | O_fcoms
            | O_fcom
            | O_fcomps
            | O_fnstsw
            | O_fnstcw
            | O_fldcw
            | O_frndint
            | O_fxch
            | O_sahf
            | O_nop
            deriving (Show, Eq)

data OperandEffect = OE_RR Int Int
                   | OE_RM Int Int
                   | OE_RW Int Int
                   | OE_nW Int
                   | OE_RRM Int Int Int
                   | OE_R Int
                   | OE_M Int
                   | OE_W Int
                   deriving (Show, Eq)

data OperandInfo = OI_Special
                 | OI_Jumpy
                 | OI_NoEffect
                 | OI_Error
                 | OI [OperandEffect]
                 deriving (Show, Eq)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.x86info :: [(Dum.Opcode, Dum.OperandInfo)]
Dum.x86info
  = [(Dum.O_movl, Dum.OI [Dum.OE_RW 4 4]),
     (Dum.O_movw, Dum.OI [Dum.OE_RW 2 2]),
     (Dum.O_movb, Dum.OI [Dum.OE_RW 1 1]),
     (Dum.O_movzbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movzbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movzwl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_movsbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movsbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movswl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_pushl, Dum.OI_Special), (Dum.O_popl, Dum.OI_Special),
     (Dum.O_pushfl, Dum.OI_Error), (Dum.O_popfl, Dum.OI_Error),
     (Dum.O_sall, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_salw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_salb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sarl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_sarw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_sarb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shrl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_shrw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_shrb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_roll, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rolw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rolb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_rorl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rorw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shldl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_shrdl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_addl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_addw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_addb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_adcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_subb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sbbl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_imull, 
      Dum.OI [Dum.OE_M 4, Dum.OE_RM 4 4, Dum.OE_RRM 4 4 4]),
     (Dum.O_imulb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_imulw, Dum.OI [Dum.OE_M 2, Dum.OE_RM 2 2]),
     (Dum.O_mull, Dum.OI [Dum.OE_M 4]),
     (Dum.O_idivl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_divb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_xorl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_xorw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_xorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_andl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_andw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_andb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_orl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_orw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_orb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_incl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_incw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_incb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_decl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_decw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_decb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_negl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_negw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_negb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_notl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_notw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_notb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_testl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_testw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_testb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_leal, Dum.OI [Dum.OE_nW 4]),
     (Dum.O_cmpl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_cmpw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_cmpb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_cmpsb, Dum.OI_Special), (Dum.O_scasb, Dum.OI_Special),
     (Dum.O_movsl, Dum.OI_Special), (Dum.O_movsw, Dum.OI_Special),
     (Dum.O_movsb, Dum.OI_Special), (Dum.O_stosl, Dum.OI_Special),
     (Dum.O_stosw, Dum.OI_Special), (Dum.O_stosb, Dum.OI_Special),
     (Dum.O_leave, Dum.OI_Error), (Dum.O_ret, Dum.OI_Special),
     (Dum.O_call, Dum.OI_Special), (Dum.O_jmp, Dum.OI_Jumpy),
     (Dum.O_je, Dum.OI_Jumpy), (Dum.O_jne, Dum.OI_Jumpy),
     (Dum.O_jl, Dum.OI_Jumpy), (Dum.O_jle, Dum.OI_Jumpy),
     (Dum.O_jg, Dum.OI_Jumpy), (Dum.O_jge, Dum.OI_Jumpy),
     (Dum.O_js, Dum.OI_Jumpy), (Dum.O_jns, Dum.OI_Jumpy),
     (Dum.O_jz, Dum.OI_Jumpy), (Dum.O_jnz, Dum.OI_Jumpy),
     (Dum.O_jc, Dum.OI_Jumpy), (Dum.O_jnc, Dum.OI_Jumpy),
     (Dum.O_jo, Dum.OI_Jumpy), (Dum.O_jno, Dum.OI_Jumpy),
     (Dum.O_ja, Dum.OI_Jumpy), (Dum.O_jae, Dum.OI_Jumpy),
     (Dum.O_jb, Dum.OI_Jumpy), (Dum.O_jbe, Dum.OI_Jumpy),
     (Dum.O_jp, Dum.OI_Jumpy), (Dum.O_seta, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setae, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setbe, Dum.OI [Dum.OE_W 1]),
     (Dum.O_sete, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setne, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setl, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setle, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setg, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setge, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setc, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setcb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_btl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_btsl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btrl, Dum.OI [Dum.OE_RM 4 4]), (Dum.O_cld, Dum.OI_NoEffect),
     (Dum.O_cltd, Dum.OI_NoEffect), (Dum.O_cwtl, Dum.OI_NoEffect),
     (Dum.O_cbtw, Dum.OI_NoEffect), (Dum.O_rep, Dum.OI_Error),
     (Dum.O_repz, Dum.OI_Error), (Dum.O_repnz, Dum.OI_Error),
     (Dum.O_fld, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldt, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_flds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fild, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildll, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fstl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstpl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstp, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstps, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fsts, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fstpt, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fistl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpll, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fst, Dum.OI [Dum.OE_W 8]), (Dum.O_fldz, Dum.OI_NoEffect),
     (Dum.O_fld1, Dum.OI_NoEffect), (Dum.O_fldl2e, Dum.OI_NoEffect),
     (Dum.O_fldln2, Dum.OI_NoEffect), (Dum.O_fchs, Dum.OI_NoEffect),
     (Dum.O_fsin, Dum.OI_NoEffect), (Dum.O_fcos, Dum.OI_NoEffect),
     (Dum.O_fptan, Dum.OI_NoEffect), (Dum.O_fsqrt, Dum.OI_NoEffect),
     (Dum.O_fpatan, Dum.OI_NoEffect), (Dum.O_fabs, Dum.OI_NoEffect),
     (Dum.O_f2xm1, Dum.OI_NoEffect), (Dum.O_fscale, Dum.OI_NoEffect),
     (Dum.O_fyl2x, Dum.OI_NoEffect),
     (Dum.O_faddp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fadds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_faddl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fiaddl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fadd, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsubrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsub, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubr, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmul, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmuls, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fmull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fmulp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fimull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdiv, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivr, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fidivrl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fidivl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivs, Dum.OI [Dum.OE_R 4]), (Dum.O_fprem, Dum.OI_NoEffect),
     (Dum.O_fucom, Dum.OI_NoEffect), (Dum.O_fucomp, Dum.OI_NoEffect),
     (Dum.O_fucompp, Dum.OI_NoEffect), (Dum.O_fcomp, Dum.OI_NoEffect),
     (Dum.O_fcompp, Dum.OI_NoEffect),
     (Dum.O_fcoms, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcoml, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcom, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcomps, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcompl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_ficompl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fnstsw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fnstcw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fldcw, Dum.OI [Dum.OE_R 2]), (Dum.O_fxch, Dum.OI_NoEffect),
     (Dum.O_frndint, Dum.OI_NoEffect), (Dum.O_sahf, Dum.OI_NoEffect),
     (Dum.O_nop, Dum.OI_NoEffect)]
Dum.nonJumpyOpcodes :: [Dum.Opcode]
Dum.nonJumpyOpcodes
  = [Dum.O_pushl, Dum.O_popl, Dum.O_movl, Dum.O_movw, Dum.O_movb,
     Dum.O_andl, Dum.O_andw, Dum.O_andb, Dum.O_orl, Dum.O_orw,
     Dum.O_orb, Dum.O_xorl, Dum.O_xorw, Dum.O_xorb, Dum.O_addl,
     Dum.O_addw, Dum.O_addb, Dum.O_subl, Dum.O_subw, Dum.O_subb,
     Dum.O_incl, Dum.O_incw, Dum.O_incb, Dum.O_decl, Dum.O_decw,
     Dum.O_decb, Dum.O_cmpl, Dum.O_cmpw, Dum.O_cmpb, Dum.O_sall,
     Dum.O_salw, Dum.O_salb, Dum.O_shrl, Dum.O_shrw, Dum.O_shrb,
     Dum.O_sarl, Dum.O_leal, Dum.O_movzbw, Dum.O_movzbl, Dum.O_movzwl,
     Dum.O_movsbw, Dum.O_movsbl, Dum.O_movswl, Dum.O_seta, Dum.O_setae,
     Dum.O_setb, Dum.O_setbe, Dum.O_sete, Dum.O_setne, Dum.O_setl,
     Dum.O_setle, Dum.O_setg, Dum.O_setge, Dum.O_setc, Dum.O_setcb,
     Dum.O_testl, Dum.O_testw, Dum.O_testb, Dum.O_fld1, Dum.O_fcoml,
     Dum.O_fnstsw, Dum.O_fstpl, Dum.O_fstp, Dum.O_fsubrl, Dum.O_fldl,
     Dum.O_faddl, Dum.O_fsubl]

data Dum.Opcode
  = Dum.O_movl |
    Dum.O_movw |
    Dum.O_movb |
    Dum.O_movzbw |
    Dum.O_movzbl |
    Dum.O_movzwl |
    Dum.O_movsbw |
    Dum.O_movsbl |
    Dum.O_movswl |
    Dum.O_pushl |
    Dum.O_popl |
    Dum.O_pushfl |
    Dum.O_popfl |
    Dum.O_notl |
    Dum.O_notw |
    Dum.O_notb |
    Dum.O_sall |
    Dum.O_salw |
    Dum.O_salb |
    Dum.O_sarl |
    Dum.O_sarw |
    Dum.O_sarb |
    Dum.O_shrl |
    Dum.O_shrw |
    Dum.O_shrb |
    Dum.O_roll |
    Dum.O_rolw |
    Dum.O_rolb |
    Dum.O_rorl |
    Dum.O_rorw |
    Dum.O_rorb |
    Dum.O_shldl |
    Dum.O_shrdl |
    Dum.O_addl |
    Dum.O_addw |
    Dum.O_addb |
    Dum.O_adcl |
    Dum.O_subl |
    Dum.O_subw |
    Dum.O_subb |
    Dum.O_sbbl |
    Dum.O_imull |
    Dum.O_imulw |
    Dum.O_imulb |
    Dum.O_mull |
    Dum.O_divl |
    Dum.O_divw |
    Dum.O_divb |
    Dum.O_idivl |
    Dum.O_xorl |
    Dum.O_xorw |
    Dum.O_xorb |
    Dum.O_andl |
    Dum.O_andw |
    Dum.O_andb |
    Dum.O_orl |
    Dum.O_orw |
    Dum.O_orb |
    Dum.O_incl |
    Dum.O_incw |
    Dum.O_incb |
    Dum.O_decl |
    Dum.O_decw |
    Dum.O_decb |
    Dum.O_negl |
    Dum.O_negw |
    Dum.O_negb |
    Dum.O_testl |
    Dum.O_testw |
    Dum.O_testb |
    Dum.O_leal |
    Dum.O_cmpl |
    Dum.O_cmpw |
    Dum.O_cmpb |
    Dum.O_cmpsb |
    Dum.O_scasb |
    Dum.O_movsl |
    Dum.O_movsw |
    Dum.O_movsb |
    Dum.O_stosl |
    Dum.O_stosw |
    Dum.O_stosb |
    Dum.O_leave |
    Dum.O_ret |
    Dum.O_call |
    Dum.O_jmp |
    Dum.O_je |
    Dum.O_jne |
    Dum.O_jl |
    Dum.O_jle |
    Dum.O_jg |
    Dum.O_jge |
    Dum.O_js |
    Dum.O_jns |
    Dum.O_jz |
    Dum.O_jnz |
    Dum.O_jc |
    Dum.O_jnc |
    Dum.O_jo |
    Dum.O_jno |
    Dum.O_ja |
    Dum.O_jae |
    Dum.O_jb |
    Dum.O_jbe |
    Dum.O_jp |
    Dum.O_seta |
    Dum.O_setae |
    Dum.O_setb |
    Dum.O_setbe |
    Dum.O_sete |
    Dum.O_setne |
    Dum.O_setl |
    Dum.O_setle |
    Dum.O_setg |
    Dum.O_setge |
    Dum.O_setc |
    Dum.O_setcb |
    Dum.O_btl |
    Dum.O_btsl |
    Dum.O_btrl |
    Dum.O_btcl |
    Dum.O_cld |
    Dum.O_cltd |
    Dum.O_cwtl |
    Dum.O_cbtw |
    Dum.O_rep |
    Dum.O_repz |
    Dum.O_repnz |
    Dum.O_fild |
    Dum.O_fildl |
    Dum.O_fildll |
    Dum.O_fsubp |
    Dum.O_fsubr |
    Dum.O_fsubrp |
    Dum.O_fsubrl |
    Dum.O_fsubrs |
    Dum.O_fsubs |
    Dum.O_fsubl |
    Dum.O_fsub |
    Dum.O_faddp |
    Dum.O_fadds |
    Dum.O_faddl |
    Dum.O_fadd |
    Dum.O_fiaddl |
    Dum.O_fmul |
    Dum.O_fmuls |
    Dum.O_fmull |
    Dum.O_fmulp |
    Dum.O_fimull |
    Dum.O_fdiv |
    Dum.O_fdivp |
    Dum.O_fdivr |
    Dum.O_fdivrs |
    Dum.O_fdivrl |
    Dum.O_fdivrp |
    Dum.O_fidivl |
    Dum.O_fidivrl |
    Dum.O_fdivl |
    Dum.O_fdivs |
    Dum.O_fprem |
    Dum.O_fstp |
    Dum.O_fsts |
    Dum.O_fstps |
    Dum.O_fstl |
    Dum.O_fstpl |
    Dum.O_fstpt |
    Dum.O_fst |
    Dum.O_fistl |
    Dum.O_fistpl |
    Dum.O_fistpll |
    Dum.O_fld |
    Dum.O_flds |
    Dum.O_fldl |
    Dum.O_fldt |
    Dum.O_fldz |
    Dum.O_fld1 |
    Dum.O_fldl2e |
    Dum.O_fldln2 |
    Dum.O_fchs |
    Dum.O_fsin |
    Dum.O_fcos |
    Dum.O_fptan |
    Dum.O_fsqrt |
    Dum.O_fpatan |
    Dum.O_fabs |
    Dum.O_f2xm1 |
    Dum.O_fscale |
    Dum.O_fyl2x |
    Dum.O_fucom |
    Dum.O_fucomp |
    Dum.O_fucompp |
    Dum.O_fcomp |
    Dum.O_fcompp |
    Dum.O_fcoml |
    Dum.O_fcompl |
    Dum.O_ficompl |
    Dum.O_fcoms |
    Dum.O_fcom |
    Dum.O_fcomps |
    Dum.O_fnstsw |
    Dum.O_fnstcw |
    Dum.O_fldcw |
    Dum.O_frndint |
    Dum.O_fxch |
    Dum.O_sahf |
    Dum.O_nop
  deriving (Show, Eq)
data Dum.OperandEffect
  = Dum.OE_RR Int Int |
    Dum.OE_RM Int Int |
    Dum.OE_RW Int Int |
    Dum.OE_nW Int |
    Dum.OE_RRM Int Int Int |
    Dum.OE_R Int |
    Dum.OE_M Int |
    Dum.OE_W Int
  deriving (Show, Eq)
data Dum.OperandInfo
  = Dum.OI_Special |
    Dum.OI_Jumpy |
    Dum.OI_NoEffect |
    Dum.OI_Error |
    Dum.OI [Dum.OperandEffect]
  deriving (Show, Eq)


["x86info","nonJumpyOpcodes"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Oct
import Csg
import Types
import Interval

x86info :: [(Opcode, OperandInfo)]
x86info
  = [(O_movl, OI [OE_RW 4 4]), (O_movw, OI [OE_RW 2 2]),
     (O_movb, OI [OE_RW 1 1]), (O_movzbw, OI [OE_RW 1 2]),
     (O_movzbl, OI [OE_RW 1 4]), (O_movzwl, OI [OE_RW 2 4]),
     (O_movsbw, OI [OE_RW 1 2]), (O_movsbl, OI [OE_RW 1 4]),
     (O_movswl, OI [OE_RW 2 4]), (O_pushl, OI_Special),
     (O_popl, OI_Special), (O_pushfl, OI_Error), (O_popfl, OI_Error),
     (O_sall, OI [OE_RM 1 4]), (O_salw, OI [OE_RM 1 2]),
     (O_salb, OI [OE_RM 1 1]), (O_sarl, OI [OE_RM 1 4]),
     (O_sarw, OI [OE_RM 1 2]), (O_sarb, OI [OE_RM 1 1]),
     (O_shrl, OI [OE_RM 1 4]), (O_shrw, OI [OE_RM 1 2]),
     (O_shrb, OI [OE_RM 1 1]), (O_roll, OI [OE_RM 1 4]),
     (O_rolw, OI [OE_RM 1 2]), (O_rolb, OI [OE_RM 1 1]),
     (O_rorl, OI [OE_RM 1 4]), (O_rorw, OI [OE_RM 1 2]),
     (O_rorb, OI [OE_RM 1 1]), (O_shldl, OI [OE_RRM 4 4 4, OE_RM 4 4]),
     (O_shrdl, OI [OE_RRM 4 4 4, OE_RM 4 4]), (O_addl, OI [OE_RM 4 4]),
     (O_addw, OI [OE_RM 2 2]), (O_addb, OI [OE_RM 1 1]),
     (O_adcl, OI [OE_RM 4 4]), (O_subl, OI [OE_RM 4 4]),
     (O_subw, OI [OE_RM 2 2]), (O_subb, OI [OE_RM 1 1]),
     (O_sbbl, OI [OE_RM 4 4]),
     (O_imull, OI [OE_M 4, OE_RM 4 4, OE_RRM 4 4 4]),
     (O_imulb, OI [OE_M 1]), (O_imulw, OI [OE_M 2, OE_RM 2 2]),
     (O_mull, OI [OE_M 4]), (O_idivl, OI [OE_M 4]),
     (O_divl, OI [OE_M 4]), (O_divw, OI [OE_M 2]),
     (O_divb, OI [OE_M 1]), (O_xorl, OI [OE_RM 4 4]),
     (O_xorw, OI [OE_RM 2 2]), (O_xorb, OI [OE_RM 1 1]),
     (O_andl, OI [OE_RM 4 4]), (O_andw, OI [OE_RM 2 2]),
     (O_andb, OI [OE_RM 1 1]), (O_orl, OI [OE_RM 4 4]),
     (O_orw, OI [OE_RM 2 2]), (O_orb, OI [OE_RM 1 1]),
     (O_incl, OI [OE_M 4]), (O_incw, OI [OE_M 2]),
     (O_incb, OI [OE_M 1]), (O_decl, OI [OE_M 4]),
     (O_decw, OI [OE_M 2]), (O_decb, OI [OE_M 1]),
     (O_negl, OI [OE_M 4]), (O_negw, OI [OE_M 2]),
     (O_negb, OI [OE_M 1]), (O_notl, OI [OE_M 4]),
     (O_notw, OI [OE_M 2]), (O_notb, OI [OE_M 1]),
     (O_testl, OI [OE_RR 4 4]), (O_testw, OI [OE_RR 2 2]),
     (O_testb, OI [OE_RR 1 1]), (O_leal, OI [OE_nW 4]),
     (O_cmpl, OI [OE_RR 4 4]), (O_cmpw, OI [OE_RR 2 2]),
     (O_cmpb, OI [OE_RR 1 1]), (O_cmpsb, OI_Special),
     (O_scasb, OI_Special), (O_movsl, OI_Special),
     (O_movsw, OI_Special), (O_movsb, OI_Special),
     (O_stosl, OI_Special), (O_stosw, OI_Special),
     (O_stosb, OI_Special), (O_leave, OI_Error), (O_ret, OI_Special),
     (O_call, OI_Special), (O_jmp, OI_Jumpy), (O_je, OI_Jumpy),
     (O_jne, OI_Jumpy), (O_jl, OI_Jumpy), (O_jle, OI_Jumpy),
     (O_jg, OI_Jumpy), (O_jge, OI_Jumpy), (O_js, OI_Jumpy),
     (O_jns, OI_Jumpy), (O_jz, OI_Jumpy), (O_jnz, OI_Jumpy),
     (O_jc, OI_Jumpy), (O_jnc, OI_Jumpy), (O_jo, OI_Jumpy),
     (O_jno, OI_Jumpy), (O_ja, OI_Jumpy), (O_jae, OI_Jumpy),
     (O_jb, OI_Jumpy), (O_jbe, OI_Jumpy), (O_jp, OI_Jumpy),
     (O_seta, OI [OE_W 1]), (O_setae, OI [OE_W 1]),
     (O_setb, OI [OE_W 1]), (O_setbe, OI [OE_W 1]),
     (O_sete, OI [OE_W 1]), (O_setne, OI [OE_W 1]),
     (O_setl, OI [OE_W 1]), (O_setle, OI [OE_W 1]),
     (O_setg, OI [OE_W 1]), (O_setge, OI [OE_W 1]),
     (O_setc, OI [OE_W 1]), (O_setcb, OI [OE_W 1]),
     (O_btl, OI [OE_RR 4 4]), (O_btsl, OI [OE_RM 4 4]),
     (O_btcl, OI [OE_RM 4 4]), (O_btrl, OI [OE_RM 4 4]),
     (O_cld, OI_NoEffect), (O_cltd, OI_NoEffect), (O_cwtl, OI_NoEffect),
     (O_cbtw, OI_NoEffect), (O_rep, OI_Error), (O_repz, OI_Error),
     (O_repnz, OI_Error), (O_fld, OI [OE_R 8]), (O_fldt, OI [OE_R 8]),
     (O_fldl, OI [OE_R 8]), (O_flds, OI [OE_R 4]),
     (O_fild, OI [OE_R 4]), (O_fildl, OI [OE_R 4]),
     (O_fildll, OI [OE_R 8]), (O_fstl, OI [OE_W 8]),
     (O_fstpl, OI [OE_W 8]), (O_fstp, OI [OE_W 8]),
     (O_fstps, OI [OE_W 4]), (O_fsts, OI [OE_W 4]),
     (O_fstpt, OI [OE_W 8]), (O_fistl, OI [OE_W 4]),
     (O_fistpl, OI [OE_W 4]), (O_fistpll, OI [OE_W 8]),
     (O_fst, OI [OE_W 8]), (O_fldz, OI_NoEffect), (O_fld1, OI_NoEffect),
     (O_fldl2e, OI_NoEffect), (O_fldln2, OI_NoEffect),
     (O_fchs, OI_NoEffect), (O_fsin, OI_NoEffect),
     (O_fcos, OI_NoEffect), (O_fptan, OI_NoEffect),
     (O_fsqrt, OI_NoEffect), (O_fpatan, OI_NoEffect),
     (O_fabs, OI_NoEffect), (O_f2xm1, OI_NoEffect),
     (O_fscale, OI_NoEffect), (O_fyl2x, OI_NoEffect),
     (O_faddp, OI [OE_R 8, OE_RM 8 8]), (O_fadds, OI [OE_R 4]),
     (O_faddl, OI [OE_R 8]), (O_fiaddl, OI [OE_R 4]),
     (O_fadd, OI [OE_R 8, OE_RM 8 8]), (O_fsubp, OI [OE_RM 8 8]),
     (O_fsubrp, OI [OE_RM 8 8]), (O_fsubrl, OI [OE_R 8]),
     (O_fsubrs, OI [OE_R 4]), (O_fsubs, OI [OE_R 4]),
     (O_fsubl, OI [OE_R 8]), (O_fsub, OI [OE_R 8, OE_RM 8 8]),
     (O_fsubr, OI [OE_R 8, OE_RM 8 8]),
     (O_fmul, OI [OE_R 8, OE_RM 8 8]), (O_fmuls, OI [OE_R 4]),
     (O_fmull, OI [OE_R 8]), (O_fmulp, OI [OE_R 8, OE_RM 8 8]),
     (O_fimull, OI [OE_R 8]), (O_fdiv, OI [OE_RM 8 8]),
     (O_fdivp, OI [OE_RM 8 8]), (O_fdivr, OI [OE_RM 8 8]),
     (O_fdivrl, OI [OE_R 8]), (O_fdivrs, OI [OE_R 4]),
     (O_fdivrp, OI [OE_RM 8 8]), (O_fidivrl, OI [OE_R 4]),
     (O_fidivl, OI [OE_R 4]), (O_fdivl, OI [OE_R 8]),
     (O_fdivs, OI [OE_R 4]), (O_fprem, OI_NoEffect),
     (O_fucom, OI_NoEffect), (O_fucomp, OI_NoEffect),
     (O_fucompp, OI_NoEffect), (O_fcomp, OI_NoEffect),
     (O_fcompp, OI_NoEffect), (O_fcoms, OI [OE_R 4]),
     (O_fcoml, OI [OE_R 8]), (O_fcom, OI [OE_R 8]),
     (O_fcomps, OI [OE_R 4]), (O_fcompl, OI [OE_R 8]),
     (O_ficompl, OI [OE_R 4]), (O_fnstsw, OI [OE_W 2]),
     (O_fnstcw, OI [OE_W 2]), (O_fldcw, OI [OE_R 2]),
     (O_fxch, OI_NoEffect), (O_frndint, OI_NoEffect),
     (O_sahf, OI_NoEffect), (O_nop, OI_NoEffect)]

nonJumpyOpcodes :: [Opcode]
nonJumpyOpcodes
  = [O_pushl, O_popl, O_movl, O_movw, O_movb, O_andl, O_andw, O_andb,
     O_orl, O_orw, O_orb, O_xorl, O_xorw, O_xorb, O_addl, O_addw,
     O_addb, O_subl, O_subw, O_subb, O_incl, O_incw, O_incb, O_decl,
     O_decw, O_decb, O_cmpl, O_cmpw, O_cmpb, O_sall, O_salw, O_salb,
     O_shrl, O_shrw, O_shrb, O_sarl, O_leal, O_movzbw, O_movzbl,
     O_movzwl, O_movsbw, O_movsbl, O_movswl, O_seta, O_setae, O_setb,
     O_setbe, O_sete, O_setne, O_setl, O_setle, O_setg, O_setge, O_setc,
     O_setcb, O_testl, O_testw, O_testb, O_fld1, O_fcoml, O_fnstsw,
     O_fstpl, O_fstp, O_fsubrl, O_fldl, O_faddl, O_fsubl]

data Opcode = O_movl
            | O_movw
            | O_movb
            | O_movzbw
            | O_movzbl
            | O_movzwl
            | O_movsbw
            | O_movsbl
            | O_movswl
            | O_pushl
            | O_popl
            | O_pushfl
            | O_popfl
            | O_notl
            | O_notw
            | O_notb
            | O_sall
            | O_salw
            | O_salb
            | O_sarl
            | O_sarw
            | O_sarb
            | O_shrl
            | O_shrw
            | O_shrb
            | O_roll
            | O_rolw
            | O_rolb
            | O_rorl
            | O_rorw
            | O_rorb
            | O_shldl
            | O_shrdl
            | O_addl
            | O_addw
            | O_addb
            | O_adcl
            | O_subl
            | O_subw
            | O_subb
            | O_sbbl
            | O_imull
            | O_imulw
            | O_imulb
            | O_mull
            | O_divl
            | O_divw
            | O_divb
            | O_idivl
            | O_xorl
            | O_xorw
            | O_xorb
            | O_andl
            | O_andw
            | O_andb
            | O_orl
            | O_orw
            | O_orb
            | O_incl
            | O_incw
            | O_incb
            | O_decl
            | O_decw
            | O_decb
            | O_negl
            | O_negw
            | O_negb
            | O_testl
            | O_testw
            | O_testb
            | O_leal
            | O_cmpl
            | O_cmpw
            | O_cmpb
            | O_cmpsb
            | O_scasb
            | O_movsl
            | O_movsw
            | O_movsb
            | O_stosl
            | O_stosw
            | O_stosb
            | O_leave
            | O_ret
            | O_call
            | O_jmp
            | O_je
            | O_jne
            | O_jl
            | O_jle
            | O_jg
            | O_jge
            | O_js
            | O_jns
            | O_jz
            | O_jnz
            | O_jc
            | O_jnc
            | O_jo
            | O_jno
            | O_ja
            | O_jae
            | O_jb
            | O_jbe
            | O_jp
            | O_seta
            | O_setae
            | O_setb
            | O_setbe
            | O_sete
            | O_setne
            | O_setl
            | O_setle
            | O_setg
            | O_setge
            | O_setc
            | O_setcb
            | O_btl
            | O_btsl
            | O_btrl
            | O_btcl
            | O_cld
            | O_cltd
            | O_cwtl
            | O_cbtw
            | O_rep
            | O_repz
            | O_repnz
            | O_fild
            | O_fildl
            | O_fildll
            | O_fsubp
            | O_fsubr
            | O_fsubrp
            | O_fsubrl
            | O_fsubrs
            | O_fsubs
            | O_fsubl
            | O_fsub
            | O_faddp
            | O_fadds
            | O_faddl
            | O_fadd
            | O_fiaddl
            | O_fmul
            | O_fmuls
            | O_fmull
            | O_fmulp
            | O_fimull
            | O_fdiv
            | O_fdivp
            | O_fdivr
            | O_fdivrs
            | O_fdivrl
            | O_fdivrp
            | O_fidivl
            | O_fidivrl
            | O_fdivl
            | O_fdivs
            | O_fprem
            | O_fstp
            | O_fsts
            | O_fstps
            | O_fstl
            | O_fstpl
            | O_fstpt
            | O_fst
            | O_fistl
            | O_fistpl
            | O_fistpll
            | O_fld
            | O_flds
            | O_fldl
            | O_fldt
            | O_fldz
            | O_fld1
            | O_fldl2e
            | O_fldln2
            | O_fchs
            | O_fsin
            | O_fcos
            | O_fptan
            | O_fsqrt
            | O_fpatan
            | O_fabs
            | O_f2xm1
            | O_fscale
            | O_fyl2x
            | O_fucom
            | O_fucomp
            | O_fucompp
            | O_fcomp
            | O_fcompp
            | O_fcoml
            | O_fcompl
            | O_ficompl
            | O_fcoms
            | O_fcom
            | O_fcomps
            | O_fnstsw
            | O_fnstcw
            | O_fldcw
            | O_frndint
            | O_fxch
            | O_sahf
            | O_nop
            deriving (Show, Eq)

data OperandEffect = OE_RR Int Int
                   | OE_RM Int Int
                   | OE_RW Int Int
                   | OE_nW Int
                   | OE_RRM Int Int Int
                   | OE_R Int
                   | OE_M Int
                   | OE_W Int
                   deriving (Show, Eq)

data OperandInfo = OI_Special
                 | OI_Jumpy
                 | OI_NoEffect
                 | OI_Error
                 | OI [OperandEffect]
                 deriving (Show, Eq)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.x86info :: [(Dum.Opcode, Dum.OperandInfo)]
Dum.x86info
  = [(Dum.O_movl, Dum.OI [Dum.OE_RW 4 4]),
     (Dum.O_movw, Dum.OI [Dum.OE_RW 2 2]),
     (Dum.O_movb, Dum.OI [Dum.OE_RW 1 1]),
     (Dum.O_movzbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movzbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movzwl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_movsbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movsbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movswl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_pushl, Dum.OI_Special), (Dum.O_popl, Dum.OI_Special),
     (Dum.O_pushfl, Dum.OI_Error), (Dum.O_popfl, Dum.OI_Error),
     (Dum.O_sall, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_salw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_salb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sarl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_sarw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_sarb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shrl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_shrw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_shrb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_roll, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rolw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rolb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_rorl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rorw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shldl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_shrdl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_addl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_addw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_addb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_adcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_subb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sbbl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_imull, 
      Dum.OI [Dum.OE_M 4, Dum.OE_RM 4 4, Dum.OE_RRM 4 4 4]),
     (Dum.O_imulb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_imulw, Dum.OI [Dum.OE_M 2, Dum.OE_RM 2 2]),
     (Dum.O_mull, Dum.OI [Dum.OE_M 4]),
     (Dum.O_idivl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_divb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_xorl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_xorw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_xorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_andl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_andw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_andb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_orl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_orw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_orb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_incl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_incw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_incb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_decl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_decw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_decb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_negl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_negw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_negb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_notl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_notw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_notb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_testl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_testw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_testb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_leal, Dum.OI [Dum.OE_nW 4]),
     (Dum.O_cmpl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_cmpw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_cmpb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_cmpsb, Dum.OI_Special), (Dum.O_scasb, Dum.OI_Special),
     (Dum.O_movsl, Dum.OI_Special), (Dum.O_movsw, Dum.OI_Special),
     (Dum.O_movsb, Dum.OI_Special), (Dum.O_stosl, Dum.OI_Special),
     (Dum.O_stosw, Dum.OI_Special), (Dum.O_stosb, Dum.OI_Special),
     (Dum.O_leave, Dum.OI_Error), (Dum.O_ret, Dum.OI_Special),
     (Dum.O_call, Dum.OI_Special), (Dum.O_jmp, Dum.OI_Jumpy),
     (Dum.O_je, Dum.OI_Jumpy), (Dum.O_jne, Dum.OI_Jumpy),
     (Dum.O_jl, Dum.OI_Jumpy), (Dum.O_jle, Dum.OI_Jumpy),
     (Dum.O_jg, Dum.OI_Jumpy), (Dum.O_jge, Dum.OI_Jumpy),
     (Dum.O_js, Dum.OI_Jumpy), (Dum.O_jns, Dum.OI_Jumpy),
     (Dum.O_jz, Dum.OI_Jumpy), (Dum.O_jnz, Dum.OI_Jumpy),
     (Dum.O_jc, Dum.OI_Jumpy), (Dum.O_jnc, Dum.OI_Jumpy),
     (Dum.O_jo, Dum.OI_Jumpy), (Dum.O_jno, Dum.OI_Jumpy),
     (Dum.O_ja, Dum.OI_Jumpy), (Dum.O_jae, Dum.OI_Jumpy),
     (Dum.O_jb, Dum.OI_Jumpy), (Dum.O_jbe, Dum.OI_Jumpy),
     (Dum.O_jp, Dum.OI_Jumpy), (Dum.O_seta, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setae, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setbe, Dum.OI [Dum.OE_W 1]),
     (Dum.O_sete, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setne, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setl, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setle, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setg, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setge, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setc, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setcb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_btl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_btsl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btrl, Dum.OI [Dum.OE_RM 4 4]), (Dum.O_cld, Dum.OI_NoEffect),
     (Dum.O_cltd, Dum.OI_NoEffect), (Dum.O_cwtl, Dum.OI_NoEffect),
     (Dum.O_cbtw, Dum.OI_NoEffect), (Dum.O_rep, Dum.OI_Error),
     (Dum.O_repz, Dum.OI_Error), (Dum.O_repnz, Dum.OI_Error),
     (Dum.O_fld, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldt, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_flds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fild, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildll, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fstl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstpl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstp, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstps, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fsts, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fstpt, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fistl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpll, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fst, Dum.OI [Dum.OE_W 8]), (Dum.O_fldz, Dum.OI_NoEffect),
     (Dum.O_fld1, Dum.OI_NoEffect), (Dum.O_fldl2e, Dum.OI_NoEffect),
     (Dum.O_fldln2, Dum.OI_NoEffect), (Dum.O_fchs, Dum.OI_NoEffect),
     (Dum.O_fsin, Dum.OI_NoEffect), (Dum.O_fcos, Dum.OI_NoEffect),
     (Dum.O_fptan, Dum.OI_NoEffect), (Dum.O_fsqrt, Dum.OI_NoEffect),
     (Dum.O_fpatan, Dum.OI_NoEffect), (Dum.O_fabs, Dum.OI_NoEffect),
     (Dum.O_f2xm1, Dum.OI_NoEffect), (Dum.O_fscale, Dum.OI_NoEffect),
     (Dum.O_fyl2x, Dum.OI_NoEffect),
     (Dum.O_faddp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fadds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_faddl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fiaddl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fadd, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsubrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsub, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubr, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmul, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmuls, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fmull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fmulp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fimull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdiv, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivr, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fidivrl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fidivl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivs, Dum.OI [Dum.OE_R 4]), (Dum.O_fprem, Dum.OI_NoEffect),
     (Dum.O_fucom, Dum.OI_NoEffect), (Dum.O_fucomp, Dum.OI_NoEffect),
     (Dum.O_fucompp, Dum.OI_NoEffect), (Dum.O_fcomp, Dum.OI_NoEffect),
     (Dum.O_fcompp, Dum.OI_NoEffect),
     (Dum.O_fcoms, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcoml, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcom, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcomps, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcompl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_ficompl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fnstsw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fnstcw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fldcw, Dum.OI [Dum.OE_R 2]), (Dum.O_fxch, Dum.OI_NoEffect),
     (Dum.O_frndint, Dum.OI_NoEffect), (Dum.O_sahf, Dum.OI_NoEffect),
     (Dum.O_nop, Dum.OI_NoEffect)]
Dum.nonJumpyOpcodes :: [Dum.Opcode]
Dum.nonJumpyOpcodes
  = [Dum.O_pushl, Dum.O_popl, Dum.O_movl, Dum.O_movw, Dum.O_movb,
     Dum.O_andl, Dum.O_andw, Dum.O_andb, Dum.O_orl, Dum.O_orw,
     Dum.O_orb, Dum.O_xorl, Dum.O_xorw, Dum.O_xorb, Dum.O_addl,
     Dum.O_addw, Dum.O_addb, Dum.O_subl, Dum.O_subw, Dum.O_subb,
     Dum.O_incl, Dum.O_incw, Dum.O_incb, Dum.O_decl, Dum.O_decw,
     Dum.O_decb, Dum.O_cmpl, Dum.O_cmpw, Dum.O_cmpb, Dum.O_sall,
     Dum.O_salw, Dum.O_salb, Dum.O_shrl, Dum.O_shrw, Dum.O_shrb,
     Dum.O_sarl, Dum.O_leal, Dum.O_movzbw, Dum.O_movzbl, Dum.O_movzwl,
     Dum.O_movsbw, Dum.O_movsbl, Dum.O_movswl, Dum.O_seta, Dum.O_setae,
     Dum.O_setb, Dum.O_setbe, Dum.O_sete, Dum.O_setne, Dum.O_setl,
     Dum.O_setle, Dum.O_setg, Dum.O_setge, Dum.O_setc, Dum.O_setcb,
     Dum.O_testl, Dum.O_testw, Dum.O_testb, Dum.O_fld1, Dum.O_fcoml,
     Dum.O_fnstsw, Dum.O_fstpl, Dum.O_fstp, Dum.O_fsubrl, Dum.O_fldl,
     Dum.O_faddl, Dum.O_fsubl]

data Dum.Opcode
  = Dum.O_movl |
    Dum.O_movw |
    Dum.O_movb |
    Dum.O_movzbw |
    Dum.O_movzbl |
    Dum.O_movzwl |
    Dum.O_movsbw |
    Dum.O_movsbl |
    Dum.O_movswl |
    Dum.O_pushl |
    Dum.O_popl |
    Dum.O_pushfl |
    Dum.O_popfl |
    Dum.O_notl |
    Dum.O_notw |
    Dum.O_notb |
    Dum.O_sall |
    Dum.O_salw |
    Dum.O_salb |
    Dum.O_sarl |
    Dum.O_sarw |
    Dum.O_sarb |
    Dum.O_shrl |
    Dum.O_shrw |
    Dum.O_shrb |
    Dum.O_roll |
    Dum.O_rolw |
    Dum.O_rolb |
    Dum.O_rorl |
    Dum.O_rorw |
    Dum.O_rorb |
    Dum.O_shldl |
    Dum.O_shrdl |
    Dum.O_addl |
    Dum.O_addw |
    Dum.O_addb |
    Dum.O_adcl |
    Dum.O_subl |
    Dum.O_subw |
    Dum.O_subb |
    Dum.O_sbbl |
    Dum.O_imull |
    Dum.O_imulw |
    Dum.O_imulb |
    Dum.O_mull |
    Dum.O_divl |
    Dum.O_divw |
    Dum.O_divb |
    Dum.O_idivl |
    Dum.O_xorl |
    Dum.O_xorw |
    Dum.O_xorb |
    Dum.O_andl |
    Dum.O_andw |
    Dum.O_andb |
    Dum.O_orl |
    Dum.O_orw |
    Dum.O_orb |
    Dum.O_incl |
    Dum.O_incw |
    Dum.O_incb |
    Dum.O_decl |
    Dum.O_decw |
    Dum.O_decb |
    Dum.O_negl |
    Dum.O_negw |
    Dum.O_negb |
    Dum.O_testl |
    Dum.O_testw |
    Dum.O_testb |
    Dum.O_leal |
    Dum.O_cmpl |
    Dum.O_cmpw |
    Dum.O_cmpb |
    Dum.O_cmpsb |
    Dum.O_scasb |
    Dum.O_movsl |
    Dum.O_movsw |
    Dum.O_movsb |
    Dum.O_stosl |
    Dum.O_stosw |
    Dum.O_stosb |
    Dum.O_leave |
    Dum.O_ret |
    Dum.O_call |
    Dum.O_jmp |
    Dum.O_je |
    Dum.O_jne |
    Dum.O_jl |
    Dum.O_jle |
    Dum.O_jg |
    Dum.O_jge |
    Dum.O_js |
    Dum.O_jns |
    Dum.O_jz |
    Dum.O_jnz |
    Dum.O_jc |
    Dum.O_jnc |
    Dum.O_jo |
    Dum.O_jno |
    Dum.O_ja |
    Dum.O_jae |
    Dum.O_jb |
    Dum.O_jbe |
    Dum.O_jp |
    Dum.O_seta |
    Dum.O_setae |
    Dum.O_setb |
    Dum.O_setbe |
    Dum.O_sete |
    Dum.O_setne |
    Dum.O_setl |
    Dum.O_setle |
    Dum.O_setg |
    Dum.O_setge |
    Dum.O_setc |
    Dum.O_setcb |
    Dum.O_btl |
    Dum.O_btsl |
    Dum.O_btrl |
    Dum.O_btcl |
    Dum.O_cld |
    Dum.O_cltd |
    Dum.O_cwtl |
    Dum.O_cbtw |
    Dum.O_rep |
    Dum.O_repz |
    Dum.O_repnz |
    Dum.O_fild |
    Dum.O_fildl |
    Dum.O_fildll |
    Dum.O_fsubp |
    Dum.O_fsubr |
    Dum.O_fsubrp |
    Dum.O_fsubrl |
    Dum.O_fsubrs |
    Dum.O_fsubs |
    Dum.O_fsubl |
    Dum.O_fsub |
    Dum.O_faddp |
    Dum.O_fadds |
    Dum.O_faddl |
    Dum.O_fadd |
    Dum.O_fiaddl |
    Dum.O_fmul |
    Dum.O_fmuls |
    Dum.O_fmull |
    Dum.O_fmulp |
    Dum.O_fimull |
    Dum.O_fdiv |
    Dum.O_fdivp |
    Dum.O_fdivr |
    Dum.O_fdivrs |
    Dum.O_fdivrl |
    Dum.O_fdivrp |
    Dum.O_fidivl |
    Dum.O_fidivrl |
    Dum.O_fdivl |
    Dum.O_fdivs |
    Dum.O_fprem |
    Dum.O_fstp |
    Dum.O_fsts |
    Dum.O_fstps |
    Dum.O_fstl |
    Dum.O_fstpl |
    Dum.O_fstpt |
    Dum.O_fst |
    Dum.O_fistl |
    Dum.O_fistpl |
    Dum.O_fistpll |
    Dum.O_fld |
    Dum.O_flds |
    Dum.O_fldl |
    Dum.O_fldt |
    Dum.O_fldz |
    Dum.O_fld1 |
    Dum.O_fldl2e |
    Dum.O_fldln2 |
    Dum.O_fchs |
    Dum.O_fsin |
    Dum.O_fcos |
    Dum.O_fptan |
    Dum.O_fsqrt |
    Dum.O_fpatan |
    Dum.O_fabs |
    Dum.O_f2xm1 |
    Dum.O_fscale |
    Dum.O_fyl2x |
    Dum.O_fucom |
    Dum.O_fucomp |
    Dum.O_fucompp |
    Dum.O_fcomp |
    Dum.O_fcompp |
    Dum.O_fcoml |
    Dum.O_fcompl |
    Dum.O_ficompl |
    Dum.O_fcoms |
    Dum.O_fcom |
    Dum.O_fcomps |
    Dum.O_fnstsw |
    Dum.O_fnstcw |
    Dum.O_fldcw |
    Dum.O_frndint |
    Dum.O_fxch |
    Dum.O_sahf |
    Dum.O_nop
  deriving (Show, Eq)
data Dum.OperandEffect
  = Dum.OE_RR Int Int |
    Dum.OE_RM Int Int |
    Dum.OE_RW Int Int |
    Dum.OE_nW Int |
    Dum.OE_RRM Int Int Int |
    Dum.OE_R Int |
    Dum.OE_M Int |
    Dum.OE_W Int
  deriving (Show, Eq)
data Dum.OperandInfo
  = Dum.OI_Special |
    Dum.OI_Jumpy |
    Dum.OI_NoEffect |
    Dum.OI_Error |
    Dum.OI [Dum.OperandEffect]
  deriving (Show, Eq)


["x86info","nonJumpyOpcodes"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Types
import Interval

x86info :: [(Opcode, OperandInfo)]
x86info
  = [(O_movl, OI [OE_RW 4 4]), (O_movw, OI [OE_RW 2 2]),
     (O_movb, OI [OE_RW 1 1]), (O_movzbw, OI [OE_RW 1 2]),
     (O_movzbl, OI [OE_RW 1 4]), (O_movzwl, OI [OE_RW 2 4]),
     (O_movsbw, OI [OE_RW 1 2]), (O_movsbl, OI [OE_RW 1 4]),
     (O_movswl, OI [OE_RW 2 4]), (O_pushl, OI_Special),
     (O_popl, OI_Special), (O_pushfl, OI_Error), (O_popfl, OI_Error),
     (O_sall, OI [OE_RM 1 4]), (O_salw, OI [OE_RM 1 2]),
     (O_salb, OI [OE_RM 1 1]), (O_sarl, OI [OE_RM 1 4]),
     (O_sarw, OI [OE_RM 1 2]), (O_sarb, OI [OE_RM 1 1]),
     (O_shrl, OI [OE_RM 1 4]), (O_shrw, OI [OE_RM 1 2]),
     (O_shrb, OI [OE_RM 1 1]), (O_roll, OI [OE_RM 1 4]),
     (O_rolw, OI [OE_RM 1 2]), (O_rolb, OI [OE_RM 1 1]),
     (O_rorl, OI [OE_RM 1 4]), (O_rorw, OI [OE_RM 1 2]),
     (O_rorb, OI [OE_RM 1 1]), (O_shldl, OI [OE_RRM 4 4 4, OE_RM 4 4]),
     (O_shrdl, OI [OE_RRM 4 4 4, OE_RM 4 4]), (O_addl, OI [OE_RM 4 4]),
     (O_addw, OI [OE_RM 2 2]), (O_addb, OI [OE_RM 1 1]),
     (O_adcl, OI [OE_RM 4 4]), (O_subl, OI [OE_RM 4 4]),
     (O_subw, OI [OE_RM 2 2]), (O_subb, OI [OE_RM 1 1]),
     (O_sbbl, OI [OE_RM 4 4]),
     (O_imull, OI [OE_M 4, OE_RM 4 4, OE_RRM 4 4 4]),
     (O_imulb, OI [OE_M 1]), (O_imulw, OI [OE_M 2, OE_RM 2 2]),
     (O_mull, OI [OE_M 4]), (O_idivl, OI [OE_M 4]),
     (O_divl, OI [OE_M 4]), (O_divw, OI [OE_M 2]),
     (O_divb, OI [OE_M 1]), (O_xorl, OI [OE_RM 4 4]),
     (O_xorw, OI [OE_RM 2 2]), (O_xorb, OI [OE_RM 1 1]),
     (O_andl, OI [OE_RM 4 4]), (O_andw, OI [OE_RM 2 2]),
     (O_andb, OI [OE_RM 1 1]), (O_orl, OI [OE_RM 4 4]),
     (O_orw, OI [OE_RM 2 2]), (O_orb, OI [OE_RM 1 1]),
     (O_incl, OI [OE_M 4]), (O_incw, OI [OE_M 2]),
     (O_incb, OI [OE_M 1]), (O_decl, OI [OE_M 4]),
     (O_decw, OI [OE_M 2]), (O_decb, OI [OE_M 1]),
     (O_negl, OI [OE_M 4]), (O_negw, OI [OE_M 2]),
     (O_negb, OI [OE_M 1]), (O_notl, OI [OE_M 4]),
     (O_notw, OI [OE_M 2]), (O_notb, OI [OE_M 1]),
     (O_testl, OI [OE_RR 4 4]), (O_testw, OI [OE_RR 2 2]),
     (O_testb, OI [OE_RR 1 1]), (O_leal, OI [OE_nW 4]),
     (O_cmpl, OI [OE_RR 4 4]), (O_cmpw, OI [OE_RR 2 2]),
     (O_cmpb, OI [OE_RR 1 1]), (O_cmpsb, OI_Special),
     (O_scasb, OI_Special), (O_movsl, OI_Special),
     (O_movsw, OI_Special), (O_movsb, OI_Special),
     (O_stosl, OI_Special), (O_stosw, OI_Special),
     (O_stosb, OI_Special), (O_leave, OI_Error), (O_ret, OI_Special),
     (O_call, OI_Special), (O_jmp, OI_Jumpy), (O_je, OI_Jumpy),
     (O_jne, OI_Jumpy), (O_jl, OI_Jumpy), (O_jle, OI_Jumpy),
     (O_jg, OI_Jumpy), (O_jge, OI_Jumpy), (O_js, OI_Jumpy),
     (O_jns, OI_Jumpy), (O_jz, OI_Jumpy), (O_jnz, OI_Jumpy),
     (O_jc, OI_Jumpy), (O_jnc, OI_Jumpy), (O_jo, OI_Jumpy),
     (O_jno, OI_Jumpy), (O_ja, OI_Jumpy), (O_jae, OI_Jumpy),
     (O_jb, OI_Jumpy), (O_jbe, OI_Jumpy), (O_jp, OI_Jumpy),
     (O_seta, OI [OE_W 1]), (O_setae, OI [OE_W 1]),
     (O_setb, OI [OE_W 1]), (O_setbe, OI [OE_W 1]),
     (O_sete, OI [OE_W 1]), (O_setne, OI [OE_W 1]),
     (O_setl, OI [OE_W 1]), (O_setle, OI [OE_W 1]),
     (O_setg, OI [OE_W 1]), (O_setge, OI [OE_W 1]),
     (O_setc, OI [OE_W 1]), (O_setcb, OI [OE_W 1]),
     (O_btl, OI [OE_RR 4 4]), (O_btsl, OI [OE_RM 4 4]),
     (O_btcl, OI [OE_RM 4 4]), (O_btrl, OI [OE_RM 4 4]),
     (O_cld, OI_NoEffect), (O_cltd, OI_NoEffect), (O_cwtl, OI_NoEffect),
     (O_cbtw, OI_NoEffect), (O_rep, OI_Error), (O_repz, OI_Error),
     (O_repnz, OI_Error), (O_fld, OI [OE_R 8]), (O_fldt, OI [OE_R 8]),
     (O_fldl, OI [OE_R 8]), (O_flds, OI [OE_R 4]),
     (O_fild, OI [OE_R 4]), (O_fildl, OI [OE_R 4]),
     (O_fildll, OI [OE_R 8]), (O_fstl, OI [OE_W 8]),
     (O_fstpl, OI [OE_W 8]), (O_fstp, OI [OE_W 8]),
     (O_fstps, OI [OE_W 4]), (O_fsts, OI [OE_W 4]),
     (O_fstpt, OI [OE_W 8]), (O_fistl, OI [OE_W 4]),
     (O_fistpl, OI [OE_W 4]), (O_fistpll, OI [OE_W 8]),
     (O_fst, OI [OE_W 8]), (O_fldz, OI_NoEffect), (O_fld1, OI_NoEffect),
     (O_fldl2e, OI_NoEffect), (O_fldln2, OI_NoEffect),
     (O_fchs, OI_NoEffect), (O_fsin, OI_NoEffect),
     (O_fcos, OI_NoEffect), (O_fptan, OI_NoEffect),
     (O_fsqrt, OI_NoEffect), (O_fpatan, OI_NoEffect),
     (O_fabs, OI_NoEffect), (O_f2xm1, OI_NoEffect),
     (O_fscale, OI_NoEffect), (O_fyl2x, OI_NoEffect),
     (O_faddp, OI [OE_R 8, OE_RM 8 8]), (O_fadds, OI [OE_R 4]),
     (O_faddl, OI [OE_R 8]), (O_fiaddl, OI [OE_R 4]),
     (O_fadd, OI [OE_R 8, OE_RM 8 8]), (O_fsubp, OI [OE_RM 8 8]),
     (O_fsubrp, OI [OE_RM 8 8]), (O_fsubrl, OI [OE_R 8]),
     (O_fsubrs, OI [OE_R 4]), (O_fsubs, OI [OE_R 4]),
     (O_fsubl, OI [OE_R 8]), (O_fsub, OI [OE_R 8, OE_RM 8 8]),
     (O_fsubr, OI [OE_R 8, OE_RM 8 8]),
     (O_fmul, OI [OE_R 8, OE_RM 8 8]), (O_fmuls, OI [OE_R 4]),
     (O_fmull, OI [OE_R 8]), (O_fmulp, OI [OE_R 8, OE_RM 8 8]),
     (O_fimull, OI [OE_R 8]), (O_fdiv, OI [OE_RM 8 8]),
     (O_fdivp, OI [OE_RM 8 8]), (O_fdivr, OI [OE_RM 8 8]),
     (O_fdivrl, OI [OE_R 8]), (O_fdivrs, OI [OE_R 4]),
     (O_fdivrp, OI [OE_RM 8 8]), (O_fidivrl, OI [OE_R 4]),
     (O_fidivl, OI [OE_R 4]), (O_fdivl, OI [OE_R 8]),
     (O_fdivs, OI [OE_R 4]), (O_fprem, OI_NoEffect),
     (O_fucom, OI_NoEffect), (O_fucomp, OI_NoEffect),
     (O_fucompp, OI_NoEffect), (O_fcomp, OI_NoEffect),
     (O_fcompp, OI_NoEffect), (O_fcoms, OI [OE_R 4]),
     (O_fcoml, OI [OE_R 8]), (O_fcom, OI [OE_R 8]),
     (O_fcomps, OI [OE_R 4]), (O_fcompl, OI [OE_R 8]),
     (O_ficompl, OI [OE_R 4]), (O_fnstsw, OI [OE_W 2]),
     (O_fnstcw, OI [OE_W 2]), (O_fldcw, OI [OE_R 2]),
     (O_fxch, OI_NoEffect), (O_frndint, OI_NoEffect),
     (O_sahf, OI_NoEffect), (O_nop, OI_NoEffect)]

nonJumpyOpcodes :: [Opcode]
nonJumpyOpcodes
  = [O_pushl, O_popl, O_movl, O_movw, O_movb, O_andl, O_andw, O_andb,
     O_orl, O_orw, O_orb, O_xorl, O_xorw, O_xorb, O_addl, O_addw,
     O_addb, O_subl, O_subw, O_subb, O_incl, O_incw, O_incb, O_decl,
     O_decw, O_decb, O_cmpl, O_cmpw, O_cmpb, O_sall, O_salw, O_salb,
     O_shrl, O_shrw, O_shrb, O_sarl, O_leal, O_movzbw, O_movzbl,
     O_movzwl, O_movsbw, O_movsbl, O_movswl, O_seta, O_setae, O_setb,
     O_setbe, O_sete, O_setne, O_setl, O_setle, O_setg, O_setge, O_setc,
     O_setcb, O_testl, O_testw, O_testb, O_fld1, O_fcoml, O_fnstsw,
     O_fstpl, O_fstp, O_fsubrl, O_fldl, O_faddl, O_fsubl]

data Opcode = O_movl
            | O_movw
            | O_movb
            | O_movzbw
            | O_movzbl
            | O_movzwl
            | O_movsbw
            | O_movsbl
            | O_movswl
            | O_pushl
            | O_popl
            | O_pushfl
            | O_popfl
            | O_notl
            | O_notw
            | O_notb
            | O_sall
            | O_salw
            | O_salb
            | O_sarl
            | O_sarw
            | O_sarb
            | O_shrl
            | O_shrw
            | O_shrb
            | O_roll
            | O_rolw
            | O_rolb
            | O_rorl
            | O_rorw
            | O_rorb
            | O_shldl
            | O_shrdl
            | O_addl
            | O_addw
            | O_addb
            | O_adcl
            | O_subl
            | O_subw
            | O_subb
            | O_sbbl
            | O_imull
            | O_imulw
            | O_imulb
            | O_mull
            | O_divl
            | O_divw
            | O_divb
            | O_idivl
            | O_xorl
            | O_xorw
            | O_xorb
            | O_andl
            | O_andw
            | O_andb
            | O_orl
            | O_orw
            | O_orb
            | O_incl
            | O_incw
            | O_incb
            | O_decl
            | O_decw
            | O_decb
            | O_negl
            | O_negw
            | O_negb
            | O_testl
            | O_testw
            | O_testb
            | O_leal
            | O_cmpl
            | O_cmpw
            | O_cmpb
            | O_cmpsb
            | O_scasb
            | O_movsl
            | O_movsw
            | O_movsb
            | O_stosl
            | O_stosw
            | O_stosb
            | O_leave
            | O_ret
            | O_call
            | O_jmp
            | O_je
            | O_jne
            | O_jl
            | O_jle
            | O_jg
            | O_jge
            | O_js
            | O_jns
            | O_jz
            | O_jnz
            | O_jc
            | O_jnc
            | O_jo
            | O_jno
            | O_ja
            | O_jae
            | O_jb
            | O_jbe
            | O_jp
            | O_seta
            | O_setae
            | O_setb
            | O_setbe
            | O_sete
            | O_setne
            | O_setl
            | O_setle
            | O_setg
            | O_setge
            | O_setc
            | O_setcb
            | O_btl
            | O_btsl
            | O_btrl
            | O_btcl
            | O_cld
            | O_cltd
            | O_cwtl
            | O_cbtw
            | O_rep
            | O_repz
            | O_repnz
            | O_fild
            | O_fildl
            | O_fildll
            | O_fsubp
            | O_fsubr
            | O_fsubrp
            | O_fsubrl
            | O_fsubrs
            | O_fsubs
            | O_fsubl
            | O_fsub
            | O_faddp
            | O_fadds
            | O_faddl
            | O_fadd
            | O_fiaddl
            | O_fmul
            | O_fmuls
            | O_fmull
            | O_fmulp
            | O_fimull
            | O_fdiv
            | O_fdivp
            | O_fdivr
            | O_fdivrs
            | O_fdivrl
            | O_fdivrp
            | O_fidivl
            | O_fidivrl
            | O_fdivl
            | O_fdivs
            | O_fprem
            | O_fstp
            | O_fsts
            | O_fstps
            | O_fstl
            | O_fstpl
            | O_fstpt
            | O_fst
            | O_fistl
            | O_fistpl
            | O_fistpll
            | O_fld
            | O_flds
            | O_fldl
            | O_fldt
            | O_fldz
            | O_fld1
            | O_fldl2e
            | O_fldln2
            | O_fchs
            | O_fsin
            | O_fcos
            | O_fptan
            | O_fsqrt
            | O_fpatan
            | O_fabs
            | O_f2xm1
            | O_fscale
            | O_fyl2x
            | O_fucom
            | O_fucomp
            | O_fucompp
            | O_fcomp
            | O_fcompp
            | O_fcoml
            | O_fcompl
            | O_ficompl
            | O_fcoms
            | O_fcom
            | O_fcomps
            | O_fnstsw
            | O_fnstcw
            | O_fldcw
            | O_frndint
            | O_fxch
            | O_sahf
            | O_nop
            deriving (Show, Eq)

data OperandEffect = OE_RR Int Int
                   | OE_RM Int Int
                   | OE_RW Int Int
                   | OE_nW Int
                   | OE_RRM Int Int Int
                   | OE_R Int
                   | OE_M Int
                   | OE_W Int
                   deriving (Show, Eq)

data OperandInfo = OI_Special
                 | OI_Jumpy
                 | OI_NoEffect
                 | OI_Error
                 | OI [OperandEffect]
                 deriving (Show, Eq)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.x86info :: [(Dum.Opcode, Dum.OperandInfo)]
Dum.x86info
  = [(Dum.O_movl, Dum.OI [Dum.OE_RW 4 4]),
     (Dum.O_movw, Dum.OI [Dum.OE_RW 2 2]),
     (Dum.O_movb, Dum.OI [Dum.OE_RW 1 1]),
     (Dum.O_movzbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movzbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movzwl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_movsbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movsbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movswl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_pushl, Dum.OI_Special), (Dum.O_popl, Dum.OI_Special),
     (Dum.O_pushfl, Dum.OI_Error), (Dum.O_popfl, Dum.OI_Error),
     (Dum.O_sall, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_salw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_salb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sarl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_sarw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_sarb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shrl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_shrw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_shrb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_roll, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rolw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rolb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_rorl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rorw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shldl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_shrdl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_addl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_addw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_addb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_adcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_subb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sbbl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_imull, 
      Dum.OI [Dum.OE_M 4, Dum.OE_RM 4 4, Dum.OE_RRM 4 4 4]),
     (Dum.O_imulb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_imulw, Dum.OI [Dum.OE_M 2, Dum.OE_RM 2 2]),
     (Dum.O_mull, Dum.OI [Dum.OE_M 4]),
     (Dum.O_idivl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_divb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_xorl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_xorw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_xorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_andl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_andw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_andb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_orl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_orw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_orb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_incl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_incw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_incb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_decl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_decw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_decb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_negl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_negw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_negb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_notl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_notw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_notb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_testl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_testw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_testb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_leal, Dum.OI [Dum.OE_nW 4]),
     (Dum.O_cmpl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_cmpw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_cmpb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_cmpsb, Dum.OI_Special), (Dum.O_scasb, Dum.OI_Special),
     (Dum.O_movsl, Dum.OI_Special), (Dum.O_movsw, Dum.OI_Special),
     (Dum.O_movsb, Dum.OI_Special), (Dum.O_stosl, Dum.OI_Special),
     (Dum.O_stosw, Dum.OI_Special), (Dum.O_stosb, Dum.OI_Special),
     (Dum.O_leave, Dum.OI_Error), (Dum.O_ret, Dum.OI_Special),
     (Dum.O_call, Dum.OI_Special), (Dum.O_jmp, Dum.OI_Jumpy),
     (Dum.O_je, Dum.OI_Jumpy), (Dum.O_jne, Dum.OI_Jumpy),
     (Dum.O_jl, Dum.OI_Jumpy), (Dum.O_jle, Dum.OI_Jumpy),
     (Dum.O_jg, Dum.OI_Jumpy), (Dum.O_jge, Dum.OI_Jumpy),
     (Dum.O_js, Dum.OI_Jumpy), (Dum.O_jns, Dum.OI_Jumpy),
     (Dum.O_jz, Dum.OI_Jumpy), (Dum.O_jnz, Dum.OI_Jumpy),
     (Dum.O_jc, Dum.OI_Jumpy), (Dum.O_jnc, Dum.OI_Jumpy),
     (Dum.O_jo, Dum.OI_Jumpy), (Dum.O_jno, Dum.OI_Jumpy),
     (Dum.O_ja, Dum.OI_Jumpy), (Dum.O_jae, Dum.OI_Jumpy),
     (Dum.O_jb, Dum.OI_Jumpy), (Dum.O_jbe, Dum.OI_Jumpy),
     (Dum.O_jp, Dum.OI_Jumpy), (Dum.O_seta, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setae, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setbe, Dum.OI [Dum.OE_W 1]),
     (Dum.O_sete, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setne, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setl, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setle, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setg, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setge, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setc, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setcb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_btl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_btsl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btrl, Dum.OI [Dum.OE_RM 4 4]), (Dum.O_cld, Dum.OI_NoEffect),
     (Dum.O_cltd, Dum.OI_NoEffect), (Dum.O_cwtl, Dum.OI_NoEffect),
     (Dum.O_cbtw, Dum.OI_NoEffect), (Dum.O_rep, Dum.OI_Error),
     (Dum.O_repz, Dum.OI_Error), (Dum.O_repnz, Dum.OI_Error),
     (Dum.O_fld, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldt, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_flds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fild, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildll, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fstl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstpl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstp, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstps, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fsts, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fstpt, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fistl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpll, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fst, Dum.OI [Dum.OE_W 8]), (Dum.O_fldz, Dum.OI_NoEffect),
     (Dum.O_fld1, Dum.OI_NoEffect), (Dum.O_fldl2e, Dum.OI_NoEffect),
     (Dum.O_fldln2, Dum.OI_NoEffect), (Dum.O_fchs, Dum.OI_NoEffect),
     (Dum.O_fsin, Dum.OI_NoEffect), (Dum.O_fcos, Dum.OI_NoEffect),
     (Dum.O_fptan, Dum.OI_NoEffect), (Dum.O_fsqrt, Dum.OI_NoEffect),
     (Dum.O_fpatan, Dum.OI_NoEffect), (Dum.O_fabs, Dum.OI_NoEffect),
     (Dum.O_f2xm1, Dum.OI_NoEffect), (Dum.O_fscale, Dum.OI_NoEffect),
     (Dum.O_fyl2x, Dum.OI_NoEffect),
     (Dum.O_faddp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fadds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_faddl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fiaddl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fadd, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsubrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsub, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubr, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmul, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmuls, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fmull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fmulp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fimull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdiv, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivr, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fidivrl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fidivl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivs, Dum.OI [Dum.OE_R 4]), (Dum.O_fprem, Dum.OI_NoEffect),
     (Dum.O_fucom, Dum.OI_NoEffect), (Dum.O_fucomp, Dum.OI_NoEffect),
     (Dum.O_fucompp, Dum.OI_NoEffect), (Dum.O_fcomp, Dum.OI_NoEffect),
     (Dum.O_fcompp, Dum.OI_NoEffect),
     (Dum.O_fcoms, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcoml, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcom, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcomps, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcompl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_ficompl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fnstsw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fnstcw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fldcw, Dum.OI [Dum.OE_R 2]), (Dum.O_fxch, Dum.OI_NoEffect),
     (Dum.O_frndint, Dum.OI_NoEffect), (Dum.O_sahf, Dum.OI_NoEffect),
     (Dum.O_nop, Dum.OI_NoEffect)]
Dum.nonJumpyOpcodes :: [Dum.Opcode]
Dum.nonJumpyOpcodes
  = [Dum.O_pushl, Dum.O_popl, Dum.O_movl, Dum.O_movw, Dum.O_movb,
     Dum.O_andl, Dum.O_andw, Dum.O_andb, Dum.O_orl, Dum.O_orw,
     Dum.O_orb, Dum.O_xorl, Dum.O_xorw, Dum.O_xorb, Dum.O_addl,
     Dum.O_addw, Dum.O_addb, Dum.O_subl, Dum.O_subw, Dum.O_subb,
     Dum.O_incl, Dum.O_incw, Dum.O_incb, Dum.O_decl, Dum.O_decw,
     Dum.O_decb, Dum.O_cmpl, Dum.O_cmpw, Dum.O_cmpb, Dum.O_sall,
     Dum.O_salw, Dum.O_salb, Dum.O_shrl, Dum.O_shrw, Dum.O_shrb,
     Dum.O_sarl, Dum.O_leal, Dum.O_movzbw, Dum.O_movzbl, Dum.O_movzwl,
     Dum.O_movsbw, Dum.O_movsbl, Dum.O_movswl, Dum.O_seta, Dum.O_setae,
     Dum.O_setb, Dum.O_setbe, Dum.O_sete, Dum.O_setne, Dum.O_setl,
     Dum.O_setle, Dum.O_setg, Dum.O_setge, Dum.O_setc, Dum.O_setcb,
     Dum.O_testl, Dum.O_testw, Dum.O_testb, Dum.O_fld1, Dum.O_fcoml,
     Dum.O_fnstsw, Dum.O_fstpl, Dum.O_fstp, Dum.O_fsubrl, Dum.O_fldl,
     Dum.O_faddl, Dum.O_fsubl]

data Dum.Opcode
  = Dum.O_movl |
    Dum.O_movw |
    Dum.O_movb |
    Dum.O_movzbw |
    Dum.O_movzbl |
    Dum.O_movzwl |
    Dum.O_movsbw |
    Dum.O_movsbl |
    Dum.O_movswl |
    Dum.O_pushl |
    Dum.O_popl |
    Dum.O_pushfl |
    Dum.O_popfl |
    Dum.O_notl |
    Dum.O_notw |
    Dum.O_notb |
    Dum.O_sall |
    Dum.O_salw |
    Dum.O_salb |
    Dum.O_sarl |
    Dum.O_sarw |
    Dum.O_sarb |
    Dum.O_shrl |
    Dum.O_shrw |
    Dum.O_shrb |
    Dum.O_roll |
    Dum.O_rolw |
    Dum.O_rolb |
    Dum.O_rorl |
    Dum.O_rorw |
    Dum.O_rorb |
    Dum.O_shldl |
    Dum.O_shrdl |
    Dum.O_addl |
    Dum.O_addw |
    Dum.O_addb |
    Dum.O_adcl |
    Dum.O_subl |
    Dum.O_subw |
    Dum.O_subb |
    Dum.O_sbbl |
    Dum.O_imull |
    Dum.O_imulw |
    Dum.O_imulb |
    Dum.O_mull |
    Dum.O_divl |
    Dum.O_divw |
    Dum.O_divb |
    Dum.O_idivl |
    Dum.O_xorl |
    Dum.O_xorw |
    Dum.O_xorb |
    Dum.O_andl |
    Dum.O_andw |
    Dum.O_andb |
    Dum.O_orl |
    Dum.O_orw |
    Dum.O_orb |
    Dum.O_incl |
    Dum.O_incw |
    Dum.O_incb |
    Dum.O_decl |
    Dum.O_decw |
    Dum.O_decb |
    Dum.O_negl |
    Dum.O_negw |
    Dum.O_negb |
    Dum.O_testl |
    Dum.O_testw |
    Dum.O_testb |
    Dum.O_leal |
    Dum.O_cmpl |
    Dum.O_cmpw |
    Dum.O_cmpb |
    Dum.O_cmpsb |
    Dum.O_scasb |
    Dum.O_movsl |
    Dum.O_movsw |
    Dum.O_movsb |
    Dum.O_stosl |
    Dum.O_stosw |
    Dum.O_stosb |
    Dum.O_leave |
    Dum.O_ret |
    Dum.O_call |
    Dum.O_jmp |
    Dum.O_je |
    Dum.O_jne |
    Dum.O_jl |
    Dum.O_jle |
    Dum.O_jg |
    Dum.O_jge |
    Dum.O_js |
    Dum.O_jns |
    Dum.O_jz |
    Dum.O_jnz |
    Dum.O_jc |
    Dum.O_jnc |
    Dum.O_jo |
    Dum.O_jno |
    Dum.O_ja |
    Dum.O_jae |
    Dum.O_jb |
    Dum.O_jbe |
    Dum.O_jp |
    Dum.O_seta |
    Dum.O_setae |
    Dum.O_setb |
    Dum.O_setbe |
    Dum.O_sete |
    Dum.O_setne |
    Dum.O_setl |
    Dum.O_setle |
    Dum.O_setg |
    Dum.O_setge |
    Dum.O_setc |
    Dum.O_setcb |
    Dum.O_btl |
    Dum.O_btsl |
    Dum.O_btrl |
    Dum.O_btcl |
    Dum.O_cld |
    Dum.O_cltd |
    Dum.O_cwtl |
    Dum.O_cbtw |
    Dum.O_rep |
    Dum.O_repz |
    Dum.O_repnz |
    Dum.O_fild |
    Dum.O_fildl |
    Dum.O_fildll |
    Dum.O_fsubp |
    Dum.O_fsubr |
    Dum.O_fsubrp |
    Dum.O_fsubrl |
    Dum.O_fsubrs |
    Dum.O_fsubs |
    Dum.O_fsubl |
    Dum.O_fsub |
    Dum.O_faddp |
    Dum.O_fadds |
    Dum.O_faddl |
    Dum.O_fadd |
    Dum.O_fiaddl |
    Dum.O_fmul |
    Dum.O_fmuls |
    Dum.O_fmull |
    Dum.O_fmulp |
    Dum.O_fimull |
    Dum.O_fdiv |
    Dum.O_fdivp |
    Dum.O_fdivr |
    Dum.O_fdivrs |
    Dum.O_fdivrl |
    Dum.O_fdivrp |
    Dum.O_fidivl |
    Dum.O_fidivrl |
    Dum.O_fdivl |
    Dum.O_fdivs |
    Dum.O_fprem |
    Dum.O_fstp |
    Dum.O_fsts |
    Dum.O_fstps |
    Dum.O_fstl |
    Dum.O_fstpl |
    Dum.O_fstpt |
    Dum.O_fst |
    Dum.O_fistl |
    Dum.O_fistpl |
    Dum.O_fistpll |
    Dum.O_fld |
    Dum.O_flds |
    Dum.O_fldl |
    Dum.O_fldt |
    Dum.O_fldz |
    Dum.O_fld1 |
    Dum.O_fldl2e |
    Dum.O_fldln2 |
    Dum.O_fchs |
    Dum.O_fsin |
    Dum.O_fcos |
    Dum.O_fptan |
    Dum.O_fsqrt |
    Dum.O_fpatan |
    Dum.O_fabs |
    Dum.O_f2xm1 |
    Dum.O_fscale |
    Dum.O_fyl2x |
    Dum.O_fucom |
    Dum.O_fucomp |
    Dum.O_fucompp |
    Dum.O_fcomp |
    Dum.O_fcompp |
    Dum.O_fcoml |
    Dum.O_fcompl |
    Dum.O_ficompl |
    Dum.O_fcoms |
    Dum.O_fcom |
    Dum.O_fcomps |
    Dum.O_fnstsw |
    Dum.O_fnstcw |
    Dum.O_fldcw |
    Dum.O_frndint |
    Dum.O_fxch |
    Dum.O_sahf |
    Dum.O_nop
  deriving (Show, Eq)
data Dum.OperandEffect
  = Dum.OE_RR Int Int |
    Dum.OE_RM Int Int |
    Dum.OE_RW Int Int |
    Dum.OE_nW Int |
    Dum.OE_RRM Int Int Int |
    Dum.OE_R Int |
    Dum.OE_M Int |
    Dum.OE_W Int
  deriving (Show, Eq)
data Dum.OperandInfo
  = Dum.OI_Special |
    Dum.OI_Jumpy |
    Dum.OI_NoEffect |
    Dum.OI_Error |
    Dum.OI [Dum.OperandEffect]
  deriving (Show, Eq)


["x86info","nonJumpyOpcodes"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Interval
import Kolor
import Types

x86info :: [(Opcode, OperandInfo)]
x86info
  = [(O_movl, OI [OE_RW 4 4]), (O_movw, OI [OE_RW 2 2]),
     (O_movb, OI [OE_RW 1 1]), (O_movzbw, OI [OE_RW 1 2]),
     (O_movzbl, OI [OE_RW 1 4]), (O_movzwl, OI [OE_RW 2 4]),
     (O_movsbw, OI [OE_RW 1 2]), (O_movsbl, OI [OE_RW 1 4]),
     (O_movswl, OI [OE_RW 2 4]), (O_pushl, OI_Special),
     (O_popl, OI_Special), (O_pushfl, OI_Error), (O_popfl, OI_Error),
     (O_sall, OI [OE_RM 1 4]), (O_salw, OI [OE_RM 1 2]),
     (O_salb, OI [OE_RM 1 1]), (O_sarl, OI [OE_RM 1 4]),
     (O_sarw, OI [OE_RM 1 2]), (O_sarb, OI [OE_RM 1 1]),
     (O_shrl, OI [OE_RM 1 4]), (O_shrw, OI [OE_RM 1 2]),
     (O_shrb, OI [OE_RM 1 1]), (O_roll, OI [OE_RM 1 4]),
     (O_rolw, OI [OE_RM 1 2]), (O_rolb, OI [OE_RM 1 1]),
     (O_rorl, OI [OE_RM 1 4]), (O_rorw, OI [OE_RM 1 2]),
     (O_rorb, OI [OE_RM 1 1]), (O_shldl, OI [OE_RRM 4 4 4, OE_RM 4 4]),
     (O_shrdl, OI [OE_RRM 4 4 4, OE_RM 4 4]), (O_addl, OI [OE_RM 4 4]),
     (O_addw, OI [OE_RM 2 2]), (O_addb, OI [OE_RM 1 1]),
     (O_adcl, OI [OE_RM 4 4]), (O_subl, OI [OE_RM 4 4]),
     (O_subw, OI [OE_RM 2 2]), (O_subb, OI [OE_RM 1 1]),
     (O_sbbl, OI [OE_RM 4 4]),
     (O_imull, OI [OE_M 4, OE_RM 4 4, OE_RRM 4 4 4]),
     (O_imulb, OI [OE_M 1]), (O_imulw, OI [OE_M 2, OE_RM 2 2]),
     (O_mull, OI [OE_M 4]), (O_idivl, OI [OE_M 4]),
     (O_divl, OI [OE_M 4]), (O_divw, OI [OE_M 2]),
     (O_divb, OI [OE_M 1]), (O_xorl, OI [OE_RM 4 4]),
     (O_xorw, OI [OE_RM 2 2]), (O_xorb, OI [OE_RM 1 1]),
     (O_andl, OI [OE_RM 4 4]), (O_andw, OI [OE_RM 2 2]),
     (O_andb, OI [OE_RM 1 1]), (O_orl, OI [OE_RM 4 4]),
     (O_orw, OI [OE_RM 2 2]), (O_orb, OI [OE_RM 1 1]),
     (O_incl, OI [OE_M 4]), (O_incw, OI [OE_M 2]),
     (O_incb, OI [OE_M 1]), (O_decl, OI [OE_M 4]),
     (O_decw, OI [OE_M 2]), (O_decb, OI [OE_M 1]),
     (O_negl, OI [OE_M 4]), (O_negw, OI [OE_M 2]),
     (O_negb, OI [OE_M 1]), (O_notl, OI [OE_M 4]),
     (O_notw, OI [OE_M 2]), (O_notb, OI [OE_M 1]),
     (O_testl, OI [OE_RR 4 4]), (O_testw, OI [OE_RR 2 2]),
     (O_testb, OI [OE_RR 1 1]), (O_leal, OI [OE_nW 4]),
     (O_cmpl, OI [OE_RR 4 4]), (O_cmpw, OI [OE_RR 2 2]),
     (O_cmpb, OI [OE_RR 1 1]), (O_cmpsb, OI_Special),
     (O_scasb, OI_Special), (O_movsl, OI_Special),
     (O_movsw, OI_Special), (O_movsb, OI_Special),
     (O_stosl, OI_Special), (O_stosw, OI_Special),
     (O_stosb, OI_Special), (O_leave, OI_Error), (O_ret, OI_Special),
     (O_call, OI_Special), (O_jmp, OI_Jumpy), (O_je, OI_Jumpy),
     (O_jne, OI_Jumpy), (O_jl, OI_Jumpy), (O_jle, OI_Jumpy),
     (O_jg, OI_Jumpy), (O_jge, OI_Jumpy), (O_js, OI_Jumpy),
     (O_jns, OI_Jumpy), (O_jz, OI_Jumpy), (O_jnz, OI_Jumpy),
     (O_jc, OI_Jumpy), (O_jnc, OI_Jumpy), (O_jo, OI_Jumpy),
     (O_jno, OI_Jumpy), (O_ja, OI_Jumpy), (O_jae, OI_Jumpy),
     (O_jb, OI_Jumpy), (O_jbe, OI_Jumpy), (O_jp, OI_Jumpy),
     (O_seta, OI [OE_W 1]), (O_setae, OI [OE_W 1]),
     (O_setb, OI [OE_W 1]), (O_setbe, OI [OE_W 1]),
     (O_sete, OI [OE_W 1]), (O_setne, OI [OE_W 1]),
     (O_setl, OI [OE_W 1]), (O_setle, OI [OE_W 1]),
     (O_setg, OI [OE_W 1]), (O_setge, OI [OE_W 1]),
     (O_setc, OI [OE_W 1]), (O_setcb, OI [OE_W 1]),
     (O_btl, OI [OE_RR 4 4]), (O_btsl, OI [OE_RM 4 4]),
     (O_btcl, OI [OE_RM 4 4]), (O_btrl, OI [OE_RM 4 4]),
     (O_cld, OI_NoEffect), (O_cltd, OI_NoEffect), (O_cwtl, OI_NoEffect),
     (O_cbtw, OI_NoEffect), (O_rep, OI_Error), (O_repz, OI_Error),
     (O_repnz, OI_Error), (O_fld, OI [OE_R 8]), (O_fldt, OI [OE_R 8]),
     (O_fldl, OI [OE_R 8]), (O_flds, OI [OE_R 4]),
     (O_fild, OI [OE_R 4]), (O_fildl, OI [OE_R 4]),
     (O_fildll, OI [OE_R 8]), (O_fstl, OI [OE_W 8]),
     (O_fstpl, OI [OE_W 8]), (O_fstp, OI [OE_W 8]),
     (O_fstps, OI [OE_W 4]), (O_fsts, OI [OE_W 4]),
     (O_fstpt, OI [OE_W 8]), (O_fistl, OI [OE_W 4]),
     (O_fistpl, OI [OE_W 4]), (O_fistpll, OI [OE_W 8]),
     (O_fst, OI [OE_W 8]), (O_fldz, OI_NoEffect), (O_fld1, OI_NoEffect),
     (O_fldl2e, OI_NoEffect), (O_fldln2, OI_NoEffect),
     (O_fchs, OI_NoEffect), (O_fsin, OI_NoEffect),
     (O_fcos, OI_NoEffect), (O_fptan, OI_NoEffect),
     (O_fsqrt, OI_NoEffect), (O_fpatan, OI_NoEffect),
     (O_fabs, OI_NoEffect), (O_f2xm1, OI_NoEffect),
     (O_fscale, OI_NoEffect), (O_fyl2x, OI_NoEffect),
     (O_faddp, OI [OE_R 8, OE_RM 8 8]), (O_fadds, OI [OE_R 4]),
     (O_faddl, OI [OE_R 8]), (O_fiaddl, OI [OE_R 4]),
     (O_fadd, OI [OE_R 8, OE_RM 8 8]), (O_fsubp, OI [OE_RM 8 8]),
     (O_fsubrp, OI [OE_RM 8 8]), (O_fsubrl, OI [OE_R 8]),
     (O_fsubrs, OI [OE_R 4]), (O_fsubs, OI [OE_R 4]),
     (O_fsubl, OI [OE_R 8]), (O_fsub, OI [OE_R 8, OE_RM 8 8]),
     (O_fsubr, OI [OE_R 8, OE_RM 8 8]),
     (O_fmul, OI [OE_R 8, OE_RM 8 8]), (O_fmuls, OI [OE_R 4]),
     (O_fmull, OI [OE_R 8]), (O_fmulp, OI [OE_R 8, OE_RM 8 8]),
     (O_fimull, OI [OE_R 8]), (O_fdiv, OI [OE_RM 8 8]),
     (O_fdivp, OI [OE_RM 8 8]), (O_fdivr, OI [OE_RM 8 8]),
     (O_fdivrl, OI [OE_R 8]), (O_fdivrs, OI [OE_R 4]),
     (O_fdivrp, OI [OE_RM 8 8]), (O_fidivrl, OI [OE_R 4]),
     (O_fidivl, OI [OE_R 4]), (O_fdivl, OI [OE_R 8]),
     (O_fdivs, OI [OE_R 4]), (O_fprem, OI_NoEffect),
     (O_fucom, OI_NoEffect), (O_fucomp, OI_NoEffect),
     (O_fucompp, OI_NoEffect), (O_fcomp, OI_NoEffect),
     (O_fcompp, OI_NoEffect), (O_fcoms, OI [OE_R 4]),
     (O_fcoml, OI [OE_R 8]), (O_fcom, OI [OE_R 8]),
     (O_fcomps, OI [OE_R 4]), (O_fcompl, OI [OE_R 8]),
     (O_ficompl, OI [OE_R 4]), (O_fnstsw, OI [OE_W 2]),
     (O_fnstcw, OI [OE_W 2]), (O_fldcw, OI [OE_R 2]),
     (O_fxch, OI_NoEffect), (O_frndint, OI_NoEffect),
     (O_sahf, OI_NoEffect), (O_nop, OI_NoEffect)]

nonJumpyOpcodes :: [Opcode]
nonJumpyOpcodes
  = [O_pushl, O_popl, O_movl, O_movw, O_movb, O_andl, O_andw, O_andb,
     O_orl, O_orw, O_orb, O_xorl, O_xorw, O_xorb, O_addl, O_addw,
     O_addb, O_subl, O_subw, O_subb, O_incl, O_incw, O_incb, O_decl,
     O_decw, O_decb, O_cmpl, O_cmpw, O_cmpb, O_sall, O_salw, O_salb,
     O_shrl, O_shrw, O_shrb, O_sarl, O_leal, O_movzbw, O_movzbl,
     O_movzwl, O_movsbw, O_movsbl, O_movswl, O_seta, O_setae, O_setb,
     O_setbe, O_sete, O_setne, O_setl, O_setle, O_setg, O_setge, O_setc,
     O_setcb, O_testl, O_testw, O_testb, O_fld1, O_fcoml, O_fnstsw,
     O_fstpl, O_fstp, O_fsubrl, O_fldl, O_faddl, O_fsubl]

data Opcode = O_movl
            | O_movw
            | O_movb
            | O_movzbw
            | O_movzbl
            | O_movzwl
            | O_movsbw
            | O_movsbl
            | O_movswl
            | O_pushl
            | O_popl
            | O_pushfl
            | O_popfl
            | O_notl
            | O_notw
            | O_notb
            | O_sall
            | O_salw
            | O_salb
            | O_sarl
            | O_sarw
            | O_sarb
            | O_shrl
            | O_shrw
            | O_shrb
            | O_roll
            | O_rolw
            | O_rolb
            | O_rorl
            | O_rorw
            | O_rorb
            | O_shldl
            | O_shrdl
            | O_addl
            | O_addw
            | O_addb
            | O_adcl
            | O_subl
            | O_subw
            | O_subb
            | O_sbbl
            | O_imull
            | O_imulw
            | O_imulb
            | O_mull
            | O_divl
            | O_divw
            | O_divb
            | O_idivl
            | O_xorl
            | O_xorw
            | O_xorb
            | O_andl
            | O_andw
            | O_andb
            | O_orl
            | O_orw
            | O_orb
            | O_incl
            | O_incw
            | O_incb
            | O_decl
            | O_decw
            | O_decb
            | O_negl
            | O_negw
            | O_negb
            | O_testl
            | O_testw
            | O_testb
            | O_leal
            | O_cmpl
            | O_cmpw
            | O_cmpb
            | O_cmpsb
            | O_scasb
            | O_movsl
            | O_movsw
            | O_movsb
            | O_stosl
            | O_stosw
            | O_stosb
            | O_leave
            | O_ret
            | O_call
            | O_jmp
            | O_je
            | O_jne
            | O_jl
            | O_jle
            | O_jg
            | O_jge
            | O_js
            | O_jns
            | O_jz
            | O_jnz
            | O_jc
            | O_jnc
            | O_jo
            | O_jno
            | O_ja
            | O_jae
            | O_jb
            | O_jbe
            | O_jp
            | O_seta
            | O_setae
            | O_setb
            | O_setbe
            | O_sete
            | O_setne
            | O_setl
            | O_setle
            | O_setg
            | O_setge
            | O_setc
            | O_setcb
            | O_btl
            | O_btsl
            | O_btrl
            | O_btcl
            | O_cld
            | O_cltd
            | O_cwtl
            | O_cbtw
            | O_rep
            | O_repz
            | O_repnz
            | O_fild
            | O_fildl
            | O_fildll
            | O_fsubp
            | O_fsubr
            | O_fsubrp
            | O_fsubrl
            | O_fsubrs
            | O_fsubs
            | O_fsubl
            | O_fsub
            | O_faddp
            | O_fadds
            | O_faddl
            | O_fadd
            | O_fiaddl
            | O_fmul
            | O_fmuls
            | O_fmull
            | O_fmulp
            | O_fimull
            | O_fdiv
            | O_fdivp
            | O_fdivr
            | O_fdivrs
            | O_fdivrl
            | O_fdivrp
            | O_fidivl
            | O_fidivrl
            | O_fdivl
            | O_fdivs
            | O_fprem
            | O_fstp
            | O_fsts
            | O_fstps
            | O_fstl
            | O_fstpl
            | O_fstpt
            | O_fst
            | O_fistl
            | O_fistpl
            | O_fistpll
            | O_fld
            | O_flds
            | O_fldl
            | O_fldt
            | O_fldz
            | O_fld1
            | O_fldl2e
            | O_fldln2
            | O_fchs
            | O_fsin
            | O_fcos
            | O_fptan
            | O_fsqrt
            | O_fpatan
            | O_fabs
            | O_f2xm1
            | O_fscale
            | O_fyl2x
            | O_fucom
            | O_fucomp
            | O_fucompp
            | O_fcomp
            | O_fcompp
            | O_fcoml
            | O_fcompl
            | O_ficompl
            | O_fcoms
            | O_fcom
            | O_fcomps
            | O_fnstsw
            | O_fnstcw
            | O_fldcw
            | O_frndint
            | O_fxch
            | O_sahf
            | O_nop
            deriving (Show, Eq)

data OperandEffect = OE_RR Int Int
                   | OE_RM Int Int
                   | OE_RW Int Int
                   | OE_nW Int
                   | OE_RRM Int Int Int
                   | OE_R Int
                   | OE_M Int
                   | OE_W Int
                   deriving (Show, Eq)

data OperandInfo = OI_Special
                 | OI_Jumpy
                 | OI_NoEffect
                 | OI_Error
                 | OI [OperandEffect]
                 deriving (Show, Eq)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.x86info :: [(Dum.Opcode, Dum.OperandInfo)]
Dum.x86info
  = [(Dum.O_movl, Dum.OI [Dum.OE_RW 4 4]),
     (Dum.O_movw, Dum.OI [Dum.OE_RW 2 2]),
     (Dum.O_movb, Dum.OI [Dum.OE_RW 1 1]),
     (Dum.O_movzbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movzbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movzwl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_movsbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movsbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movswl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_pushl, Dum.OI_Special), (Dum.O_popl, Dum.OI_Special),
     (Dum.O_pushfl, Dum.OI_Error), (Dum.O_popfl, Dum.OI_Error),
     (Dum.O_sall, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_salw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_salb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sarl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_sarw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_sarb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shrl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_shrw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_shrb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_roll, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rolw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rolb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_rorl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rorw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shldl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_shrdl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_addl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_addw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_addb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_adcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_subb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sbbl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_imull, 
      Dum.OI [Dum.OE_M 4, Dum.OE_RM 4 4, Dum.OE_RRM 4 4 4]),
     (Dum.O_imulb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_imulw, Dum.OI [Dum.OE_M 2, Dum.OE_RM 2 2]),
     (Dum.O_mull, Dum.OI [Dum.OE_M 4]),
     (Dum.O_idivl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_divb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_xorl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_xorw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_xorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_andl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_andw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_andb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_orl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_orw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_orb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_incl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_incw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_incb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_decl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_decw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_decb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_negl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_negw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_negb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_notl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_notw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_notb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_testl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_testw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_testb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_leal, Dum.OI [Dum.OE_nW 4]),
     (Dum.O_cmpl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_cmpw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_cmpb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_cmpsb, Dum.OI_Special), (Dum.O_scasb, Dum.OI_Special),
     (Dum.O_movsl, Dum.OI_Special), (Dum.O_movsw, Dum.OI_Special),
     (Dum.O_movsb, Dum.OI_Special), (Dum.O_stosl, Dum.OI_Special),
     (Dum.O_stosw, Dum.OI_Special), (Dum.O_stosb, Dum.OI_Special),
     (Dum.O_leave, Dum.OI_Error), (Dum.O_ret, Dum.OI_Special),
     (Dum.O_call, Dum.OI_Special), (Dum.O_jmp, Dum.OI_Jumpy),
     (Dum.O_je, Dum.OI_Jumpy), (Dum.O_jne, Dum.OI_Jumpy),
     (Dum.O_jl, Dum.OI_Jumpy), (Dum.O_jle, Dum.OI_Jumpy),
     (Dum.O_jg, Dum.OI_Jumpy), (Dum.O_jge, Dum.OI_Jumpy),
     (Dum.O_js, Dum.OI_Jumpy), (Dum.O_jns, Dum.OI_Jumpy),
     (Dum.O_jz, Dum.OI_Jumpy), (Dum.O_jnz, Dum.OI_Jumpy),
     (Dum.O_jc, Dum.OI_Jumpy), (Dum.O_jnc, Dum.OI_Jumpy),
     (Dum.O_jo, Dum.OI_Jumpy), (Dum.O_jno, Dum.OI_Jumpy),
     (Dum.O_ja, Dum.OI_Jumpy), (Dum.O_jae, Dum.OI_Jumpy),
     (Dum.O_jb, Dum.OI_Jumpy), (Dum.O_jbe, Dum.OI_Jumpy),
     (Dum.O_jp, Dum.OI_Jumpy), (Dum.O_seta, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setae, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setbe, Dum.OI [Dum.OE_W 1]),
     (Dum.O_sete, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setne, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setl, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setle, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setg, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setge, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setc, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setcb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_btl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_btsl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btrl, Dum.OI [Dum.OE_RM 4 4]), (Dum.O_cld, Dum.OI_NoEffect),
     (Dum.O_cltd, Dum.OI_NoEffect), (Dum.O_cwtl, Dum.OI_NoEffect),
     (Dum.O_cbtw, Dum.OI_NoEffect), (Dum.O_rep, Dum.OI_Error),
     (Dum.O_repz, Dum.OI_Error), (Dum.O_repnz, Dum.OI_Error),
     (Dum.O_fld, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldt, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_flds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fild, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildll, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fstl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstpl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstp, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstps, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fsts, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fstpt, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fistl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpll, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fst, Dum.OI [Dum.OE_W 8]), (Dum.O_fldz, Dum.OI_NoEffect),
     (Dum.O_fld1, Dum.OI_NoEffect), (Dum.O_fldl2e, Dum.OI_NoEffect),
     (Dum.O_fldln2, Dum.OI_NoEffect), (Dum.O_fchs, Dum.OI_NoEffect),
     (Dum.O_fsin, Dum.OI_NoEffect), (Dum.O_fcos, Dum.OI_NoEffect),
     (Dum.O_fptan, Dum.OI_NoEffect), (Dum.O_fsqrt, Dum.OI_NoEffect),
     (Dum.O_fpatan, Dum.OI_NoEffect), (Dum.O_fabs, Dum.OI_NoEffect),
     (Dum.O_f2xm1, Dum.OI_NoEffect), (Dum.O_fscale, Dum.OI_NoEffect),
     (Dum.O_fyl2x, Dum.OI_NoEffect),
     (Dum.O_faddp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fadds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_faddl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fiaddl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fadd, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsubrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsub, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubr, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmul, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmuls, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fmull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fmulp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fimull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdiv, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivr, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fidivrl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fidivl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivs, Dum.OI [Dum.OE_R 4]), (Dum.O_fprem, Dum.OI_NoEffect),
     (Dum.O_fucom, Dum.OI_NoEffect), (Dum.O_fucomp, Dum.OI_NoEffect),
     (Dum.O_fucompp, Dum.OI_NoEffect), (Dum.O_fcomp, Dum.OI_NoEffect),
     (Dum.O_fcompp, Dum.OI_NoEffect),
     (Dum.O_fcoms, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcoml, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcom, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcomps, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcompl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_ficompl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fnstsw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fnstcw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fldcw, Dum.OI [Dum.OE_R 2]), (Dum.O_fxch, Dum.OI_NoEffect),
     (Dum.O_frndint, Dum.OI_NoEffect), (Dum.O_sahf, Dum.OI_NoEffect),
     (Dum.O_nop, Dum.OI_NoEffect)]
Dum.nonJumpyOpcodes :: [Dum.Opcode]
Dum.nonJumpyOpcodes
  = [Dum.O_pushl, Dum.O_popl, Dum.O_movl, Dum.O_movw, Dum.O_movb,
     Dum.O_andl, Dum.O_andw, Dum.O_andb, Dum.O_orl, Dum.O_orw,
     Dum.O_orb, Dum.O_xorl, Dum.O_xorw, Dum.O_xorb, Dum.O_addl,
     Dum.O_addw, Dum.O_addb, Dum.O_subl, Dum.O_subw, Dum.O_subb,
     Dum.O_incl, Dum.O_incw, Dum.O_incb, Dum.O_decl, Dum.O_decw,
     Dum.O_decb, Dum.O_cmpl, Dum.O_cmpw, Dum.O_cmpb, Dum.O_sall,
     Dum.O_salw, Dum.O_salb, Dum.O_shrl, Dum.O_shrw, Dum.O_shrb,
     Dum.O_sarl, Dum.O_leal, Dum.O_movzbw, Dum.O_movzbl, Dum.O_movzwl,
     Dum.O_movsbw, Dum.O_movsbl, Dum.O_movswl, Dum.O_seta, Dum.O_setae,
     Dum.O_setb, Dum.O_setbe, Dum.O_sete, Dum.O_setne, Dum.O_setl,
     Dum.O_setle, Dum.O_setg, Dum.O_setge, Dum.O_setc, Dum.O_setcb,
     Dum.O_testl, Dum.O_testw, Dum.O_testb, Dum.O_fld1, Dum.O_fcoml,
     Dum.O_fnstsw, Dum.O_fstpl, Dum.O_fstp, Dum.O_fsubrl, Dum.O_fldl,
     Dum.O_faddl, Dum.O_fsubl]

data Dum.Opcode
  = Dum.O_movl |
    Dum.O_movw |
    Dum.O_movb |
    Dum.O_movzbw |
    Dum.O_movzbl |
    Dum.O_movzwl |
    Dum.O_movsbw |
    Dum.O_movsbl |
    Dum.O_movswl |
    Dum.O_pushl |
    Dum.O_popl |
    Dum.O_pushfl |
    Dum.O_popfl |
    Dum.O_notl |
    Dum.O_notw |
    Dum.O_notb |
    Dum.O_sall |
    Dum.O_salw |
    Dum.O_salb |
    Dum.O_sarl |
    Dum.O_sarw |
    Dum.O_sarb |
    Dum.O_shrl |
    Dum.O_shrw |
    Dum.O_shrb |
    Dum.O_roll |
    Dum.O_rolw |
    Dum.O_rolb |
    Dum.O_rorl |
    Dum.O_rorw |
    Dum.O_rorb |
    Dum.O_shldl |
    Dum.O_shrdl |
    Dum.O_addl |
    Dum.O_addw |
    Dum.O_addb |
    Dum.O_adcl |
    Dum.O_subl |
    Dum.O_subw |
    Dum.O_subb |
    Dum.O_sbbl |
    Dum.O_imull |
    Dum.O_imulw |
    Dum.O_imulb |
    Dum.O_mull |
    Dum.O_divl |
    Dum.O_divw |
    Dum.O_divb |
    Dum.O_idivl |
    Dum.O_xorl |
    Dum.O_xorw |
    Dum.O_xorb |
    Dum.O_andl |
    Dum.O_andw |
    Dum.O_andb |
    Dum.O_orl |
    Dum.O_orw |
    Dum.O_orb |
    Dum.O_incl |
    Dum.O_incw |
    Dum.O_incb |
    Dum.O_decl |
    Dum.O_decw |
    Dum.O_decb |
    Dum.O_negl |
    Dum.O_negw |
    Dum.O_negb |
    Dum.O_testl |
    Dum.O_testw |
    Dum.O_testb |
    Dum.O_leal |
    Dum.O_cmpl |
    Dum.O_cmpw |
    Dum.O_cmpb |
    Dum.O_cmpsb |
    Dum.O_scasb |
    Dum.O_movsl |
    Dum.O_movsw |
    Dum.O_movsb |
    Dum.O_stosl |
    Dum.O_stosw |
    Dum.O_stosb |
    Dum.O_leave |
    Dum.O_ret |
    Dum.O_call |
    Dum.O_jmp |
    Dum.O_je |
    Dum.O_jne |
    Dum.O_jl |
    Dum.O_jle |
    Dum.O_jg |
    Dum.O_jge |
    Dum.O_js |
    Dum.O_jns |
    Dum.O_jz |
    Dum.O_jnz |
    Dum.O_jc |
    Dum.O_jnc |
    Dum.O_jo |
    Dum.O_jno |
    Dum.O_ja |
    Dum.O_jae |
    Dum.O_jb |
    Dum.O_jbe |
    Dum.O_jp |
    Dum.O_seta |
    Dum.O_setae |
    Dum.O_setb |
    Dum.O_setbe |
    Dum.O_sete |
    Dum.O_setne |
    Dum.O_setl |
    Dum.O_setle |
    Dum.O_setg |
    Dum.O_setge |
    Dum.O_setc |
    Dum.O_setcb |
    Dum.O_btl |
    Dum.O_btsl |
    Dum.O_btrl |
    Dum.O_btcl |
    Dum.O_cld |
    Dum.O_cltd |
    Dum.O_cwtl |
    Dum.O_cbtw |
    Dum.O_rep |
    Dum.O_repz |
    Dum.O_repnz |
    Dum.O_fild |
    Dum.O_fildl |
    Dum.O_fildll |
    Dum.O_fsubp |
    Dum.O_fsubr |
    Dum.O_fsubrp |
    Dum.O_fsubrl |
    Dum.O_fsubrs |
    Dum.O_fsubs |
    Dum.O_fsubl |
    Dum.O_fsub |
    Dum.O_faddp |
    Dum.O_fadds |
    Dum.O_faddl |
    Dum.O_fadd |
    Dum.O_fiaddl |
    Dum.O_fmul |
    Dum.O_fmuls |
    Dum.O_fmull |
    Dum.O_fmulp |
    Dum.O_fimull |
    Dum.O_fdiv |
    Dum.O_fdivp |
    Dum.O_fdivr |
    Dum.O_fdivrs |
    Dum.O_fdivrl |
    Dum.O_fdivrp |
    Dum.O_fidivl |
    Dum.O_fidivrl |
    Dum.O_fdivl |
    Dum.O_fdivs |
    Dum.O_fprem |
    Dum.O_fstp |
    Dum.O_fsts |
    Dum.O_fstps |
    Dum.O_fstl |
    Dum.O_fstpl |
    Dum.O_fstpt |
    Dum.O_fst |
    Dum.O_fistl |
    Dum.O_fistpl |
    Dum.O_fistpll |
    Dum.O_fld |
    Dum.O_flds |
    Dum.O_fldl |
    Dum.O_fldt |
    Dum.O_fldz |
    Dum.O_fld1 |
    Dum.O_fldl2e |
    Dum.O_fldln2 |
    Dum.O_fchs |
    Dum.O_fsin |
    Dum.O_fcos |
    Dum.O_fptan |
    Dum.O_fsqrt |
    Dum.O_fpatan |
    Dum.O_fabs |
    Dum.O_f2xm1 |
    Dum.O_fscale |
    Dum.O_fyl2x |
    Dum.O_fucom |
    Dum.O_fucomp |
    Dum.O_fucompp |
    Dum.O_fcomp |
    Dum.O_fcompp |
    Dum.O_fcoml |
    Dum.O_fcompl |
    Dum.O_ficompl |
    Dum.O_fcoms |
    Dum.O_fcom |
    Dum.O_fcomps |
    Dum.O_fnstsw |
    Dum.O_fnstcw |
    Dum.O_fldcw |
    Dum.O_frndint |
    Dum.O_fxch |
    Dum.O_sahf |
    Dum.O_nop
  deriving (Show, Eq)
data Dum.OperandEffect
  = Dum.OE_RR Int Int |
    Dum.OE_RM Int Int |
    Dum.OE_RW Int Int |
    Dum.OE_nW Int |
    Dum.OE_RRM Int Int Int |
    Dum.OE_R Int |
    Dum.OE_M Int |
    Dum.OE_W Int
  deriving (Show, Eq)
data Dum.OperandInfo
  = Dum.OI_Special |
    Dum.OI_Jumpy |
    Dum.OI_NoEffect |
    Dum.OI_Error |
    Dum.OI [Dum.OperandEffect]
  deriving (Show, Eq)


["x86info","nonJumpyOpcodes"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Shapes
import Raster
import Quad
import Oct
import Csg
import Interval
import Types
import Vector
import Kolor
import Matrix

x86info :: [(Opcode, OperandInfo)]
x86info
  = [(O_movl, OI [OE_RW 4 4]), (O_movw, OI [OE_RW 2 2]),
     (O_movb, OI [OE_RW 1 1]), (O_movzbw, OI [OE_RW 1 2]),
     (O_movzbl, OI [OE_RW 1 4]), (O_movzwl, OI [OE_RW 2 4]),
     (O_movsbw, OI [OE_RW 1 2]), (O_movsbl, OI [OE_RW 1 4]),
     (O_movswl, OI [OE_RW 2 4]), (O_pushl, OI_Special),
     (O_popl, OI_Special), (O_pushfl, OI_Error), (O_popfl, OI_Error),
     (O_sall, OI [OE_RM 1 4]), (O_salw, OI [OE_RM 1 2]),
     (O_salb, OI [OE_RM 1 1]), (O_sarl, OI [OE_RM 1 4]),
     (O_sarw, OI [OE_RM 1 2]), (O_sarb, OI [OE_RM 1 1]),
     (O_shrl, OI [OE_RM 1 4]), (O_shrw, OI [OE_RM 1 2]),
     (O_shrb, OI [OE_RM 1 1]), (O_roll, OI [OE_RM 1 4]),
     (O_rolw, OI [OE_RM 1 2]), (O_rolb, OI [OE_RM 1 1]),
     (O_rorl, OI [OE_RM 1 4]), (O_rorw, OI [OE_RM 1 2]),
     (O_rorb, OI [OE_RM 1 1]), (O_shldl, OI [OE_RRM 4 4 4, OE_RM 4 4]),
     (O_shrdl, OI [OE_RRM 4 4 4, OE_RM 4 4]), (O_addl, OI [OE_RM 4 4]),
     (O_addw, OI [OE_RM 2 2]), (O_addb, OI [OE_RM 1 1]),
     (O_adcl, OI [OE_RM 4 4]), (O_subl, OI [OE_RM 4 4]),
     (O_subw, OI [OE_RM 2 2]), (O_subb, OI [OE_RM 1 1]),
     (O_sbbl, OI [OE_RM 4 4]),
     (O_imull, OI [OE_M 4, OE_RM 4 4, OE_RRM 4 4 4]),
     (O_imulb, OI [OE_M 1]), (O_imulw, OI [OE_M 2, OE_RM 2 2]),
     (O_mull, OI [OE_M 4]), (O_idivl, OI [OE_M 4]),
     (O_divl, OI [OE_M 4]), (O_divw, OI [OE_M 2]),
     (O_divb, OI [OE_M 1]), (O_xorl, OI [OE_RM 4 4]),
     (O_xorw, OI [OE_RM 2 2]), (O_xorb, OI [OE_RM 1 1]),
     (O_andl, OI [OE_RM 4 4]), (O_andw, OI [OE_RM 2 2]),
     (O_andb, OI [OE_RM 1 1]), (O_orl, OI [OE_RM 4 4]),
     (O_orw, OI [OE_RM 2 2]), (O_orb, OI [OE_RM 1 1]),
     (O_incl, OI [OE_M 4]), (O_incw, OI [OE_M 2]),
     (O_incb, OI [OE_M 1]), (O_decl, OI [OE_M 4]),
     (O_decw, OI [OE_M 2]), (O_decb, OI [OE_M 1]),
     (O_negl, OI [OE_M 4]), (O_negw, OI [OE_M 2]),
     (O_negb, OI [OE_M 1]), (O_notl, OI [OE_M 4]),
     (O_notw, OI [OE_M 2]), (O_notb, OI [OE_M 1]),
     (O_testl, OI [OE_RR 4 4]), (O_testw, OI [OE_RR 2 2]),
     (O_testb, OI [OE_RR 1 1]), (O_leal, OI [OE_nW 4]),
     (O_cmpl, OI [OE_RR 4 4]), (O_cmpw, OI [OE_RR 2 2]),
     (O_cmpb, OI [OE_RR 1 1]), (O_cmpsb, OI_Special),
     (O_scasb, OI_Special), (O_movsl, OI_Special),
     (O_movsw, OI_Special), (O_movsb, OI_Special),
     (O_stosl, OI_Special), (O_stosw, OI_Special),
     (O_stosb, OI_Special), (O_leave, OI_Error), (O_ret, OI_Special),
     (O_call, OI_Special), (O_jmp, OI_Jumpy), (O_je, OI_Jumpy),
     (O_jne, OI_Jumpy), (O_jl, OI_Jumpy), (O_jle, OI_Jumpy),
     (O_jg, OI_Jumpy), (O_jge, OI_Jumpy), (O_js, OI_Jumpy),
     (O_jns, OI_Jumpy), (O_jz, OI_Jumpy), (O_jnz, OI_Jumpy),
     (O_jc, OI_Jumpy), (O_jnc, OI_Jumpy), (O_jo, OI_Jumpy),
     (O_jno, OI_Jumpy), (O_ja, OI_Jumpy), (O_jae, OI_Jumpy),
     (O_jb, OI_Jumpy), (O_jbe, OI_Jumpy), (O_jp, OI_Jumpy),
     (O_seta, OI [OE_W 1]), (O_setae, OI [OE_W 1]),
     (O_setb, OI [OE_W 1]), (O_setbe, OI [OE_W 1]),
     (O_sete, OI [OE_W 1]), (O_setne, OI [OE_W 1]),
     (O_setl, OI [OE_W 1]), (O_setle, OI [OE_W 1]),
     (O_setg, OI [OE_W 1]), (O_setge, OI [OE_W 1]),
     (O_setc, OI [OE_W 1]), (O_setcb, OI [OE_W 1]),
     (O_btl, OI [OE_RR 4 4]), (O_btsl, OI [OE_RM 4 4]),
     (O_btcl, OI [OE_RM 4 4]), (O_btrl, OI [OE_RM 4 4]),
     (O_cld, OI_NoEffect), (O_cltd, OI_NoEffect), (O_cwtl, OI_NoEffect),
     (O_cbtw, OI_NoEffect), (O_rep, OI_Error), (O_repz, OI_Error),
     (O_repnz, OI_Error), (O_fld, OI [OE_R 8]), (O_fldt, OI [OE_R 8]),
     (O_fldl, OI [OE_R 8]), (O_flds, OI [OE_R 4]),
     (O_fild, OI [OE_R 4]), (O_fildl, OI [OE_R 4]),
     (O_fildll, OI [OE_R 8]), (O_fstl, OI [OE_W 8]),
     (O_fstpl, OI [OE_W 8]), (O_fstp, OI [OE_W 8]),
     (O_fstps, OI [OE_W 4]), (O_fsts, OI [OE_W 4]),
     (O_fstpt, OI [OE_W 8]), (O_fistl, OI [OE_W 4]),
     (O_fistpl, OI [OE_W 4]), (O_fistpll, OI [OE_W 8]),
     (O_fst, OI [OE_W 8]), (O_fldz, OI_NoEffect), (O_fld1, OI_NoEffect),
     (O_fldl2e, OI_NoEffect), (O_fldln2, OI_NoEffect),
     (O_fchs, OI_NoEffect), (O_fsin, OI_NoEffect),
     (O_fcos, OI_NoEffect), (O_fptan, OI_NoEffect),
     (O_fsqrt, OI_NoEffect), (O_fpatan, OI_NoEffect),
     (O_fabs, OI_NoEffect), (O_f2xm1, OI_NoEffect),
     (O_fscale, OI_NoEffect), (O_fyl2x, OI_NoEffect),
     (O_faddp, OI [OE_R 8, OE_RM 8 8]), (O_fadds, OI [OE_R 4]),
     (O_faddl, OI [OE_R 8]), (O_fiaddl, OI [OE_R 4]),
     (O_fadd, OI [OE_R 8, OE_RM 8 8]), (O_fsubp, OI [OE_RM 8 8]),
     (O_fsubrp, OI [OE_RM 8 8]), (O_fsubrl, OI [OE_R 8]),
     (O_fsubrs, OI [OE_R 4]), (O_fsubs, OI [OE_R 4]),
     (O_fsubl, OI [OE_R 8]), (O_fsub, OI [OE_R 8, OE_RM 8 8]),
     (O_fsubr, OI [OE_R 8, OE_RM 8 8]),
     (O_fmul, OI [OE_R 8, OE_RM 8 8]), (O_fmuls, OI [OE_R 4]),
     (O_fmull, OI [OE_R 8]), (O_fmulp, OI [OE_R 8, OE_RM 8 8]),
     (O_fimull, OI [OE_R 8]), (O_fdiv, OI [OE_RM 8 8]),
     (O_fdivp, OI [OE_RM 8 8]), (O_fdivr, OI [OE_RM 8 8]),
     (O_fdivrl, OI [OE_R 8]), (O_fdivrs, OI [OE_R 4]),
     (O_fdivrp, OI [OE_RM 8 8]), (O_fidivrl, OI [OE_R 4]),
     (O_fidivl, OI [OE_R 4]), (O_fdivl, OI [OE_R 8]),
     (O_fdivs, OI [OE_R 4]), (O_fprem, OI_NoEffect),
     (O_fucom, OI_NoEffect), (O_fucomp, OI_NoEffect),
     (O_fucompp, OI_NoEffect), (O_fcomp, OI_NoEffect),
     (O_fcompp, OI_NoEffect), (O_fcoms, OI [OE_R 4]),
     (O_fcoml, OI [OE_R 8]), (O_fcom, OI [OE_R 8]),
     (O_fcomps, OI [OE_R 4]), (O_fcompl, OI [OE_R 8]),
     (O_ficompl, OI [OE_R 4]), (O_fnstsw, OI [OE_W 2]),
     (O_fnstcw, OI [OE_W 2]), (O_fldcw, OI [OE_R 2]),
     (O_fxch, OI_NoEffect), (O_frndint, OI_NoEffect),
     (O_sahf, OI_NoEffect), (O_nop, OI_NoEffect)]

nonJumpyOpcodes :: [Opcode]
nonJumpyOpcodes
  = [O_pushl, O_popl, O_movl, O_movw, O_movb, O_andl, O_andw, O_andb,
     O_orl, O_orw, O_orb, O_xorl, O_xorw, O_xorb, O_addl, O_addw,
     O_addb, O_subl, O_subw, O_subb, O_incl, O_incw, O_incb, O_decl,
     O_decw, O_decb, O_cmpl, O_cmpw, O_cmpb, O_sall, O_salw, O_salb,
     O_shrl, O_shrw, O_shrb, O_sarl, O_leal, O_movzbw, O_movzbl,
     O_movzwl, O_movsbw, O_movsbl, O_movswl, O_seta, O_setae, O_setb,
     O_setbe, O_sete, O_setne, O_setl, O_setle, O_setg, O_setge, O_setc,
     O_setcb, O_testl, O_testw, O_testb, O_fld1, O_fcoml, O_fnstsw,
     O_fstpl, O_fstp, O_fsubrl, O_fldl, O_faddl, O_fsubl]

data Opcode = O_movl
            | O_movw
            | O_movb
            | O_movzbw
            | O_movzbl
            | O_movzwl
            | O_movsbw
            | O_movsbl
            | O_movswl
            | O_pushl
            | O_popl
            | O_pushfl
            | O_popfl
            | O_notl
            | O_notw
            | O_notb
            | O_sall
            | O_salw
            | O_salb
            | O_sarl
            | O_sarw
            | O_sarb
            | O_shrl
            | O_shrw
            | O_shrb
            | O_roll
            | O_rolw
            | O_rolb
            | O_rorl
            | O_rorw
            | O_rorb
            | O_shldl
            | O_shrdl
            | O_addl
            | O_addw
            | O_addb
            | O_adcl
            | O_subl
            | O_subw
            | O_subb
            | O_sbbl
            | O_imull
            | O_imulw
            | O_imulb
            | O_mull
            | O_divl
            | O_divw
            | O_divb
            | O_idivl
            | O_xorl
            | O_xorw
            | O_xorb
            | O_andl
            | O_andw
            | O_andb
            | O_orl
            | O_orw
            | O_orb
            | O_incl
            | O_incw
            | O_incb
            | O_decl
            | O_decw
            | O_decb
            | O_negl
            | O_negw
            | O_negb
            | O_testl
            | O_testw
            | O_testb
            | O_leal
            | O_cmpl
            | O_cmpw
            | O_cmpb
            | O_cmpsb
            | O_scasb
            | O_movsl
            | O_movsw
            | O_movsb
            | O_stosl
            | O_stosw
            | O_stosb
            | O_leave
            | O_ret
            | O_call
            | O_jmp
            | O_je
            | O_jne
            | O_jl
            | O_jle
            | O_jg
            | O_jge
            | O_js
            | O_jns
            | O_jz
            | O_jnz
            | O_jc
            | O_jnc
            | O_jo
            | O_jno
            | O_ja
            | O_jae
            | O_jb
            | O_jbe
            | O_jp
            | O_seta
            | O_setae
            | O_setb
            | O_setbe
            | O_sete
            | O_setne
            | O_setl
            | O_setle
            | O_setg
            | O_setge
            | O_setc
            | O_setcb
            | O_btl
            | O_btsl
            | O_btrl
            | O_btcl
            | O_cld
            | O_cltd
            | O_cwtl
            | O_cbtw
            | O_rep
            | O_repz
            | O_repnz
            | O_fild
            | O_fildl
            | O_fildll
            | O_fsubp
            | O_fsubr
            | O_fsubrp
            | O_fsubrl
            | O_fsubrs
            | O_fsubs
            | O_fsubl
            | O_fsub
            | O_faddp
            | O_fadds
            | O_faddl
            | O_fadd
            | O_fiaddl
            | O_fmul
            | O_fmuls
            | O_fmull
            | O_fmulp
            | O_fimull
            | O_fdiv
            | O_fdivp
            | O_fdivr
            | O_fdivrs
            | O_fdivrl
            | O_fdivrp
            | O_fidivl
            | O_fidivrl
            | O_fdivl
            | O_fdivs
            | O_fprem
            | O_fstp
            | O_fsts
            | O_fstps
            | O_fstl
            | O_fstpl
            | O_fstpt
            | O_fst
            | O_fistl
            | O_fistpl
            | O_fistpll
            | O_fld
            | O_flds
            | O_fldl
            | O_fldt
            | O_fldz
            | O_fld1
            | O_fldl2e
            | O_fldln2
            | O_fchs
            | O_fsin
            | O_fcos
            | O_fptan
            | O_fsqrt
            | O_fpatan
            | O_fabs
            | O_f2xm1
            | O_fscale
            | O_fyl2x
            | O_fucom
            | O_fucomp
            | O_fucompp
            | O_fcomp
            | O_fcompp
            | O_fcoml
            | O_fcompl
            | O_ficompl
            | O_fcoms
            | O_fcom
            | O_fcomps
            | O_fnstsw
            | O_fnstcw
            | O_fldcw
            | O_frndint
            | O_fxch
            | O_sahf
            | O_nop
            deriving (Show, Eq)

data OperandEffect = OE_RR Int Int
                   | OE_RM Int Int
                   | OE_RW Int Int
                   | OE_nW Int
                   | OE_RRM Int Int Int
                   | OE_R Int
                   | OE_M Int
                   | OE_W Int
                   deriving (Show, Eq)

data OperandInfo = OI_Special
                 | OI_Jumpy
                 | OI_NoEffect
                 | OI_Error
                 | OI [OperandEffect]
                 deriving (Show, Eq)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.x86info :: [(Dum.Opcode, Dum.OperandInfo)]
Dum.x86info
  = [(Dum.O_movl, Dum.OI [Dum.OE_RW 4 4]),
     (Dum.O_movw, Dum.OI [Dum.OE_RW 2 2]),
     (Dum.O_movb, Dum.OI [Dum.OE_RW 1 1]),
     (Dum.O_movzbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movzbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movzwl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_movsbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movsbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movswl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_pushl, Dum.OI_Special), (Dum.O_popl, Dum.OI_Special),
     (Dum.O_pushfl, Dum.OI_Error), (Dum.O_popfl, Dum.OI_Error),
     (Dum.O_sall, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_salw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_salb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sarl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_sarw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_sarb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shrl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_shrw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_shrb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_roll, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rolw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rolb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_rorl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rorw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shldl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_shrdl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_addl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_addw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_addb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_adcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_subb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sbbl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_imull, 
      Dum.OI [Dum.OE_M 4, Dum.OE_RM 4 4, Dum.OE_RRM 4 4 4]),
     (Dum.O_imulb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_imulw, Dum.OI [Dum.OE_M 2, Dum.OE_RM 2 2]),
     (Dum.O_mull, Dum.OI [Dum.OE_M 4]),
     (Dum.O_idivl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_divb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_xorl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_xorw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_xorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_andl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_andw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_andb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_orl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_orw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_orb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_incl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_incw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_incb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_decl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_decw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_decb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_negl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_negw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_negb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_notl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_notw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_notb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_testl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_testw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_testb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_leal, Dum.OI [Dum.OE_nW 4]),
     (Dum.O_cmpl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_cmpw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_cmpb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_cmpsb, Dum.OI_Special), (Dum.O_scasb, Dum.OI_Special),
     (Dum.O_movsl, Dum.OI_Special), (Dum.O_movsw, Dum.OI_Special),
     (Dum.O_movsb, Dum.OI_Special), (Dum.O_stosl, Dum.OI_Special),
     (Dum.O_stosw, Dum.OI_Special), (Dum.O_stosb, Dum.OI_Special),
     (Dum.O_leave, Dum.OI_Error), (Dum.O_ret, Dum.OI_Special),
     (Dum.O_call, Dum.OI_Special), (Dum.O_jmp, Dum.OI_Jumpy),
     (Dum.O_je, Dum.OI_Jumpy), (Dum.O_jne, Dum.OI_Jumpy),
     (Dum.O_jl, Dum.OI_Jumpy), (Dum.O_jle, Dum.OI_Jumpy),
     (Dum.O_jg, Dum.OI_Jumpy), (Dum.O_jge, Dum.OI_Jumpy),
     (Dum.O_js, Dum.OI_Jumpy), (Dum.O_jns, Dum.OI_Jumpy),
     (Dum.O_jz, Dum.OI_Jumpy), (Dum.O_jnz, Dum.OI_Jumpy),
     (Dum.O_jc, Dum.OI_Jumpy), (Dum.O_jnc, Dum.OI_Jumpy),
     (Dum.O_jo, Dum.OI_Jumpy), (Dum.O_jno, Dum.OI_Jumpy),
     (Dum.O_ja, Dum.OI_Jumpy), (Dum.O_jae, Dum.OI_Jumpy),
     (Dum.O_jb, Dum.OI_Jumpy), (Dum.O_jbe, Dum.OI_Jumpy),
     (Dum.O_jp, Dum.OI_Jumpy), (Dum.O_seta, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setae, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setbe, Dum.OI [Dum.OE_W 1]),
     (Dum.O_sete, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setne, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setl, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setle, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setg, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setge, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setc, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setcb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_btl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_btsl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btrl, Dum.OI [Dum.OE_RM 4 4]), (Dum.O_cld, Dum.OI_NoEffect),
     (Dum.O_cltd, Dum.OI_NoEffect), (Dum.O_cwtl, Dum.OI_NoEffect),
     (Dum.O_cbtw, Dum.OI_NoEffect), (Dum.O_rep, Dum.OI_Error),
     (Dum.O_repz, Dum.OI_Error), (Dum.O_repnz, Dum.OI_Error),
     (Dum.O_fld, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldt, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_flds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fild, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildll, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fstl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstpl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstp, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstps, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fsts, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fstpt, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fistl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpll, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fst, Dum.OI [Dum.OE_W 8]), (Dum.O_fldz, Dum.OI_NoEffect),
     (Dum.O_fld1, Dum.OI_NoEffect), (Dum.O_fldl2e, Dum.OI_NoEffect),
     (Dum.O_fldln2, Dum.OI_NoEffect), (Dum.O_fchs, Dum.OI_NoEffect),
     (Dum.O_fsin, Dum.OI_NoEffect), (Dum.O_fcos, Dum.OI_NoEffect),
     (Dum.O_fptan, Dum.OI_NoEffect), (Dum.O_fsqrt, Dum.OI_NoEffect),
     (Dum.O_fpatan, Dum.OI_NoEffect), (Dum.O_fabs, Dum.OI_NoEffect),
     (Dum.O_f2xm1, Dum.OI_NoEffect), (Dum.O_fscale, Dum.OI_NoEffect),
     (Dum.O_fyl2x, Dum.OI_NoEffect),
     (Dum.O_faddp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fadds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_faddl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fiaddl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fadd, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsubrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsub, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubr, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmul, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmuls, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fmull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fmulp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fimull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdiv, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivr, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fidivrl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fidivl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivs, Dum.OI [Dum.OE_R 4]), (Dum.O_fprem, Dum.OI_NoEffect),
     (Dum.O_fucom, Dum.OI_NoEffect), (Dum.O_fucomp, Dum.OI_NoEffect),
     (Dum.O_fucompp, Dum.OI_NoEffect), (Dum.O_fcomp, Dum.OI_NoEffect),
     (Dum.O_fcompp, Dum.OI_NoEffect),
     (Dum.O_fcoms, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcoml, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcom, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcomps, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcompl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_ficompl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fnstsw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fnstcw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fldcw, Dum.OI [Dum.OE_R 2]), (Dum.O_fxch, Dum.OI_NoEffect),
     (Dum.O_frndint, Dum.OI_NoEffect), (Dum.O_sahf, Dum.OI_NoEffect),
     (Dum.O_nop, Dum.OI_NoEffect)]
Dum.nonJumpyOpcodes :: [Dum.Opcode]
Dum.nonJumpyOpcodes
  = [Dum.O_pushl, Dum.O_popl, Dum.O_movl, Dum.O_movw, Dum.O_movb,
     Dum.O_andl, Dum.O_andw, Dum.O_andb, Dum.O_orl, Dum.O_orw,
     Dum.O_orb, Dum.O_xorl, Dum.O_xorw, Dum.O_xorb, Dum.O_addl,
     Dum.O_addw, Dum.O_addb, Dum.O_subl, Dum.O_subw, Dum.O_subb,
     Dum.O_incl, Dum.O_incw, Dum.O_incb, Dum.O_decl, Dum.O_decw,
     Dum.O_decb, Dum.O_cmpl, Dum.O_cmpw, Dum.O_cmpb, Dum.O_sall,
     Dum.O_salw, Dum.O_salb, Dum.O_shrl, Dum.O_shrw, Dum.O_shrb,
     Dum.O_sarl, Dum.O_leal, Dum.O_movzbw, Dum.O_movzbl, Dum.O_movzwl,
     Dum.O_movsbw, Dum.O_movsbl, Dum.O_movswl, Dum.O_seta, Dum.O_setae,
     Dum.O_setb, Dum.O_setbe, Dum.O_sete, Dum.O_setne, Dum.O_setl,
     Dum.O_setle, Dum.O_setg, Dum.O_setge, Dum.O_setc, Dum.O_setcb,
     Dum.O_testl, Dum.O_testw, Dum.O_testb, Dum.O_fld1, Dum.O_fcoml,
     Dum.O_fnstsw, Dum.O_fstpl, Dum.O_fstp, Dum.O_fsubrl, Dum.O_fldl,
     Dum.O_faddl, Dum.O_fsubl]

data Dum.Opcode
  = Dum.O_movl |
    Dum.O_movw |
    Dum.O_movb |
    Dum.O_movzbw |
    Dum.O_movzbl |
    Dum.O_movzwl |
    Dum.O_movsbw |
    Dum.O_movsbl |
    Dum.O_movswl |
    Dum.O_pushl |
    Dum.O_popl |
    Dum.O_pushfl |
    Dum.O_popfl |
    Dum.O_notl |
    Dum.O_notw |
    Dum.O_notb |
    Dum.O_sall |
    Dum.O_salw |
    Dum.O_salb |
    Dum.O_sarl |
    Dum.O_sarw |
    Dum.O_sarb |
    Dum.O_shrl |
    Dum.O_shrw |
    Dum.O_shrb |
    Dum.O_roll |
    Dum.O_rolw |
    Dum.O_rolb |
    Dum.O_rorl |
    Dum.O_rorw |
    Dum.O_rorb |
    Dum.O_shldl |
    Dum.O_shrdl |
    Dum.O_addl |
    Dum.O_addw |
    Dum.O_addb |
    Dum.O_adcl |
    Dum.O_subl |
    Dum.O_subw |
    Dum.O_subb |
    Dum.O_sbbl |
    Dum.O_imull |
    Dum.O_imulw |
    Dum.O_imulb |
    Dum.O_mull |
    Dum.O_divl |
    Dum.O_divw |
    Dum.O_divb |
    Dum.O_idivl |
    Dum.O_xorl |
    Dum.O_xorw |
    Dum.O_xorb |
    Dum.O_andl |
    Dum.O_andw |
    Dum.O_andb |
    Dum.O_orl |
    Dum.O_orw |
    Dum.O_orb |
    Dum.O_incl |
    Dum.O_incw |
    Dum.O_incb |
    Dum.O_decl |
    Dum.O_decw |
    Dum.O_decb |
    Dum.O_negl |
    Dum.O_negw |
    Dum.O_negb |
    Dum.O_testl |
    Dum.O_testw |
    Dum.O_testb |
    Dum.O_leal |
    Dum.O_cmpl |
    Dum.O_cmpw |
    Dum.O_cmpb |
    Dum.O_cmpsb |
    Dum.O_scasb |
    Dum.O_movsl |
    Dum.O_movsw |
    Dum.O_movsb |
    Dum.O_stosl |
    Dum.O_stosw |
    Dum.O_stosb |
    Dum.O_leave |
    Dum.O_ret |
    Dum.O_call |
    Dum.O_jmp |
    Dum.O_je |
    Dum.O_jne |
    Dum.O_jl |
    Dum.O_jle |
    Dum.O_jg |
    Dum.O_jge |
    Dum.O_js |
    Dum.O_jns |
    Dum.O_jz |
    Dum.O_jnz |
    Dum.O_jc |
    Dum.O_jnc |
    Dum.O_jo |
    Dum.O_jno |
    Dum.O_ja |
    Dum.O_jae |
    Dum.O_jb |
    Dum.O_jbe |
    Dum.O_jp |
    Dum.O_seta |
    Dum.O_setae |
    Dum.O_setb |
    Dum.O_setbe |
    Dum.O_sete |
    Dum.O_setne |
    Dum.O_setl |
    Dum.O_setle |
    Dum.O_setg |
    Dum.O_setge |
    Dum.O_setc |
    Dum.O_setcb |
    Dum.O_btl |
    Dum.O_btsl |
    Dum.O_btrl |
    Dum.O_btcl |
    Dum.O_cld |
    Dum.O_cltd |
    Dum.O_cwtl |
    Dum.O_cbtw |
    Dum.O_rep |
    Dum.O_repz |
    Dum.O_repnz |
    Dum.O_fild |
    Dum.O_fildl |
    Dum.O_fildll |
    Dum.O_fsubp |
    Dum.O_fsubr |
    Dum.O_fsubrp |
    Dum.O_fsubrl |
    Dum.O_fsubrs |
    Dum.O_fsubs |
    Dum.O_fsubl |
    Dum.O_fsub |
    Dum.O_faddp |
    Dum.O_fadds |
    Dum.O_faddl |
    Dum.O_fadd |
    Dum.O_fiaddl |
    Dum.O_fmul |
    Dum.O_fmuls |
    Dum.O_fmull |
    Dum.O_fmulp |
    Dum.O_fimull |
    Dum.O_fdiv |
    Dum.O_fdivp |
    Dum.O_fdivr |
    Dum.O_fdivrs |
    Dum.O_fdivrl |
    Dum.O_fdivrp |
    Dum.O_fidivl |
    Dum.O_fidivrl |
    Dum.O_fdivl |
    Dum.O_fdivs |
    Dum.O_fprem |
    Dum.O_fstp |
    Dum.O_fsts |
    Dum.O_fstps |
    Dum.O_fstl |
    Dum.O_fstpl |
    Dum.O_fstpt |
    Dum.O_fst |
    Dum.O_fistl |
    Dum.O_fistpl |
    Dum.O_fistpll |
    Dum.O_fld |
    Dum.O_flds |
    Dum.O_fldl |
    Dum.O_fldt |
    Dum.O_fldz |
    Dum.O_fld1 |
    Dum.O_fldl2e |
    Dum.O_fldln2 |
    Dum.O_fchs |
    Dum.O_fsin |
    Dum.O_fcos |
    Dum.O_fptan |
    Dum.O_fsqrt |
    Dum.O_fpatan |
    Dum.O_fabs |
    Dum.O_f2xm1 |
    Dum.O_fscale |
    Dum.O_fyl2x |
    Dum.O_fucom |
    Dum.O_fucomp |
    Dum.O_fucompp |
    Dum.O_fcomp |
    Dum.O_fcompp |
    Dum.O_fcoml |
    Dum.O_fcompl |
    Dum.O_ficompl |
    Dum.O_fcoms |
    Dum.O_fcom |
    Dum.O_fcomps |
    Dum.O_fnstsw |
    Dum.O_fnstcw |
    Dum.O_fldcw |
    Dum.O_frndint |
    Dum.O_fxch |
    Dum.O_sahf |
    Dum.O_nop
  deriving (Show, Eq)
data Dum.OperandEffect
  = Dum.OE_RR Int Int |
    Dum.OE_RM Int Int |
    Dum.OE_RW Int Int |
    Dum.OE_nW Int |
    Dum.OE_RRM Int Int Int |
    Dum.OE_R Int |
    Dum.OE_M Int |
    Dum.OE_W Int
  deriving (Show, Eq)
data Dum.OperandInfo
  = Dum.OI_Special |
    Dum.OI_Jumpy |
    Dum.OI_NoEffect |
    Dum.OI_Error |
    Dum.OI [Dum.OperandEffect]
  deriving (Show, Eq)


["x86info","nonJumpyOpcodes"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Interval
import Types

x86info :: [(Opcode, OperandInfo)]
x86info
  = [(O_movl, OI [OE_RW 4 4]), (O_movw, OI [OE_RW 2 2]),
     (O_movb, OI [OE_RW 1 1]), (O_movzbw, OI [OE_RW 1 2]),
     (O_movzbl, OI [OE_RW 1 4]), (O_movzwl, OI [OE_RW 2 4]),
     (O_movsbw, OI [OE_RW 1 2]), (O_movsbl, OI [OE_RW 1 4]),
     (O_movswl, OI [OE_RW 2 4]), (O_pushl, OI_Special),
     (O_popl, OI_Special), (O_pushfl, OI_Error), (O_popfl, OI_Error),
     (O_sall, OI [OE_RM 1 4]), (O_salw, OI [OE_RM 1 2]),
     (O_salb, OI [OE_RM 1 1]), (O_sarl, OI [OE_RM 1 4]),
     (O_sarw, OI [OE_RM 1 2]), (O_sarb, OI [OE_RM 1 1]),
     (O_shrl, OI [OE_RM 1 4]), (O_shrw, OI [OE_RM 1 2]),
     (O_shrb, OI [OE_RM 1 1]), (O_roll, OI [OE_RM 1 4]),
     (O_rolw, OI [OE_RM 1 2]), (O_rolb, OI [OE_RM 1 1]),
     (O_rorl, OI [OE_RM 1 4]), (O_rorw, OI [OE_RM 1 2]),
     (O_rorb, OI [OE_RM 1 1]), (O_shldl, OI [OE_RRM 4 4 4, OE_RM 4 4]),
     (O_shrdl, OI [OE_RRM 4 4 4, OE_RM 4 4]), (O_addl, OI [OE_RM 4 4]),
     (O_addw, OI [OE_RM 2 2]), (O_addb, OI [OE_RM 1 1]),
     (O_adcl, OI [OE_RM 4 4]), (O_subl, OI [OE_RM 4 4]),
     (O_subw, OI [OE_RM 2 2]), (O_subb, OI [OE_RM 1 1]),
     (O_sbbl, OI [OE_RM 4 4]),
     (O_imull, OI [OE_M 4, OE_RM 4 4, OE_RRM 4 4 4]),
     (O_imulb, OI [OE_M 1]), (O_imulw, OI [OE_M 2, OE_RM 2 2]),
     (O_mull, OI [OE_M 4]), (O_idivl, OI [OE_M 4]),
     (O_divl, OI [OE_M 4]), (O_divw, OI [OE_M 2]),
     (O_divb, OI [OE_M 1]), (O_xorl, OI [OE_RM 4 4]),
     (O_xorw, OI [OE_RM 2 2]), (O_xorb, OI [OE_RM 1 1]),
     (O_andl, OI [OE_RM 4 4]), (O_andw, OI [OE_RM 2 2]),
     (O_andb, OI [OE_RM 1 1]), (O_orl, OI [OE_RM 4 4]),
     (O_orw, OI [OE_RM 2 2]), (O_orb, OI [OE_RM 1 1]),
     (O_incl, OI [OE_M 4]), (O_incw, OI [OE_M 2]),
     (O_incb, OI [OE_M 1]), (O_decl, OI [OE_M 4]),
     (O_decw, OI [OE_M 2]), (O_decb, OI [OE_M 1]),
     (O_negl, OI [OE_M 4]), (O_negw, OI [OE_M 2]),
     (O_negb, OI [OE_M 1]), (O_notl, OI [OE_M 4]),
     (O_notw, OI [OE_M 2]), (O_notb, OI [OE_M 1]),
     (O_testl, OI [OE_RR 4 4]), (O_testw, OI [OE_RR 2 2]),
     (O_testb, OI [OE_RR 1 1]), (O_leal, OI [OE_nW 4]),
     (O_cmpl, OI [OE_RR 4 4]), (O_cmpw, OI [OE_RR 2 2]),
     (O_cmpb, OI [OE_RR 1 1]), (O_cmpsb, OI_Special),
     (O_scasb, OI_Special), (O_movsl, OI_Special),
     (O_movsw, OI_Special), (O_movsb, OI_Special),
     (O_stosl, OI_Special), (O_stosw, OI_Special),
     (O_stosb, OI_Special), (O_leave, OI_Error), (O_ret, OI_Special),
     (O_call, OI_Special), (O_jmp, OI_Jumpy), (O_je, OI_Jumpy),
     (O_jne, OI_Jumpy), (O_jl, OI_Jumpy), (O_jle, OI_Jumpy),
     (O_jg, OI_Jumpy), (O_jge, OI_Jumpy), (O_js, OI_Jumpy),
     (O_jns, OI_Jumpy), (O_jz, OI_Jumpy), (O_jnz, OI_Jumpy),
     (O_jc, OI_Jumpy), (O_jnc, OI_Jumpy), (O_jo, OI_Jumpy),
     (O_jno, OI_Jumpy), (O_ja, OI_Jumpy), (O_jae, OI_Jumpy),
     (O_jb, OI_Jumpy), (O_jbe, OI_Jumpy), (O_jp, OI_Jumpy),
     (O_seta, OI [OE_W 1]), (O_setae, OI [OE_W 1]),
     (O_setb, OI [OE_W 1]), (O_setbe, OI [OE_W 1]),
     (O_sete, OI [OE_W 1]), (O_setne, OI [OE_W 1]),
     (O_setl, OI [OE_W 1]), (O_setle, OI [OE_W 1]),
     (O_setg, OI [OE_W 1]), (O_setge, OI [OE_W 1]),
     (O_setc, OI [OE_W 1]), (O_setcb, OI [OE_W 1]),
     (O_btl, OI [OE_RR 4 4]), (O_btsl, OI [OE_RM 4 4]),
     (O_btcl, OI [OE_RM 4 4]), (O_btrl, OI [OE_RM 4 4]),
     (O_cld, OI_NoEffect), (O_cltd, OI_NoEffect), (O_cwtl, OI_NoEffect),
     (O_cbtw, OI_NoEffect), (O_rep, OI_Error), (O_repz, OI_Error),
     (O_repnz, OI_Error), (O_fld, OI [OE_R 8]), (O_fldt, OI [OE_R 8]),
     (O_fldl, OI [OE_R 8]), (O_flds, OI [OE_R 4]),
     (O_fild, OI [OE_R 4]), (O_fildl, OI [OE_R 4]),
     (O_fildll, OI [OE_R 8]), (O_fstl, OI [OE_W 8]),
     (O_fstpl, OI [OE_W 8]), (O_fstp, OI [OE_W 8]),
     (O_fstps, OI [OE_W 4]), (O_fsts, OI [OE_W 4]),
     (O_fstpt, OI [OE_W 8]), (O_fistl, OI [OE_W 4]),
     (O_fistpl, OI [OE_W 4]), (O_fistpll, OI [OE_W 8]),
     (O_fst, OI [OE_W 8]), (O_fldz, OI_NoEffect), (O_fld1, OI_NoEffect),
     (O_fldl2e, OI_NoEffect), (O_fldln2, OI_NoEffect),
     (O_fchs, OI_NoEffect), (O_fsin, OI_NoEffect),
     (O_fcos, OI_NoEffect), (O_fptan, OI_NoEffect),
     (O_fsqrt, OI_NoEffect), (O_fpatan, OI_NoEffect),
     (O_fabs, OI_NoEffect), (O_f2xm1, OI_NoEffect),
     (O_fscale, OI_NoEffect), (O_fyl2x, OI_NoEffect),
     (O_faddp, OI [OE_R 8, OE_RM 8 8]), (O_fadds, OI [OE_R 4]),
     (O_faddl, OI [OE_R 8]), (O_fiaddl, OI [OE_R 4]),
     (O_fadd, OI [OE_R 8, OE_RM 8 8]), (O_fsubp, OI [OE_RM 8 8]),
     (O_fsubrp, OI [OE_RM 8 8]), (O_fsubrl, OI [OE_R 8]),
     (O_fsubrs, OI [OE_R 4]), (O_fsubs, OI [OE_R 4]),
     (O_fsubl, OI [OE_R 8]), (O_fsub, OI [OE_R 8, OE_RM 8 8]),
     (O_fsubr, OI [OE_R 8, OE_RM 8 8]),
     (O_fmul, OI [OE_R 8, OE_RM 8 8]), (O_fmuls, OI [OE_R 4]),
     (O_fmull, OI [OE_R 8]), (O_fmulp, OI [OE_R 8, OE_RM 8 8]),
     (O_fimull, OI [OE_R 8]), (O_fdiv, OI [OE_RM 8 8]),
     (O_fdivp, OI [OE_RM 8 8]), (O_fdivr, OI [OE_RM 8 8]),
     (O_fdivrl, OI [OE_R 8]), (O_fdivrs, OI [OE_R 4]),
     (O_fdivrp, OI [OE_RM 8 8]), (O_fidivrl, OI [OE_R 4]),
     (O_fidivl, OI [OE_R 4]), (O_fdivl, OI [OE_R 8]),
     (O_fdivs, OI [OE_R 4]), (O_fprem, OI_NoEffect),
     (O_fucom, OI_NoEffect), (O_fucomp, OI_NoEffect),
     (O_fucompp, OI_NoEffect), (O_fcomp, OI_NoEffect),
     (O_fcompp, OI_NoEffect), (O_fcoms, OI [OE_R 4]),
     (O_fcoml, OI [OE_R 8]), (O_fcom, OI [OE_R 8]),
     (O_fcomps, OI [OE_R 4]), (O_fcompl, OI [OE_R 8]),
     (O_ficompl, OI [OE_R 4]), (O_fnstsw, OI [OE_W 2]),
     (O_fnstcw, OI [OE_W 2]), (O_fldcw, OI [OE_R 2]),
     (O_fxch, OI_NoEffect), (O_frndint, OI_NoEffect),
     (O_sahf, OI_NoEffect), (O_nop, OI_NoEffect)]

nonJumpyOpcodes :: [Opcode]
nonJumpyOpcodes
  = [O_pushl, O_popl, O_movl, O_movw, O_movb, O_andl, O_andw, O_andb,
     O_orl, O_orw, O_orb, O_xorl, O_xorw, O_xorb, O_addl, O_addw,
     O_addb, O_subl, O_subw, O_subb, O_incl, O_incw, O_incb, O_decl,
     O_decw, O_decb, O_cmpl, O_cmpw, O_cmpb, O_sall, O_salw, O_salb,
     O_shrl, O_shrw, O_shrb, O_sarl, O_leal, O_movzbw, O_movzbl,
     O_movzwl, O_movsbw, O_movsbl, O_movswl, O_seta, O_setae, O_setb,
     O_setbe, O_sete, O_setne, O_setl, O_setle, O_setg, O_setge, O_setc,
     O_setcb, O_testl, O_testw, O_testb, O_fld1, O_fcoml, O_fnstsw,
     O_fstpl, O_fstp, O_fsubrl, O_fldl, O_faddl, O_fsubl]

data Opcode = O_movl
            | O_movw
            | O_movb
            | O_movzbw
            | O_movzbl
            | O_movzwl
            | O_movsbw
            | O_movsbl
            | O_movswl
            | O_pushl
            | O_popl
            | O_pushfl
            | O_popfl
            | O_notl
            | O_notw
            | O_notb
            | O_sall
            | O_salw
            | O_salb
            | O_sarl
            | O_sarw
            | O_sarb
            | O_shrl
            | O_shrw
            | O_shrb
            | O_roll
            | O_rolw
            | O_rolb
            | O_rorl
            | O_rorw
            | O_rorb
            | O_shldl
            | O_shrdl
            | O_addl
            | O_addw
            | O_addb
            | O_adcl
            | O_subl
            | O_subw
            | O_subb
            | O_sbbl
            | O_imull
            | O_imulw
            | O_imulb
            | O_mull
            | O_divl
            | O_divw
            | O_divb
            | O_idivl
            | O_xorl
            | O_xorw
            | O_xorb
            | O_andl
            | O_andw
            | O_andb
            | O_orl
            | O_orw
            | O_orb
            | O_incl
            | O_incw
            | O_incb
            | O_decl
            | O_decw
            | O_decb
            | O_negl
            | O_negw
            | O_negb
            | O_testl
            | O_testw
            | O_testb
            | O_leal
            | O_cmpl
            | O_cmpw
            | O_cmpb
            | O_cmpsb
            | O_scasb
            | O_movsl
            | O_movsw
            | O_movsb
            | O_stosl
            | O_stosw
            | O_stosb
            | O_leave
            | O_ret
            | O_call
            | O_jmp
            | O_je
            | O_jne
            | O_jl
            | O_jle
            | O_jg
            | O_jge
            | O_js
            | O_jns
            | O_jz
            | O_jnz
            | O_jc
            | O_jnc
            | O_jo
            | O_jno
            | O_ja
            | O_jae
            | O_jb
            | O_jbe
            | O_jp
            | O_seta
            | O_setae
            | O_setb
            | O_setbe
            | O_sete
            | O_setne
            | O_setl
            | O_setle
            | O_setg
            | O_setge
            | O_setc
            | O_setcb
            | O_btl
            | O_btsl
            | O_btrl
            | O_btcl
            | O_cld
            | O_cltd
            | O_cwtl
            | O_cbtw
            | O_rep
            | O_repz
            | O_repnz
            | O_fild
            | O_fildl
            | O_fildll
            | O_fsubp
            | O_fsubr
            | O_fsubrp
            | O_fsubrl
            | O_fsubrs
            | O_fsubs
            | O_fsubl
            | O_fsub
            | O_faddp
            | O_fadds
            | O_faddl
            | O_fadd
            | O_fiaddl
            | O_fmul
            | O_fmuls
            | O_fmull
            | O_fmulp
            | O_fimull
            | O_fdiv
            | O_fdivp
            | O_fdivr
            | O_fdivrs
            | O_fdivrl
            | O_fdivrp
            | O_fidivl
            | O_fidivrl
            | O_fdivl
            | O_fdivs
            | O_fprem
            | O_fstp
            | O_fsts
            | O_fstps
            | O_fstl
            | O_fstpl
            | O_fstpt
            | O_fst
            | O_fistl
            | O_fistpl
            | O_fistpll
            | O_fld
            | O_flds
            | O_fldl
            | O_fldt
            | O_fldz
            | O_fld1
            | O_fldl2e
            | O_fldln2
            | O_fchs
            | O_fsin
            | O_fcos
            | O_fptan
            | O_fsqrt
            | O_fpatan
            | O_fabs
            | O_f2xm1
            | O_fscale
            | O_fyl2x
            | O_fucom
            | O_fucomp
            | O_fucompp
            | O_fcomp
            | O_fcompp
            | O_fcoml
            | O_fcompl
            | O_ficompl
            | O_fcoms
            | O_fcom
            | O_fcomps
            | O_fnstsw
            | O_fnstcw
            | O_fldcw
            | O_frndint
            | O_fxch
            | O_sahf
            | O_nop
            deriving (Show, Eq)

data OperandEffect = OE_RR Int Int
                   | OE_RM Int Int
                   | OE_RW Int Int
                   | OE_nW Int
                   | OE_RRM Int Int Int
                   | OE_R Int
                   | OE_M Int
                   | OE_W Int
                   deriving (Show, Eq)

data OperandInfo = OI_Special
                 | OI_Jumpy
                 | OI_NoEffect
                 | OI_Error
                 | OI [OperandEffect]
                 deriving (Show, Eq)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.x86info :: [(Dum.Opcode, Dum.OperandInfo)]
Dum.x86info
  = [(Dum.O_movl, Dum.OI [Dum.OE_RW 4 4]),
     (Dum.O_movw, Dum.OI [Dum.OE_RW 2 2]),
     (Dum.O_movb, Dum.OI [Dum.OE_RW 1 1]),
     (Dum.O_movzbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movzbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movzwl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_movsbw, Dum.OI [Dum.OE_RW 1 2]),
     (Dum.O_movsbl, Dum.OI [Dum.OE_RW 1 4]),
     (Dum.O_movswl, Dum.OI [Dum.OE_RW 2 4]),
     (Dum.O_pushl, Dum.OI_Special), (Dum.O_popl, Dum.OI_Special),
     (Dum.O_pushfl, Dum.OI_Error), (Dum.O_popfl, Dum.OI_Error),
     (Dum.O_sall, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_salw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_salb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sarl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_sarw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_sarb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shrl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_shrw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_shrb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_roll, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rolw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rolb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_rorl, Dum.OI [Dum.OE_RM 1 4]),
     (Dum.O_rorw, Dum.OI [Dum.OE_RM 1 2]),
     (Dum.O_rorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_shldl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_shrdl, Dum.OI [Dum.OE_RRM 4 4 4, Dum.OE_RM 4 4]),
     (Dum.O_addl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_addw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_addb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_adcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_subw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_subb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_sbbl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_imull, 
      Dum.OI [Dum.OE_M 4, Dum.OE_RM 4 4, Dum.OE_RRM 4 4 4]),
     (Dum.O_imulb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_imulw, Dum.OI [Dum.OE_M 2, Dum.OE_RM 2 2]),
     (Dum.O_mull, Dum.OI [Dum.OE_M 4]),
     (Dum.O_idivl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_divw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_divb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_xorl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_xorw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_xorb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_andl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_andw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_andb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_orl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_orw, Dum.OI [Dum.OE_RM 2 2]),
     (Dum.O_orb, Dum.OI [Dum.OE_RM 1 1]),
     (Dum.O_incl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_incw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_incb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_decl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_decw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_decb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_negl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_negw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_negb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_notl, Dum.OI [Dum.OE_M 4]),
     (Dum.O_notw, Dum.OI [Dum.OE_M 2]),
     (Dum.O_notb, Dum.OI [Dum.OE_M 1]),
     (Dum.O_testl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_testw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_testb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_leal, Dum.OI [Dum.OE_nW 4]),
     (Dum.O_cmpl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_cmpw, Dum.OI [Dum.OE_RR 2 2]),
     (Dum.O_cmpb, Dum.OI [Dum.OE_RR 1 1]),
     (Dum.O_cmpsb, Dum.OI_Special), (Dum.O_scasb, Dum.OI_Special),
     (Dum.O_movsl, Dum.OI_Special), (Dum.O_movsw, Dum.OI_Special),
     (Dum.O_movsb, Dum.OI_Special), (Dum.O_stosl, Dum.OI_Special),
     (Dum.O_stosw, Dum.OI_Special), (Dum.O_stosb, Dum.OI_Special),
     (Dum.O_leave, Dum.OI_Error), (Dum.O_ret, Dum.OI_Special),
     (Dum.O_call, Dum.OI_Special), (Dum.O_jmp, Dum.OI_Jumpy),
     (Dum.O_je, Dum.OI_Jumpy), (Dum.O_jne, Dum.OI_Jumpy),
     (Dum.O_jl, Dum.OI_Jumpy), (Dum.O_jle, Dum.OI_Jumpy),
     (Dum.O_jg, Dum.OI_Jumpy), (Dum.O_jge, Dum.OI_Jumpy),
     (Dum.O_js, Dum.OI_Jumpy), (Dum.O_jns, Dum.OI_Jumpy),
     (Dum.O_jz, Dum.OI_Jumpy), (Dum.O_jnz, Dum.OI_Jumpy),
     (Dum.O_jc, Dum.OI_Jumpy), (Dum.O_jnc, Dum.OI_Jumpy),
     (Dum.O_jo, Dum.OI_Jumpy), (Dum.O_jno, Dum.OI_Jumpy),
     (Dum.O_ja, Dum.OI_Jumpy), (Dum.O_jae, Dum.OI_Jumpy),
     (Dum.O_jb, Dum.OI_Jumpy), (Dum.O_jbe, Dum.OI_Jumpy),
     (Dum.O_jp, Dum.OI_Jumpy), (Dum.O_seta, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setae, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setbe, Dum.OI [Dum.OE_W 1]),
     (Dum.O_sete, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setne, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setl, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setle, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setg, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setge, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setc, Dum.OI [Dum.OE_W 1]),
     (Dum.O_setcb, Dum.OI [Dum.OE_W 1]),
     (Dum.O_btl, Dum.OI [Dum.OE_RR 4 4]),
     (Dum.O_btsl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btcl, Dum.OI [Dum.OE_RM 4 4]),
     (Dum.O_btrl, Dum.OI [Dum.OE_RM 4 4]), (Dum.O_cld, Dum.OI_NoEffect),
     (Dum.O_cltd, Dum.OI_NoEffect), (Dum.O_cwtl, Dum.OI_NoEffect),
     (Dum.O_cbtw, Dum.OI_NoEffect), (Dum.O_rep, Dum.OI_Error),
     (Dum.O_repz, Dum.OI_Error), (Dum.O_repnz, Dum.OI_Error),
     (Dum.O_fld, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldt, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fldl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_flds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fild, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fildll, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fstl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstpl, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstp, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fstps, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fsts, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fstpt, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fistl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpl, Dum.OI [Dum.OE_W 4]),
     (Dum.O_fistpll, Dum.OI [Dum.OE_W 8]),
     (Dum.O_fst, Dum.OI [Dum.OE_W 8]), (Dum.O_fldz, Dum.OI_NoEffect),
     (Dum.O_fld1, Dum.OI_NoEffect), (Dum.O_fldl2e, Dum.OI_NoEffect),
     (Dum.O_fldln2, Dum.OI_NoEffect), (Dum.O_fchs, Dum.OI_NoEffect),
     (Dum.O_fsin, Dum.OI_NoEffect), (Dum.O_fcos, Dum.OI_NoEffect),
     (Dum.O_fptan, Dum.OI_NoEffect), (Dum.O_fsqrt, Dum.OI_NoEffect),
     (Dum.O_fpatan, Dum.OI_NoEffect), (Dum.O_fabs, Dum.OI_NoEffect),
     (Dum.O_f2xm1, Dum.OI_NoEffect), (Dum.O_fscale, Dum.OI_NoEffect),
     (Dum.O_fyl2x, Dum.OI_NoEffect),
     (Dum.O_faddp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fadds, Dum.OI [Dum.OE_R 4]),
     (Dum.O_faddl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fiaddl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fadd, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fsubrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsubrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fsubl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fsub, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fsubr, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmul, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fmuls, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fmull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fmulp, Dum.OI [Dum.OE_R 8, Dum.OE_RM 8 8]),
     (Dum.O_fimull, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdiv, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivr, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fdivrl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivrs, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivrp, Dum.OI [Dum.OE_RM 8 8]),
     (Dum.O_fidivrl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fidivl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fdivl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fdivs, Dum.OI [Dum.OE_R 4]), (Dum.O_fprem, Dum.OI_NoEffect),
     (Dum.O_fucom, Dum.OI_NoEffect), (Dum.O_fucomp, Dum.OI_NoEffect),
     (Dum.O_fucompp, Dum.OI_NoEffect), (Dum.O_fcomp, Dum.OI_NoEffect),
     (Dum.O_fcompp, Dum.OI_NoEffect),
     (Dum.O_fcoms, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcoml, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcom, Dum.OI [Dum.OE_R 8]),
     (Dum.O_fcomps, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fcompl, Dum.OI [Dum.OE_R 8]),
     (Dum.O_ficompl, Dum.OI [Dum.OE_R 4]),
     (Dum.O_fnstsw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fnstcw, Dum.OI [Dum.OE_W 2]),
     (Dum.O_fldcw, Dum.OI [Dum.OE_R 2]), (Dum.O_fxch, Dum.OI_NoEffect),
     (Dum.O_frndint, Dum.OI_NoEffect), (Dum.O_sahf, Dum.OI_NoEffect),
     (Dum.O_nop, Dum.OI_NoEffect)]
Dum.nonJumpyOpcodes :: [Dum.Opcode]
Dum.nonJumpyOpcodes
  = [Dum.O_pushl, Dum.O_popl, Dum.O_movl, Dum.O_movw, Dum.O_movb,
     Dum.O_andl, Dum.O_andw, Dum.O_andb, Dum.O_orl, Dum.O_orw,
     Dum.O_orb, Dum.O_xorl, Dum.O_xorw, Dum.O_xorb, Dum.O_addl,
     Dum.O_addw, Dum.O_addb, Dum.O_subl, Dum.O_subw, Dum.O_subb,
     Dum.O_incl, Dum.O_incw, Dum.O_incb, Dum.O_decl, Dum.O_decw,
     Dum.O_decb, Dum.O_cmpl, Dum.O_cmpw, Dum.O_cmpb, Dum.O_sall,
     Dum.O_salw, Dum.O_salb, Dum.O_shrl, Dum.O_shrw, Dum.O_shrb,
     Dum.O_sarl, Dum.O_leal, Dum.O_movzbw, Dum.O_movzbl, Dum.O_movzwl,
     Dum.O_movsbw, Dum.O_movsbl, Dum.O_movswl, Dum.O_seta, Dum.O_setae,
     Dum.O_setb, Dum.O_setbe, Dum.O_sete, Dum.O_setne, Dum.O_setl,
     Dum.O_setle, Dum.O_setg, Dum.O_setge, Dum.O_setc, Dum.O_setcb,
     Dum.O_testl, Dum.O_testw, Dum.O_testb, Dum.O_fld1, Dum.O_fcoml,
     Dum.O_fnstsw, Dum.O_fstpl, Dum.O_fstp, Dum.O_fsubrl, Dum.O_fldl,
     Dum.O_faddl, Dum.O_fsubl]

data Dum.Opcode
  = Dum.O_movl |
    Dum.O_movw |
    Dum.O_movb |
    Dum.O_movzbw |
    Dum.O_movzbl |
    Dum.O_movzwl |
    Dum.O_movsbw |
    Dum.O_movsbl |
    Dum.O_movswl |
    Dum.O_pushl |
    Dum.O_popl |
    Dum.O_pushfl |
    Dum.O_popfl |
    Dum.O_notl |
    Dum.O_notw |
    Dum.O_notb |
    Dum.O_sall |
    Dum.O_salw |
    Dum.O_salb |
    Dum.O_sarl |
    Dum.O_sarw |
    Dum.O_sarb |
    Dum.O_shrl |
    Dum.O_shrw |
    Dum.O_shrb |
    Dum.O_roll |
    Dum.O_rolw |
    Dum.O_rolb |
    Dum.O_rorl |
    Dum.O_rorw |
    Dum.O_rorb |
    Dum.O_shldl |
    Dum.O_shrdl |
    Dum.O_addl |
    Dum.O_addw |
    Dum.O_addb |
    Dum.O_adcl |
    Dum.O_subl |
    Dum.O_subw |
    Dum.O_subb |
    Dum.O_sbbl |
    Dum.O_imull |
    Dum.O_imulw |
    Dum.O_imulb |
    Dum.O_mull |
    Dum.O_divl |
    Dum.O_divw |
    Dum.O_divb |
    Dum.O_idivl |
    Dum.O_xorl |
    Dum.O_xorw |
    Dum.O_xorb |
    Dum.O_andl |
    Dum.O_andw |
    Dum.O_andb |
    Dum.O_orl |
    Dum.O_orw |
    Dum.O_orb |
    Dum.O_incl |
    Dum.O_incw |
    Dum.O_incb |
    Dum.O_decl |
    Dum.O_decw |
    Dum.O_decb |
    Dum.O_negl |
    Dum.O_negw |
    Dum.O_negb |
    Dum.O_testl |
    Dum.O_testw |
    Dum.O_testb |
    Dum.O_leal |
    Dum.O_cmpl |
    Dum.O_cmpw |
    Dum.O_cmpb |
    Dum.O_cmpsb |
    Dum.O_scasb |
    Dum.O_movsl |
    Dum.O_movsw |
    Dum.O_movsb |
    Dum.O_stosl |
    Dum.O_stosw |
    Dum.O_stosb |
    Dum.O_leave |
    Dum.O_ret |
    Dum.O_call |
    Dum.O_jmp |
    Dum.O_je |
    Dum.O_jne |
    Dum.O_jl |
    Dum.O_jle |
    Dum.O_jg |
    Dum.O_jge |
    Dum.O_js |
    Dum.O_jns |
    Dum.O_jz |
    Dum.O_jnz |
    Dum.O_jc |
    Dum.O_jnc |
    Dum.O_jo |
    Dum.O_jno |
    Dum.O_ja |
    Dum.O_jae |
    Dum.O_jb |
    Dum.O_jbe |
    Dum.O_jp |
    Dum.O_seta |
    Dum.O_setae |
    Dum.O_setb |
    Dum.O_setbe |
    Dum.O_sete |
    Dum.O_setne |
    Dum.O_setl |
    Dum.O_setle |
    Dum.O_setg |
    Dum.O_setge |
    Dum.O_setc |
    Dum.O_setcb |
    Dum.O_btl |
    Dum.O_btsl |
    Dum.O_btrl |
    Dum.O_btcl |
    Dum.O_cld |
    Dum.O_cltd |
    Dum.O_cwtl |
    Dum.O_cbtw |
    Dum.O_rep |
    Dum.O_repz |
    Dum.O_repnz |
    Dum.O_fild |
    Dum.O_fildl |
    Dum.O_fildll |
    Dum.O_fsubp |
    Dum.O_fsubr |
    Dum.O_fsubrp |
    Dum.O_fsubrl |
    Dum.O_fsubrs |
    Dum.O_fsubs |
    Dum.O_fsubl |
    Dum.O_fsub |
    Dum.O_faddp |
    Dum.O_fadds |
    Dum.O_faddl |
    Dum.O_fadd |
    Dum.O_fiaddl |
    Dum.O_fmul |
    Dum.O_fmuls |
    Dum.O_fmull |
    Dum.O_fmulp |
    Dum.O_fimull |
    Dum.O_fdiv |
    Dum.O_fdivp |
    Dum.O_fdivr |
    Dum.O_fdivrs |
    Dum.O_fdivrl |
    Dum.O_fdivrp |
    Dum.O_fidivl |
    Dum.O_fidivrl |
    Dum.O_fdivl |
    Dum.O_fdivs |
    Dum.O_fprem |
    Dum.O_fstp |
    Dum.O_fsts |
    Dum.O_fstps |
    Dum.O_fstl |
    Dum.O_fstpl |
    Dum.O_fstpt |
    Dum.O_fst |
    Dum.O_fistl |
    Dum.O_fistpl |
    Dum.O_fistpll |
    Dum.O_fld |
    Dum.O_flds |
    Dum.O_fldl |
    Dum.O_fldt |
    Dum.O_fldz |
    Dum.O_fld1 |
    Dum.O_fldl2e |
    Dum.O_fldln2 |
    Dum.O_fchs |
    Dum.O_fsin |
    Dum.O_fcos |
    Dum.O_fptan |
    Dum.O_fsqrt |
    Dum.O_fpatan |
    Dum.O_fabs |
    Dum.O_f2xm1 |
    Dum.O_fscale |
    Dum.O_fyl2x |
    Dum.O_fucom |
    Dum.O_fucomp |
    Dum.O_fucompp |
    Dum.O_fcomp |
    Dum.O_fcompp |
    Dum.O_fcoml |
    Dum.O_fcompl |
    Dum.O_ficompl |
    Dum.O_fcoms |
    Dum.O_fcom |
    Dum.O_fcomps |
    Dum.O_fnstsw |
    Dum.O_fnstcw |
    Dum.O_fldcw |
    Dum.O_frndint |
    Dum.O_fxch |
    Dum.O_sahf |
    Dum.O_nop
  deriving (Show, Eq)
data Dum.OperandEffect
  = Dum.OE_RR Int Int |
    Dum.OE_RM Int Int |
    Dum.OE_RW Int Int |
    Dum.OE_nW Int |
    Dum.OE_RRM Int Int Int |
    Dum.OE_R Int |
    Dum.OE_M Int |
    Dum.OE_W Int
  deriving (Show, Eq)
data Dum.OperandInfo
  = Dum.OI_Special |
    Dum.OI_Jumpy |
    Dum.OI_NoEffect |
    Dum.OI_Error |
    Dum.OI [Dum.OperandEffect]
  deriving (Show, Eq)


["x86info","nonJumpyOpcodes"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Csg
import Interval
import Types
import Kolor
import Vector

x86info :: [(Opcode, OperandInfo)]
x86info
  = [(O_movl, OI [OE_RW 4 4]), (O_movw, OI [OE_RW 2 2]),
     (O_movb, OI [OE_RW 1 1]), (O_movzbw, OI [OE_RW 1 2]),
     (O_movzbl, OI [OE_RW 1 4]), (O_movzwl, OI [OE_RW 2 4]),
     (O_movsbw, OI [OE_RW 1 2]), (O_movsbl, OI [OE_RW 1 4]),
     (O_movswl, OI [OE_RW 2 4]), (O_pushl, OI_Special),
     (O_popl, OI_Special), (O_pushfl, OI_Error), (O_popfl, OI_Error),
     (O_sall, OI [OE_RM 1 4]), (O_salw, OI [OE_RM 1 2]),
     (O_salb, OI [OE_RM 1 1]), (O_sarl, OI [OE_RM 1 4]),
     (O_sarw, OI [OE_RM 1 2]), (O_sarb, OI [OE_RM 1 1]),
     (O_shrl, OI [OE_RM 1 4]), (O_shrw, OI [OE_RM 1 2]),
     (O_shrb, OI [OE_RM 1 1]), (O_roll, OI [OE_RM 1 4]),
     (O_rolw, OI [OE_RM 1 2]), (O_rolb, OI [OE_RM 1 1]),
     (O_rorl, OI [OE_RM 1 4]), (O_rorw, OI [OE_RM 1 2]),
     (O_rorb, OI [OE_RM 1 1]), (O_shldl, OI [OE_RRM 4 4 4, OE_RM 4 4]),
     (O_shrdl, OI [OE_RRM 4 4 4, OE_RM 4 4]), (O_addl, OI [OE_RM 4 4]),
     (O_addw, OI [OE_RM 2 2]), (O_addb, OI [OE_RM 1 1]),
     (O_adcl, OI [OE_RM 4 4]), (O_subl, OI [OE_RM 4 4]),
     (O_subw, OI [OE_RM 2 2]), (O_subb, OI [OE_RM 1 1]),
     (O_sbbl, OI [OE_RM 4 4]),
     (O_imull, OI [OE_M 4, OE_RM 4 4, OE_RRM 4 4 4]),
     (O_imulb, OI [OE_M 1]), (O_imulw, OI [OE_M 2, OE_RM 2 2]),
     (O_mull, OI [OE_M 4]), (O_idivl, OI [OE_M 4]),
     (O_divl, OI [OE_M 4]), (O_divw, OI [OE_M 2]),
     (O_divb, OI [OE_M 1]), (O_xorl, OI [OE_RM 4 4]),
     (O_xorw, OI [OE_RM 2 2]), (O_xorb, OI [OE_RM 1 1]),
     (O_andl, OI [OE_RM 4 4]), (O_andw, OI [OE_RM 2 2]),
     (O_andb, OI [OE_RM 1 1]), (O_orl, OI [OE_RM 4 4]),
     (O_orw, OI [OE_RM 2 2]), (O_orb, OI [OE_RM 1 1]),
     (O_incl, OI [OE_M 4]), (O_incw, OI [OE_M 2]),
     (O_incb, OI [OE_M 1]), (O_decl, OI [OE_M 4]),
     (O_decw, OI [OE_M 2]), (O_decb, OI [OE_M 1]),
     (O_negl, OI [OE_M 4]), (O_negw, OI [OE_M 2]),
     (O_negb, OI [OE_M 1]), (O_notl, OI [OE_M 4]),
     (O_notw, OI [OE_M 2]), (O_notb, OI [OE_M 1]),
     (O_testl, OI [OE_RR 4 4]), (O_testw, OI [OE_RR 2 2]),
     (O_testb, OI [OE_RR 1 1]), (O_leal, OI [OE_nW 4]),
     (O_cmpl, OI [OE_RR 4 4]), (O_cmpw, OI [OE_RR 2 2]),
     (O_cmpb, OI [OE_RR 1 1]), (O_cmpsb, OI_Special),
     (O_scasb, OI_Special), (O_movsl, OI_Special),
     (O_movsw, OI_Special), (O_movsb, OI_Special),
     (O_stosl, OI_Special), (O_stosw, OI_Special),
     (O_stosb, OI_Special), (O_leave, OI_Error), (O_ret, OI_Special),
     (O_call, OI_Special), (O_jmp, OI_Jumpy), (O_je, OI_Jumpy),
     (O_jne, OI_Jumpy), (O_jl, OI_Jumpy), (O_jle, OI_Jumpy),
     (O_jg, OI_Jumpy), (O_jge, OI_Jumpy), (O_js, OI_Jumpy),
     (O_jns, OI_Jumpy), (O_jz, OI_Jumpy), (O_jnz, OI_Jumpy),
     (O_jc, OI_Jumpy), (O_jnc, OI_Jumpy), (O_jo, OI_Jumpy),
     (O_jno, OI_Jumpy), (O_ja, OI_Jumpy), (O_jae, OI_Jumpy),
     (O_jb, OI_Jumpy), (O_jbe, OI_Jumpy), (O_jp, OI_Jumpy),
     (O_seta, OI [OE_W 1]), (O_setae, OI [OE_W 1]),
     (O_setb, OI [OE_W 1]), (O_setbe, OI [OE_W 1]),
     (O_sete, OI [OE_W 1]), (O_setne, OI [OE_W 1]),
     (O_setl, OI [OE_W 1]), (O_setle, OI [OE_W 1]),
     (O_setg, OI [OE_W 1]), (O_setge, OI [OE_W 1]),
     (O_setc, OI [OE_W 1]), (O_setcb, OI [OE_W 1]),
     (O_btl, OI [OE_RR 4 4]), (O_btsl, OI [OE_RM 4 4]),
     (O_btcl, OI [OE_RM 4 4]), (O_btrl, OI [OE_RM 4 4]),
     (O_cld, OI_NoEffect), (O_cltd, OI_NoEffect), (O_cwtl, OI_NoEffect),
     (O_cbtw, OI_NoEffect), (O_rep, OI_Error), (O_repz, OI_Error),
     (O_repnz, OI_Error), (O_fld, OI [OE_R 8]), (O_fldt, OI [OE_R 8]),
     (O_fldl, OI [OE_R 8]), (O_flds, OI [OE_R 4]),
     (O_fild, OI [OE_R 4]), (O_fildl, OI [OE_R 4]),
     (O_fildll, OI [OE_R 8]), (O_fstl, OI [OE_W 8]),
     (O_fstpl, OI [OE_W 8]), (O_fstp, OI [OE_W 8]),
     (O_fstps, OI [OE_W 4]), (O_fsts, OI [OE_W 4]),
     (O_fstpt, OI [OE_W 8]), (O_fistl, OI [OE_W 4]),
     (O_fistpl, OI [OE_W 4]), (O_fistpll, OI [OE_W 8]),
     (O_fst, OI [OE_W 8]), (O_fldz, OI_NoEffect), (O_fld1, OI_NoEffect),
     (O_fldl2e, OI_NoEffect), (O_fldln2, OI_NoEffect),
     (O_fchs, OI_NoEffect), (O_fsin, OI_NoEffect),
     (O_fcos, OI_NoEffect), (O_fptan, OI_NoEffect),
     (O_fsqrt, OI_NoEffect), (O_fpatan, OI_NoEffect),
     (O_fabs, OI_NoEffect), (O_f2xm1, OI_NoEffect),
     (O_fscale, OI_NoEffect), (O_fyl2x, OI_NoEffect),
     (O_faddp, OI [OE_R 8, OE_RM 8 8]), (O_fadds, OI [OE_R 4]),
     (O_faddl, OI [OE_R 8]), (O_fiaddl, OI [OE_R 4]),
     (O_fadd, OI [OE_R 8, OE_RM 8 8]), (O_fsubp, OI [OE_RM 8 8]),
     (O_fsubrp, OI [OE_RM 8 8]), (O_fsubrl, OI [OE_R 8]),
     (O_fsubrs, OI [OE_R 4]), (O_fsubs, OI [OE_R 4]),
     (O_fsubl, OI [OE_R 8]), (O_fsub, OI [OE_R 8, OE_RM 8 8]),
     (O_fsubr, OI [OE_R 8, OE_RM 8 8]),
     (O_fmul, OI [OE_R 8, OE_RM 8 8]), (O_fmuls, OI [OE_R 4]),
     (O_fmull, OI [OE_R 8]), (O_fmulp, OI [OE_R 8, OE_RM 8 8]),
     (O_fimull, OI [OE_R 8]), (O_fdiv, OI [OE_RM 8 8]),
     (O_fdivp, OI [OE_RM 8 8]), (O_fdivr, OI [OE_RM 8 8]),
     (O_fdivrl, OI [OE_R 8]), (O_fdivrs, OI [OE_R 4]),
     (O_fdivrp, OI [OE_RM 8 8]), (O_fidivrl, OI [OE_R 4]),
     (O_fidivl, OI [OE_R 4]), (O_fdivl, OI [OE_R 8]),
     (O_fdivs, OI [OE_R 4]), (O_fprem, OI_NoEffect),
     (O_fucom, OI_NoEffect), (O_fucomp, OI_NoEffect),
     (O_fucompp, OI_NoEffect), (O_fcomp, OI_NoEffect),
     (O_fcompp, OI_NoEffect), (O_fcoms, OI [OE_R 4]),
     (O_fcoml, OI [OE_R 8]), (O_fcom, OI [OE_R 8]),
     (O_fcomps, OI [OE_R 4]), (O_fcompl, OI [OE_R 8]),
     (O_ficompl, OI [OE_R 4]), (O_fnstsw, OI [OE_W 2]),
     (O_fnstcw, OI [OE_W 2]), (O_fldcw, OI [OE_R 2]),
     (O_fxch, OI_NoEffect), (O_frndint, OI_NoEffect),
     (O_sahf, OI_NoEffect), (O_nop, OI_NoEffect)]

nonJumpyOpcodes :: [Opcode]
nonJumpyOpcodes
  = [O_pushl, O_popl, O_movl, O_movw, O_movb, O_andl, O_andw, O_andb,
     O_orl, O_orw, O_orb, O_xorl, O_xorw, O_xorb, O_addl, O_addw,
     O_addb, O_subl, O_subw, O_subb, O_incl, O_incw, O_incb, O_decl,
     O_decw, O_decb, O_cmpl, O_cmpw, O_cmpb, O_sall, O_salw, O_salb,
     O_shrl, O_shrw, O_shrb, O_sarl, O_leal, O_movzbw, O_movzbl,
     O_movzwl, O_movsbw, O_movsbl, O_movswl, O_seta, O_setae, O_setb,
     O_setbe, O_sete, O_setne, O_setl, O_setle, O_setg, O_setge, O_setc,
     O_setcb, O_testl, O_testw, O_testb, O_fld1, O_fcoml, O_fnstsw,
     O_fstpl, O_fstp, O_fsubrl, O_fldl, O_faddl, O_fsubl]

data Opcode = O_movl
            | O_movw
            | O_movb
            | O_movzbw
            | O_movzbl
            | O_movzwl
            | O_movsbw
            | O_movsbl
            | O_movswl
            | O_pushl
            | O_popl
            | O_pushfl
            | O_popfl
            | O_notl
            | O_notw
            | O_notb
            | O_sall
            | O_salw
            | O_salb
            | O_sarl
            | O_sarw
            | O_sarb
            | O_shrl
            | O_shrw
            | O_shrb
            | O_roll
            | O_rolw
            | O_rolb
            | O_rorl
            | O_rorw
            | O_rorb
            | O_shldl
            | O_shrdl
            | O_addl
            | O_addw
            | O_addb
            | O_adcl
            | O_subl
            | O_subw
            | O_subb
            | O_sbbl
            | O_imull
            | O_imulw
            | O_imulb
            | O_mull
            | O_divl
            | O_divw
            | O_divb
            | O_idivl
            | O_xorl
            | O_xorw
            | O_xorb
            | O_andl
            | O_andw
            | O_andb
            | O_orl
            | O_orw
            | O_orb
            | O_incl
            | O_incw
            | O_incb
            | O_decl
            | O_decw
            | O_decb
            | O_negl
            | O_negw
            | O_negb
            | O_testl
            | O_testw
            | O_testb
            | O_leal
            | O_cmpl
            | O_cmpw
            | O_cmpb
            | O_cmpsb
            | O_scasb
            | O_movsl
            | O_movsw
            | O_movsb
            | O_stosl
            | O_stosw
            | O_stosb
            | O_leave
            | O_ret
            | O_call
            | O_jmp
            | O_je
            | O_jne
            | O_jl
            | O_jle
            | O_jg
            | O_jge
            | O_js
            | O_jns
            | O_jz
            | O_jnz
            | O_jc
            | O_jnc
            | O_jo
            | O_jno
            | O_ja
            | O_jae
            | O_jb
            | O_jbe
            | O_jp
            | O_seta
            | O_setae
            | O_setb
            | O_setbe
            | O_sete
            | O_setne
            | O_setl
            | O_setle
            | O_setg
            | O_setge
            | O_setc
            | O_setcb
            | O_btl
            | O_btsl
            | O_btrl
            | O_btcl
            | O_cld
            | O_cltd
            | O_cwtl
            | O_cbtw
            | O_rep
            | O_repz
            | O_repnz
            | O_fild
            | O_fildl
            | O_fildll
            | O_fsubp
            | O_fsubr
            | O_fsubrp
            | O_fsubrl
            | O_fsubrs
            | O_fsubs
            | O_fsubl
            | O_fsub
            | O_faddp
            | O_fadds
            | O_faddl
            | O_fadd
            | O_fiaddl
            | O_fmul
            | O_fmuls
            | O_fmull
            | O_fmulp
            | O_fimull
            | O_fdiv
            | O_fdivp
            | O_fdivr
            | O_fdivrs
            | O_fdivrl
            | O_fdivrp
            | O_fidivl
            | O_fidivrl
            | O_fdivl
            | O_fdivs
            | O_fprem
            | O_fstp
            | O_fsts
            | O_fstps
            | O_fstl
            | O_fstpl
            | O_fstpt
            | O_fst
            | O_fistl
            | O_fistpl
            | O_fistpll
            | O_fld
            | O_flds
            | O_fldl
            | O_fldt
            | O_fldz
            | O_fld1
            | O_fldl2e
            | O_fldln2
            | O_fchs
            | O_fsin
            | O_fcos
            | O_fptan
            | O_fsqrt
            | O_fpatan
            | O_fabs
            | O_f2xm1
            | O_fscale
            | O_fyl2x
            | O_fucom
            | O_fucomp
            | O_fucompp
            | O_fcomp
            | O_fcompp
            | O_fcoml
            | O_fcompl
            | O_ficompl
            | O_fcoms
            | O_fcom
            | O_fcomps
            | O_fnstsw
            | O_fnstcw
            | O_fldcw
            | O_frndint
            | O_fxch
            | O_sahf
            | O_nop
            deriving (Show, Eq)

data OperandEffect = OE_RR Int Int
                   | OE_RM Int Int
                   | OE_RW Int Int
                   | OE_nW Int
                   | OE_RRM Int Int Int
                   | OE_R Int
                   | OE_M Int
                   | OE_W Int
                   deriving (Show, Eq)

data OperandInfo = OI_Special
                 | OI_Jumpy
                 | OI_NoEffect
                 | OI_Error
                 | OI [OperandEffect]
                 deriving (Show, Eq)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.version = "Fulsom version 3.4"
Dum.major = 3 :: Int
Dum.minor = 4 :: Int
Dum.patch = 0 :: Int


["version","major","minor","patch"]
{-# LANGUAGE BangPatterns #-}
module Dum where
version = "Fulsom version 3.4"
major = 3 :: Int
minor = 4 :: Int
patch = 0 :: Int
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.version = "Fulsom version 3.4"
Dum.major = 3 :: Int
Dum.minor = 4 :: Int
Dum.patch = 0 :: Int


["version","major","minor","patch"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Interval
version = "Fulsom version 3.4"
major = 3 :: Int
minor = 4 :: Int
patch = 0 :: Int
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.version = "Fulsom version 3.4"
Dum.major = 3 :: Int
Dum.minor = 4 :: Int
Dum.patch = 0 :: Int


["version","major","minor","patch"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Interval
import Kolor
import Quad
import Types
version = "Fulsom version 3.4"
major = 3 :: Int
minor = 4 :: Int
patch = 0 :: Int
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.version = "Fulsom version 3.4"
Dum.major = 3 :: Int
Dum.minor = 4 :: Int
Dum.patch = 0 :: Int


["version","major","minor","patch"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Matrix
import Types
import Interval
version = "Fulsom version 3.4"
major = 3 :: Int
minor = 4 :: Int
patch = 0 :: Int
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 4 `Dum.orelse`
infixl 5 `Dum.doo`
infixr 6 `Dum.seQ`

Dum.faiL :: Dum.Parser a_axS
Dum.faiL inn_axT = []
Dum.okay :: a_axR -> Dum.Parser a_axR
Dum.okay v_axU inn_axV = [(v_axU, inn_axV)]
Dum.tok :: [Char] -> Dum.Parser [Char]
Dum.tok w_axW inn_axX
  = [(w_axW, drop n_axY inn_axX) | w_axW == take n_axY inn_axX]
  where
      n_axY = length w_axW
Dum.sat :: (Char -> Bool) -> Dum.Parser Char
Dum.sat p_a1Qf (![]) = []
Dum.sat (!p_a1Qg) (c_a1Qh : (!inn_a1Qi))
  = [(c_a1Qh, inn_a1Qi) | p_a1Qg c_a1Qh]
Dum.orelse ::
  Dum.Parser a_axQ -> Dum.Parser a_axQ -> Dum.Parser a_axQ
Dum.orelse (!p1_a1Qj) (!p2_a1Qk) inn_a1Ql
  = p1_a1Qj inn_a1Ql ++ p2_a1Qk inn_a1Ql
Dum.seQ ::
  Dum.Parser a_axO -> Dum.Parser b_axP -> Dum.Parser (a_axO, b_axP)
Dum.seQ p1_a1Qm p2_a1Qn inn_a1Qo
  = [((v1_a1Qp, v2_a1Qr), inn2_a1Qs) |
       (v1_a1Qp, inn1_a1Qq) <- p1_a1Qm inn_a1Qo,
       (!(v2_a1Qr, (!inn2_a1Qs))) <- p2_a1Qn inn1_a1Qq]
Dum.doo :: Dum.Parser a_axM -> (a_axM -> b_axN) -> Dum.Parser b_axN
Dum.doo p_a1Qt (!f_a1Qu) inn_a1Qv
  = [(f_a1Qu v_a1Qw, inn1_a1Qx) |
       (!(v_a1Qw, inn1_a1Qx)) <- p_a1Qt inn_a1Qv]
Dum.just :: Dum.Parser a_axL -> Dum.Parser a_axL
Dum.just (!p_a1Qy) inn_a1Qz
  = [(v_a1QA, "") |
       (v_a1QA, inn'_a1QB) <- p_a1Qy inn_a1Qz,
       dropWhile (' ' ==) inn'_a1QB == ""]
Dum.sp :: Dum.Parser a_axK -> Dum.Parser a_axK
Dum.sp p_a1QC = p_a1QC . dropWhile (' ' ==)
Dum.sptok :: [Char] -> Dum.Parser [Char]
Dum.sptok = Dum.sp . Dum.tok
Dum.many :: Dum.Parser a_axJ -> Dum.Parser [a_axJ]
Dum.many (!p_a1QD)
  = q_a1QE
  where
      q_a1QE
        = ((p_a1QD `Dum.seQ` q_a1QE) `Dum.doo` Dum.makeList)
          `Dum.orelse` (Dum.okay [])
Dum.many1 :: Dum.Parser a_axI -> Dum.Parser [a_axI]
Dum.many1 p_a1QF
  = p_a1QF `Dum.seQ` Dum.many p_a1QF `Dum.doo` Dum.makeList
Dum.listOf ::
  Dum.Parser a_axG -> Dum.Parser b_axH -> Dum.Parser [a_axG]
Dum.listOf (!p_a1QG) s_a1QH
  = p_a1QG `Dum.seQ` Dum.many (s_a1QH `Dum.seQ` p_a1QG)
    `Dum.doo` nonempty_a1QI
    `Dum.orelse` Dum.okay []
  where
      nonempty_a1QI (!(x_a1QJ, (!xs_a1QK))) = x_a1QJ : (map snd xs_a1QK)
Dum.makeList :: (a_axF, [a_axF]) -> [a_axF]
Dum.makeList (x_a1QX, xs_a1QY) = x_a1QX : xs_a1QY

type Dum.Parser a_aqA = [Char] -> [(a_aqA, [Char])]


["inn_axT","v_axU","inn_axV","w_axW","inn_axX","n_axY","p_a1Qf","[]","![]","(![])","p_a1Qg","!p_a1Qg","(!p_a1Qg)","c_a1Qh","inn_a1Qi","!inn_a1Qi","(!inn_a1Qi)","c_a1Qh : (!inn_a1Qi)","(c_a1Qh : (!inn_a1Qi))","p1_a1Qj","safebang@!p1_a1Qj","(!p1_a1Qj)","p2_a1Qk","safebang@!p2_a1Qk","(!p2_a1Qk)","inn_a1Ql","p1_a1Qm","p2_a1Qn","inn_a1Qo","v1_a1Qp","inn1_a1Qq","(v1_a1Qp, inn1_a1Qq)","v2_a1Qr","inn2_a1Qs","safebang@!inn2_a1Qs","(!inn2_a1Qs)","(v2_a1Qr, (!inn2_a1Qs))","!(v2_a1Qr, (!inn2_a1Qs))","(!(v2_a1Qr, (!inn2_a1Qs)))","p_a1Qt","f_a1Qu","safebang@!f_a1Qu","(!f_a1Qu)","inn_a1Qv","v_a1Qw","inn1_a1Qx","(v_a1Qw, inn1_a1Qx)","!(v_a1Qw, inn1_a1Qx)","(!(v_a1Qw, inn1_a1Qx))","p_a1Qy","safebang@!p_a1Qy","(!p_a1Qy)","inn_a1Qz","v_a1QA","inn'_a1QB","(v_a1QA, inn'_a1QB)","p_a1QC","sptok","p_a1QD","safebang@!p_a1QD","(!p_a1QD)","q_a1QE","p_a1QF","p_a1QG","safebang@!p_a1QG","(!p_a1QG)","s_a1QH","x_a1QJ","xs_a1QK","!xs_a1QK","(!xs_a1QK)","(x_a1QJ, (!xs_a1QK))","!(x_a1QJ, (!xs_a1QK))","(!(x_a1QJ, (!xs_a1QK)))","x_a1QX","xs_a1QY","(x_a1QX, xs_a1QY)"]
{-# LANGUAGE BangPatterns #-}
module Dum where

infixr 4 `orelse`

infixl 5 `doo`

infixr 6 `seQ`

faiL :: Parser a_axS
faiL inn_axT = []

okay :: a_axR -> Parser a_axR
okay v_axU inn_axV = [(v_axU, inn_axV)]

tok :: [Char] -> Parser [Char]
tok w_axW inn_axX
  = [(w_axW, drop n_axY inn_axX) | w_axW == take n_axY inn_axX]
  where n_axY = length w_axW

sat :: (Char -> Bool) -> Parser Char
sat p_a1Qf (investigate@[]) = []
sat (investigate@p_a1Qg) (c_a1Qh : (investigate@inn_a1Qi))
  = [(c_a1Qh, inn_a1Qi) | p_a1Qg c_a1Qh]

orelse :: Parser a_axQ -> Parser a_axQ -> Parser a_axQ
orelse (!p1_a1Qj) (!p2_a1Qk) inn_a1Ql
  = p1_a1Qj inn_a1Ql ++ p2_a1Qk inn_a1Ql

seQ :: Parser a_axO -> Parser b_axP -> Parser (a_axO, b_axP)
seQ p1_a1Qm p2_a1Qn inn_a1Qo
  = [((v1_a1Qp, v2_a1Qr), inn2_a1Qs) |
     (v1_a1Qp, inn1_a1Qq) <- p1_a1Qm inn_a1Qo,
     (investigate@(v2_a1Qr, (!inn2_a1Qs))) <- p2_a1Qn inn1_a1Qq]

doo :: Parser a_axM -> (a_axM -> b_axN) -> Parser b_axN
doo p_a1Qt (!f_a1Qu) inn_a1Qv
  = [(f_a1Qu v_a1Qw, inn1_a1Qx) |
     (investigate@(v_a1Qw, inn1_a1Qx)) <- p_a1Qt inn_a1Qv]

just :: Parser a_axL -> Parser a_axL
just (!p_a1Qy) inn_a1Qz
  = [(v_a1QA, "") | (v_a1QA, inn'_a1QB) <- p_a1Qy inn_a1Qz,
     dropWhile (' ' ==) inn'_a1QB == ""]

sp :: Parser a_axK -> Parser a_axK
sp p_a1QC = p_a1QC . dropWhile (' ' ==)

sptok :: [Char] -> Parser [Char]
sptok = sp . tok

many :: Parser a_axJ -> Parser [a_axJ]
many (!p_a1QD) = q_a1QE
  where q_a1QE
          = ((p_a1QD `seQ` q_a1QE) `doo` makeList) `orelse` (okay [])

many1 :: Parser a_axI -> Parser [a_axI]
many1 p_a1QF = p_a1QF `seQ` many p_a1QF `doo` makeList

listOf :: Parser a_axG -> Parser b_axH -> Parser [a_axG]
listOf (!p_a1QG) s_a1QH
  = p_a1QG `seQ` many (s_a1QH `seQ` p_a1QG) `doo` nonempty_a1QI
      `orelse` okay []
  where nonempty_a1QI (investigate@(x_a1QJ, (investigate@xs_a1QK)))
          = x_a1QJ : (map snd xs_a1QK)

makeList :: (a_axF, [a_axF]) -> [a_axF]
makeList (x_a1QX, xs_a1QY) = x_a1QX : xs_a1QY

type Parser a_aqA = [Char] -> [(a_aqA, [Char])]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 4 `Dum.orelse`
infixl 5 `Dum.doo`
infixr 6 `Dum.seQ`

Dum.faiL :: Dum.Parser a_axS
Dum.faiL inn_axT = []
Dum.okay :: a_axR -> Dum.Parser a_axR
Dum.okay v_axU inn_axV = [(v_axU, inn_axV)]
Dum.tok :: [Char] -> Dum.Parser [Char]
Dum.tok w_axW inn_axX
  = [(w_axW, drop n_axY inn_axX) | w_axW == take n_axY inn_axX]
  where
      n_axY = length w_axW
Dum.sat :: (Char -> Bool) -> Dum.Parser Char
Dum.sat p_a1Qf (![]) = []
Dum.sat (!p_a1Qg) (c_a1Qh : (!inn_a1Qi))
  = [(c_a1Qh, inn_a1Qi) | p_a1Qg c_a1Qh]
Dum.orelse ::
  Dum.Parser a_axQ -> Dum.Parser a_axQ -> Dum.Parser a_axQ
Dum.orelse (!p1_a1Qj) (!p2_a1Qk) inn_a1Ql
  = p1_a1Qj inn_a1Ql ++ p2_a1Qk inn_a1Ql
Dum.seQ ::
  Dum.Parser a_axO -> Dum.Parser b_axP -> Dum.Parser (a_axO, b_axP)
Dum.seQ p1_a1Qm p2_a1Qn inn_a1Qo
  = [((v1_a1Qp, v2_a1Qr), inn2_a1Qs) |
       (v1_a1Qp, inn1_a1Qq) <- p1_a1Qm inn_a1Qo,
       (!(v2_a1Qr, (!inn2_a1Qs))) <- p2_a1Qn inn1_a1Qq]
Dum.doo :: Dum.Parser a_axM -> (a_axM -> b_axN) -> Dum.Parser b_axN
Dum.doo p_a1Qt (!f_a1Qu) inn_a1Qv
  = [(f_a1Qu v_a1Qw, inn1_a1Qx) |
       (!(v_a1Qw, inn1_a1Qx)) <- p_a1Qt inn_a1Qv]
Dum.just :: Dum.Parser a_axL -> Dum.Parser a_axL
Dum.just (!p_a1Qy) inn_a1Qz
  = [(v_a1QA, "") |
       (v_a1QA, inn'_a1QB) <- p_a1Qy inn_a1Qz,
       dropWhile (' ' ==) inn'_a1QB == ""]
Dum.sp :: Dum.Parser a_axK -> Dum.Parser a_axK
Dum.sp p_a1QC = p_a1QC . dropWhile (' ' ==)
Dum.sptok :: [Char] -> Dum.Parser [Char]
Dum.sptok = Dum.sp . Dum.tok
Dum.many :: Dum.Parser a_axJ -> Dum.Parser [a_axJ]
Dum.many (!p_a1QD)
  = q_a1QE
  where
      q_a1QE
        = ((p_a1QD `Dum.seQ` q_a1QE) `Dum.doo` Dum.makeList)
          `Dum.orelse` (Dum.okay [])
Dum.many1 :: Dum.Parser a_axI -> Dum.Parser [a_axI]
Dum.many1 p_a1QF
  = p_a1QF `Dum.seQ` Dum.many p_a1QF `Dum.doo` Dum.makeList
Dum.listOf ::
  Dum.Parser a_axG -> Dum.Parser b_axH -> Dum.Parser [a_axG]
Dum.listOf (!p_a1QG) s_a1QH
  = p_a1QG `Dum.seQ` Dum.many (s_a1QH `Dum.seQ` p_a1QG)
    `Dum.doo` nonempty_a1QI
    `Dum.orelse` Dum.okay []
  where
      nonempty_a1QI (!(x_a1QJ, (!xs_a1QK))) = x_a1QJ : (map snd xs_a1QK)
Dum.makeList :: (a_axF, [a_axF]) -> [a_axF]
Dum.makeList (x_a1QX, xs_a1QY) = x_a1QX : xs_a1QY

type Dum.Parser a_aqA = [Char] -> [(a_aqA, [Char])]


["inn_axT","v_axU","inn_axV","w_axW","inn_axX","n_axY","p_a1Qf","[]","![]","(![])","p_a1Qg","!p_a1Qg","(!p_a1Qg)","c_a1Qh","inn_a1Qi","!inn_a1Qi","(!inn_a1Qi)","c_a1Qh : (!inn_a1Qi)","(c_a1Qh : (!inn_a1Qi))","p1_a1Qj","safebang@!p1_a1Qj","(!p1_a1Qj)","p2_a1Qk","safebang@!p2_a1Qk","(!p2_a1Qk)","inn_a1Ql","p1_a1Qm","p2_a1Qn","inn_a1Qo","v1_a1Qp","inn1_a1Qq","(v1_a1Qp, inn1_a1Qq)","v2_a1Qr","inn2_a1Qs","safebang@!inn2_a1Qs","(!inn2_a1Qs)","(v2_a1Qr, (!inn2_a1Qs))","!(v2_a1Qr, (!inn2_a1Qs))","(!(v2_a1Qr, (!inn2_a1Qs)))","p_a1Qt","f_a1Qu","safebang@!f_a1Qu","(!f_a1Qu)","inn_a1Qv","v_a1Qw","inn1_a1Qx","(v_a1Qw, inn1_a1Qx)","!(v_a1Qw, inn1_a1Qx)","(!(v_a1Qw, inn1_a1Qx))","p_a1Qy","safebang@!p_a1Qy","(!p_a1Qy)","inn_a1Qz","v_a1QA","inn'_a1QB","(v_a1QA, inn'_a1QB)","p_a1QC","sptok","p_a1QD","safebang@!p_a1QD","(!p_a1QD)","q_a1QE","p_a1QF","p_a1QG","safebang@!p_a1QG","(!p_a1QG)","s_a1QH","x_a1QJ","xs_a1QK","!xs_a1QK","(!xs_a1QK)","(x_a1QJ, (!xs_a1QK))","!(x_a1QJ, (!xs_a1QK))","(!(x_a1QJ, (!xs_a1QK)))","x_a1QX","xs_a1QY","(x_a1QX, xs_a1QY)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import PrologData

infixr 4 `orelse`

infixl 5 `doo`

infixr 6 `seQ`

faiL :: Parser a_axS
faiL inn_axT = []

okay :: a_axR -> Parser a_axR
okay v_axU inn_axV = [(v_axU, inn_axV)]

tok :: [Char] -> Parser [Char]
tok w_axW inn_axX
  = [(w_axW, drop n_axY inn_axX) | w_axW == take n_axY inn_axX]
  where n_axY = length w_axW

sat :: (Char -> Bool) -> Parser Char
sat p_a1Qf (investigate@[]) = []
sat (investigate@p_a1Qg) (c_a1Qh : (investigate@inn_a1Qi))
  = [(c_a1Qh, inn_a1Qi) | p_a1Qg c_a1Qh]

orelse :: Parser a_axQ -> Parser a_axQ -> Parser a_axQ
orelse (!p1_a1Qj) (!p2_a1Qk) inn_a1Ql
  = p1_a1Qj inn_a1Ql ++ p2_a1Qk inn_a1Ql

seQ :: Parser a_axO -> Parser b_axP -> Parser (a_axO, b_axP)
seQ p1_a1Qm p2_a1Qn inn_a1Qo
  = [((v1_a1Qp, v2_a1Qr), inn2_a1Qs) |
     (v1_a1Qp, inn1_a1Qq) <- p1_a1Qm inn_a1Qo,
     (investigate@(v2_a1Qr, (!inn2_a1Qs))) <- p2_a1Qn inn1_a1Qq]

doo :: Parser a_axM -> (a_axM -> b_axN) -> Parser b_axN
doo p_a1Qt (!f_a1Qu) inn_a1Qv
  = [(f_a1Qu v_a1Qw, inn1_a1Qx) |
     (investigate@(v_a1Qw, inn1_a1Qx)) <- p_a1Qt inn_a1Qv]

just :: Parser a_axL -> Parser a_axL
just (!p_a1Qy) inn_a1Qz
  = [(v_a1QA, "") | (v_a1QA, inn'_a1QB) <- p_a1Qy inn_a1Qz,
     dropWhile (' ' ==) inn'_a1QB == ""]

sp :: Parser a_axK -> Parser a_axK
sp p_a1QC = p_a1QC . dropWhile (' ' ==)

sptok :: [Char] -> Parser [Char]
sptok = sp . tok

many :: Parser a_axJ -> Parser [a_axJ]
many (!p_a1QD) = q_a1QE
  where q_a1QE
          = ((p_a1QD `seQ` q_a1QE) `doo` makeList) `orelse` (okay [])

many1 :: Parser a_axI -> Parser [a_axI]
many1 p_a1QF = p_a1QF `seQ` many p_a1QF `doo` makeList

listOf :: Parser a_axG -> Parser b_axH -> Parser [a_axG]
listOf (!p_a1QG) s_a1QH
  = p_a1QG `seQ` many (s_a1QH `seQ` p_a1QG) `doo` nonempty_a1QI
      `orelse` okay []
  where nonempty_a1QI (investigate@(x_a1QJ, (investigate@xs_a1QK)))
          = x_a1QJ : (map snd xs_a1QK)

makeList :: (a_axF, [a_axF]) -> [a_axF]
makeList (x_a1QX, xs_a1QY) = x_a1QX : xs_a1QY

type Parser a_aqA = [Char] -> [(a_aqA, [Char])]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 4 `Dum.orelse`
infixl 5 `Dum.doo`
infixr 6 `Dum.seQ`

Dum.faiL :: Dum.Parser a_axS
Dum.faiL inn_axT = []
Dum.okay :: a_axR -> Dum.Parser a_axR
Dum.okay v_axU inn_axV = [(v_axU, inn_axV)]
Dum.tok :: [Char] -> Dum.Parser [Char]
Dum.tok w_axW inn_axX
  = [(w_axW, drop n_axY inn_axX) | w_axW == take n_axY inn_axX]
  where
      n_axY = length w_axW
Dum.sat :: (Char -> Bool) -> Dum.Parser Char
Dum.sat p_a1Qf (![]) = []
Dum.sat (!p_a1Qg) (c_a1Qh : (!inn_a1Qi))
  = [(c_a1Qh, inn_a1Qi) | p_a1Qg c_a1Qh]
Dum.orelse ::
  Dum.Parser a_axQ -> Dum.Parser a_axQ -> Dum.Parser a_axQ
Dum.orelse (!p1_a1Qj) (!p2_a1Qk) inn_a1Ql
  = p1_a1Qj inn_a1Ql ++ p2_a1Qk inn_a1Ql
Dum.seQ ::
  Dum.Parser a_axO -> Dum.Parser b_axP -> Dum.Parser (a_axO, b_axP)
Dum.seQ p1_a1Qm p2_a1Qn inn_a1Qo
  = [((v1_a1Qp, v2_a1Qr), inn2_a1Qs) |
       (v1_a1Qp, inn1_a1Qq) <- p1_a1Qm inn_a1Qo,
       (!(v2_a1Qr, (!inn2_a1Qs))) <- p2_a1Qn inn1_a1Qq]
Dum.doo :: Dum.Parser a_axM -> (a_axM -> b_axN) -> Dum.Parser b_axN
Dum.doo p_a1Qt (!f_a1Qu) inn_a1Qv
  = [(f_a1Qu v_a1Qw, inn1_a1Qx) |
       (!(v_a1Qw, inn1_a1Qx)) <- p_a1Qt inn_a1Qv]
Dum.just :: Dum.Parser a_axL -> Dum.Parser a_axL
Dum.just (!p_a1Qy) inn_a1Qz
  = [(v_a1QA, "") |
       (v_a1QA, inn'_a1QB) <- p_a1Qy inn_a1Qz,
       dropWhile (' ' ==) inn'_a1QB == ""]
Dum.sp :: Dum.Parser a_axK -> Dum.Parser a_axK
Dum.sp p_a1QC = p_a1QC . dropWhile (' ' ==)
Dum.sptok :: [Char] -> Dum.Parser [Char]
Dum.sptok = Dum.sp . Dum.tok
Dum.many :: Dum.Parser a_axJ -> Dum.Parser [a_axJ]
Dum.many (!p_a1QD)
  = q_a1QE
  where
      q_a1QE
        = ((p_a1QD `Dum.seQ` q_a1QE) `Dum.doo` Dum.makeList)
          `Dum.orelse` (Dum.okay [])
Dum.many1 :: Dum.Parser a_axI -> Dum.Parser [a_axI]
Dum.many1 p_a1QF
  = p_a1QF `Dum.seQ` Dum.many p_a1QF `Dum.doo` Dum.makeList
Dum.listOf ::
  Dum.Parser a_axG -> Dum.Parser b_axH -> Dum.Parser [a_axG]
Dum.listOf (!p_a1QG) s_a1QH
  = p_a1QG `Dum.seQ` Dum.many (s_a1QH `Dum.seQ` p_a1QG)
    `Dum.doo` nonempty_a1QI
    `Dum.orelse` Dum.okay []
  where
      nonempty_a1QI (!(x_a1QJ, (!xs_a1QK))) = x_a1QJ : (map snd xs_a1QK)
Dum.makeList :: (a_axF, [a_axF]) -> [a_axF]
Dum.makeList (x_a1QX, xs_a1QY) = x_a1QX : xs_a1QY

type Dum.Parser a_aqA = [Char] -> [(a_aqA, [Char])]


["inn_axT","v_axU","inn_axV","w_axW","inn_axX","n_axY","p_a1Qf","[]","![]","(![])","p_a1Qg","!p_a1Qg","(!p_a1Qg)","c_a1Qh","inn_a1Qi","!inn_a1Qi","(!inn_a1Qi)","c_a1Qh : (!inn_a1Qi)","(c_a1Qh : (!inn_a1Qi))","p1_a1Qj","safebang@!p1_a1Qj","(!p1_a1Qj)","p2_a1Qk","safebang@!p2_a1Qk","(!p2_a1Qk)","inn_a1Ql","p1_a1Qm","p2_a1Qn","inn_a1Qo","v1_a1Qp","inn1_a1Qq","(v1_a1Qp, inn1_a1Qq)","v2_a1Qr","inn2_a1Qs","safebang@!inn2_a1Qs","(!inn2_a1Qs)","(v2_a1Qr, (!inn2_a1Qs))","!(v2_a1Qr, (!inn2_a1Qs))","(!(v2_a1Qr, (!inn2_a1Qs)))","p_a1Qt","f_a1Qu","safebang@!f_a1Qu","(!f_a1Qu)","inn_a1Qv","v_a1Qw","inn1_a1Qx","(v_a1Qw, inn1_a1Qx)","!(v_a1Qw, inn1_a1Qx)","(!(v_a1Qw, inn1_a1Qx))","p_a1Qy","safebang@!p_a1Qy","(!p_a1Qy)","inn_a1Qz","v_a1QA","inn'_a1QB","(v_a1QA, inn'_a1QB)","p_a1QC","sptok","p_a1QD","safebang@!p_a1QD","(!p_a1QD)","q_a1QE","p_a1QF","p_a1QG","safebang@!p_a1QG","(!p_a1QG)","s_a1QH","x_a1QJ","xs_a1QK","!xs_a1QK","(!xs_a1QK)","(x_a1QJ, (!xs_a1QK))","!(x_a1QJ, (!xs_a1QK))","(!(x_a1QJ, (!xs_a1QK)))","x_a1QX","xs_a1QY","(x_a1QX, xs_a1QY)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import PrologData
import Subst

infixr 4 `orelse`

infixl 5 `doo`

infixr 6 `seQ`

faiL :: Parser a_axS
faiL inn_axT = []

okay :: a_axR -> Parser a_axR
okay v_axU inn_axV = [(v_axU, inn_axV)]

tok :: [Char] -> Parser [Char]
tok w_axW inn_axX
  = [(w_axW, drop n_axY inn_axX) | w_axW == take n_axY inn_axX]
  where n_axY = length w_axW

sat :: (Char -> Bool) -> Parser Char
sat p_a1Qf (investigate@[]) = []
sat (investigate@p_a1Qg) (c_a1Qh : (investigate@inn_a1Qi))
  = [(c_a1Qh, inn_a1Qi) | p_a1Qg c_a1Qh]

orelse :: Parser a_axQ -> Parser a_axQ -> Parser a_axQ
orelse (!p1_a1Qj) (!p2_a1Qk) inn_a1Ql
  = p1_a1Qj inn_a1Ql ++ p2_a1Qk inn_a1Ql

seQ :: Parser a_axO -> Parser b_axP -> Parser (a_axO, b_axP)
seQ p1_a1Qm p2_a1Qn inn_a1Qo
  = [((v1_a1Qp, v2_a1Qr), inn2_a1Qs) |
     (v1_a1Qp, inn1_a1Qq) <- p1_a1Qm inn_a1Qo,
     (investigate@(v2_a1Qr, (!inn2_a1Qs))) <- p2_a1Qn inn1_a1Qq]

doo :: Parser a_axM -> (a_axM -> b_axN) -> Parser b_axN
doo p_a1Qt (!f_a1Qu) inn_a1Qv
  = [(f_a1Qu v_a1Qw, inn1_a1Qx) |
     (investigate@(v_a1Qw, inn1_a1Qx)) <- p_a1Qt inn_a1Qv]

just :: Parser a_axL -> Parser a_axL
just (!p_a1Qy) inn_a1Qz
  = [(v_a1QA, "") | (v_a1QA, inn'_a1QB) <- p_a1Qy inn_a1Qz,
     dropWhile (' ' ==) inn'_a1QB == ""]

sp :: Parser a_axK -> Parser a_axK
sp p_a1QC = p_a1QC . dropWhile (' ' ==)

sptok :: [Char] -> Parser [Char]
sptok = sp . tok

many :: Parser a_axJ -> Parser [a_axJ]
many (!p_a1QD) = q_a1QE
  where q_a1QE
          = ((p_a1QD `seQ` q_a1QE) `doo` makeList) `orelse` (okay [])

many1 :: Parser a_axI -> Parser [a_axI]
many1 p_a1QF = p_a1QF `seQ` many p_a1QF `doo` makeList

listOf :: Parser a_axG -> Parser b_axH -> Parser [a_axG]
listOf (!p_a1QG) s_a1QH
  = p_a1QG `seQ` many (s_a1QH `seQ` p_a1QG) `doo` nonempty_a1QI
      `orelse` okay []
  where nonempty_a1QI (investigate@(x_a1QJ, (investigate@xs_a1QK)))
          = x_a1QJ : (map snd xs_a1QK)

makeList :: (a_axF, [a_axF]) -> [a_axF]
makeList (x_a1QX, xs_a1QY) = x_a1QX : xs_a1QY

type Parser a_aqA = [Char] -> [(a_aqA, [Char])]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.version = "stack based"


["version"]
{-# LANGUAGE BangPatterns #-}
module Dum where
version = "stack based"
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.skip :: Dum.Interactive -> Dum.Interactive
Dum.skip p_axv inn_axw = p_axv inn_axw
Dum.end :: Dum.Interactive
Dum.end inn_axx = ""
Dum.writeln :: String -> Dum.Interactive -> Dum.Interactive
Dum.writeln txt_axy p_axz inn_axA = txt_axy ++ p_axz inn_axA
Dum.readch ::
  (Char -> Dum.Interactive) -> String -> Dum.Interactive
Dum.readch act_axB (!def_axC) (!"") = def_axC
Dum.readch act_axD (!def_axE) (!((!(c_axF : cs_axG))))
  = act_axD c_axF cs_axG
Dum.readln ::
  String -> (String -> Dum.Interactive) -> Dum.Interactive
Dum.readln prompt_axH g_axI inn_axJ
  = prompt_axH
    ++
      Dum.lineOut 0 line_axK
      ++ "\n" ++ g_axI (Dum.noBackSpaces line_axK) input'_axL
  where
      line_axK = before_axN '\n' inn_axJ
      input'_axL = after_axM '\n' inn_axJ
      after_axM x_axO = tail . dropWhile (x_axO /=)
      before_axN x_a1xq = takeWhile (x_a1xq /=)
Dum.rubout :: Char -> Bool
Dum.rubout c_a1xr = (c_a1xr == '\DEL' || c_a1xr == '\b')
Dum.lineOut :: Int -> String -> String
Dum.lineOut (!n_a1xs) (!"") = ""
Dum.lineOut n_a1xt ((!c_a1xu) : cs_a1xv)
  | n_a1xt > 0 && Dum.rubout c_a1xu
  = "\b \b" ++ Dum.lineOut (n_a1xt - 1) cs_a1xv
  | n_a1xt == 0 && Dum.rubout c_a1xu = Dum.lineOut 0 cs_a1xv
  | otherwise = c_a1xu : Dum.lineOut (n_a1xt + 1) cs_a1xv
Dum.noBackSpaces :: String -> String
Dum.noBackSpaces
  = reverse . delete_a1yI 0 . reverse
  where
      delete_a1yI (!n_a1yJ) "" = ""
      delete_a1yI n_a1yK (!(c_a1yL : cs_a1yM))
        | Dum.rubout c_a1yL = delete_a1yI (n_a1yK + 1) cs_a1yM
        | n_a1yK > 0 = delete_a1yI (n_a1yK - 1) cs_a1yM
        | otherwise = c_a1yL : delete_a1yI 0 cs_a1yM

type Dum.Interactive = String -> String


["p_axv","inn_axw","inn_axx","txt_axy","p_axz","inn_axA","act_axB","def_axC","safebang@!def_axC","(!def_axC)","\"\"","!\"\"","(!\"\")","act_axD","def_axE","!def_axE","(!def_axE)","c_axF","cs_axG","c_axF : cs_axG","(c_axF : cs_axG)","!(c_axF : cs_axG)","(!(c_axF : cs_axG))","((!(c_axF : cs_axG)))","!((!(c_axF : cs_axG)))","(!((!(c_axF : cs_axG))))","prompt_axH","g_axI","inn_axJ","line_axK","input'_axL","x_axO","x_a1xq","c_a1xr","n_a1xs","safebang@!n_a1xs","(!n_a1xs)","\"\"","!\"\"","(!\"\")","n_a1xt","c_a1xu","!c_a1xu","(!c_a1xu)","cs_a1xv","(!c_a1xu) : cs_a1xv","((!c_a1xu) : cs_a1xv)","noBackSpaces","n_a1yJ","safebang@!n_a1yJ","(!n_a1yJ)","\"\"","n_a1yK","c_a1yL","cs_a1yM","c_a1yL : cs_a1yM","(c_a1yL : cs_a1yM)","!(c_a1yL : cs_a1yM)","(!(c_a1yL : cs_a1yM))"]
{-# LANGUAGE BangPatterns #-}
module Dum where

skip :: Interactive -> Interactive
skip p_axv inn_axw = p_axv inn_axw

end :: Interactive
end inn_axx = ""

writeln :: String -> Interactive -> Interactive
writeln txt_axy p_axz inn_axA = txt_axy ++ p_axz inn_axA

readch :: (Char -> Interactive) -> String -> Interactive
readch act_axB (!def_axC) (investigate@"") = def_axC
readch act_axD (investigate@def_axE)
  (investigate@((investigate@(c_axF : cs_axG))))
  = act_axD c_axF cs_axG

readln :: String -> (String -> Interactive) -> Interactive
readln prompt_axH g_axI inn_axJ
  = prompt_axH ++ lineOut 0 line_axK ++ "\n" ++
      g_axI (noBackSpaces line_axK) input'_axL
  where line_axK = before_axN '\n' inn_axJ
        input'_axL = after_axM '\n' inn_axJ
        after_axM x_axO = tail . dropWhile (x_axO /=)
        before_axN x_a1xq = takeWhile (x_a1xq /=)

rubout :: Char -> Bool
rubout c_a1xr = (c_a1xr == '\DEL' || c_a1xr == '\b')

lineOut :: Int -> String -> String
lineOut (!n_a1xs) (investigate@"") = ""
lineOut n_a1xt ((investigate@c_a1xu) : cs_a1xv)
  | n_a1xt > 0 && rubout c_a1xu =
    "\b \b" ++ lineOut (n_a1xt - 1) cs_a1xv
  | n_a1xt == 0 && rubout c_a1xu = lineOut 0 cs_a1xv
  | otherwise = c_a1xu : lineOut (n_a1xt + 1) cs_a1xv

noBackSpaces :: String -> String
noBackSpaces = reverse . delete_a1yI 0 . reverse
  where delete_a1yI (!n_a1yJ) "" = ""
        delete_a1yI n_a1yK (investigate@(c_a1yL : cs_a1yM))
          | rubout c_a1yL = delete_a1yI (n_a1yK + 1) cs_a1yM
          | n_a1yK > 0 = delete_a1yI (n_a1yK - 1) cs_a1yM
          | otherwise = c_a1yL : delete_a1yI 0 cs_a1yM

type Interactive = String -> String
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.skip :: Dum.Interactive -> Dum.Interactive
Dum.skip p_axv inn_axw = p_axv inn_axw
Dum.end :: Dum.Interactive
Dum.end inn_axx = ""
Dum.writeln :: String -> Dum.Interactive -> Dum.Interactive
Dum.writeln txt_axy p_axz inn_axA = txt_axy ++ p_axz inn_axA
Dum.readch ::
  (Char -> Dum.Interactive) -> String -> Dum.Interactive
Dum.readch act_axB (!def_axC) (!"") = def_axC
Dum.readch act_axD (!def_axE) (!((!(c_axF : cs_axG))))
  = act_axD c_axF cs_axG
Dum.readln ::
  String -> (String -> Dum.Interactive) -> Dum.Interactive
Dum.readln prompt_axH g_axI inn_axJ
  = prompt_axH
    ++
      Dum.lineOut 0 line_axK
      ++ "\n" ++ g_axI (Dum.noBackSpaces line_axK) input'_axL
  where
      line_axK = before_axN '\n' inn_axJ
      input'_axL = after_axM '\n' inn_axJ
      after_axM x_axO = tail . dropWhile (x_axO /=)
      before_axN x_a1xq = takeWhile (x_a1xq /=)
Dum.rubout :: Char -> Bool
Dum.rubout c_a1xr = (c_a1xr == '\DEL' || c_a1xr == '\b')
Dum.lineOut :: Int -> String -> String
Dum.lineOut (!n_a1xs) (!"") = ""
Dum.lineOut n_a1xt ((!c_a1xu) : cs_a1xv)
  | n_a1xt > 0 && Dum.rubout c_a1xu
  = "\b \b" ++ Dum.lineOut (n_a1xt - 1) cs_a1xv
  | n_a1xt == 0 && Dum.rubout c_a1xu = Dum.lineOut 0 cs_a1xv
  | otherwise = c_a1xu : Dum.lineOut (n_a1xt + 1) cs_a1xv
Dum.noBackSpaces :: String -> String
Dum.noBackSpaces
  = reverse . delete_a1yI 0 . reverse
  where
      delete_a1yI (!n_a1yJ) "" = ""
      delete_a1yI n_a1yK (!(c_a1yL : cs_a1yM))
        | Dum.rubout c_a1yL = delete_a1yI (n_a1yK + 1) cs_a1yM
        | n_a1yK > 0 = delete_a1yI (n_a1yK - 1) cs_a1yM
        | otherwise = c_a1yL : delete_a1yI 0 cs_a1yM

type Dum.Interactive = String -> String


["p_axv","inn_axw","inn_axx","txt_axy","p_axz","inn_axA","act_axB","def_axC","safebang@!def_axC","(!def_axC)","\"\"","!\"\"","(!\"\")","act_axD","def_axE","!def_axE","(!def_axE)","c_axF","cs_axG","c_axF : cs_axG","(c_axF : cs_axG)","!(c_axF : cs_axG)","(!(c_axF : cs_axG))","((!(c_axF : cs_axG)))","!((!(c_axF : cs_axG)))","(!((!(c_axF : cs_axG))))","prompt_axH","g_axI","inn_axJ","line_axK","input'_axL","x_axO","x_a1xq","c_a1xr","n_a1xs","safebang@!n_a1xs","(!n_a1xs)","\"\"","!\"\"","(!\"\")","n_a1xt","c_a1xu","!c_a1xu","(!c_a1xu)","cs_a1xv","(!c_a1xu) : cs_a1xv","((!c_a1xu) : cs_a1xv)","noBackSpaces","n_a1yJ","safebang@!n_a1yJ","(!n_a1yJ)","\"\"","n_a1yK","c_a1yL","cs_a1yM","c_a1yL : cs_a1yM","(c_a1yL : cs_a1yM)","!(c_a1yL : cs_a1yM)","(!(c_a1yL : cs_a1yM))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import PrologData
import Subst

skip :: Interactive -> Interactive
skip p_axv inn_axw = p_axv inn_axw

end :: Interactive
end inn_axx = ""

writeln :: String -> Interactive -> Interactive
writeln txt_axy p_axz inn_axA = txt_axy ++ p_axz inn_axA

readch :: (Char -> Interactive) -> String -> Interactive
readch act_axB (!def_axC) (investigate@"") = def_axC
readch act_axD (investigate@def_axE)
  (investigate@((investigate@(c_axF : cs_axG))))
  = act_axD c_axF cs_axG

readln :: String -> (String -> Interactive) -> Interactive
readln prompt_axH g_axI inn_axJ
  = prompt_axH ++ lineOut 0 line_axK ++ "\n" ++
      g_axI (noBackSpaces line_axK) input'_axL
  where line_axK = before_axN '\n' inn_axJ
        input'_axL = after_axM '\n' inn_axJ
        after_axM x_axO = tail . dropWhile (x_axO /=)
        before_axN x_a1xq = takeWhile (x_a1xq /=)

rubout :: Char -> Bool
rubout c_a1xr = (c_a1xr == '\DEL' || c_a1xr == '\b')

lineOut :: Int -> String -> String
lineOut (!n_a1xs) (investigate@"") = ""
lineOut n_a1xt ((investigate@c_a1xu) : cs_a1xv)
  | n_a1xt > 0 && rubout c_a1xu =
    "\b \b" ++ lineOut (n_a1xt - 1) cs_a1xv
  | n_a1xt == 0 && rubout c_a1xu = lineOut 0 cs_a1xv
  | otherwise = c_a1xu : lineOut (n_a1xt + 1) cs_a1xv

noBackSpaces :: String -> String
noBackSpaces = reverse . delete_a1yI 0 . reverse
  where delete_a1yI (!n_a1yJ) "" = ""
        delete_a1yI n_a1yK (investigate@(c_a1yL : cs_a1yM))
          | rubout c_a1yL = delete_a1yI (n_a1yK + 1) cs_a1yM
          | n_a1yK > 0 = delete_a1yI (n_a1yK - 1) cs_a1yM
          | otherwise = c_a1yL : delete_a1yI 0 cs_a1yM

type Interactive = String -> String
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.skip :: Dum.Interactive -> Dum.Interactive
Dum.skip p_axv inn_axw = p_axv inn_axw
Dum.end :: Dum.Interactive
Dum.end inn_axx = ""
Dum.writeln :: String -> Dum.Interactive -> Dum.Interactive
Dum.writeln txt_axy p_axz inn_axA = txt_axy ++ p_axz inn_axA
Dum.readch ::
  (Char -> Dum.Interactive) -> String -> Dum.Interactive
Dum.readch act_axB (!def_axC) (!"") = def_axC
Dum.readch act_axD (!def_axE) (!((!(c_axF : cs_axG))))
  = act_axD c_axF cs_axG
Dum.readln ::
  String -> (String -> Dum.Interactive) -> Dum.Interactive
Dum.readln prompt_axH g_axI inn_axJ
  = prompt_axH
    ++
      Dum.lineOut 0 line_axK
      ++ "\n" ++ g_axI (Dum.noBackSpaces line_axK) input'_axL
  where
      line_axK = before_axN '\n' inn_axJ
      input'_axL = after_axM '\n' inn_axJ
      after_axM x_axO = tail . dropWhile (x_axO /=)
      before_axN x_a1xq = takeWhile (x_a1xq /=)
Dum.rubout :: Char -> Bool
Dum.rubout c_a1xr = (c_a1xr == '\DEL' || c_a1xr == '\b')
Dum.lineOut :: Int -> String -> String
Dum.lineOut (!n_a1xs) (!"") = ""
Dum.lineOut n_a1xt ((!c_a1xu) : cs_a1xv)
  | n_a1xt > 0 && Dum.rubout c_a1xu
  = "\b \b" ++ Dum.lineOut (n_a1xt - 1) cs_a1xv
  | n_a1xt == 0 && Dum.rubout c_a1xu = Dum.lineOut 0 cs_a1xv
  | otherwise = c_a1xu : Dum.lineOut (n_a1xt + 1) cs_a1xv
Dum.noBackSpaces :: String -> String
Dum.noBackSpaces
  = reverse . delete_a1yI 0 . reverse
  where
      delete_a1yI (!n_a1yJ) "" = ""
      delete_a1yI n_a1yK (!(c_a1yL : cs_a1yM))
        | Dum.rubout c_a1yL = delete_a1yI (n_a1yK + 1) cs_a1yM
        | n_a1yK > 0 = delete_a1yI (n_a1yK - 1) cs_a1yM
        | otherwise = c_a1yL : delete_a1yI 0 cs_a1yM

type Dum.Interactive = String -> String


["p_axv","inn_axw","inn_axx","txt_axy","p_axz","inn_axA","act_axB","def_axC","safebang@!def_axC","(!def_axC)","\"\"","!\"\"","(!\"\")","act_axD","def_axE","!def_axE","(!def_axE)","c_axF","cs_axG","c_axF : cs_axG","(c_axF : cs_axG)","!(c_axF : cs_axG)","(!(c_axF : cs_axG))","((!(c_axF : cs_axG)))","!((!(c_axF : cs_axG)))","(!((!(c_axF : cs_axG))))","prompt_axH","g_axI","inn_axJ","line_axK","input'_axL","x_axO","x_a1xq","c_a1xr","n_a1xs","safebang@!n_a1xs","(!n_a1xs)","\"\"","!\"\"","(!\"\")","n_a1xt","c_a1xu","!c_a1xu","(!c_a1xu)","cs_a1xv","(!c_a1xu) : cs_a1xv","((!c_a1xu) : cs_a1xv)","noBackSpaces","n_a1yJ","safebang@!n_a1yJ","(!n_a1yJ)","\"\"","n_a1yK","c_a1yL","cs_a1yM","c_a1yL : cs_a1yM","(c_a1yL : cs_a1yM)","!(c_a1yL : cs_a1yM)","(!(c_a1yL : cs_a1yM))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import PrologData
import Subst

skip :: Interactive -> Interactive
skip p_axv inn_axw = p_axv inn_axw

end :: Interactive
end inn_axx = ""

writeln :: String -> Interactive -> Interactive
writeln txt_axy p_axz inn_axA = txt_axy ++ p_axz inn_axA

readch :: (Char -> Interactive) -> String -> Interactive
readch act_axB (!def_axC) (investigate@"") = def_axC
readch act_axD (investigate@def_axE)
  (investigate@((investigate@(c_axF : cs_axG))))
  = act_axD c_axF cs_axG

readln :: String -> (String -> Interactive) -> Interactive
readln prompt_axH g_axI inn_axJ
  = prompt_axH ++ lineOut 0 line_axK ++ "\n" ++
      g_axI (noBackSpaces line_axK) input'_axL
  where line_axK = before_axN '\n' inn_axJ
        input'_axL = after_axM '\n' inn_axJ
        after_axM x_axO = tail . dropWhile (x_axO /=)
        before_axN x_a1xq = takeWhile (x_a1xq /=)

rubout :: Char -> Bool
rubout c_a1xr = (c_a1xr == '\DEL' || c_a1xr == '\b')

lineOut :: Int -> String -> String
lineOut (!n_a1xs) (investigate@"") = ""
lineOut n_a1xt ((investigate@c_a1xu) : cs_a1xv)
  | n_a1xt > 0 && rubout c_a1xu =
    "\b \b" ++ lineOut (n_a1xt - 1) cs_a1xv
  | n_a1xt == 0 && rubout c_a1xu = lineOut 0 cs_a1xv
  | otherwise = c_a1xu : lineOut (n_a1xt + 1) cs_a1xv

noBackSpaces :: String -> String
noBackSpaces = reverse . delete_a1yI 0 . reverse
  where delete_a1yI (!n_a1yJ) "" = ""
        delete_a1yI n_a1yK (investigate@(c_a1yL : cs_a1yM))
          | rubout c_a1yL = delete_a1yI (n_a1yK + 1) cs_a1yM
          | n_a1yK > 0 = delete_a1yI (n_a1yK - 1) cs_a1yM
          | otherwise = c_a1yL : delete_a1yI 0 cs_a1yM

type Interactive = String -> String
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.skip :: Dum.Interactive -> Dum.Interactive
Dum.skip p_axv inn_axw = p_axv inn_axw
Dum.end :: Dum.Interactive
Dum.end inn_axx = ""
Dum.writeln :: String -> Dum.Interactive -> Dum.Interactive
Dum.writeln txt_axy p_axz inn_axA = txt_axy ++ p_axz inn_axA
Dum.readch ::
  (Char -> Dum.Interactive) -> String -> Dum.Interactive
Dum.readch act_axB (!def_axC) (!"") = def_axC
Dum.readch act_axD (!def_axE) (!((!(c_axF : cs_axG))))
  = act_axD c_axF cs_axG
Dum.readln ::
  String -> (String -> Dum.Interactive) -> Dum.Interactive
Dum.readln prompt_axH g_axI inn_axJ
  = prompt_axH
    ++
      Dum.lineOut 0 line_axK
      ++ "\n" ++ g_axI (Dum.noBackSpaces line_axK) input'_axL
  where
      line_axK = before_axN '\n' inn_axJ
      input'_axL = after_axM '\n' inn_axJ
      after_axM x_axO = tail . dropWhile (x_axO /=)
      before_axN x_a1xq = takeWhile (x_a1xq /=)
Dum.rubout :: Char -> Bool
Dum.rubout c_a1xr = (c_a1xr == '\DEL' || c_a1xr == '\b')
Dum.lineOut :: Int -> String -> String
Dum.lineOut (!n_a1xs) (!"") = ""
Dum.lineOut n_a1xt ((!c_a1xu) : cs_a1xv)
  | n_a1xt > 0 && Dum.rubout c_a1xu
  = "\b \b" ++ Dum.lineOut (n_a1xt - 1) cs_a1xv
  | n_a1xt == 0 && Dum.rubout c_a1xu = Dum.lineOut 0 cs_a1xv
  | otherwise = c_a1xu : Dum.lineOut (n_a1xt + 1) cs_a1xv
Dum.noBackSpaces :: String -> String
Dum.noBackSpaces
  = reverse . delete_a1yI 0 . reverse
  where
      delete_a1yI (!n_a1yJ) "" = ""
      delete_a1yI n_a1yK (!(c_a1yL : cs_a1yM))
        | Dum.rubout c_a1yL = delete_a1yI (n_a1yK + 1) cs_a1yM
        | n_a1yK > 0 = delete_a1yI (n_a1yK - 1) cs_a1yM
        | otherwise = c_a1yL : delete_a1yI 0 cs_a1yM

type Dum.Interactive = String -> String


["p_axv","inn_axw","inn_axx","txt_axy","p_axz","inn_axA","act_axB","def_axC","safebang@!def_axC","(!def_axC)","\"\"","!\"\"","(!\"\")","act_axD","def_axE","!def_axE","(!def_axE)","c_axF","cs_axG","c_axF : cs_axG","(c_axF : cs_axG)","!(c_axF : cs_axG)","(!(c_axF : cs_axG))","((!(c_axF : cs_axG)))","!((!(c_axF : cs_axG)))","(!((!(c_axF : cs_axG))))","prompt_axH","g_axI","inn_axJ","line_axK","input'_axL","x_axO","x_a1xq","c_a1xr","n_a1xs","safebang@!n_a1xs","(!n_a1xs)","\"\"","!\"\"","(!\"\")","n_a1xt","c_a1xu","!c_a1xu","(!c_a1xu)","cs_a1xv","(!c_a1xu) : cs_a1xv","((!c_a1xu) : cs_a1xv)","noBackSpaces","n_a1yJ","safebang@!n_a1yJ","(!n_a1yJ)","\"\"","n_a1yK","c_a1yL","cs_a1yM","c_a1yL : cs_a1yM","(c_a1yL : cs_a1yM)","!(c_a1yL : cs_a1yM)","(!(c_a1yL : cs_a1yM))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import PicType
import Consts
import Data.Array

skip :: Interactive -> Interactive
skip p_axv inn_axw = p_axv inn_axw

end :: Interactive
end inn_axx = ""

writeln :: String -> Interactive -> Interactive
writeln txt_axy p_axz inn_axA = txt_axy ++ p_axz inn_axA

readch :: (Char -> Interactive) -> String -> Interactive
readch act_axB (!def_axC) (investigate@"") = def_axC
readch act_axD (investigate@def_axE)
  (investigate@((investigate@(c_axF : cs_axG))))
  = act_axD c_axF cs_axG

readln :: String -> (String -> Interactive) -> Interactive
readln prompt_axH g_axI inn_axJ
  = prompt_axH ++ lineOut 0 line_axK ++ "\n" ++
      g_axI (noBackSpaces line_axK) input'_axL
  where line_axK = before_axN '\n' inn_axJ
        input'_axL = after_axM '\n' inn_axJ
        after_axM x_axO = tail . dropWhile (x_axO /=)
        before_axN x_a1xq = takeWhile (x_a1xq /=)

rubout :: Char -> Bool
rubout c_a1xr = (c_a1xr == '\DEL' || c_a1xr == '\b')

lineOut :: Int -> String -> String
lineOut (!n_a1xs) (investigate@"") = ""
lineOut n_a1xt ((investigate@c_a1xu) : cs_a1xv)
  | n_a1xt > 0 && rubout c_a1xu =
    "\b \b" ++ lineOut (n_a1xt - 1) cs_a1xv
  | n_a1xt == 0 && rubout c_a1xu = lineOut 0 cs_a1xv
  | otherwise = c_a1xu : lineOut (n_a1xt + 1) cs_a1xv

noBackSpaces :: String -> String
noBackSpaces = reverse . delete_a1yI 0 . reverse
  where delete_a1yI (!n_a1yJ) "" = ""
        delete_a1yI n_a1yK (investigate@(c_a1yL : cs_a1yM))
          | rubout c_a1yL = delete_a1yI (n_a1yK + 1) cs_a1yM
          | n_a1yK > 0 = delete_a1yI (n_a1yK - 1) cs_a1yM
          | otherwise = c_a1yL : delete_a1yI 0 cs_a1yM

type Interactive = String -> String
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.skip :: Dum.Interactive -> Dum.Interactive
Dum.skip p_axv inn_axw = p_axv inn_axw
Dum.end :: Dum.Interactive
Dum.end inn_axx = ""
Dum.writeln :: String -> Dum.Interactive -> Dum.Interactive
Dum.writeln txt_axy p_axz inn_axA = txt_axy ++ p_axz inn_axA
Dum.readch ::
  (Char -> Dum.Interactive) -> String -> Dum.Interactive
Dum.readch act_axB (!def_axC) (!"") = def_axC
Dum.readch act_axD (!def_axE) (!((!(c_axF : cs_axG))))
  = act_axD c_axF cs_axG
Dum.readln ::
  String -> (String -> Dum.Interactive) -> Dum.Interactive
Dum.readln prompt_axH g_axI inn_axJ
  = prompt_axH
    ++
      Dum.lineOut 0 line_axK
      ++ "\n" ++ g_axI (Dum.noBackSpaces line_axK) input'_axL
  where
      line_axK = before_axN '\n' inn_axJ
      input'_axL = after_axM '\n' inn_axJ
      after_axM x_axO = tail . dropWhile (x_axO /=)
      before_axN x_a1xq = takeWhile (x_a1xq /=)
Dum.rubout :: Char -> Bool
Dum.rubout c_a1xr = (c_a1xr == '\DEL' || c_a1xr == '\b')
Dum.lineOut :: Int -> String -> String
Dum.lineOut (!n_a1xs) (!"") = ""
Dum.lineOut n_a1xt ((!c_a1xu) : cs_a1xv)
  | n_a1xt > 0 && Dum.rubout c_a1xu
  = "\b \b" ++ Dum.lineOut (n_a1xt - 1) cs_a1xv
  | n_a1xt == 0 && Dum.rubout c_a1xu = Dum.lineOut 0 cs_a1xv
  | otherwise = c_a1xu : Dum.lineOut (n_a1xt + 1) cs_a1xv
Dum.noBackSpaces :: String -> String
Dum.noBackSpaces
  = reverse . delete_a1yI 0 . reverse
  where
      delete_a1yI (!n_a1yJ) "" = ""
      delete_a1yI n_a1yK (!(c_a1yL : cs_a1yM))
        | Dum.rubout c_a1yL = delete_a1yI (n_a1yK + 1) cs_a1yM
        | n_a1yK > 0 = delete_a1yI (n_a1yK - 1) cs_a1yM
        | otherwise = c_a1yL : delete_a1yI 0 cs_a1yM

type Dum.Interactive = String -> String


["p_axv","inn_axw","inn_axx","txt_axy","p_axz","inn_axA","act_axB","def_axC","safebang@!def_axC","(!def_axC)","\"\"","!\"\"","(!\"\")","act_axD","def_axE","!def_axE","(!def_axE)","c_axF","cs_axG","c_axF : cs_axG","(c_axF : cs_axG)","!(c_axF : cs_axG)","(!(c_axF : cs_axG))","((!(c_axF : cs_axG)))","!((!(c_axF : cs_axG)))","(!((!(c_axF : cs_axG))))","prompt_axH","g_axI","inn_axJ","line_axK","input'_axL","x_axO","x_a1xq","c_a1xr","n_a1xs","safebang@!n_a1xs","(!n_a1xs)","\"\"","!\"\"","(!\"\")","n_a1xt","c_a1xu","!c_a1xu","(!c_a1xu)","cs_a1xv","(!c_a1xu) : cs_a1xv","((!c_a1xu) : cs_a1xv)","noBackSpaces","n_a1yJ","safebang@!n_a1yJ","(!n_a1yJ)","\"\"","n_a1yK","c_a1yL","cs_a1yM","c_a1yL : cs_a1yM","(c_a1yL : cs_a1yM)","!(c_a1yL : cs_a1yM)","(!(c_a1yL : cs_a1yM))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Pic
import PicType
import System.IO (hPutStr, stderr)

skip :: Interactive -> Interactive
skip p_axv inn_axw = p_axv inn_axw

end :: Interactive
end inn_axx = ""

writeln :: String -> Interactive -> Interactive
writeln txt_axy p_axz inn_axA = txt_axy ++ p_axz inn_axA

readch :: (Char -> Interactive) -> String -> Interactive
readch act_axB (!def_axC) (investigate@"") = def_axC
readch act_axD (investigate@def_axE)
  (investigate@((investigate@(c_axF : cs_axG))))
  = act_axD c_axF cs_axG

readln :: String -> (String -> Interactive) -> Interactive
readln prompt_axH g_axI inn_axJ
  = prompt_axH ++ lineOut 0 line_axK ++ "\n" ++
      g_axI (noBackSpaces line_axK) input'_axL
  where line_axK = before_axN '\n' inn_axJ
        input'_axL = after_axM '\n' inn_axJ
        after_axM x_axO = tail . dropWhile (x_axO /=)
        before_axN x_a1xq = takeWhile (x_a1xq /=)

rubout :: Char -> Bool
rubout c_a1xr = (c_a1xr == '\DEL' || c_a1xr == '\b')

lineOut :: Int -> String -> String
lineOut (!n_a1xs) (investigate@"") = ""
lineOut n_a1xt ((investigate@c_a1xu) : cs_a1xv)
  | n_a1xt > 0 && rubout c_a1xu =
    "\b \b" ++ lineOut (n_a1xt - 1) cs_a1xv
  | n_a1xt == 0 && rubout c_a1xu = lineOut 0 cs_a1xv
  | otherwise = c_a1xu : lineOut (n_a1xt + 1) cs_a1xv

noBackSpaces :: String -> String
noBackSpaces = reverse . delete_a1yI 0 . reverse
  where delete_a1yI (!n_a1yJ) "" = ""
        delete_a1yI n_a1yK (investigate@(c_a1yL : cs_a1yM))
          | rubout c_a1yL = delete_a1yI (n_a1yK + 1) cs_a1yM
          | n_a1yK > 0 = delete_a1yI (n_a1yK - 1) cs_a1yM
          | otherwise = c_a1yL : delete_a1yI 0 cs_a1yM

type Interactive = String -> String
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.skip :: Dum.Interactive -> Dum.Interactive
Dum.skip p_axv inn_axw = p_axv inn_axw
Dum.end :: Dum.Interactive
Dum.end inn_axx = ""
Dum.writeln :: String -> Dum.Interactive -> Dum.Interactive
Dum.writeln txt_axy p_axz inn_axA = txt_axy ++ p_axz inn_axA
Dum.readch ::
  (Char -> Dum.Interactive) -> String -> Dum.Interactive
Dum.readch act_axB (!def_axC) (!"") = def_axC
Dum.readch act_axD (!def_axE) (!((!(c_axF : cs_axG))))
  = act_axD c_axF cs_axG
Dum.readln ::
  String -> (String -> Dum.Interactive) -> Dum.Interactive
Dum.readln prompt_axH g_axI inn_axJ
  = prompt_axH
    ++
      Dum.lineOut 0 line_axK
      ++ "\n" ++ g_axI (Dum.noBackSpaces line_axK) input'_axL
  where
      line_axK = before_axN '\n' inn_axJ
      input'_axL = after_axM '\n' inn_axJ
      after_axM x_axO = tail . dropWhile (x_axO /=)
      before_axN x_a1xq = takeWhile (x_a1xq /=)
Dum.rubout :: Char -> Bool
Dum.rubout c_a1xr = (c_a1xr == '\DEL' || c_a1xr == '\b')
Dum.lineOut :: Int -> String -> String
Dum.lineOut (!n_a1xs) (!"") = ""
Dum.lineOut n_a1xt ((!c_a1xu) : cs_a1xv)
  | n_a1xt > 0 && Dum.rubout c_a1xu
  = "\b \b" ++ Dum.lineOut (n_a1xt - 1) cs_a1xv
  | n_a1xt == 0 && Dum.rubout c_a1xu = Dum.lineOut 0 cs_a1xv
  | otherwise = c_a1xu : Dum.lineOut (n_a1xt + 1) cs_a1xv
Dum.noBackSpaces :: String -> String
Dum.noBackSpaces
  = reverse . delete_a1yI 0 . reverse
  where
      delete_a1yI (!n_a1yJ) "" = ""
      delete_a1yI n_a1yK (!(c_a1yL : cs_a1yM))
        | Dum.rubout c_a1yL = delete_a1yI (n_a1yK + 1) cs_a1yM
        | n_a1yK > 0 = delete_a1yI (n_a1yK - 1) cs_a1yM
        | otherwise = c_a1yL : delete_a1yI 0 cs_a1yM

type Dum.Interactive = String -> String


["p_axv","inn_axw","inn_axx","txt_axy","p_axz","inn_axA","act_axB","def_axC","safebang@!def_axC","(!def_axC)","\"\"","!\"\"","(!\"\")","act_axD","def_axE","!def_axE","(!def_axE)","c_axF","cs_axG","c_axF : cs_axG","(c_axF : cs_axG)","!(c_axF : cs_axG)","(!(c_axF : cs_axG))","((!(c_axF : cs_axG)))","!((!(c_axF : cs_axG)))","(!((!(c_axF : cs_axG))))","prompt_axH","g_axI","inn_axJ","line_axK","input'_axL","x_axO","x_a1xq","c_a1xr","n_a1xs","safebang@!n_a1xs","(!n_a1xs)","\"\"","!\"\"","(!\"\")","n_a1xt","c_a1xu","!c_a1xu","(!c_a1xu)","cs_a1xv","(!c_a1xu) : cs_a1xv","((!c_a1xu) : cs_a1xv)","noBackSpaces","n_a1yJ","safebang@!n_a1yJ","(!n_a1yJ)","\"\"","n_a1yK","c_a1yL","cs_a1yM","c_a1yL : cs_a1yM","(c_a1yL : cs_a1yM)","!(c_a1yL : cs_a1yM)","(!(c_a1yL : cs_a1yM))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import PicType
import Utils

skip :: Interactive -> Interactive
skip p_axv inn_axw = p_axv inn_axw

end :: Interactive
end inn_axx = ""

writeln :: String -> Interactive -> Interactive
writeln txt_axy p_axz inn_axA = txt_axy ++ p_axz inn_axA

readch :: (Char -> Interactive) -> String -> Interactive
readch act_axB (!def_axC) (investigate@"") = def_axC
readch act_axD (investigate@def_axE)
  (investigate@((investigate@(c_axF : cs_axG))))
  = act_axD c_axF cs_axG

readln :: String -> (String -> Interactive) -> Interactive
readln prompt_axH g_axI inn_axJ
  = prompt_axH ++ lineOut 0 line_axK ++ "\n" ++
      g_axI (noBackSpaces line_axK) input'_axL
  where line_axK = before_axN '\n' inn_axJ
        input'_axL = after_axM '\n' inn_axJ
        after_axM x_axO = tail . dropWhile (x_axO /=)
        before_axN x_a1xq = takeWhile (x_a1xq /=)

rubout :: Char -> Bool
rubout c_a1xr = (c_a1xr == '\DEL' || c_a1xr == '\b')

lineOut :: Int -> String -> String
lineOut (!n_a1xs) (investigate@"") = ""
lineOut n_a1xt ((investigate@c_a1xu) : cs_a1xv)
  | n_a1xt > 0 && rubout c_a1xu =
    "\b \b" ++ lineOut (n_a1xt - 1) cs_a1xv
  | n_a1xt == 0 && rubout c_a1xu = lineOut 0 cs_a1xv
  | otherwise = c_a1xu : lineOut (n_a1xt + 1) cs_a1xv

noBackSpaces :: String -> String
noBackSpaces = reverse . delete_a1yI 0 . reverse
  where delete_a1yI (!n_a1yJ) "" = ""
        delete_a1yI n_a1yK (investigate@(c_a1yL : cs_a1yM))
          | rubout c_a1yL = delete_a1yI (n_a1yK + 1) cs_a1yM
          | n_a1yK > 0 = delete_a1yI (n_a1yK - 1) cs_a1yM
          | otherwise = c_a1yL : delete_a1yI 0 cs_a1yM

type Interactive = String -> String
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.skip :: Dum.Interactive -> Dum.Interactive
Dum.skip p_axv inn_axw = p_axv inn_axw
Dum.end :: Dum.Interactive
Dum.end inn_axx = ""
Dum.writeln :: String -> Dum.Interactive -> Dum.Interactive
Dum.writeln txt_axy p_axz inn_axA = txt_axy ++ p_axz inn_axA
Dum.readch ::
  (Char -> Dum.Interactive) -> String -> Dum.Interactive
Dum.readch act_axB (!def_axC) (!"") = def_axC
Dum.readch act_axD (!def_axE) (!((!(c_axF : cs_axG))))
  = act_axD c_axF cs_axG
Dum.readln ::
  String -> (String -> Dum.Interactive) -> Dum.Interactive
Dum.readln prompt_axH g_axI inn_axJ
  = prompt_axH
    ++
      Dum.lineOut 0 line_axK
      ++ "\n" ++ g_axI (Dum.noBackSpaces line_axK) input'_axL
  where
      line_axK = before_axN '\n' inn_axJ
      input'_axL = after_axM '\n' inn_axJ
      after_axM x_axO = tail . dropWhile (x_axO /=)
      before_axN x_a1xq = takeWhile (x_a1xq /=)
Dum.rubout :: Char -> Bool
Dum.rubout c_a1xr = (c_a1xr == '\DEL' || c_a1xr == '\b')
Dum.lineOut :: Int -> String -> String
Dum.lineOut (!n_a1xs) (!"") = ""
Dum.lineOut n_a1xt ((!c_a1xu) : cs_a1xv)
  | n_a1xt > 0 && Dum.rubout c_a1xu
  = "\b \b" ++ Dum.lineOut (n_a1xt - 1) cs_a1xv
  | n_a1xt == 0 && Dum.rubout c_a1xu = Dum.lineOut 0 cs_a1xv
  | otherwise = c_a1xu : Dum.lineOut (n_a1xt + 1) cs_a1xv
Dum.noBackSpaces :: String -> String
Dum.noBackSpaces
  = reverse . delete_a1yI 0 . reverse
  where
      delete_a1yI (!n_a1yJ) "" = ""
      delete_a1yI n_a1yK (!(c_a1yL : cs_a1yM))
        | Dum.rubout c_a1yL = delete_a1yI (n_a1yK + 1) cs_a1yM
        | n_a1yK > 0 = delete_a1yI (n_a1yK - 1) cs_a1yM
        | otherwise = c_a1yL : delete_a1yI 0 cs_a1yM

type Dum.Interactive = String -> String


["p_axv","inn_axw","inn_axx","txt_axy","p_axz","inn_axA","act_axB","def_axC","safebang@!def_axC","(!def_axC)","\"\"","!\"\"","(!\"\")","act_axD","def_axE","!def_axE","(!def_axE)","c_axF","cs_axG","c_axF : cs_axG","(c_axF : cs_axG)","!(c_axF : cs_axG)","(!(c_axF : cs_axG))","((!(c_axF : cs_axG)))","!((!(c_axF : cs_axG)))","(!((!(c_axF : cs_axG))))","prompt_axH","g_axI","inn_axJ","line_axK","input'_axL","x_axO","x_a1xq","c_a1xr","n_a1xs","safebang@!n_a1xs","(!n_a1xs)","\"\"","!\"\"","(!\"\")","n_a1xt","c_a1xu","!c_a1xu","(!c_a1xu)","cs_a1xv","(!c_a1xu) : cs_a1xv","((!c_a1xu) : cs_a1xv)","noBackSpaces","n_a1yJ","safebang@!n_a1yJ","(!n_a1yJ)","\"\"","n_a1yK","c_a1yL","cs_a1yM","c_a1yL : cs_a1yM","(c_a1yL : cs_a1yM)","!(c_a1yL : cs_a1yM)","(!(c_a1yL : cs_a1yM))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import PicType
import Consts
import Utils
import Data.Array

skip :: Interactive -> Interactive
skip p_axv inn_axw = p_axv inn_axw

end :: Interactive
end inn_axx = ""

writeln :: String -> Interactive -> Interactive
writeln txt_axy p_axz inn_axA = txt_axy ++ p_axz inn_axA

readch :: (Char -> Interactive) -> String -> Interactive
readch act_axB (!def_axC) (investigate@"") = def_axC
readch act_axD (investigate@def_axE)
  (investigate@((investigate@(c_axF : cs_axG))))
  = act_axD c_axF cs_axG

readln :: String -> (String -> Interactive) -> Interactive
readln prompt_axH g_axI inn_axJ
  = prompt_axH ++ lineOut 0 line_axK ++ "\n" ++
      g_axI (noBackSpaces line_axK) input'_axL
  where line_axK = before_axN '\n' inn_axJ
        input'_axL = after_axM '\n' inn_axJ
        after_axM x_axO = tail . dropWhile (x_axO /=)
        before_axN x_a1xq = takeWhile (x_a1xq /=)

rubout :: Char -> Bool
rubout c_a1xr = (c_a1xr == '\DEL' || c_a1xr == '\b')

lineOut :: Int -> String -> String
lineOut (!n_a1xs) (investigate@"") = ""
lineOut n_a1xt ((investigate@c_a1xu) : cs_a1xv)
  | n_a1xt > 0 && rubout c_a1xu =
    "\b \b" ++ lineOut (n_a1xt - 1) cs_a1xv
  | n_a1xt == 0 && rubout c_a1xu = lineOut 0 cs_a1xv
  | otherwise = c_a1xu : lineOut (n_a1xt + 1) cs_a1xv

noBackSpaces :: String -> String
noBackSpaces = reverse . delete_a1yI 0 . reverse
  where delete_a1yI (!n_a1yJ) "" = ""
        delete_a1yI n_a1yK (investigate@(c_a1yL : cs_a1yM))
          | rubout c_a1yL = delete_a1yI (n_a1yK + 1) cs_a1yM
          | n_a1yK > 0 = delete_a1yI (n_a1yK - 1) cs_a1yM
          | otherwise = c_a1yL : delete_a1yI 0 cs_a1yM

type Interactive = String -> String
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
type Dum.Count = Int
type Dum.Indx = Int
type Dum.Value = Double
type Dum.Mesh = Array (Int, Int) Dum.Value
type Dum.MeshAssoc = ((Int, Int), Dum.Value)
type Dum.Electric = (Dum.Mesh, Dum.Mesh)
type Dum.Phi = Dum.Mesh
type Dum.Rho = Dum.Mesh
type Dum.Position = (Dum.Value, Dum.Value)
type Dum.Range = [Dum.Indx]
type Dum.Velocity = (Dum.Value, Dum.Value)
type Dum.ParticleHeap = ([Dum.Position], [Dum.Velocity])


[]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Array

type Count = Int

type Indx = Int

type Value = Double

type Mesh = Array (Int, Int) Value

type MeshAssoc = ((Int, Int), Value)

type Electric = (Mesh, Mesh)

type Phi = Mesh

type Rho = Mesh

type Position = (Value, Value)

type Range = [Indx]

type Velocity = (Value, Value)

type ParticleHeap = ([Position], [Velocity])
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
type Dum.Count = Int
type Dum.Indx = Int
type Dum.Value = Double
type Dum.Mesh = Array (Int, Int) Dum.Value
type Dum.MeshAssoc = ((Int, Int), Dum.Value)
type Dum.Electric = (Dum.Mesh, Dum.Mesh)
type Dum.Phi = Dum.Mesh
type Dum.Rho = Dum.Mesh
type Dum.Position = (Dum.Value, Dum.Value)
type Dum.Range = [Dum.Indx]
type Dum.Velocity = (Dum.Value, Dum.Value)
type Dum.ParticleHeap = ([Dum.Position], [Dum.Velocity])


[]
{-# LANGUAGE BangPatterns #-}
module Dum where
import PicType
import Consts
import Utils
import ChargeDensity
import Potential
import ElecField
import PushParticle
import Data.Array

type Count = Int

type Indx = Int

type Value = Double

type Mesh = Array (Int, Int) Value

type MeshAssoc = ((Int, Int), Value)

type Electric = (Mesh, Mesh)

type Phi = Mesh

type Rho = Mesh

type Position = (Value, Value)

type Range = [Indx]

type Velocity = (Value, Value)

type ParticleHeap = ([Position], [Velocity])
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
type Dum.Count = Int
type Dum.Indx = Int
type Dum.Value = Double
type Dum.Mesh = Array (Int, Int) Dum.Value
type Dum.MeshAssoc = ((Int, Int), Dum.Value)
type Dum.Electric = (Dum.Mesh, Dum.Mesh)
type Dum.Phi = Dum.Mesh
type Dum.Rho = Dum.Mesh
type Dum.Position = (Dum.Value, Dum.Value)
type Dum.Range = [Dum.Indx]
type Dum.Velocity = (Dum.Value, Dum.Value)
type Dum.ParticleHeap = ([Dum.Position], [Dum.Velocity])


[]
{-# LANGUAGE BangPatterns #-}
module Dum where
import PicType
import Data.Array

type Count = Int

type Indx = Int

type Value = Double

type Mesh = Array (Int, Int) Value

type MeshAssoc = ((Int, Int), Value)

type Electric = (Mesh, Mesh)

type Phi = Mesh

type Rho = Mesh

type Position = (Value, Value)

type Range = [Indx]

type Velocity = (Value, Value)

type ParticleHeap = ([Position], [Velocity])
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
type Dum.Count = Int
type Dum.Indx = Int
type Dum.Value = Double
type Dum.Mesh = Array (Int, Int) Dum.Value
type Dum.MeshAssoc = ((Int, Int), Dum.Value)
type Dum.Electric = (Dum.Mesh, Dum.Mesh)
type Dum.Phi = Dum.Mesh
type Dum.Rho = Dum.Mesh
type Dum.Position = (Dum.Value, Dum.Value)
type Dum.Range = [Dum.Indx]
type Dum.Velocity = (Dum.Value, Dum.Value)
type Dum.ParticleHeap = ([Dum.Position], [Dum.Velocity])


[]
{-# LANGUAGE BangPatterns #-}
module Dum where
import PicType
import Consts
import Data.Array

type Count = Int

type Indx = Int

type Value = Double

type Mesh = Array (Int, Int) Value

type MeshAssoc = ((Int, Int), Value)

type Electric = (Mesh, Mesh)

type Phi = Mesh

type Rho = Mesh

type Position = (Value, Value)

type Range = [Indx]

type Velocity = (Value, Value)

type ParticleHeap = ([Position], [Velocity])
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
type Dum.Count = Int
type Dum.Indx = Int
type Dum.Value = Double
type Dum.Mesh = Array (Int, Int) Dum.Value
type Dum.MeshAssoc = ((Int, Int), Dum.Value)
type Dum.Electric = (Dum.Mesh, Dum.Mesh)
type Dum.Phi = Dum.Mesh
type Dum.Rho = Dum.Mesh
type Dum.Position = (Dum.Value, Dum.Value)
type Dum.Range = [Dum.Indx]
type Dum.Velocity = (Dum.Value, Dum.Value)
type Dum.ParticleHeap = ([Dum.Position], [Dum.Velocity])


[]
{-# LANGUAGE BangPatterns #-}
module Dum where
import PicType
import Consts
import Data.Array

type Count = Int

type Indx = Int

type Value = Double

type Mesh = Array (Int, Int) Value

type MeshAssoc = ((Int, Int), Value)

type Electric = (Mesh, Mesh)

type Phi = Mesh

type Rho = Mesh

type Position = (Value, Value)

type Range = [Indx]

type Velocity = (Value, Value)

type ParticleHeap = ([Position], [Velocity])
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
type Dum.Count = Int
type Dum.Indx = Int
type Dum.Value = Double
type Dum.Mesh = Array (Int, Int) Dum.Value
type Dum.MeshAssoc = ((Int, Int), Dum.Value)
type Dum.Electric = (Dum.Mesh, Dum.Mesh)
type Dum.Phi = Dum.Mesh
type Dum.Rho = Dum.Mesh
type Dum.Position = (Dum.Value, Dum.Value)
type Dum.Range = [Dum.Indx]
type Dum.Velocity = (Dum.Value, Dum.Value)
type Dum.ParticleHeap = ([Dum.Position], [Dum.Velocity])


[]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils

type Count = Int

type Indx = Int

type Value = Double

type Mesh = Array (Int, Int) Value

type MeshAssoc = ((Int, Int), Value)

type Electric = (Mesh, Mesh)

type Phi = Mesh

type Rho = Mesh

type Position = (Value, Value)

type Range = [Indx]

type Velocity = (Value, Value)

type ParticleHeap = ([Position], [Velocity])
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import AbstractVals2
import SuccsAndPreds2
import AbstractMisc
import Apply
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import Parser2
import PrettyPrint
import LambdaLift5
import TypeCheck5
import EtaAbstract
import StrictAn6
import ReadTable
import System.Environment
import Data.Char (isDigit)
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import AbstractVals2
import SuccsAndPreds2
import AbstractMisc
import AbstractEval2
import AbsConc3
import FrontierMisc2
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import AbstractVals2
import SuccsAndPreds2
import AbstractMisc
import DomainExpr
import AbsConc3
import BarakiMeet
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import AbstractVals2
import AbstractEval2
import Apply
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import AbstractVals2
import SuccsAndPreds2
import Data.List (nub)
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import AbstractVals2
import SuccsAndPreds2
import AbstractMisc
import DomainExpr
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import AbstractVals2
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import Dependancy
import Data.List (nub)
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import Parser2
import Data.Char (isDigit)
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import Data.List (nub)
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import AbstractVals2
import SuccsAndPreds2
import AbstractMisc
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import MyUtils
import Utils
import AbstractVals2
import SuccsAndPreds2
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import AbstractVals2
import Apply
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import DomainExpr
import MakeDomains
import TypeCheck5
import Data.List (nub)
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import BarakiConc3
import Constructors
import PrintResults
import AbstractVals2
import DomainExpr
import TExpr2DExpr
import AbstractMisc
import Inverse
import AbstractEval2
import Simplify
import FrontierGENERIC2
import SmallerLattice
import AbsConc3
import Data.List (transpose)
import Data.Char (isLower, isUpper)
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import MyUtils
import BaseDefs
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import DomainExpr
import AbstractVals2
import SuccsAndPreds2
import AbstractMisc
import Inverse
import Apply
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import AbstractVals2
import SuccsAndPreds2
import AbstractEval2
import AbsConc3
import FrontierMisc2
import FrontierDATAFN2
import AbstractMisc
import Apply
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import Inverse
import AbstractMisc
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import Dependancy
import Data.List (nub)
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import MyUtils
import Utils
import AbstractVals2
import SuccsAndPreds2
import AbstractMisc
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import AbstractVals2
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import MyUtils
import Utils
import AbsConc3
import Data.List (nub, transpose)
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BaseDefs
import Utils
import MyUtils
import MakeDomains
import Data.List (nub)
import Data.Char (isAlpha, isDigit)
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Norm
import Data.Array
import Data.Ix
import Data.List
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm
import Elefac
import Asb_routs
import Chl_routs
import Chl_decomp
import Chl_method
import Jcb_method
import TG_iter
import Min_degree
import Input_proc
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm
import Asb_routs
import Data.Ix
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm
import Asb_routs
import Tol_cal
import Data.Ix
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm
import Asb_routs
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.bdDefaultSettings
  = [Dum.PolyLim 10000, Dum.MonoLim 10000, Dum.LowerLim 0,
     Dum.UpperLim 1000000, Dum.ScaleUp 20]
Dum.bdDryRunSettings
  = [Dum.NoBaraki, Dum.LowerLim 0, Dum.UpperLim 0, Dum.PolyLim 1,
     Dum.MonoLim 1, Dum.ScaleUp 20]

type Dum.AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]
type Dum.DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]
type Dum.ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)
data Dum.ATree a_a1Uk b_a1Ul
  = Dum.ALeaf |
    Dum.ABranch (Dum.ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (Dum.ATree a_a1Uk b_a1Ul) Int
  deriving (Eq)
data Dum.Reply a_a1Ui b_a1Uj
  = Dum.Ok a_a1Ui | Dum.Fail b_a1Uj
  deriving (Eq)
type Dum.NameSupply = Int
type Dum.Oseq = Int -> Int -> [Char]
type Dum.Iseq = Dum.Oseq -> Dum.Oseq
data Dum.Set a_a1Uh
  = Dum.MkSet [a_a1Uh]
  deriving (Eq)
type Dum.Bag a_a1Ug = [a_a1Ug]
data Dum.Flag
  = Dum.Typecheck |
    Dum.Simp |
    Dum.NoCaseOpt |
    Dum.ShowHExpr |
    Dum.NoPretty |
    Dum.NoFormat |
    Dum.NoBaraki |
    Dum.SimpleInv |
    Dum.PolyLim Int |
    Dum.MonoLim Int |
    Dum.ForceAll |
    Dum.DryRun |
    Dum.LowerLim Int |
    Dum.UpperLim Int |
    Dum.ScaleUp Int
  deriving (Eq)
data Dum.ExceptionInt a_a1Uf
  = Dum.MkExInt Int [a_a1Uf]
  deriving (Eq, Ord, Show)
type Dum.Naam = [Char]
data Dum.TDefExpr
  = Dum.TDefVar Dum.Naam | Dum.TDefCons Dum.Naam [Dum.TDefExpr]
  deriving (Eq)
type Dum.ConstrAlt = (Dum.Naam, [Dum.TDefExpr])
type Dum.TypeDef = (Dum.Naam, [Dum.Naam], [Dum.ConstrAlt])
data Dum.CExprP a_a1Ub
  = Dum.EVar Dum.Naam |
    Dum.ENum Int |
    Dum.EConstr Dum.Naam |
    Dum.EAp (Dum.CExprP a_a1Ub) (Dum.CExprP a_a1Ub) |
    Dum.ELet Bool [(a_a1Ub, Dum.CExprP a_a1Ub)] (Dum.CExprP a_a1Ub) |
    Dum.ECase (Dum.CExprP a_a1Ub) [(Dum.Naam, Dum.AlterP a_a1Ub)] |
    Dum.ELam [a_a1Ub] (Dum.CExprP a_a1Ub)
  deriving (Eq)
type Dum.AlterP a_a1Ue = ([a_a1Ue], Dum.CExprP a_a1Ue)
type Dum.CExpr = Dum.CExprP Dum.Naam
type Dum.AtomicProgram = ([Dum.TypeDef], Dum.CExpr)
type Dum.ScValueP a_a1Ud = ([a_a1Ud], Dum.CExprP a_a1Ud)
type Dum.CoreProgramP a_a1Uc =
    ([Dum.TypeDef], [(Dum.Naam, Dum.ScValueP a_a1Uc)])
type Dum.CoreProgram = Dum.CoreProgramP Dum.Naam
type Dum.ScValue = Dum.ScValueP Dum.Naam
type Dum.Alter = Dum.AlterP Dum.Naam
type Dum.AnnAlt a_a1U3 b_a1U4 =
    (Dum.Naam, ([a_a1U3], Dum.AnnExpr a_a1U3 b_a1U4))
type Dum.AnnExpr a_a1U9 b_a1Ua =
    (b_a1Ua, Dum.AnnExpr' a_a1U9 b_a1Ua)
data Dum.AnnExpr' a_a1U7 b_a1U8
  = Dum.AVar Dum.Naam |
    Dum.ANum Int |
    Dum.AConstr Dum.Naam |
    Dum.AAp (Dum.AnnExpr a_a1U7 b_a1U8) (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ALet Bool [Dum.AnnDefn a_a1U7 b_a1U8] (Dum.AnnExpr a_a1U7 b_a1U8) |
    Dum.ACase (Dum.AnnExpr a_a1U7 b_a1U8) [Dum.AnnAlt a_a1U7 b_a1U8] |
    Dum.ALam [a_a1U7] (Dum.AnnExpr a_a1U7 b_a1U8)
  deriving (Eq)
type Dum.AnnDefn a_a1U5 b_a1U6 =
    (a_a1U5, Dum.AnnExpr a_a1U5 b_a1U6)
type Dum.AnnProgram a_a1U1 b_a1U2 =
    [(Dum.Naam, [a_a1U1], Dum.AnnExpr a_a1U1 b_a1U2)]
data Dum.Eqn
  = Dum.EqnNVC Dum.Naam (Dum.Set Dum.Naam) (Dum.Set Dum.Naam)
  deriving (Eq)
type Dum.TVName = ([Int], [Int])
type Dum.Message = [Char]
data Dum.TExpr
  = Dum.TVar Dum.TVName |
    Dum.TArr Dum.TExpr Dum.TExpr |
    Dum.TCons [Char] [Dum.TExpr]
  deriving (Eq)
data Dum.TypeScheme
  = Dum.Scheme [Dum.TVName] Dum.TExpr
  deriving (Eq)
type Dum.Subst = Dum.AList Dum.TVName Dum.TExpr
type Dum.TcTypeEnv = Dum.AList Dum.Naam Dum.TypeScheme
type Dum.TypeEnv = Dum.AList Dum.Naam Dum.TExpr
type Dum.TypeNameSupply = Dum.TVName
type Dum.TypeInfo =
    (Dum.Subst, Dum.TExpr, Dum.AnnExpr Dum.Naam Dum.TExpr)
type Dum.TypeDependancy = Dum.DefnGroup Dum.Naam
data Dum.Domain
  = Dum.Two |
    Dum.Lift1 [Dum.Domain] |
    Dum.Lift2 [Dum.Domain] |
    Dum.Func [Dum.Domain] Dum.Domain
  deriving (Eq, Ord, Show, Read)
type Dum.OneFuncSize = (Int, [Dum.Domain])
type Dum.Sequence = ([[Dum.OneFuncSize]], [[Dum.OneFuncSize]])
type Dum.DInt = (Dum.Domain, Int)
type Dum.DomainInt = Dum.ExceptionInt Dum.Domain
data Dum.Rep
  = Dum.RepTwo Dum.Frontier |
    Dum.Rep1 Dum.Frontier [Dum.Rep] |
    Dum.Rep2 Dum.Frontier Dum.Frontier [Dum.Rep]
  deriving (Eq, Ord, Show)
data Dum.Frontier
  = Dum.Min1Max0 Int [Dum.FrontierElem] [Dum.FrontierElem]
  deriving (Eq, Ord, Show)
data Dum.FrontierElem
  = Dum.MkFrel [Dum.Route]
  deriving (Eq, Ord, Show)
data Dum.Route
  = Dum.Zero |
    Dum.One |
    Dum.Stop1 |
    Dum.Up1 [Dum.Route] |
    Dum.Stop2 |
    Dum.Up2 |
    Dum.UpUp2 [Dum.Route] |
    Dum.Rep Dum.Rep
  deriving (Eq, Ord, Show)
type Dum.Point = (Dum.Domain, Dum.Route)
data Dum.DExpr
  = Dum.DXTwo |
    Dum.DXLift1 [Dum.DExpr] |
    Dum.DXLift2 [Dum.DExpr] |
    Dum.DXFunc [Dum.DExpr] Dum.DExpr |
    Dum.DXVar String
  deriving (Eq)
type Dum.RSubst = Dum.AList String Dum.Route
type Dum.DSubst = Dum.AList String Dum.Domain
type Dum.DRRSubst =
    Dum.AList String (Dum.Domain, Dum.Route, Dum.Route)
type Dum.DExprEnv = Dum.AList String Dum.DExpr
data Dum.ConstrElem
  = Dum.ConstrRec | Dum.ConstrVar Int
  deriving (Eq, Ord, Show)
data Dum.ACMode
  = Dum.Safe | Dum.Live
  deriving (Eq)
type Dum.MemoList = Dum.AList [Dum.Route] Dum.Route
data Dum.AppInfo
  = Dum.A2 |
    Dum.ALo1 |
    Dum.AHi1 Int Int Dum.Domain |
    Dum.ALo2 |
    Dum.AMid2 |
    Dum.AHi2 Int Int Dum.Domain
  deriving (Eq)
data Dum.HExpr a_a1x6
  = Dum.HApp (Dum.HExpr a_a1x6) (Dum.HExpr a_a1x6) |
    Dum.HVAp (Dum.HExpr a_a1x6) [Dum.HExpr a_a1x6] |
    Dum.HLam [a_a1x6] (Dum.HExpr a_a1x6) |
    Dum.HVar a_a1x6 |
    Dum.HMeet [Dum.HExpr a_a1x6] |
    Dum.HPoint Dum.Route |
    Dum.HTable (Dum.AList Dum.Route (Dum.HExpr a_a1x6))
  deriving (Eq, Show)
data Dum.SAInfo
  = Dum.SAResult String Dum.Domain Dum.Route |
    Dum.SASearch Dum.ACMode String Int Int |
    Dum.SASizes String [Dum.OneFuncSize] [Dum.OneFuncSize] |
    Dum.SAHExpr String (Dum.HExpr Dum.Naam) |
    Dum.SASL [Dum.Route] [Dum.Route] |
    Dum.SAGiveUp [String]
type Dum.PrPoint = [Int]
type Dum.PrDomain = [Dum.PrPoint]
type Dum.Token = (Int, [Char])
data Dum.PResult a_a1x5
  = Dum.PFail [Dum.Token] | Dum.POk a_a1x5 [Dum.Token]
  deriving (Eq)
type Dum.Parser a_a1x4 = [Dum.Token] -> Dum.PResult a_a1x4
data Dum.PartialExpr
  = Dum.NoOp | Dum.FoundOp Dum.Naam Dum.CExpr
  deriving (Eq)
type Dum.StaticComponent =
    (Dum.DExprEnv, Dum.DSubst, Dum.AList Dum.Naam [Dum.ConstrElem],
     Dum.AList Dum.Naam [Dum.Naam], [Dum.Flag],
     (Int, Int, Int, Int, Int), Dum.AList Dum.Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) =>
         Num (Dum.ExceptionInt a_a1Ur) where
  (Dum.MkExInt i1_a1Us xs1_a1Ut) + (Dum.MkExInt i2_a1Uu xs2_a1Uv)
    = Dum.MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
  (Dum.MkExInt i1_a1Uw xs1_a1Ux) * (Dum.MkExInt i2_a1Uy xs2_a1Uz)
    = Dum.MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)


["bdDefaultSettings","bdDryRunSettings","i1_a1Us","xs1_a1Ut","MkExInt i1_a1Us xs1_a1Ut","(MkExInt i1_a1Us xs1_a1Ut)","i2_a1Uu","xs2_a1Uv","MkExInt i2_a1Uu xs2_a1Uv","(MkExInt i2_a1Uu xs2_a1Uv)","i1_a1Uw","xs1_a1Ux","MkExInt i1_a1Uw xs1_a1Ux","(MkExInt i1_a1Uw xs1_a1Ux)","i2_a1Uy","xs2_a1Uz","MkExInt i2_a1Uy xs2_a1Uz","(MkExInt i2_a1Uy xs2_a1Uz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm
import Asb_routs
import Rhs_Asb_routs
import Jcb_method
import Chl_method
import Tol_cal
bdDefaultSettings
  = [PolyLim 10000, MonoLim 10000, LowerLim 0, UpperLim 1000000,
     ScaleUp 20]
bdDryRunSettings
  = [NoBaraki, LowerLim 0, UpperLim 0, PolyLim 1, MonoLim 1,
     ScaleUp 20]

type AList a_a1Up b_a1Uq = [(a_a1Up, b_a1Uq)]

type DefnGroup a_a1Uo = [(Bool, [a_a1Uo])]

type ST a_a1Um b_a1Un = b_a1Un -> (a_a1Um, b_a1Un)

data ATree a_a1Uk b_a1Ul = ALeaf
                         | ABranch (ATree a_a1Uk b_a1Ul) a_a1Uk b_a1Ul (ATree a_a1Uk b_a1Ul)
                                   Int
                         deriving Eq

data Reply a_a1Ui b_a1Uj = Ok a_a1Ui
                         | Fail b_a1Uj
                         deriving Eq

type NameSupply = Int

type Oseq = Int -> Int -> [Char]

type Iseq = Oseq -> Oseq

data Set a_a1Uh = MkSet [a_a1Uh]
                deriving Eq

type Bag a_a1Ug = [a_a1Ug]

data Flag = Typecheck
          | Simp
          | NoCaseOpt
          | ShowHExpr
          | NoPretty
          | NoFormat
          | NoBaraki
          | SimpleInv
          | PolyLim Int
          | MonoLim Int
          | ForceAll
          | DryRun
          | LowerLim Int
          | UpperLim Int
          | ScaleUp Int
          deriving Eq

data ExceptionInt a_a1Uf = MkExInt Int [a_a1Uf]
                         deriving (Eq, Ord, Show)

type Naam = [Char]

data TDefExpr = TDefVar Naam
              | TDefCons Naam [TDefExpr]
              deriving Eq

type ConstrAlt = (Naam, [TDefExpr])

type TypeDef = (Naam, [Naam], [ConstrAlt])

data CExprP a_a1Ub = EVar Naam
                   | ENum Int
                   | EConstr Naam
                   | EAp (CExprP a_a1Ub) (CExprP a_a1Ub)
                   | ELet Bool [(a_a1Ub, CExprP a_a1Ub)] (CExprP a_a1Ub)
                   | ECase (CExprP a_a1Ub) [(Naam, AlterP a_a1Ub)]
                   | ELam [a_a1Ub] (CExprP a_a1Ub)
                   deriving Eq

type AlterP a_a1Ue = ([a_a1Ue], CExprP a_a1Ue)

type CExpr = CExprP Naam

type AtomicProgram = ([TypeDef], CExpr)

type ScValueP a_a1Ud = ([a_a1Ud], CExprP a_a1Ud)

type CoreProgramP a_a1Uc = ([TypeDef], [(Naam, ScValueP a_a1Uc)])

type CoreProgram = CoreProgramP Naam

type ScValue = ScValueP Naam

type Alter = AlterP Naam

type AnnAlt a_a1U3 b_a1U4 =
     (Naam, ([a_a1U3], AnnExpr a_a1U3 b_a1U4))

type AnnExpr a_a1U9 b_a1Ua = (b_a1Ua, AnnExpr' a_a1U9 b_a1Ua)

data AnnExpr' a_a1U7 b_a1U8 = AVar Naam
                            | ANum Int
                            | AConstr Naam
                            | AAp (AnnExpr a_a1U7 b_a1U8) (AnnExpr a_a1U7 b_a1U8)
                            | ALet Bool [AnnDefn a_a1U7 b_a1U8] (AnnExpr a_a1U7 b_a1U8)
                            | ACase (AnnExpr a_a1U7 b_a1U8) [AnnAlt a_a1U7 b_a1U8]
                            | ALam [a_a1U7] (AnnExpr a_a1U7 b_a1U8)
                            deriving Eq

type AnnDefn a_a1U5 b_a1U6 = (a_a1U5, AnnExpr a_a1U5 b_a1U6)

type AnnProgram a_a1U1 b_a1U2 =
     [(Naam, [a_a1U1], AnnExpr a_a1U1 b_a1U2)]

data Eqn = EqnNVC Naam (Set Naam) (Set Naam)
         deriving Eq

type TVName = ([Int], [Int])

type Message = [Char]

data TExpr = TVar TVName
           | TArr TExpr TExpr
           | TCons [Char] [TExpr]
           deriving Eq

data TypeScheme = Scheme [TVName] TExpr
                deriving Eq

type Subst = AList TVName TExpr

type TcTypeEnv = AList Naam TypeScheme

type TypeEnv = AList Naam TExpr

type TypeNameSupply = TVName

type TypeInfo = (Subst, TExpr, AnnExpr Naam TExpr)

type TypeDependancy = DefnGroup Naam

data Domain = Two
            | Lift1 [Domain]
            | Lift2 [Domain]
            | Func [Domain] Domain
            deriving (Eq, Ord, Show, Read)

type OneFuncSize = (Int, [Domain])

type Sequence = ([[OneFuncSize]], [[OneFuncSize]])

type DInt = (Domain, Int)

type DomainInt = ExceptionInt Domain

data Rep = RepTwo Frontier
         | Rep1 Frontier [Rep]
         | Rep2 Frontier Frontier [Rep]
         deriving (Eq, Ord, Show)

data Frontier = Min1Max0 Int [FrontierElem] [FrontierElem]
              deriving (Eq, Ord, Show)

data FrontierElem = MkFrel [Route]
                  deriving (Eq, Ord, Show)

data Route = Zero
           | One
           | Stop1
           | Up1 [Route]
           | Stop2
           | Up2
           | UpUp2 [Route]
           | Rep Rep
           deriving (Eq, Ord, Show)

type Point = (Domain, Route)

data DExpr = DXTwo
           | DXLift1 [DExpr]
           | DXLift2 [DExpr]
           | DXFunc [DExpr] DExpr
           | DXVar String
           deriving Eq

type RSubst = AList String Route

type DSubst = AList String Domain

type DRRSubst = AList String (Domain, Route, Route)

type DExprEnv = AList String DExpr

data ConstrElem = ConstrRec
                | ConstrVar Int
                deriving (Eq, Ord, Show)

data ACMode = Safe
            | Live
            deriving Eq

type MemoList = AList [Route] Route

data AppInfo = A2
             | ALo1
             | AHi1 Int Int Domain
             | ALo2
             | AMid2
             | AHi2 Int Int Domain
             deriving Eq

data HExpr a_a1x6 = HApp (HExpr a_a1x6) (HExpr a_a1x6)
                  | HVAp (HExpr a_a1x6) [HExpr a_a1x6]
                  | HLam [a_a1x6] (HExpr a_a1x6)
                  | HVar a_a1x6
                  | HMeet [HExpr a_a1x6]
                  | HPoint Route
                  | HTable (AList Route (HExpr a_a1x6))
                  deriving (Eq, Show)

data SAInfo = SAResult String Domain Route
            | SASearch ACMode String Int Int
            | SASizes String [OneFuncSize] [OneFuncSize]
            | SAHExpr String (HExpr Naam)
            | SASL [Route] [Route]
            | SAGiveUp [String]

type PrPoint = [Int]

type PrDomain = [PrPoint]

type Token = (Int, [Char])

data PResult a_a1x5 = PFail [Token]
                    | POk a_a1x5 [Token]
                    deriving Eq

type Parser a_a1x4 = [Token] -> PResult a_a1x4

data PartialExpr = NoOp
                 | FoundOp Naam CExpr
                 deriving Eq

type StaticComponent =
     (DExprEnv, DSubst, AList Naam [ConstrElem], AList Naam [Naam],
      [Flag], (Int, Int, Int, Int, Int), AList Domain Int)

instance (Show a_a1Ur, Ord a_a1Ur) => Num (ExceptionInt a_a1Ur)
         where
        (MkExInt i1_a1Us xs1_a1Ut) + (MkExInt i2_a1Uu xs2_a1Uv)
          = MkExInt (i1_a1Us + i2_a1Uu) (xs1_a1Ut ++ xs2_a1Uv)
        (MkExInt i1_a1Uw xs1_a1Ux) * (MkExInt i2_a1Uy xs2_a1Uz)
          = MkExInt (i1_a1Uw * i2_a1Uy) (xs1_a1Ux ++ xs2_a1Uz)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 3 `Dum.andAnd`

Dum.andAnd a_aGK b_aGL
  = if a_aGK then
        if b_aGL then True else error "andAnd: 2nd argument not True"
    else
        error "andAnd: first argument not True\n"
Dum.pack_obj obj_aHo = Dum.Norm_pack (Dum.normal obj_aHo) obj_aHo
Dum.normalize_obj (Dum.Norm_pack b_aHp _) = b_aHp
Dum.retrieve_obj (Dum.Norm_pack _ obj_aHq) = obj_aHq

data Dum.Norm_able a_aGJ = Dum.Norm_pack Bool a_aGJ
class Dum.Normal a_azE where
  Dum.normal :: a_azE -> Bool

instance Dum.Normal Double where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Float where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Int where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Bool where
  Dum.normal True = True
  Dum.normal _ = True
instance (Dum.Normal a_aHr,
          Dum.Normal b_aHs,
          Dum.Normal c_aHt,
          Dum.Normal d_aHu,
          Dum.Normal e_aHv,
          Dum.Normal f_aHw) =>
         Dum.Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
  Dum.normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
    = Dum.normal x_aHx
      `Dum.andAnd`
        Dum.normal y_aHy
        `Dum.andAnd`
          Dum.normal z_aHz
          `Dum.andAnd`
            Dum.normal u_aHA
            `Dum.andAnd` Dum.normal v_aHB `Dum.andAnd` Dum.normal w_aHC
instance (Dum.Normal a_aHD, Dum.Normal b_aHE, Dum.Normal c_aHF) =>
         Dum.Normal (a_aHD, b_aHE, c_aHF) where
  Dum.normal (x_aHG, y_aHH, z_aHI)
    = Dum.normal x_aHG
      `Dum.andAnd` Dum.normal y_aHH `Dum.andAnd` Dum.normal z_aHI
instance (Dum.Normal a_aHJ, Dum.Normal b_aHK) =>
         Dum.Normal (a_aHJ, b_aHK) where
  Dum.normal (x_aHL, y_aHM)
    = Dum.normal x_aHL `Dum.andAnd` Dum.normal y_aHM
instance (Dum.Normal a_aHN) => Dum.Normal [a_aHN] where
  Dum.normal (x_aHO : xs_aHP)
    = Dum.normal x_aHO `Dum.andAnd` Dum.normal xs_aHP
  Dum.normal _ = True


["a_aGK","b_aGL","obj_aHo","b_aHp","_","Norm_pack b_aHp _","(Norm_pack b_aHp _)","_","obj_aHq","Norm_pack _ obj_aHq","(Norm_pack _ obj_aHq)","0","_","0","_","0","_","True","_","x_aHx","y_aHy","z_aHz","u_aHA","v_aHB","w_aHC","(x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)","x_aHG","y_aHH","z_aHI","(x_aHG, y_aHH, z_aHI)","x_aHL","y_aHM","(x_aHL, y_aHM)","x_aHO","xs_aHP","x_aHO : xs_aHP","(x_aHO : xs_aHP)","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where

infixr 3 `andAnd`
andAnd a_aGK b_aGL
  = if a_aGK then
      if b_aGL then True else error "andAnd: 2nd argument not True" else
      error "andAnd: first argument not True\n"
pack_obj obj_aHo = Norm_pack (normal obj_aHo) obj_aHo
normalize_obj (Norm_pack b_aHp _) = b_aHp
retrieve_obj (Norm_pack _ obj_aHq) = obj_aHq

data Norm_able a_aGJ = Norm_pack Bool a_aGJ

class Normal a_azE where
        normal :: a_azE -> Bool

instance Normal Double where
        normal 0 = True
        normal _ = True

instance Normal Float where
        normal 0 = True
        normal _ = True

instance Normal Int where
        normal 0 = True
        normal _ = True

instance Normal Bool where
        normal True = True
        normal _ = True

instance (Normal a_aHr, Normal b_aHs, Normal c_aHt, Normal d_aHu,
          Normal e_aHv, Normal f_aHw) =>
         Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
        normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
          = normal x_aHx `andAnd` normal y_aHy `andAnd` normal z_aHz `andAnd`
              normal u_aHA
              `andAnd` normal v_aHB
              `andAnd` normal w_aHC

instance (Normal a_aHD, Normal b_aHE, Normal c_aHF) => Normal
         (a_aHD, b_aHE, c_aHF) where
        normal (x_aHG, y_aHH, z_aHI)
          = normal x_aHG `andAnd` normal y_aHH `andAnd` normal z_aHI

instance (Normal a_aHJ, Normal b_aHK) => Normal (a_aHJ, b_aHK)
         where
        normal (x_aHL, y_aHM) = normal x_aHL `andAnd` normal y_aHM

instance (Normal a_aHN) => Normal [a_aHN] where
        normal (x_aHO : xs_aHP) = normal x_aHO `andAnd` normal xs_aHP
        normal _ = True
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 3 `Dum.andAnd`

Dum.andAnd a_aGK b_aGL
  = if a_aGK then
        if b_aGL then True else error "andAnd: 2nd argument not True"
    else
        error "andAnd: first argument not True\n"
Dum.pack_obj obj_aHo = Dum.Norm_pack (Dum.normal obj_aHo) obj_aHo
Dum.normalize_obj (Dum.Norm_pack b_aHp _) = b_aHp
Dum.retrieve_obj (Dum.Norm_pack _ obj_aHq) = obj_aHq

data Dum.Norm_able a_aGJ = Dum.Norm_pack Bool a_aGJ
class Dum.Normal a_azE where
  Dum.normal :: a_azE -> Bool

instance Dum.Normal Double where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Float where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Int where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Bool where
  Dum.normal True = True
  Dum.normal _ = True
instance (Dum.Normal a_aHr,
          Dum.Normal b_aHs,
          Dum.Normal c_aHt,
          Dum.Normal d_aHu,
          Dum.Normal e_aHv,
          Dum.Normal f_aHw) =>
         Dum.Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
  Dum.normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
    = Dum.normal x_aHx
      `Dum.andAnd`
        Dum.normal y_aHy
        `Dum.andAnd`
          Dum.normal z_aHz
          `Dum.andAnd`
            Dum.normal u_aHA
            `Dum.andAnd` Dum.normal v_aHB `Dum.andAnd` Dum.normal w_aHC
instance (Dum.Normal a_aHD, Dum.Normal b_aHE, Dum.Normal c_aHF) =>
         Dum.Normal (a_aHD, b_aHE, c_aHF) where
  Dum.normal (x_aHG, y_aHH, z_aHI)
    = Dum.normal x_aHG
      `Dum.andAnd` Dum.normal y_aHH `Dum.andAnd` Dum.normal z_aHI
instance (Dum.Normal a_aHJ, Dum.Normal b_aHK) =>
         Dum.Normal (a_aHJ, b_aHK) where
  Dum.normal (x_aHL, y_aHM)
    = Dum.normal x_aHL `Dum.andAnd` Dum.normal y_aHM
instance (Dum.Normal a_aHN) => Dum.Normal [a_aHN] where
  Dum.normal (x_aHO : xs_aHP)
    = Dum.normal x_aHO `Dum.andAnd` Dum.normal xs_aHP
  Dum.normal _ = True


["a_aGK","b_aGL","obj_aHo","b_aHp","_","Norm_pack b_aHp _","(Norm_pack b_aHp _)","_","obj_aHq","Norm_pack _ obj_aHq","(Norm_pack _ obj_aHq)","0","_","0","_","0","_","True","_","x_aHx","y_aHy","z_aHz","u_aHA","v_aHB","w_aHC","(x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)","x_aHG","y_aHH","z_aHI","(x_aHG, y_aHH, z_aHI)","x_aHL","y_aHM","(x_aHL, y_aHM)","x_aHO","xs_aHP","x_aHO : xs_aHP","(x_aHO : xs_aHP)","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm
import Data.Ix

infixr 3 `andAnd`
andAnd a_aGK b_aGL
  = if a_aGK then
      if b_aGL then True else error "andAnd: 2nd argument not True" else
      error "andAnd: first argument not True\n"
pack_obj obj_aHo = Norm_pack (normal obj_aHo) obj_aHo
normalize_obj (Norm_pack b_aHp _) = b_aHp
retrieve_obj (Norm_pack _ obj_aHq) = obj_aHq

data Norm_able a_aGJ = Norm_pack Bool a_aGJ

class Normal a_azE where
        normal :: a_azE -> Bool

instance Normal Double where
        normal 0 = True
        normal _ = True

instance Normal Float where
        normal 0 = True
        normal _ = True

instance Normal Int where
        normal 0 = True
        normal _ = True

instance Normal Bool where
        normal True = True
        normal _ = True

instance (Normal a_aHr, Normal b_aHs, Normal c_aHt, Normal d_aHu,
          Normal e_aHv, Normal f_aHw) =>
         Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
        normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
          = normal x_aHx `andAnd` normal y_aHy `andAnd` normal z_aHz `andAnd`
              normal u_aHA
              `andAnd` normal v_aHB
              `andAnd` normal w_aHC

instance (Normal a_aHD, Normal b_aHE, Normal c_aHF) => Normal
         (a_aHD, b_aHE, c_aHF) where
        normal (x_aHG, y_aHH, z_aHI)
          = normal x_aHG `andAnd` normal y_aHH `andAnd` normal z_aHI

instance (Normal a_aHJ, Normal b_aHK) => Normal (a_aHJ, b_aHK)
         where
        normal (x_aHL, y_aHM) = normal x_aHL `andAnd` normal y_aHM

instance (Normal a_aHN) => Normal [a_aHN] where
        normal (x_aHO : xs_aHP) = normal x_aHO `andAnd` normal xs_aHP
        normal _ = True
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 3 `Dum.andAnd`

Dum.andAnd a_aGK b_aGL
  = if a_aGK then
        if b_aGL then True else error "andAnd: 2nd argument not True"
    else
        error "andAnd: first argument not True\n"
Dum.pack_obj obj_aHo = Dum.Norm_pack (Dum.normal obj_aHo) obj_aHo
Dum.normalize_obj (Dum.Norm_pack b_aHp _) = b_aHp
Dum.retrieve_obj (Dum.Norm_pack _ obj_aHq) = obj_aHq

data Dum.Norm_able a_aGJ = Dum.Norm_pack Bool a_aGJ
class Dum.Normal a_azE where
  Dum.normal :: a_azE -> Bool

instance Dum.Normal Double where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Float where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Int where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Bool where
  Dum.normal True = True
  Dum.normal _ = True
instance (Dum.Normal a_aHr,
          Dum.Normal b_aHs,
          Dum.Normal c_aHt,
          Dum.Normal d_aHu,
          Dum.Normal e_aHv,
          Dum.Normal f_aHw) =>
         Dum.Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
  Dum.normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
    = Dum.normal x_aHx
      `Dum.andAnd`
        Dum.normal y_aHy
        `Dum.andAnd`
          Dum.normal z_aHz
          `Dum.andAnd`
            Dum.normal u_aHA
            `Dum.andAnd` Dum.normal v_aHB `Dum.andAnd` Dum.normal w_aHC
instance (Dum.Normal a_aHD, Dum.Normal b_aHE, Dum.Normal c_aHF) =>
         Dum.Normal (a_aHD, b_aHE, c_aHF) where
  Dum.normal (x_aHG, y_aHH, z_aHI)
    = Dum.normal x_aHG
      `Dum.andAnd` Dum.normal y_aHH `Dum.andAnd` Dum.normal z_aHI
instance (Dum.Normal a_aHJ, Dum.Normal b_aHK) =>
         Dum.Normal (a_aHJ, b_aHK) where
  Dum.normal (x_aHL, y_aHM)
    = Dum.normal x_aHL `Dum.andAnd` Dum.normal y_aHM
instance (Dum.Normal a_aHN) => Dum.Normal [a_aHN] where
  Dum.normal (x_aHO : xs_aHP)
    = Dum.normal x_aHO `Dum.andAnd` Dum.normal xs_aHP
  Dum.normal _ = True


["a_aGK","b_aGL","obj_aHo","b_aHp","_","Norm_pack b_aHp _","(Norm_pack b_aHp _)","_","obj_aHq","Norm_pack _ obj_aHq","(Norm_pack _ obj_aHq)","0","_","0","_","0","_","True","_","x_aHx","y_aHy","z_aHz","u_aHA","v_aHB","w_aHC","(x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)","x_aHG","y_aHH","z_aHI","(x_aHG, y_aHH, z_aHI)","x_aHL","y_aHM","(x_aHL, y_aHM)","x_aHO","xs_aHP","x_aHO : xs_aHP","(x_aHO : xs_aHP)","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm

infixr 3 `andAnd`
andAnd a_aGK b_aGL
  = if a_aGK then
      if b_aGL then True else error "andAnd: 2nd argument not True" else
      error "andAnd: first argument not True\n"
pack_obj obj_aHo = Norm_pack (normal obj_aHo) obj_aHo
normalize_obj (Norm_pack b_aHp _) = b_aHp
retrieve_obj (Norm_pack _ obj_aHq) = obj_aHq

data Norm_able a_aGJ = Norm_pack Bool a_aGJ

class Normal a_azE where
        normal :: a_azE -> Bool

instance Normal Double where
        normal 0 = True
        normal _ = True

instance Normal Float where
        normal 0 = True
        normal _ = True

instance Normal Int where
        normal 0 = True
        normal _ = True

instance Normal Bool where
        normal True = True
        normal _ = True

instance (Normal a_aHr, Normal b_aHs, Normal c_aHt, Normal d_aHu,
          Normal e_aHv, Normal f_aHw) =>
         Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
        normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
          = normal x_aHx `andAnd` normal y_aHy `andAnd` normal z_aHz `andAnd`
              normal u_aHA
              `andAnd` normal v_aHB
              `andAnd` normal w_aHC

instance (Normal a_aHD, Normal b_aHE, Normal c_aHF) => Normal
         (a_aHD, b_aHE, c_aHF) where
        normal (x_aHG, y_aHH, z_aHI)
          = normal x_aHG `andAnd` normal y_aHH `andAnd` normal z_aHI

instance (Normal a_aHJ, Normal b_aHK) => Normal (a_aHJ, b_aHK)
         where
        normal (x_aHL, y_aHM) = normal x_aHL `andAnd` normal y_aHM

instance (Normal a_aHN) => Normal [a_aHN] where
        normal (x_aHO : xs_aHP) = normal x_aHO `andAnd` normal xs_aHP
        normal _ = True
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 3 `Dum.andAnd`

Dum.andAnd a_aGK b_aGL
  = if a_aGK then
        if b_aGL then True else error "andAnd: 2nd argument not True"
    else
        error "andAnd: first argument not True\n"
Dum.pack_obj obj_aHo = Dum.Norm_pack (Dum.normal obj_aHo) obj_aHo
Dum.normalize_obj (Dum.Norm_pack b_aHp _) = b_aHp
Dum.retrieve_obj (Dum.Norm_pack _ obj_aHq) = obj_aHq

data Dum.Norm_able a_aGJ = Dum.Norm_pack Bool a_aGJ
class Dum.Normal a_azE where
  Dum.normal :: a_azE -> Bool

instance Dum.Normal Double where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Float where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Int where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Bool where
  Dum.normal True = True
  Dum.normal _ = True
instance (Dum.Normal a_aHr,
          Dum.Normal b_aHs,
          Dum.Normal c_aHt,
          Dum.Normal d_aHu,
          Dum.Normal e_aHv,
          Dum.Normal f_aHw) =>
         Dum.Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
  Dum.normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
    = Dum.normal x_aHx
      `Dum.andAnd`
        Dum.normal y_aHy
        `Dum.andAnd`
          Dum.normal z_aHz
          `Dum.andAnd`
            Dum.normal u_aHA
            `Dum.andAnd` Dum.normal v_aHB `Dum.andAnd` Dum.normal w_aHC
instance (Dum.Normal a_aHD, Dum.Normal b_aHE, Dum.Normal c_aHF) =>
         Dum.Normal (a_aHD, b_aHE, c_aHF) where
  Dum.normal (x_aHG, y_aHH, z_aHI)
    = Dum.normal x_aHG
      `Dum.andAnd` Dum.normal y_aHH `Dum.andAnd` Dum.normal z_aHI
instance (Dum.Normal a_aHJ, Dum.Normal b_aHK) =>
         Dum.Normal (a_aHJ, b_aHK) where
  Dum.normal (x_aHL, y_aHM)
    = Dum.normal x_aHL `Dum.andAnd` Dum.normal y_aHM
instance (Dum.Normal a_aHN) => Dum.Normal [a_aHN] where
  Dum.normal (x_aHO : xs_aHP)
    = Dum.normal x_aHO `Dum.andAnd` Dum.normal xs_aHP
  Dum.normal _ = True


["a_aGK","b_aGL","obj_aHo","b_aHp","_","Norm_pack b_aHp _","(Norm_pack b_aHp _)","_","obj_aHq","Norm_pack _ obj_aHq","(Norm_pack _ obj_aHq)","0","_","0","_","0","_","True","_","x_aHx","y_aHy","z_aHz","u_aHA","v_aHB","w_aHC","(x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)","x_aHG","y_aHH","z_aHI","(x_aHG, y_aHH, z_aHI)","x_aHL","y_aHM","(x_aHL, y_aHM)","x_aHO","xs_aHP","x_aHO : xs_aHP","(x_aHO : xs_aHP)","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm
import S_matrix
import C_matrix
import L_matrix
import Asb_routs
import Data.Ix

infixr 3 `andAnd`
andAnd a_aGK b_aGL
  = if a_aGK then
      if b_aGL then True else error "andAnd: 2nd argument not True" else
      error "andAnd: first argument not True\n"
pack_obj obj_aHo = Norm_pack (normal obj_aHo) obj_aHo
normalize_obj (Norm_pack b_aHp _) = b_aHp
retrieve_obj (Norm_pack _ obj_aHq) = obj_aHq

data Norm_able a_aGJ = Norm_pack Bool a_aGJ

class Normal a_azE where
        normal :: a_azE -> Bool

instance Normal Double where
        normal 0 = True
        normal _ = True

instance Normal Float where
        normal 0 = True
        normal _ = True

instance Normal Int where
        normal 0 = True
        normal _ = True

instance Normal Bool where
        normal True = True
        normal _ = True

instance (Normal a_aHr, Normal b_aHs, Normal c_aHt, Normal d_aHu,
          Normal e_aHv, Normal f_aHw) =>
         Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
        normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
          = normal x_aHx `andAnd` normal y_aHy `andAnd` normal z_aHz `andAnd`
              normal u_aHA
              `andAnd` normal v_aHB
              `andAnd` normal w_aHC

instance (Normal a_aHD, Normal b_aHE, Normal c_aHF) => Normal
         (a_aHD, b_aHE, c_aHF) where
        normal (x_aHG, y_aHH, z_aHI)
          = normal x_aHG `andAnd` normal y_aHH `andAnd` normal z_aHI

instance (Normal a_aHJ, Normal b_aHK) => Normal (a_aHJ, b_aHK)
         where
        normal (x_aHL, y_aHM) = normal x_aHL `andAnd` normal y_aHM

instance (Normal a_aHN) => Normal [a_aHN] where
        normal (x_aHO : xs_aHP) = normal x_aHO `andAnd` normal xs_aHP
        normal _ = True
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 3 `Dum.andAnd`

Dum.andAnd a_aGK b_aGL
  = if a_aGK then
        if b_aGL then True else error "andAnd: 2nd argument not True"
    else
        error "andAnd: first argument not True\n"
Dum.pack_obj obj_aHo = Dum.Norm_pack (Dum.normal obj_aHo) obj_aHo
Dum.normalize_obj (Dum.Norm_pack b_aHp _) = b_aHp
Dum.retrieve_obj (Dum.Norm_pack _ obj_aHq) = obj_aHq

data Dum.Norm_able a_aGJ = Dum.Norm_pack Bool a_aGJ
class Dum.Normal a_azE where
  Dum.normal :: a_azE -> Bool

instance Dum.Normal Double where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Float where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Int where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Bool where
  Dum.normal True = True
  Dum.normal _ = True
instance (Dum.Normal a_aHr,
          Dum.Normal b_aHs,
          Dum.Normal c_aHt,
          Dum.Normal d_aHu,
          Dum.Normal e_aHv,
          Dum.Normal f_aHw) =>
         Dum.Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
  Dum.normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
    = Dum.normal x_aHx
      `Dum.andAnd`
        Dum.normal y_aHy
        `Dum.andAnd`
          Dum.normal z_aHz
          `Dum.andAnd`
            Dum.normal u_aHA
            `Dum.andAnd` Dum.normal v_aHB `Dum.andAnd` Dum.normal w_aHC
instance (Dum.Normal a_aHD, Dum.Normal b_aHE, Dum.Normal c_aHF) =>
         Dum.Normal (a_aHD, b_aHE, c_aHF) where
  Dum.normal (x_aHG, y_aHH, z_aHI)
    = Dum.normal x_aHG
      `Dum.andAnd` Dum.normal y_aHH `Dum.andAnd` Dum.normal z_aHI
instance (Dum.Normal a_aHJ, Dum.Normal b_aHK) =>
         Dum.Normal (a_aHJ, b_aHK) where
  Dum.normal (x_aHL, y_aHM)
    = Dum.normal x_aHL `Dum.andAnd` Dum.normal y_aHM
instance (Dum.Normal a_aHN) => Dum.Normal [a_aHN] where
  Dum.normal (x_aHO : xs_aHP)
    = Dum.normal x_aHO `Dum.andAnd` Dum.normal xs_aHP
  Dum.normal _ = True


["a_aGK","b_aGL","obj_aHo","b_aHp","_","Norm_pack b_aHp _","(Norm_pack b_aHp _)","_","obj_aHq","Norm_pack _ obj_aHq","(Norm_pack _ obj_aHq)","0","_","0","_","0","_","True","_","x_aHx","y_aHy","z_aHz","u_aHA","v_aHB","w_aHC","(x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)","x_aHG","y_aHH","z_aHI","(x_aHG, y_aHH, z_aHI)","x_aHL","y_aHM","(x_aHL, y_aHM)","x_aHO","xs_aHP","x_aHO : xs_aHP","(x_aHO : xs_aHP)","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import S_Array
import Norm

infixr 3 `andAnd`
andAnd a_aGK b_aGL
  = if a_aGK then
      if b_aGL then True else error "andAnd: 2nd argument not True" else
      error "andAnd: first argument not True\n"
pack_obj obj_aHo = Norm_pack (normal obj_aHo) obj_aHo
normalize_obj (Norm_pack b_aHp _) = b_aHp
retrieve_obj (Norm_pack _ obj_aHq) = obj_aHq

data Norm_able a_aGJ = Norm_pack Bool a_aGJ

class Normal a_azE where
        normal :: a_azE -> Bool

instance Normal Double where
        normal 0 = True
        normal _ = True

instance Normal Float where
        normal 0 = True
        normal _ = True

instance Normal Int where
        normal 0 = True
        normal _ = True

instance Normal Bool where
        normal True = True
        normal _ = True

instance (Normal a_aHr, Normal b_aHs, Normal c_aHt, Normal d_aHu,
          Normal e_aHv, Normal f_aHw) =>
         Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
        normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
          = normal x_aHx `andAnd` normal y_aHy `andAnd` normal z_aHz `andAnd`
              normal u_aHA
              `andAnd` normal v_aHB
              `andAnd` normal w_aHC

instance (Normal a_aHD, Normal b_aHE, Normal c_aHF) => Normal
         (a_aHD, b_aHE, c_aHF) where
        normal (x_aHG, y_aHH, z_aHI)
          = normal x_aHG `andAnd` normal y_aHH `andAnd` normal z_aHI

instance (Normal a_aHJ, Normal b_aHK) => Normal (a_aHJ, b_aHK)
         where
        normal (x_aHL, y_aHM) = normal x_aHL `andAnd` normal y_aHM

instance (Normal a_aHN) => Normal [a_aHN] where
        normal (x_aHO : xs_aHP) = normal x_aHO `andAnd` normal xs_aHP
        normal _ = True
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 3 `Dum.andAnd`

Dum.andAnd a_aGK b_aGL
  = if a_aGK then
        if b_aGL then True else error "andAnd: 2nd argument not True"
    else
        error "andAnd: first argument not True\n"
Dum.pack_obj obj_aHo = Dum.Norm_pack (Dum.normal obj_aHo) obj_aHo
Dum.normalize_obj (Dum.Norm_pack b_aHp _) = b_aHp
Dum.retrieve_obj (Dum.Norm_pack _ obj_aHq) = obj_aHq

data Dum.Norm_able a_aGJ = Dum.Norm_pack Bool a_aGJ
class Dum.Normal a_azE where
  Dum.normal :: a_azE -> Bool

instance Dum.Normal Double where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Float where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Int where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Bool where
  Dum.normal True = True
  Dum.normal _ = True
instance (Dum.Normal a_aHr,
          Dum.Normal b_aHs,
          Dum.Normal c_aHt,
          Dum.Normal d_aHu,
          Dum.Normal e_aHv,
          Dum.Normal f_aHw) =>
         Dum.Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
  Dum.normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
    = Dum.normal x_aHx
      `Dum.andAnd`
        Dum.normal y_aHy
        `Dum.andAnd`
          Dum.normal z_aHz
          `Dum.andAnd`
            Dum.normal u_aHA
            `Dum.andAnd` Dum.normal v_aHB `Dum.andAnd` Dum.normal w_aHC
instance (Dum.Normal a_aHD, Dum.Normal b_aHE, Dum.Normal c_aHF) =>
         Dum.Normal (a_aHD, b_aHE, c_aHF) where
  Dum.normal (x_aHG, y_aHH, z_aHI)
    = Dum.normal x_aHG
      `Dum.andAnd` Dum.normal y_aHH `Dum.andAnd` Dum.normal z_aHI
instance (Dum.Normal a_aHJ, Dum.Normal b_aHK) =>
         Dum.Normal (a_aHJ, b_aHK) where
  Dum.normal (x_aHL, y_aHM)
    = Dum.normal x_aHL `Dum.andAnd` Dum.normal y_aHM
instance (Dum.Normal a_aHN) => Dum.Normal [a_aHN] where
  Dum.normal (x_aHO : xs_aHP)
    = Dum.normal x_aHO `Dum.andAnd` Dum.normal xs_aHP
  Dum.normal _ = True


["a_aGK","b_aGL","obj_aHo","b_aHp","_","Norm_pack b_aHp _","(Norm_pack b_aHp _)","_","obj_aHq","Norm_pack _ obj_aHq","(Norm_pack _ obj_aHq)","0","_","0","_","0","_","True","_","x_aHx","y_aHy","z_aHz","u_aHA","v_aHB","w_aHC","(x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)","x_aHG","y_aHH","z_aHI","(x_aHG, y_aHH, z_aHI)","x_aHL","y_aHM","(x_aHL, y_aHM)","x_aHO","xs_aHP","x_aHO : xs_aHP","(x_aHO : xs_aHP)","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm
import Data.List (nub, partition)

infixr 3 `andAnd`
andAnd a_aGK b_aGL
  = if a_aGK then
      if b_aGL then True else error "andAnd: 2nd argument not True" else
      error "andAnd: first argument not True\n"
pack_obj obj_aHo = Norm_pack (normal obj_aHo) obj_aHo
normalize_obj (Norm_pack b_aHp _) = b_aHp
retrieve_obj (Norm_pack _ obj_aHq) = obj_aHq

data Norm_able a_aGJ = Norm_pack Bool a_aGJ

class Normal a_azE where
        normal :: a_azE -> Bool

instance Normal Double where
        normal 0 = True
        normal _ = True

instance Normal Float where
        normal 0 = True
        normal _ = True

instance Normal Int where
        normal 0 = True
        normal _ = True

instance Normal Bool where
        normal True = True
        normal _ = True

instance (Normal a_aHr, Normal b_aHs, Normal c_aHt, Normal d_aHu,
          Normal e_aHv, Normal f_aHw) =>
         Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
        normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
          = normal x_aHx `andAnd` normal y_aHy `andAnd` normal z_aHz `andAnd`
              normal u_aHA
              `andAnd` normal v_aHB
              `andAnd` normal w_aHC

instance (Normal a_aHD, Normal b_aHE, Normal c_aHF) => Normal
         (a_aHD, b_aHE, c_aHF) where
        normal (x_aHG, y_aHH, z_aHI)
          = normal x_aHG `andAnd` normal y_aHH `andAnd` normal z_aHI

instance (Normal a_aHJ, Normal b_aHK) => Normal (a_aHJ, b_aHK)
         where
        normal (x_aHL, y_aHM) = normal x_aHL `andAnd` normal y_aHM

instance (Normal a_aHN) => Normal [a_aHN] where
        normal (x_aHO : xs_aHP) = normal x_aHO `andAnd` normal xs_aHP
        normal _ = True
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 3 `Dum.andAnd`

Dum.andAnd a_aGK b_aGL
  = if a_aGK then
        if b_aGL then True else error "andAnd: 2nd argument not True"
    else
        error "andAnd: first argument not True\n"
Dum.pack_obj obj_aHo = Dum.Norm_pack (Dum.normal obj_aHo) obj_aHo
Dum.normalize_obj (Dum.Norm_pack b_aHp _) = b_aHp
Dum.retrieve_obj (Dum.Norm_pack _ obj_aHq) = obj_aHq

data Dum.Norm_able a_aGJ = Dum.Norm_pack Bool a_aGJ
class Dum.Normal a_azE where
  Dum.normal :: a_azE -> Bool

instance Dum.Normal Double where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Float where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Int where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Bool where
  Dum.normal True = True
  Dum.normal _ = True
instance (Dum.Normal a_aHr,
          Dum.Normal b_aHs,
          Dum.Normal c_aHt,
          Dum.Normal d_aHu,
          Dum.Normal e_aHv,
          Dum.Normal f_aHw) =>
         Dum.Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
  Dum.normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
    = Dum.normal x_aHx
      `Dum.andAnd`
        Dum.normal y_aHy
        `Dum.andAnd`
          Dum.normal z_aHz
          `Dum.andAnd`
            Dum.normal u_aHA
            `Dum.andAnd` Dum.normal v_aHB `Dum.andAnd` Dum.normal w_aHC
instance (Dum.Normal a_aHD, Dum.Normal b_aHE, Dum.Normal c_aHF) =>
         Dum.Normal (a_aHD, b_aHE, c_aHF) where
  Dum.normal (x_aHG, y_aHH, z_aHI)
    = Dum.normal x_aHG
      `Dum.andAnd` Dum.normal y_aHH `Dum.andAnd` Dum.normal z_aHI
instance (Dum.Normal a_aHJ, Dum.Normal b_aHK) =>
         Dum.Normal (a_aHJ, b_aHK) where
  Dum.normal (x_aHL, y_aHM)
    = Dum.normal x_aHL `Dum.andAnd` Dum.normal y_aHM
instance (Dum.Normal a_aHN) => Dum.Normal [a_aHN] where
  Dum.normal (x_aHO : xs_aHP)
    = Dum.normal x_aHO `Dum.andAnd` Dum.normal xs_aHP
  Dum.normal _ = True


["a_aGK","b_aGL","obj_aHo","b_aHp","_","Norm_pack b_aHp _","(Norm_pack b_aHp _)","_","obj_aHq","Norm_pack _ obj_aHq","(Norm_pack _ obj_aHq)","0","_","0","_","0","_","True","_","x_aHx","y_aHy","z_aHz","u_aHA","v_aHB","w_aHC","(x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)","x_aHG","y_aHH","z_aHI","(x_aHG, y_aHH, z_aHI)","x_aHL","y_aHM","(x_aHL, y_aHM)","x_aHO","xs_aHP","x_aHO : xs_aHP","(x_aHO : xs_aHP)","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm
import Min_degree
import Data.Ix

infixr 3 `andAnd`
andAnd a_aGK b_aGL
  = if a_aGK then
      if b_aGL then True else error "andAnd: 2nd argument not True" else
      error "andAnd: first argument not True\n"
pack_obj obj_aHo = Norm_pack (normal obj_aHo) obj_aHo
normalize_obj (Norm_pack b_aHp _) = b_aHp
retrieve_obj (Norm_pack _ obj_aHq) = obj_aHq

data Norm_able a_aGJ = Norm_pack Bool a_aGJ

class Normal a_azE where
        normal :: a_azE -> Bool

instance Normal Double where
        normal 0 = True
        normal _ = True

instance Normal Float where
        normal 0 = True
        normal _ = True

instance Normal Int where
        normal 0 = True
        normal _ = True

instance Normal Bool where
        normal True = True
        normal _ = True

instance (Normal a_aHr, Normal b_aHs, Normal c_aHt, Normal d_aHu,
          Normal e_aHv, Normal f_aHw) =>
         Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
        normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
          = normal x_aHx `andAnd` normal y_aHy `andAnd` normal z_aHz `andAnd`
              normal u_aHA
              `andAnd` normal v_aHB
              `andAnd` normal w_aHC

instance (Normal a_aHD, Normal b_aHE, Normal c_aHF) => Normal
         (a_aHD, b_aHE, c_aHF) where
        normal (x_aHG, y_aHH, z_aHI)
          = normal x_aHG `andAnd` normal y_aHH `andAnd` normal z_aHI

instance (Normal a_aHJ, Normal b_aHK) => Normal (a_aHJ, b_aHK)
         where
        normal (x_aHL, y_aHM) = normal x_aHL `andAnd` normal y_aHM

instance (Normal a_aHN) => Normal [a_aHN] where
        normal (x_aHO : xs_aHP) = normal x_aHO `andAnd` normal xs_aHP
        normal _ = True
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 3 `Dum.andAnd`

Dum.andAnd a_aGK b_aGL
  = if a_aGK then
        if b_aGL then True else error "andAnd: 2nd argument not True"
    else
        error "andAnd: first argument not True\n"
Dum.pack_obj obj_aHo = Dum.Norm_pack (Dum.normal obj_aHo) obj_aHo
Dum.normalize_obj (Dum.Norm_pack b_aHp _) = b_aHp
Dum.retrieve_obj (Dum.Norm_pack _ obj_aHq) = obj_aHq

data Dum.Norm_able a_aGJ = Dum.Norm_pack Bool a_aGJ
class Dum.Normal a_azE where
  Dum.normal :: a_azE -> Bool

instance Dum.Normal Double where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Float where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Int where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Bool where
  Dum.normal True = True
  Dum.normal _ = True
instance (Dum.Normal a_aHr,
          Dum.Normal b_aHs,
          Dum.Normal c_aHt,
          Dum.Normal d_aHu,
          Dum.Normal e_aHv,
          Dum.Normal f_aHw) =>
         Dum.Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
  Dum.normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
    = Dum.normal x_aHx
      `Dum.andAnd`
        Dum.normal y_aHy
        `Dum.andAnd`
          Dum.normal z_aHz
          `Dum.andAnd`
            Dum.normal u_aHA
            `Dum.andAnd` Dum.normal v_aHB `Dum.andAnd` Dum.normal w_aHC
instance (Dum.Normal a_aHD, Dum.Normal b_aHE, Dum.Normal c_aHF) =>
         Dum.Normal (a_aHD, b_aHE, c_aHF) where
  Dum.normal (x_aHG, y_aHH, z_aHI)
    = Dum.normal x_aHG
      `Dum.andAnd` Dum.normal y_aHH `Dum.andAnd` Dum.normal z_aHI
instance (Dum.Normal a_aHJ, Dum.Normal b_aHK) =>
         Dum.Normal (a_aHJ, b_aHK) where
  Dum.normal (x_aHL, y_aHM)
    = Dum.normal x_aHL `Dum.andAnd` Dum.normal y_aHM
instance (Dum.Normal a_aHN) => Dum.Normal [a_aHN] where
  Dum.normal (x_aHO : xs_aHP)
    = Dum.normal x_aHO `Dum.andAnd` Dum.normal xs_aHP
  Dum.normal _ = True


["a_aGK","b_aGL","obj_aHo","b_aHp","_","Norm_pack b_aHp _","(Norm_pack b_aHp _)","_","obj_aHq","Norm_pack _ obj_aHq","(Norm_pack _ obj_aHq)","0","_","0","_","0","_","True","_","x_aHx","y_aHy","z_aHz","u_aHA","v_aHB","w_aHC","(x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)","x_aHG","y_aHH","z_aHI","(x_aHG, y_aHH, z_aHI)","x_aHL","y_aHM","(x_aHL, y_aHM)","x_aHO","xs_aHP","x_aHO : xs_aHP","(x_aHO : xs_aHP)","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm
import Asb_routs
import Data.Ix

infixr 3 `andAnd`
andAnd a_aGK b_aGL
  = if a_aGK then
      if b_aGL then True else error "andAnd: 2nd argument not True" else
      error "andAnd: first argument not True\n"
pack_obj obj_aHo = Norm_pack (normal obj_aHo) obj_aHo
normalize_obj (Norm_pack b_aHp _) = b_aHp
retrieve_obj (Norm_pack _ obj_aHq) = obj_aHq

data Norm_able a_aGJ = Norm_pack Bool a_aGJ

class Normal a_azE where
        normal :: a_azE -> Bool

instance Normal Double where
        normal 0 = True
        normal _ = True

instance Normal Float where
        normal 0 = True
        normal _ = True

instance Normal Int where
        normal 0 = True
        normal _ = True

instance Normal Bool where
        normal True = True
        normal _ = True

instance (Normal a_aHr, Normal b_aHs, Normal c_aHt, Normal d_aHu,
          Normal e_aHv, Normal f_aHw) =>
         Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
        normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
          = normal x_aHx `andAnd` normal y_aHy `andAnd` normal z_aHz `andAnd`
              normal u_aHA
              `andAnd` normal v_aHB
              `andAnd` normal w_aHC

instance (Normal a_aHD, Normal b_aHE, Normal c_aHF) => Normal
         (a_aHD, b_aHE, c_aHF) where
        normal (x_aHG, y_aHH, z_aHI)
          = normal x_aHG `andAnd` normal y_aHH `andAnd` normal z_aHI

instance (Normal a_aHJ, Normal b_aHK) => Normal (a_aHJ, b_aHK)
         where
        normal (x_aHL, y_aHM) = normal x_aHL `andAnd` normal y_aHM

instance (Normal a_aHN) => Normal [a_aHN] where
        normal (x_aHO : xs_aHP) = normal x_aHO `andAnd` normal xs_aHP
        normal _ = True
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 3 `Dum.andAnd`

Dum.andAnd a_aGK b_aGL
  = if a_aGK then
        if b_aGL then True else error "andAnd: 2nd argument not True"
    else
        error "andAnd: first argument not True\n"
Dum.pack_obj obj_aHo = Dum.Norm_pack (Dum.normal obj_aHo) obj_aHo
Dum.normalize_obj (Dum.Norm_pack b_aHp _) = b_aHp
Dum.retrieve_obj (Dum.Norm_pack _ obj_aHq) = obj_aHq

data Dum.Norm_able a_aGJ = Dum.Norm_pack Bool a_aGJ
class Dum.Normal a_azE where
  Dum.normal :: a_azE -> Bool

instance Dum.Normal Double where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Float where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Int where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Bool where
  Dum.normal True = True
  Dum.normal _ = True
instance (Dum.Normal a_aHr,
          Dum.Normal b_aHs,
          Dum.Normal c_aHt,
          Dum.Normal d_aHu,
          Dum.Normal e_aHv,
          Dum.Normal f_aHw) =>
         Dum.Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
  Dum.normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
    = Dum.normal x_aHx
      `Dum.andAnd`
        Dum.normal y_aHy
        `Dum.andAnd`
          Dum.normal z_aHz
          `Dum.andAnd`
            Dum.normal u_aHA
            `Dum.andAnd` Dum.normal v_aHB `Dum.andAnd` Dum.normal w_aHC
instance (Dum.Normal a_aHD, Dum.Normal b_aHE, Dum.Normal c_aHF) =>
         Dum.Normal (a_aHD, b_aHE, c_aHF) where
  Dum.normal (x_aHG, y_aHH, z_aHI)
    = Dum.normal x_aHG
      `Dum.andAnd` Dum.normal y_aHH `Dum.andAnd` Dum.normal z_aHI
instance (Dum.Normal a_aHJ, Dum.Normal b_aHK) =>
         Dum.Normal (a_aHJ, b_aHK) where
  Dum.normal (x_aHL, y_aHM)
    = Dum.normal x_aHL `Dum.andAnd` Dum.normal y_aHM
instance (Dum.Normal a_aHN) => Dum.Normal [a_aHN] where
  Dum.normal (x_aHO : xs_aHP)
    = Dum.normal x_aHO `Dum.andAnd` Dum.normal xs_aHP
  Dum.normal _ = True


["a_aGK","b_aGL","obj_aHo","b_aHp","_","Norm_pack b_aHp _","(Norm_pack b_aHp _)","_","obj_aHq","Norm_pack _ obj_aHq","(Norm_pack _ obj_aHq)","0","_","0","_","0","_","True","_","x_aHx","y_aHy","z_aHz","u_aHA","v_aHB","w_aHC","(x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)","x_aHG","y_aHH","z_aHI","(x_aHG, y_aHH, z_aHI)","x_aHL","y_aHM","(x_aHL, y_aHM)","x_aHO","xs_aHP","x_aHO : xs_aHP","(x_aHO : xs_aHP)","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm

infixr 3 `andAnd`
andAnd a_aGK b_aGL
  = if a_aGK then
      if b_aGL then True else error "andAnd: 2nd argument not True" else
      error "andAnd: first argument not True\n"
pack_obj obj_aHo = Norm_pack (normal obj_aHo) obj_aHo
normalize_obj (Norm_pack b_aHp _) = b_aHp
retrieve_obj (Norm_pack _ obj_aHq) = obj_aHq

data Norm_able a_aGJ = Norm_pack Bool a_aGJ

class Normal a_azE where
        normal :: a_azE -> Bool

instance Normal Double where
        normal 0 = True
        normal _ = True

instance Normal Float where
        normal 0 = True
        normal _ = True

instance Normal Int where
        normal 0 = True
        normal _ = True

instance Normal Bool where
        normal True = True
        normal _ = True

instance (Normal a_aHr, Normal b_aHs, Normal c_aHt, Normal d_aHu,
          Normal e_aHv, Normal f_aHw) =>
         Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
        normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
          = normal x_aHx `andAnd` normal y_aHy `andAnd` normal z_aHz `andAnd`
              normal u_aHA
              `andAnd` normal v_aHB
              `andAnd` normal w_aHC

instance (Normal a_aHD, Normal b_aHE, Normal c_aHF) => Normal
         (a_aHD, b_aHE, c_aHF) where
        normal (x_aHG, y_aHH, z_aHI)
          = normal x_aHG `andAnd` normal y_aHH `andAnd` normal z_aHI

instance (Normal a_aHJ, Normal b_aHK) => Normal (a_aHJ, b_aHK)
         where
        normal (x_aHL, y_aHM) = normal x_aHL `andAnd` normal y_aHM

instance (Normal a_aHN) => Normal [a_aHN] where
        normal (x_aHO : xs_aHP) = normal x_aHO `andAnd` normal xs_aHP
        normal _ = True
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 3 `Dum.andAnd`

Dum.andAnd a_aGK b_aGL
  = if a_aGK then
        if b_aGL then True else error "andAnd: 2nd argument not True"
    else
        error "andAnd: first argument not True\n"
Dum.pack_obj obj_aHo = Dum.Norm_pack (Dum.normal obj_aHo) obj_aHo
Dum.normalize_obj (Dum.Norm_pack b_aHp _) = b_aHp
Dum.retrieve_obj (Dum.Norm_pack _ obj_aHq) = obj_aHq

data Dum.Norm_able a_aGJ = Dum.Norm_pack Bool a_aGJ
class Dum.Normal a_azE where
  Dum.normal :: a_azE -> Bool

instance Dum.Normal Double where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Float where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Int where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Bool where
  Dum.normal True = True
  Dum.normal _ = True
instance (Dum.Normal a_aHr,
          Dum.Normal b_aHs,
          Dum.Normal c_aHt,
          Dum.Normal d_aHu,
          Dum.Normal e_aHv,
          Dum.Normal f_aHw) =>
         Dum.Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
  Dum.normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
    = Dum.normal x_aHx
      `Dum.andAnd`
        Dum.normal y_aHy
        `Dum.andAnd`
          Dum.normal z_aHz
          `Dum.andAnd`
            Dum.normal u_aHA
            `Dum.andAnd` Dum.normal v_aHB `Dum.andAnd` Dum.normal w_aHC
instance (Dum.Normal a_aHD, Dum.Normal b_aHE, Dum.Normal c_aHF) =>
         Dum.Normal (a_aHD, b_aHE, c_aHF) where
  Dum.normal (x_aHG, y_aHH, z_aHI)
    = Dum.normal x_aHG
      `Dum.andAnd` Dum.normal y_aHH `Dum.andAnd` Dum.normal z_aHI
instance (Dum.Normal a_aHJ, Dum.Normal b_aHK) =>
         Dum.Normal (a_aHJ, b_aHK) where
  Dum.normal (x_aHL, y_aHM)
    = Dum.normal x_aHL `Dum.andAnd` Dum.normal y_aHM
instance (Dum.Normal a_aHN) => Dum.Normal [a_aHN] where
  Dum.normal (x_aHO : xs_aHP)
    = Dum.normal x_aHO `Dum.andAnd` Dum.normal xs_aHP
  Dum.normal _ = True


["a_aGK","b_aGL","obj_aHo","b_aHp","_","Norm_pack b_aHp _","(Norm_pack b_aHp _)","_","obj_aHq","Norm_pack _ obj_aHq","(Norm_pack _ obj_aHq)","0","_","0","_","0","_","True","_","x_aHx","y_aHy","z_aHz","u_aHA","v_aHB","w_aHC","(x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)","x_aHG","y_aHH","z_aHI","(x_aHG, y_aHH, z_aHI)","x_aHL","y_aHM","(x_aHL, y_aHM)","x_aHO","xs_aHP","x_aHO : xs_aHP","(x_aHO : xs_aHP)","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm

infixr 3 `andAnd`
andAnd a_aGK b_aGL
  = if a_aGK then
      if b_aGL then True else error "andAnd: 2nd argument not True" else
      error "andAnd: first argument not True\n"
pack_obj obj_aHo = Norm_pack (normal obj_aHo) obj_aHo
normalize_obj (Norm_pack b_aHp _) = b_aHp
retrieve_obj (Norm_pack _ obj_aHq) = obj_aHq

data Norm_able a_aGJ = Norm_pack Bool a_aGJ

class Normal a_azE where
        normal :: a_azE -> Bool

instance Normal Double where
        normal 0 = True
        normal _ = True

instance Normal Float where
        normal 0 = True
        normal _ = True

instance Normal Int where
        normal 0 = True
        normal _ = True

instance Normal Bool where
        normal True = True
        normal _ = True

instance (Normal a_aHr, Normal b_aHs, Normal c_aHt, Normal d_aHu,
          Normal e_aHv, Normal f_aHw) =>
         Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
        normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
          = normal x_aHx `andAnd` normal y_aHy `andAnd` normal z_aHz `andAnd`
              normal u_aHA
              `andAnd` normal v_aHB
              `andAnd` normal w_aHC

instance (Normal a_aHD, Normal b_aHE, Normal c_aHF) => Normal
         (a_aHD, b_aHE, c_aHF) where
        normal (x_aHG, y_aHH, z_aHI)
          = normal x_aHG `andAnd` normal y_aHH `andAnd` normal z_aHI

instance (Normal a_aHJ, Normal b_aHK) => Normal (a_aHJ, b_aHK)
         where
        normal (x_aHL, y_aHM) = normal x_aHL `andAnd` normal y_aHM

instance (Normal a_aHN) => Normal [a_aHN] where
        normal (x_aHO : xs_aHP) = normal x_aHO `andAnd` normal xs_aHP
        normal _ = True
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 3 `Dum.andAnd`

Dum.andAnd a_aGK b_aGL
  = if a_aGK then
        if b_aGL then True else error "andAnd: 2nd argument not True"
    else
        error "andAnd: first argument not True\n"
Dum.pack_obj obj_aHo = Dum.Norm_pack (Dum.normal obj_aHo) obj_aHo
Dum.normalize_obj (Dum.Norm_pack b_aHp _) = b_aHp
Dum.retrieve_obj (Dum.Norm_pack _ obj_aHq) = obj_aHq

data Dum.Norm_able a_aGJ = Dum.Norm_pack Bool a_aGJ
class Dum.Normal a_azE where
  Dum.normal :: a_azE -> Bool

instance Dum.Normal Double where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Float where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Int where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Bool where
  Dum.normal True = True
  Dum.normal _ = True
instance (Dum.Normal a_aHr,
          Dum.Normal b_aHs,
          Dum.Normal c_aHt,
          Dum.Normal d_aHu,
          Dum.Normal e_aHv,
          Dum.Normal f_aHw) =>
         Dum.Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
  Dum.normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
    = Dum.normal x_aHx
      `Dum.andAnd`
        Dum.normal y_aHy
        `Dum.andAnd`
          Dum.normal z_aHz
          `Dum.andAnd`
            Dum.normal u_aHA
            `Dum.andAnd` Dum.normal v_aHB `Dum.andAnd` Dum.normal w_aHC
instance (Dum.Normal a_aHD, Dum.Normal b_aHE, Dum.Normal c_aHF) =>
         Dum.Normal (a_aHD, b_aHE, c_aHF) where
  Dum.normal (x_aHG, y_aHH, z_aHI)
    = Dum.normal x_aHG
      `Dum.andAnd` Dum.normal y_aHH `Dum.andAnd` Dum.normal z_aHI
instance (Dum.Normal a_aHJ, Dum.Normal b_aHK) =>
         Dum.Normal (a_aHJ, b_aHK) where
  Dum.normal (x_aHL, y_aHM)
    = Dum.normal x_aHL `Dum.andAnd` Dum.normal y_aHM
instance (Dum.Normal a_aHN) => Dum.Normal [a_aHN] where
  Dum.normal (x_aHO : xs_aHP)
    = Dum.normal x_aHO `Dum.andAnd` Dum.normal xs_aHP
  Dum.normal _ = True


["a_aGK","b_aGL","obj_aHo","b_aHp","_","Norm_pack b_aHp _","(Norm_pack b_aHp _)","_","obj_aHq","Norm_pack _ obj_aHq","(Norm_pack _ obj_aHq)","0","_","0","_","0","_","True","_","x_aHx","y_aHy","z_aHz","u_aHA","v_aHB","w_aHC","(x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)","x_aHG","y_aHH","z_aHI","(x_aHG, y_aHH, z_aHI)","x_aHL","y_aHM","(x_aHL, y_aHM)","x_aHO","xs_aHP","x_aHO : xs_aHP","(x_aHO : xs_aHP)","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Defs
import S_Array
import Norm

infixr 3 `andAnd`
andAnd a_aGK b_aGL
  = if a_aGK then
      if b_aGL then True else error "andAnd: 2nd argument not True" else
      error "andAnd: first argument not True\n"
pack_obj obj_aHo = Norm_pack (normal obj_aHo) obj_aHo
normalize_obj (Norm_pack b_aHp _) = b_aHp
retrieve_obj (Norm_pack _ obj_aHq) = obj_aHq

data Norm_able a_aGJ = Norm_pack Bool a_aGJ

class Normal a_azE where
        normal :: a_azE -> Bool

instance Normal Double where
        normal 0 = True
        normal _ = True

instance Normal Float where
        normal 0 = True
        normal _ = True

instance Normal Int where
        normal 0 = True
        normal _ = True

instance Normal Bool where
        normal True = True
        normal _ = True

instance (Normal a_aHr, Normal b_aHs, Normal c_aHt, Normal d_aHu,
          Normal e_aHv, Normal f_aHw) =>
         Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
        normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
          = normal x_aHx `andAnd` normal y_aHy `andAnd` normal z_aHz `andAnd`
              normal u_aHA
              `andAnd` normal v_aHB
              `andAnd` normal w_aHC

instance (Normal a_aHD, Normal b_aHE, Normal c_aHF) => Normal
         (a_aHD, b_aHE, c_aHF) where
        normal (x_aHG, y_aHH, z_aHI)
          = normal x_aHG `andAnd` normal y_aHH `andAnd` normal z_aHI

instance (Normal a_aHJ, Normal b_aHK) => Normal (a_aHJ, b_aHK)
         where
        normal (x_aHL, y_aHM) = normal x_aHL `andAnd` normal y_aHM

instance (Normal a_aHN) => Normal [a_aHN] where
        normal (x_aHO : xs_aHP) = normal x_aHO `andAnd` normal xs_aHP
        normal _ = True
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 3 `Dum.andAnd`

Dum.andAnd a_aGK b_aGL
  = if a_aGK then
        if b_aGL then True else error "andAnd: 2nd argument not True"
    else
        error "andAnd: first argument not True\n"
Dum.pack_obj obj_aHo = Dum.Norm_pack (Dum.normal obj_aHo) obj_aHo
Dum.normalize_obj (Dum.Norm_pack b_aHp _) = b_aHp
Dum.retrieve_obj (Dum.Norm_pack _ obj_aHq) = obj_aHq

data Dum.Norm_able a_aGJ = Dum.Norm_pack Bool a_aGJ
class Dum.Normal a_azE where
  Dum.normal :: a_azE -> Bool

instance Dum.Normal Double where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Float where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Int where
  Dum.normal 0 = True
  Dum.normal _ = True
instance Dum.Normal Bool where
  Dum.normal True = True
  Dum.normal _ = True
instance (Dum.Normal a_aHr,
          Dum.Normal b_aHs,
          Dum.Normal c_aHt,
          Dum.Normal d_aHu,
          Dum.Normal e_aHv,
          Dum.Normal f_aHw) =>
         Dum.Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
  Dum.normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
    = Dum.normal x_aHx
      `Dum.andAnd`
        Dum.normal y_aHy
        `Dum.andAnd`
          Dum.normal z_aHz
          `Dum.andAnd`
            Dum.normal u_aHA
            `Dum.andAnd` Dum.normal v_aHB `Dum.andAnd` Dum.normal w_aHC
instance (Dum.Normal a_aHD, Dum.Normal b_aHE, Dum.Normal c_aHF) =>
         Dum.Normal (a_aHD, b_aHE, c_aHF) where
  Dum.normal (x_aHG, y_aHH, z_aHI)
    = Dum.normal x_aHG
      `Dum.andAnd` Dum.normal y_aHH `Dum.andAnd` Dum.normal z_aHI
instance (Dum.Normal a_aHJ, Dum.Normal b_aHK) =>
         Dum.Normal (a_aHJ, b_aHK) where
  Dum.normal (x_aHL, y_aHM)
    = Dum.normal x_aHL `Dum.andAnd` Dum.normal y_aHM
instance (Dum.Normal a_aHN) => Dum.Normal [a_aHN] where
  Dum.normal (x_aHO : xs_aHP)
    = Dum.normal x_aHO `Dum.andAnd` Dum.normal xs_aHP
  Dum.normal _ = True


["a_aGK","b_aGL","obj_aHo","b_aHp","_","Norm_pack b_aHp _","(Norm_pack b_aHp _)","_","obj_aHq","Norm_pack _ obj_aHq","(Norm_pack _ obj_aHq)","0","_","0","_","0","_","True","_","x_aHx","y_aHy","z_aHz","u_aHA","v_aHB","w_aHC","(x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)","x_aHG","y_aHH","z_aHI","(x_aHG, y_aHH, z_aHI)","x_aHL","y_aHM","(x_aHL, y_aHM)","x_aHO","xs_aHP","x_aHO : xs_aHP","(x_aHO : xs_aHP)","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import GRIP
import PSlib
import Graph
import Parse
import Pool
import Activity
import Spark
import System.Environment

infixr 3 `andAnd`
andAnd a_aGK b_aGL
  = if a_aGK then
      if b_aGL then True else error "andAnd: 2nd argument not True" else
      error "andAnd: first argument not True\n"
pack_obj obj_aHo = Norm_pack (normal obj_aHo) obj_aHo
normalize_obj (Norm_pack b_aHp _) = b_aHp
retrieve_obj (Norm_pack _ obj_aHq) = obj_aHq

data Norm_able a_aGJ = Norm_pack Bool a_aGJ

class Normal a_azE where
        normal :: a_azE -> Bool

instance Normal Double where
        normal 0 = True
        normal _ = True

instance Normal Float where
        normal 0 = True
        normal _ = True

instance Normal Int where
        normal 0 = True
        normal _ = True

instance Normal Bool where
        normal True = True
        normal _ = True

instance (Normal a_aHr, Normal b_aHs, Normal c_aHt, Normal d_aHu,
          Normal e_aHv, Normal f_aHw) =>
         Normal (a_aHr, b_aHs, c_aHt, d_aHu, e_aHv, f_aHw) where
        normal (x_aHx, y_aHy, z_aHz, u_aHA, v_aHB, w_aHC)
          = normal x_aHx `andAnd` normal y_aHy `andAnd` normal z_aHz `andAnd`
              normal u_aHA
              `andAnd` normal v_aHB
              `andAnd` normal w_aHC

instance (Normal a_aHD, Normal b_aHE, Normal c_aHF) => Normal
         (a_aHD, b_aHE, c_aHF) where
        normal (x_aHG, y_aHH, z_aHI)
          = normal x_aHG `andAnd` normal y_aHH `andAnd` normal z_aHI

instance (Normal a_aHJ, Normal b_aHK) => Normal (a_aHJ, b_aHK)
         where
        normal (x_aHL, y_aHM) = normal x_aHL `andAnd` normal y_aHM

instance (Normal a_aHN) => Normal [a_aHN] where
        normal (x_aHO : xs_aHP) = normal x_aHO `andAnd` normal xs_aHP
        normal _ = True
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.initialise header_a1El
  = header_a1El
    ++
      "/SMALL /Helvetica findfont 4 scalefont def\n"
      ++
        "/SMALLBOLD /Helvetica-Bold findfont 4 scalefont def\n"
        ++
          "/SMALLITALIC /Helvetica-Oblique findfont 4 scalefont def\n"
          ++
            "/NORM /Helvetica findfont 5 scalefont def\n"
            ++
              "/BOLD /Helvetica-Bold findfont 5 scalefont def\n"
              ++
                "/LARGE /Helvetica-Bold findfont 11 scalefont def\n"
                ++
                  "NORM setfont\n"
                  ++ Dum.setcms ++ Dum.stdProcedures ++ Dum.thinlines
Dum.setfont str_a1Em = str_a1Em ++ " setfont\n"
Dum.stdheader :: Dum.Postscript
Dum.stdheader
  = "%!PS-Adobe-2.0\n\
    \%%Created by Haskell Graph Package\n"
Dum.gslandscape = ""
Dum.landscape
  = Dum.translate 8 290
    ++ Dum.rotate 270 ++ Dum.translate 20 10 ++ "0.9 0.9 scale\n"
Dum.portrait = ""
Dum.stdProcedures = Dum.rightshow ++ Dum.centreshow
Dum.drawObject :: [Dum.Point] -> Dum.Postscript
Dum.drawObject (pts_a1En)
  = Dum.newpath
    ++
      Dum.moveto (Dum.Pt 0 0)
      ++ concat (map Dum.lineto pts_a1En) ++ Dum.thinlines ++ Dum.stroke
Dum.fillObject :: [Dum.Point] -> Dum.Postscript
Dum.fillObject (!(pts_a1Xe))
  = Dum.newpath
    ++
      Dum.moveto (Dum.Pt 0 0)
      ++
        concat (map Dum.lineto pts_a1Xe)
        ++ Dum.closepath ++ Dum.fill ++ Dum.stroke
Dum.fillBox :: Dum.Point -> Int -> Int -> Int -> Dum.Postscript
Dum.fillBox pt_a1Xf (!dx_a1Xg) dy_a1Xh (!c_a1Xi)
  = Dum.newpath
    ++
      Dum.moveto pt_a1Xf
      ++
        Dum.rlineto 0 dy_a1Xh
        ++
          Dum.rlineto dx_a1Xg 0
          ++
            Dum.rlineto 0 (- dy_a1Xh)
            ++ Dum.closepath ++ Dum.setgray c_a1Xi ++ Dum.fill
Dum.drawBox :: Dum.Point -> Int -> Int -> Dum.Postscript
Dum.drawBox (!pt_a1Xj) (!dx_a1Xk) dy_a1Xl
  = Dum.thinlines
    ++
      Dum.newpath
      ++
        Dum.moveto pt_a1Xj
        ++
          Dum.rlineto 0 dy_a1Xl
          ++
            Dum.rlineto dx_a1Xk 0
            ++ Dum.rlineto 0 (- dy_a1Xl) ++ Dum.closepath ++ Dum.stroke
Dum.rjustify (!str_a1Xm) = "(" ++ str_a1Xm ++ ") rightshow\n"
Dum.cjustify (!str_a1Xn) = "(" ++ str_a1Xn ++ ") centreshow\n"
Dum.rightshow
  = "/rightshow\n\
    \{dup stringwidth pop\n\
    \0 exch sub\n\
    \0 rmoveto\n\
    \show } def \n"
Dum.centreshow
  = "/centreshow\n\
    \{dup stringwidth pop\n\
    \0 exch sub\n\
    \2 div\n\
    \0 rmoveto\n\
    \show } def \n"
Dum.fill = "fill\n"
Dum.stroke = "stroke\n"
Dum.closepath = "closepath\n"
Dum.newpath = "newpath\n"
Dum.showpage
  = "showpage\n\
    \\n"
Dum.gsave = "gsave\n"
Dum.grestore = "grestore\n"
Dum.text (!t_a1Xo) = Dum.setgray 0 ++ "(" ++ t_a1Xo ++ ") show\n"
Dum.setgray 0 = "0 setgray\n"
Dum.setgray 10 = "1 setgray\n"
Dum.setgray (!n_a1Xp) = "." ++ show n_a1Xp ++ " setgray\n"
Dum.moveto (Dum.Pt x_a1Xq y_a1Xr)
  = Dum.psCommand "moveto" [x_a1Xq, y_a1Xr]
Dum.rmoveto x_a1Xs (!y_a1Xt)
  = Dum.psCommand "rmoveto" [x_a1Xs, y_a1Xt]
Dum.lineto :: Dum.Point -> Dum.Postscript
Dum.lineto (!((!(Dum.Pt x_a1Xu y_a1Xv))))
  = Dum.psCommand "lineto" [x_a1Xu, y_a1Xv]
Dum.rlineto x_a1Xw (!y_a1Xx)
  = Dum.psCommand "rlineto" [x_a1Xw, y_a1Xx]
Dum.setlinewidth n_a1Xy = Dum.psCommand "setlinewidth" [n_a1Xy]
Dum.thinlines = "0.2 setlinewidth\n"
Dum.rotate n_a1Xz = Dum.psCommand "rotate" [n_a1Xz]
Dum.psCommand c_a1XA (!args_a1XB)
  = concat (map f_a1XC args_a1XB) ++ c_a1XA ++ "\n"
  where
      f_a1XC (!x_a1XD) = show x_a1XD ++ " "
Dum.translate (!x_a1XE) y_a1XF
  = Dum.psCommand "translate" [x_a1XE, y_a1XF]
Dum.scale x_a1XG y_a1XH = Dum.psCommand "scale" [x_a1XG, y_a1XH]
Dum.setcms = "2.84584 2.84584 scale\n"

type Dum.Postscript = String
data Dum.Point
  = Dum.Pt Int Int
  deriving (Eq, Show)


["header_a1El","str_a1Em","stdheader","gslandscape","landscape","portrait","stdProcedures","pts_a1En","(pts_a1En)","pts_a1Xe","(pts_a1Xe)","!(pts_a1Xe)","(!(pts_a1Xe))","pt_a1Xf","dx_a1Xg","safebang@!dx_a1Xg","(!dx_a1Xg)","dy_a1Xh","c_a1Xi","safebang@!c_a1Xi","(!c_a1Xi)","pt_a1Xj","safebang@!pt_a1Xj","(!pt_a1Xj)","dx_a1Xk","safebang@!dx_a1Xk","(!dx_a1Xk)","dy_a1Xl","str_a1Xm","safebang@!str_a1Xm","(!str_a1Xm)","str_a1Xn","safebang@!str_a1Xn","(!str_a1Xn)","rightshow","centreshow","fill","stroke","closepath","newpath","showpage","gsave","grestore","t_a1Xo","safebang@!t_a1Xo","(!t_a1Xo)","0","10","n_a1Xp","!n_a1Xp","(!n_a1Xp)","x_a1Xq","y_a1Xr","Pt x_a1Xq y_a1Xr","(Pt x_a1Xq y_a1Xr)","x_a1Xs","y_a1Xt","safebang@!y_a1Xt","(!y_a1Xt)","x_a1Xu","y_a1Xv","Pt x_a1Xu y_a1Xv","(Pt x_a1Xu y_a1Xv)","!(Pt x_a1Xu y_a1Xv)","(!(Pt x_a1Xu y_a1Xv))","((!(Pt x_a1Xu y_a1Xv)))","!((!(Pt x_a1Xu y_a1Xv)))","(!((!(Pt x_a1Xu y_a1Xv))))","x_a1Xw","y_a1Xx","safebang@!y_a1Xx","(!y_a1Xx)","n_a1Xy","thinlines","n_a1Xz","c_a1XA","args_a1XB","safebang@!args_a1XB","(!args_a1XB)","x_a1XD","!x_a1XD","(!x_a1XD)","x_a1XE","safebang@!x_a1XE","(!x_a1XE)","y_a1XF","x_a1XG","y_a1XH","setcms"]
{-# LANGUAGE BangPatterns #-}
module Dum where
initialise header_a1El
  = header_a1El ++ "/SMALL /Helvetica findfont 4 scalefont def\n" ++
      "/SMALLBOLD /Helvetica-Bold findfont 4 scalefont def\n"
      ++ "/SMALLITALIC /Helvetica-Oblique findfont 4 scalefont def\n"
      ++ "/NORM /Helvetica findfont 5 scalefont def\n"
      ++ "/BOLD /Helvetica-Bold findfont 5 scalefont def\n"
      ++ "/LARGE /Helvetica-Bold findfont 11 scalefont def\n"
      ++ "NORM setfont\n"
      ++ setcms
      ++ stdProcedures
      ++ thinlines
setfont str_a1Em = str_a1Em ++ " setfont\n"

stdheader :: Postscript
stdheader = "%!PS-Adobe-2.0\n%%Created by Haskell Graph Package\n"
gslandscape = ""
landscape
  = translate 8 290 ++ rotate 270 ++ translate 20 10 ++
      "0.9 0.9 scale\n"
portrait = ""
stdProcedures = rightshow ++ centreshow

drawObject :: [Point] -> Postscript
drawObject (pts_a1En)
  = newpath ++ moveto (Pt 0 0) ++ concat (map lineto pts_a1En) ++
      thinlines
      ++ stroke

fillObject :: [Point] -> Postscript
fillObject (investigate@(pts_a1Xe))
  = newpath ++ moveto (Pt 0 0) ++ concat (map lineto pts_a1Xe) ++
      closepath
      ++ fill
      ++ stroke

fillBox :: Point -> Int -> Int -> Int -> Postscript
fillBox pt_a1Xf (!dx_a1Xg) dy_a1Xh (!c_a1Xi)
  = newpath ++ moveto pt_a1Xf ++ rlineto 0 dy_a1Xh ++
      rlineto dx_a1Xg 0
      ++ rlineto 0 (-dy_a1Xh)
      ++ closepath
      ++ setgray c_a1Xi
      ++ fill

drawBox :: Point -> Int -> Int -> Postscript
drawBox (!pt_a1Xj) (!dx_a1Xk) dy_a1Xl
  = thinlines ++ newpath ++ moveto pt_a1Xj ++ rlineto 0 dy_a1Xl ++
      rlineto dx_a1Xk 0
      ++ rlineto 0 (-dy_a1Xl)
      ++ closepath
      ++ stroke
rjustify (!str_a1Xm) = "(" ++ str_a1Xm ++ ") rightshow\n"
cjustify (!str_a1Xn) = "(" ++ str_a1Xn ++ ") centreshow\n"
rightshow
  = "/rightshow\n{dup stringwidth pop\n0 exch sub\n0 rmoveto\nshow } def \n"
centreshow
  = "/centreshow\n{dup stringwidth pop\n0 exch sub\n2 div\n0 rmoveto\nshow } def \n"
fill = "fill\n"
stroke = "stroke\n"
closepath = "closepath\n"
newpath = "newpath\n"
showpage = "showpage\n\n"
gsave = "gsave\n"
grestore = "grestore\n"
text (!t_a1Xo) = setgray 0 ++ "(" ++ t_a1Xo ++ ") show\n"
setgray 0 = "0 setgray\n"
setgray 10 = "1 setgray\n"
setgray (investigate@n_a1Xp) = "." ++ show n_a1Xp ++ " setgray\n"
moveto (Pt x_a1Xq y_a1Xr) = psCommand "moveto" [x_a1Xq, y_a1Xr]
rmoveto x_a1Xs (!y_a1Xt) = psCommand "rmoveto" [x_a1Xs, y_a1Xt]

lineto :: Point -> Postscript
lineto (investigate@((investigate@(Pt x_a1Xu y_a1Xv))))
  = psCommand "lineto" [x_a1Xu, y_a1Xv]
rlineto x_a1Xw (!y_a1Xx) = psCommand "rlineto" [x_a1Xw, y_a1Xx]
setlinewidth n_a1Xy = psCommand "setlinewidth" [n_a1Xy]
thinlines = "0.2 setlinewidth\n"
rotate n_a1Xz = psCommand "rotate" [n_a1Xz]
psCommand c_a1XA (!args_a1XB)
  = concat (map f_a1XC args_a1XB) ++ c_a1XA ++ "\n"
  where f_a1XC (investigate@x_a1XD) = show x_a1XD ++ " "
translate (!x_a1XE) y_a1XF = psCommand "translate" [x_a1XE, y_a1XF]
scale x_a1XG y_a1XH = psCommand "scale" [x_a1XG, y_a1XH]
setcms = "2.84584 2.84584 scale\n"

type Postscript = String

data Point = Pt Int Int
           deriving (Eq, Show)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.initialise header_a1El
  = header_a1El
    ++
      "/SMALL /Helvetica findfont 4 scalefont def\n"
      ++
        "/SMALLBOLD /Helvetica-Bold findfont 4 scalefont def\n"
        ++
          "/SMALLITALIC /Helvetica-Oblique findfont 4 scalefont def\n"
          ++
            "/NORM /Helvetica findfont 5 scalefont def\n"
            ++
              "/BOLD /Helvetica-Bold findfont 5 scalefont def\n"
              ++
                "/LARGE /Helvetica-Bold findfont 11 scalefont def\n"
                ++
                  "NORM setfont\n"
                  ++ Dum.setcms ++ Dum.stdProcedures ++ Dum.thinlines
Dum.setfont str_a1Em = str_a1Em ++ " setfont\n"
Dum.stdheader :: Dum.Postscript
Dum.stdheader
  = "%!PS-Adobe-2.0\n\
    \%%Created by Haskell Graph Package\n"
Dum.gslandscape = ""
Dum.landscape
  = Dum.translate 8 290
    ++ Dum.rotate 270 ++ Dum.translate 20 10 ++ "0.9 0.9 scale\n"
Dum.portrait = ""
Dum.stdProcedures = Dum.rightshow ++ Dum.centreshow
Dum.drawObject :: [Dum.Point] -> Dum.Postscript
Dum.drawObject (pts_a1En)
  = Dum.newpath
    ++
      Dum.moveto (Dum.Pt 0 0)
      ++ concat (map Dum.lineto pts_a1En) ++ Dum.thinlines ++ Dum.stroke
Dum.fillObject :: [Dum.Point] -> Dum.Postscript
Dum.fillObject (!(pts_a1Xe))
  = Dum.newpath
    ++
      Dum.moveto (Dum.Pt 0 0)
      ++
        concat (map Dum.lineto pts_a1Xe)
        ++ Dum.closepath ++ Dum.fill ++ Dum.stroke
Dum.fillBox :: Dum.Point -> Int -> Int -> Int -> Dum.Postscript
Dum.fillBox pt_a1Xf (!dx_a1Xg) dy_a1Xh (!c_a1Xi)
  = Dum.newpath
    ++
      Dum.moveto pt_a1Xf
      ++
        Dum.rlineto 0 dy_a1Xh
        ++
          Dum.rlineto dx_a1Xg 0
          ++
            Dum.rlineto 0 (- dy_a1Xh)
            ++ Dum.closepath ++ Dum.setgray c_a1Xi ++ Dum.fill
Dum.drawBox :: Dum.Point -> Int -> Int -> Dum.Postscript
Dum.drawBox (!pt_a1Xj) (!dx_a1Xk) dy_a1Xl
  = Dum.thinlines
    ++
      Dum.newpath
      ++
        Dum.moveto pt_a1Xj
        ++
          Dum.rlineto 0 dy_a1Xl
          ++
            Dum.rlineto dx_a1Xk 0
            ++ Dum.rlineto 0 (- dy_a1Xl) ++ Dum.closepath ++ Dum.stroke
Dum.rjustify (!str_a1Xm) = "(" ++ str_a1Xm ++ ") rightshow\n"
Dum.cjustify (!str_a1Xn) = "(" ++ str_a1Xn ++ ") centreshow\n"
Dum.rightshow
  = "/rightshow\n\
    \{dup stringwidth pop\n\
    \0 exch sub\n\
    \0 rmoveto\n\
    \show } def \n"
Dum.centreshow
  = "/centreshow\n\
    \{dup stringwidth pop\n\
    \0 exch sub\n\
    \2 div\n\
    \0 rmoveto\n\
    \show } def \n"
Dum.fill = "fill\n"
Dum.stroke = "stroke\n"
Dum.closepath = "closepath\n"
Dum.newpath = "newpath\n"
Dum.showpage
  = "showpage\n\
    \\n"
Dum.gsave = "gsave\n"
Dum.grestore = "grestore\n"
Dum.text (!t_a1Xo) = Dum.setgray 0 ++ "(" ++ t_a1Xo ++ ") show\n"
Dum.setgray 0 = "0 setgray\n"
Dum.setgray 10 = "1 setgray\n"
Dum.setgray (!n_a1Xp) = "." ++ show n_a1Xp ++ " setgray\n"
Dum.moveto (Dum.Pt x_a1Xq y_a1Xr)
  = Dum.psCommand "moveto" [x_a1Xq, y_a1Xr]
Dum.rmoveto x_a1Xs (!y_a1Xt)
  = Dum.psCommand "rmoveto" [x_a1Xs, y_a1Xt]
Dum.lineto :: Dum.Point -> Dum.Postscript
Dum.lineto (!((!(Dum.Pt x_a1Xu y_a1Xv))))
  = Dum.psCommand "lineto" [x_a1Xu, y_a1Xv]
Dum.rlineto x_a1Xw (!y_a1Xx)
  = Dum.psCommand "rlineto" [x_a1Xw, y_a1Xx]
Dum.setlinewidth n_a1Xy = Dum.psCommand "setlinewidth" [n_a1Xy]
Dum.thinlines = "0.2 setlinewidth\n"
Dum.rotate n_a1Xz = Dum.psCommand "rotate" [n_a1Xz]
Dum.psCommand c_a1XA (!args_a1XB)
  = concat (map f_a1XC args_a1XB) ++ c_a1XA ++ "\n"
  where
      f_a1XC (!x_a1XD) = show x_a1XD ++ " "
Dum.translate (!x_a1XE) y_a1XF
  = Dum.psCommand "translate" [x_a1XE, y_a1XF]
Dum.scale x_a1XG y_a1XH = Dum.psCommand "scale" [x_a1XG, y_a1XH]
Dum.setcms = "2.84584 2.84584 scale\n"

type Dum.Postscript = String
data Dum.Point
  = Dum.Pt Int Int
  deriving (Eq, Show)


["header_a1El","str_a1Em","stdheader","gslandscape","landscape","portrait","stdProcedures","pts_a1En","(pts_a1En)","pts_a1Xe","(pts_a1Xe)","!(pts_a1Xe)","(!(pts_a1Xe))","pt_a1Xf","dx_a1Xg","safebang@!dx_a1Xg","(!dx_a1Xg)","dy_a1Xh","c_a1Xi","safebang@!c_a1Xi","(!c_a1Xi)","pt_a1Xj","safebang@!pt_a1Xj","(!pt_a1Xj)","dx_a1Xk","safebang@!dx_a1Xk","(!dx_a1Xk)","dy_a1Xl","str_a1Xm","safebang@!str_a1Xm","(!str_a1Xm)","str_a1Xn","safebang@!str_a1Xn","(!str_a1Xn)","rightshow","centreshow","fill","stroke","closepath","newpath","showpage","gsave","grestore","t_a1Xo","safebang@!t_a1Xo","(!t_a1Xo)","0","10","n_a1Xp","!n_a1Xp","(!n_a1Xp)","x_a1Xq","y_a1Xr","Pt x_a1Xq y_a1Xr","(Pt x_a1Xq y_a1Xr)","x_a1Xs","y_a1Xt","safebang@!y_a1Xt","(!y_a1Xt)","x_a1Xu","y_a1Xv","Pt x_a1Xu y_a1Xv","(Pt x_a1Xu y_a1Xv)","!(Pt x_a1Xu y_a1Xv)","(!(Pt x_a1Xu y_a1Xv))","((!(Pt x_a1Xu y_a1Xv)))","!((!(Pt x_a1Xu y_a1Xv)))","(!((!(Pt x_a1Xu y_a1Xv))))","x_a1Xw","y_a1Xx","safebang@!y_a1Xx","(!y_a1Xx)","n_a1Xy","thinlines","n_a1Xz","c_a1XA","args_a1XB","safebang@!args_a1XB","(!args_a1XB)","x_a1XD","!x_a1XD","(!x_a1XD)","x_a1XE","safebang@!x_a1XE","(!x_a1XE)","y_a1XF","x_a1XG","y_a1XH","setcms"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Parse
import StdLib
import PSlib
import GRIP
initialise header_a1El
  = header_a1El ++ "/SMALL /Helvetica findfont 4 scalefont def\n" ++
      "/SMALLBOLD /Helvetica-Bold findfont 4 scalefont def\n"
      ++ "/SMALLITALIC /Helvetica-Oblique findfont 4 scalefont def\n"
      ++ "/NORM /Helvetica findfont 5 scalefont def\n"
      ++ "/BOLD /Helvetica-Bold findfont 5 scalefont def\n"
      ++ "/LARGE /Helvetica-Bold findfont 11 scalefont def\n"
      ++ "NORM setfont\n"
      ++ setcms
      ++ stdProcedures
      ++ thinlines
setfont str_a1Em = str_a1Em ++ " setfont\n"

stdheader :: Postscript
stdheader = "%!PS-Adobe-2.0\n%%Created by Haskell Graph Package\n"
gslandscape = ""
landscape
  = translate 8 290 ++ rotate 270 ++ translate 20 10 ++
      "0.9 0.9 scale\n"
portrait = ""
stdProcedures = rightshow ++ centreshow

drawObject :: [Point] -> Postscript
drawObject (pts_a1En)
  = newpath ++ moveto (Pt 0 0) ++ concat (map lineto pts_a1En) ++
      thinlines
      ++ stroke

fillObject :: [Point] -> Postscript
fillObject (investigate@(pts_a1Xe))
  = newpath ++ moveto (Pt 0 0) ++ concat (map lineto pts_a1Xe) ++
      closepath
      ++ fill
      ++ stroke

fillBox :: Point -> Int -> Int -> Int -> Postscript
fillBox pt_a1Xf (!dx_a1Xg) dy_a1Xh (!c_a1Xi)
  = newpath ++ moveto pt_a1Xf ++ rlineto 0 dy_a1Xh ++
      rlineto dx_a1Xg 0
      ++ rlineto 0 (-dy_a1Xh)
      ++ closepath
      ++ setgray c_a1Xi
      ++ fill

drawBox :: Point -> Int -> Int -> Postscript
drawBox (!pt_a1Xj) (!dx_a1Xk) dy_a1Xl
  = thinlines ++ newpath ++ moveto pt_a1Xj ++ rlineto 0 dy_a1Xl ++
      rlineto dx_a1Xk 0
      ++ rlineto 0 (-dy_a1Xl)
      ++ closepath
      ++ stroke
rjustify (!str_a1Xm) = "(" ++ str_a1Xm ++ ") rightshow\n"
cjustify (!str_a1Xn) = "(" ++ str_a1Xn ++ ") centreshow\n"
rightshow
  = "/rightshow\n{dup stringwidth pop\n0 exch sub\n0 rmoveto\nshow } def \n"
centreshow
  = "/centreshow\n{dup stringwidth pop\n0 exch sub\n2 div\n0 rmoveto\nshow } def \n"
fill = "fill\n"
stroke = "stroke\n"
closepath = "closepath\n"
newpath = "newpath\n"
showpage = "showpage\n\n"
gsave = "gsave\n"
grestore = "grestore\n"
text (!t_a1Xo) = setgray 0 ++ "(" ++ t_a1Xo ++ ") show\n"
setgray 0 = "0 setgray\n"
setgray 10 = "1 setgray\n"
setgray (investigate@n_a1Xp) = "." ++ show n_a1Xp ++ " setgray\n"
moveto (Pt x_a1Xq y_a1Xr) = psCommand "moveto" [x_a1Xq, y_a1Xr]
rmoveto x_a1Xs (!y_a1Xt) = psCommand "rmoveto" [x_a1Xs, y_a1Xt]

lineto :: Point -> Postscript
lineto (investigate@((investigate@(Pt x_a1Xu y_a1Xv))))
  = psCommand "lineto" [x_a1Xu, y_a1Xv]
rlineto x_a1Xw (!y_a1Xx) = psCommand "rlineto" [x_a1Xw, y_a1Xx]
setlinewidth n_a1Xy = psCommand "setlinewidth" [n_a1Xy]
thinlines = "0.2 setlinewidth\n"
rotate n_a1Xz = psCommand "rotate" [n_a1Xz]
psCommand c_a1XA (!args_a1XB)
  = concat (map f_a1XC args_a1XB) ++ c_a1XA ++ "\n"
  where f_a1XC (investigate@x_a1XD) = show x_a1XD ++ " "
translate (!x_a1XE) y_a1XF = psCommand "translate" [x_a1XE, y_a1XF]
scale x_a1XG y_a1XH = psCommand "scale" [x_a1XG, y_a1XH]
setcms = "2.84584 2.84584 scale\n"

type Postscript = String

data Point = Pt Int Int
           deriving (Eq, Show)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.initialise header_a1El
  = header_a1El
    ++
      "/SMALL /Helvetica findfont 4 scalefont def\n"
      ++
        "/SMALLBOLD /Helvetica-Bold findfont 4 scalefont def\n"
        ++
          "/SMALLITALIC /Helvetica-Oblique findfont 4 scalefont def\n"
          ++
            "/NORM /Helvetica findfont 5 scalefont def\n"
            ++
              "/BOLD /Helvetica-Bold findfont 5 scalefont def\n"
              ++
                "/LARGE /Helvetica-Bold findfont 11 scalefont def\n"
                ++
                  "NORM setfont\n"
                  ++ Dum.setcms ++ Dum.stdProcedures ++ Dum.thinlines
Dum.setfont str_a1Em = str_a1Em ++ " setfont\n"
Dum.stdheader :: Dum.Postscript
Dum.stdheader
  = "%!PS-Adobe-2.0\n\
    \%%Created by Haskell Graph Package\n"
Dum.gslandscape = ""
Dum.landscape
  = Dum.translate 8 290
    ++ Dum.rotate 270 ++ Dum.translate 20 10 ++ "0.9 0.9 scale\n"
Dum.portrait = ""
Dum.stdProcedures = Dum.rightshow ++ Dum.centreshow
Dum.drawObject :: [Dum.Point] -> Dum.Postscript
Dum.drawObject (pts_a1En)
  = Dum.newpath
    ++
      Dum.moveto (Dum.Pt 0 0)
      ++ concat (map Dum.lineto pts_a1En) ++ Dum.thinlines ++ Dum.stroke
Dum.fillObject :: [Dum.Point] -> Dum.Postscript
Dum.fillObject (!(pts_a1Xe))
  = Dum.newpath
    ++
      Dum.moveto (Dum.Pt 0 0)
      ++
        concat (map Dum.lineto pts_a1Xe)
        ++ Dum.closepath ++ Dum.fill ++ Dum.stroke
Dum.fillBox :: Dum.Point -> Int -> Int -> Int -> Dum.Postscript
Dum.fillBox pt_a1Xf (!dx_a1Xg) dy_a1Xh (!c_a1Xi)
  = Dum.newpath
    ++
      Dum.moveto pt_a1Xf
      ++
        Dum.rlineto 0 dy_a1Xh
        ++
          Dum.rlineto dx_a1Xg 0
          ++
            Dum.rlineto 0 (- dy_a1Xh)
            ++ Dum.closepath ++ Dum.setgray c_a1Xi ++ Dum.fill
Dum.drawBox :: Dum.Point -> Int -> Int -> Dum.Postscript
Dum.drawBox (!pt_a1Xj) (!dx_a1Xk) dy_a1Xl
  = Dum.thinlines
    ++
      Dum.newpath
      ++
        Dum.moveto pt_a1Xj
        ++
          Dum.rlineto 0 dy_a1Xl
          ++
            Dum.rlineto dx_a1Xk 0
            ++ Dum.rlineto 0 (- dy_a1Xl) ++ Dum.closepath ++ Dum.stroke
Dum.rjustify (!str_a1Xm) = "(" ++ str_a1Xm ++ ") rightshow\n"
Dum.cjustify (!str_a1Xn) = "(" ++ str_a1Xn ++ ") centreshow\n"
Dum.rightshow
  = "/rightshow\n\
    \{dup stringwidth pop\n\
    \0 exch sub\n\
    \0 rmoveto\n\
    \show } def \n"
Dum.centreshow
  = "/centreshow\n\
    \{dup stringwidth pop\n\
    \0 exch sub\n\
    \2 div\n\
    \0 rmoveto\n\
    \show } def \n"
Dum.fill = "fill\n"
Dum.stroke = "stroke\n"
Dum.closepath = "closepath\n"
Dum.newpath = "newpath\n"
Dum.showpage
  = "showpage\n\
    \\n"
Dum.gsave = "gsave\n"
Dum.grestore = "grestore\n"
Dum.text (!t_a1Xo) = Dum.setgray 0 ++ "(" ++ t_a1Xo ++ ") show\n"
Dum.setgray 0 = "0 setgray\n"
Dum.setgray 10 = "1 setgray\n"
Dum.setgray (!n_a1Xp) = "." ++ show n_a1Xp ++ " setgray\n"
Dum.moveto (Dum.Pt x_a1Xq y_a1Xr)
  = Dum.psCommand "moveto" [x_a1Xq, y_a1Xr]
Dum.rmoveto x_a1Xs (!y_a1Xt)
  = Dum.psCommand "rmoveto" [x_a1Xs, y_a1Xt]
Dum.lineto :: Dum.Point -> Dum.Postscript
Dum.lineto (!((!(Dum.Pt x_a1Xu y_a1Xv))))
  = Dum.psCommand "lineto" [x_a1Xu, y_a1Xv]
Dum.rlineto x_a1Xw (!y_a1Xx)
  = Dum.psCommand "rlineto" [x_a1Xw, y_a1Xx]
Dum.setlinewidth n_a1Xy = Dum.psCommand "setlinewidth" [n_a1Xy]
Dum.thinlines = "0.2 setlinewidth\n"
Dum.rotate n_a1Xz = Dum.psCommand "rotate" [n_a1Xz]
Dum.psCommand c_a1XA (!args_a1XB)
  = concat (map f_a1XC args_a1XB) ++ c_a1XA ++ "\n"
  where
      f_a1XC (!x_a1XD) = show x_a1XD ++ " "
Dum.translate (!x_a1XE) y_a1XF
  = Dum.psCommand "translate" [x_a1XE, y_a1XF]
Dum.scale x_a1XG y_a1XH = Dum.psCommand "scale" [x_a1XG, y_a1XH]
Dum.setcms = "2.84584 2.84584 scale\n"

type Dum.Postscript = String
data Dum.Point
  = Dum.Pt Int Int
  deriving (Eq, Show)


["header_a1El","str_a1Em","stdheader","gslandscape","landscape","portrait","stdProcedures","pts_a1En","(pts_a1En)","pts_a1Xe","(pts_a1Xe)","!(pts_a1Xe)","(!(pts_a1Xe))","pt_a1Xf","dx_a1Xg","safebang@!dx_a1Xg","(!dx_a1Xg)","dy_a1Xh","c_a1Xi","safebang@!c_a1Xi","(!c_a1Xi)","pt_a1Xj","safebang@!pt_a1Xj","(!pt_a1Xj)","dx_a1Xk","safebang@!dx_a1Xk","(!dx_a1Xk)","dy_a1Xl","str_a1Xm","safebang@!str_a1Xm","(!str_a1Xm)","str_a1Xn","safebang@!str_a1Xn","(!str_a1Xn)","rightshow","centreshow","fill","stroke","closepath","newpath","showpage","gsave","grestore","t_a1Xo","safebang@!t_a1Xo","(!t_a1Xo)","0","10","n_a1Xp","!n_a1Xp","(!n_a1Xp)","x_a1Xq","y_a1Xr","Pt x_a1Xq y_a1Xr","(Pt x_a1Xq y_a1Xr)","x_a1Xs","y_a1Xt","safebang@!y_a1Xt","(!y_a1Xt)","x_a1Xu","y_a1Xv","Pt x_a1Xu y_a1Xv","(Pt x_a1Xu y_a1Xv)","!(Pt x_a1Xu y_a1Xv)","(!(Pt x_a1Xu y_a1Xv))","((!(Pt x_a1Xu y_a1Xv)))","!((!(Pt x_a1Xu y_a1Xv)))","(!((!(Pt x_a1Xu y_a1Xv))))","x_a1Xw","y_a1Xx","safebang@!y_a1Xx","(!y_a1Xx)","n_a1Xy","thinlines","n_a1Xz","c_a1XA","args_a1XB","safebang@!args_a1XB","(!args_a1XB)","x_a1XD","!x_a1XD","(!x_a1XD)","x_a1XE","safebang@!x_a1XE","(!x_a1XE)","y_a1XF","x_a1XG","y_a1XH","setcms"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import StdLib
import GRIP
import PSlib
import Graph
import Parse
initialise header_a1El
  = header_a1El ++ "/SMALL /Helvetica findfont 4 scalefont def\n" ++
      "/SMALLBOLD /Helvetica-Bold findfont 4 scalefont def\n"
      ++ "/SMALLITALIC /Helvetica-Oblique findfont 4 scalefont def\n"
      ++ "/NORM /Helvetica findfont 5 scalefont def\n"
      ++ "/BOLD /Helvetica-Bold findfont 5 scalefont def\n"
      ++ "/LARGE /Helvetica-Bold findfont 11 scalefont def\n"
      ++ "NORM setfont\n"
      ++ setcms
      ++ stdProcedures
      ++ thinlines
setfont str_a1Em = str_a1Em ++ " setfont\n"

stdheader :: Postscript
stdheader = "%!PS-Adobe-2.0\n%%Created by Haskell Graph Package\n"
gslandscape = ""
landscape
  = translate 8 290 ++ rotate 270 ++ translate 20 10 ++
      "0.9 0.9 scale\n"
portrait = ""
stdProcedures = rightshow ++ centreshow

drawObject :: [Point] -> Postscript
drawObject (pts_a1En)
  = newpath ++ moveto (Pt 0 0) ++ concat (map lineto pts_a1En) ++
      thinlines
      ++ stroke

fillObject :: [Point] -> Postscript
fillObject (investigate@(pts_a1Xe))
  = newpath ++ moveto (Pt 0 0) ++ concat (map lineto pts_a1Xe) ++
      closepath
      ++ fill
      ++ stroke

fillBox :: Point -> Int -> Int -> Int -> Postscript
fillBox pt_a1Xf (!dx_a1Xg) dy_a1Xh (!c_a1Xi)
  = newpath ++ moveto pt_a1Xf ++ rlineto 0 dy_a1Xh ++
      rlineto dx_a1Xg 0
      ++ rlineto 0 (-dy_a1Xh)
      ++ closepath
      ++ setgray c_a1Xi
      ++ fill

drawBox :: Point -> Int -> Int -> Postscript
drawBox (!pt_a1Xj) (!dx_a1Xk) dy_a1Xl
  = thinlines ++ newpath ++ moveto pt_a1Xj ++ rlineto 0 dy_a1Xl ++
      rlineto dx_a1Xk 0
      ++ rlineto 0 (-dy_a1Xl)
      ++ closepath
      ++ stroke
rjustify (!str_a1Xm) = "(" ++ str_a1Xm ++ ") rightshow\n"
cjustify (!str_a1Xn) = "(" ++ str_a1Xn ++ ") centreshow\n"
rightshow
  = "/rightshow\n{dup stringwidth pop\n0 exch sub\n0 rmoveto\nshow } def \n"
centreshow
  = "/centreshow\n{dup stringwidth pop\n0 exch sub\n2 div\n0 rmoveto\nshow } def \n"
fill = "fill\n"
stroke = "stroke\n"
closepath = "closepath\n"
newpath = "newpath\n"
showpage = "showpage\n\n"
gsave = "gsave\n"
grestore = "grestore\n"
text (!t_a1Xo) = setgray 0 ++ "(" ++ t_a1Xo ++ ") show\n"
setgray 0 = "0 setgray\n"
setgray 10 = "1 setgray\n"
setgray (investigate@n_a1Xp) = "." ++ show n_a1Xp ++ " setgray\n"
moveto (Pt x_a1Xq y_a1Xr) = psCommand "moveto" [x_a1Xq, y_a1Xr]
rmoveto x_a1Xs (!y_a1Xt) = psCommand "rmoveto" [x_a1Xs, y_a1Xt]

lineto :: Point -> Postscript
lineto (investigate@((investigate@(Pt x_a1Xu y_a1Xv))))
  = psCommand "lineto" [x_a1Xu, y_a1Xv]
rlineto x_a1Xw (!y_a1Xx) = psCommand "rlineto" [x_a1Xw, y_a1Xx]
setlinewidth n_a1Xy = psCommand "setlinewidth" [n_a1Xy]
thinlines = "0.2 setlinewidth\n"
rotate n_a1Xz = psCommand "rotate" [n_a1Xz]
psCommand c_a1XA (!args_a1XB)
  = concat (map f_a1XC args_a1XB) ++ c_a1XA ++ "\n"
  where f_a1XC (investigate@x_a1XD) = show x_a1XD ++ " "
translate (!x_a1XE) y_a1XF = psCommand "translate" [x_a1XE, y_a1XF]
scale x_a1XG y_a1XH = psCommand "scale" [x_a1XG, y_a1XH]
setcms = "2.84584 2.84584 scale\n"

type Postscript = String

data Point = Pt Int Int
           deriving (Eq, Show)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.initialise header_a1El
  = header_a1El
    ++
      "/SMALL /Helvetica findfont 4 scalefont def\n"
      ++
        "/SMALLBOLD /Helvetica-Bold findfont 4 scalefont def\n"
        ++
          "/SMALLITALIC /Helvetica-Oblique findfont 4 scalefont def\n"
          ++
            "/NORM /Helvetica findfont 5 scalefont def\n"
            ++
              "/BOLD /Helvetica-Bold findfont 5 scalefont def\n"
              ++
                "/LARGE /Helvetica-Bold findfont 11 scalefont def\n"
                ++
                  "NORM setfont\n"
                  ++ Dum.setcms ++ Dum.stdProcedures ++ Dum.thinlines
Dum.setfont str_a1Em = str_a1Em ++ " setfont\n"
Dum.stdheader :: Dum.Postscript
Dum.stdheader
  = "%!PS-Adobe-2.0\n\
    \%%Created by Haskell Graph Package\n"
Dum.gslandscape = ""
Dum.landscape
  = Dum.translate 8 290
    ++ Dum.rotate 270 ++ Dum.translate 20 10 ++ "0.9 0.9 scale\n"
Dum.portrait = ""
Dum.stdProcedures = Dum.rightshow ++ Dum.centreshow
Dum.drawObject :: [Dum.Point] -> Dum.Postscript
Dum.drawObject (pts_a1En)
  = Dum.newpath
    ++
      Dum.moveto (Dum.Pt 0 0)
      ++ concat (map Dum.lineto pts_a1En) ++ Dum.thinlines ++ Dum.stroke
Dum.fillObject :: [Dum.Point] -> Dum.Postscript
Dum.fillObject (!(pts_a1Xe))
  = Dum.newpath
    ++
      Dum.moveto (Dum.Pt 0 0)
      ++
        concat (map Dum.lineto pts_a1Xe)
        ++ Dum.closepath ++ Dum.fill ++ Dum.stroke
Dum.fillBox :: Dum.Point -> Int -> Int -> Int -> Dum.Postscript
Dum.fillBox pt_a1Xf (!dx_a1Xg) dy_a1Xh (!c_a1Xi)
  = Dum.newpath
    ++
      Dum.moveto pt_a1Xf
      ++
        Dum.rlineto 0 dy_a1Xh
        ++
          Dum.rlineto dx_a1Xg 0
          ++
            Dum.rlineto 0 (- dy_a1Xh)
            ++ Dum.closepath ++ Dum.setgray c_a1Xi ++ Dum.fill
Dum.drawBox :: Dum.Point -> Int -> Int -> Dum.Postscript
Dum.drawBox (!pt_a1Xj) (!dx_a1Xk) dy_a1Xl
  = Dum.thinlines
    ++
      Dum.newpath
      ++
        Dum.moveto pt_a1Xj
        ++
          Dum.rlineto 0 dy_a1Xl
          ++
            Dum.rlineto dx_a1Xk 0
            ++ Dum.rlineto 0 (- dy_a1Xl) ++ Dum.closepath ++ Dum.stroke
Dum.rjustify (!str_a1Xm) = "(" ++ str_a1Xm ++ ") rightshow\n"
Dum.cjustify (!str_a1Xn) = "(" ++ str_a1Xn ++ ") centreshow\n"
Dum.rightshow
  = "/rightshow\n\
    \{dup stringwidth pop\n\
    \0 exch sub\n\
    \0 rmoveto\n\
    \show } def \n"
Dum.centreshow
  = "/centreshow\n\
    \{dup stringwidth pop\n\
    \0 exch sub\n\
    \2 div\n\
    \0 rmoveto\n\
    \show } def \n"
Dum.fill = "fill\n"
Dum.stroke = "stroke\n"
Dum.closepath = "closepath\n"
Dum.newpath = "newpath\n"
Dum.showpage
  = "showpage\n\
    \\n"
Dum.gsave = "gsave\n"
Dum.grestore = "grestore\n"
Dum.text (!t_a1Xo) = Dum.setgray 0 ++ "(" ++ t_a1Xo ++ ") show\n"
Dum.setgray 0 = "0 setgray\n"
Dum.setgray 10 = "1 setgray\n"
Dum.setgray (!n_a1Xp) = "." ++ show n_a1Xp ++ " setgray\n"
Dum.moveto (Dum.Pt x_a1Xq y_a1Xr)
  = Dum.psCommand "moveto" [x_a1Xq, y_a1Xr]
Dum.rmoveto x_a1Xs (!y_a1Xt)
  = Dum.psCommand "rmoveto" [x_a1Xs, y_a1Xt]
Dum.lineto :: Dum.Point -> Dum.Postscript
Dum.lineto (!((!(Dum.Pt x_a1Xu y_a1Xv))))
  = Dum.psCommand "lineto" [x_a1Xu, y_a1Xv]
Dum.rlineto x_a1Xw (!y_a1Xx)
  = Dum.psCommand "rlineto" [x_a1Xw, y_a1Xx]
Dum.setlinewidth n_a1Xy = Dum.psCommand "setlinewidth" [n_a1Xy]
Dum.thinlines = "0.2 setlinewidth\n"
Dum.rotate n_a1Xz = Dum.psCommand "rotate" [n_a1Xz]
Dum.psCommand c_a1XA (!args_a1XB)
  = concat (map f_a1XC args_a1XB) ++ c_a1XA ++ "\n"
  where
      f_a1XC (!x_a1XD) = show x_a1XD ++ " "
Dum.translate (!x_a1XE) y_a1XF
  = Dum.psCommand "translate" [x_a1XE, y_a1XF]
Dum.scale x_a1XG y_a1XH = Dum.psCommand "scale" [x_a1XG, y_a1XH]
Dum.setcms = "2.84584 2.84584 scale\n"

type Dum.Postscript = String
data Dum.Point
  = Dum.Pt Int Int
  deriving (Eq, Show)


["header_a1El","str_a1Em","stdheader","gslandscape","landscape","portrait","stdProcedures","pts_a1En","(pts_a1En)","pts_a1Xe","(pts_a1Xe)","!(pts_a1Xe)","(!(pts_a1Xe))","pt_a1Xf","dx_a1Xg","safebang@!dx_a1Xg","(!dx_a1Xg)","dy_a1Xh","c_a1Xi","safebang@!c_a1Xi","(!c_a1Xi)","pt_a1Xj","safebang@!pt_a1Xj","(!pt_a1Xj)","dx_a1Xk","safebang@!dx_a1Xk","(!dx_a1Xk)","dy_a1Xl","str_a1Xm","safebang@!str_a1Xm","(!str_a1Xm)","str_a1Xn","safebang@!str_a1Xn","(!str_a1Xn)","rightshow","centreshow","fill","stroke","closepath","newpath","showpage","gsave","grestore","t_a1Xo","safebang@!t_a1Xo","(!t_a1Xo)","0","10","n_a1Xp","!n_a1Xp","(!n_a1Xp)","x_a1Xq","y_a1Xr","Pt x_a1Xq y_a1Xr","(Pt x_a1Xq y_a1Xr)","x_a1Xs","y_a1Xt","safebang@!y_a1Xt","(!y_a1Xt)","x_a1Xu","y_a1Xv","Pt x_a1Xu y_a1Xv","(Pt x_a1Xu y_a1Xv)","!(Pt x_a1Xu y_a1Xv)","(!(Pt x_a1Xu y_a1Xv))","((!(Pt x_a1Xu y_a1Xv)))","!((!(Pt x_a1Xu y_a1Xv)))","(!((!(Pt x_a1Xu y_a1Xv))))","x_a1Xw","y_a1Xx","safebang@!y_a1Xx","(!y_a1Xx)","n_a1Xy","thinlines","n_a1Xz","c_a1XA","args_a1XB","safebang@!args_a1XB","(!args_a1XB)","x_a1XD","!x_a1XD","(!x_a1XD)","x_a1XE","safebang@!x_a1XE","(!x_a1XE)","y_a1XF","x_a1XG","y_a1XH","setcms"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import GRIP
import StdLib
import PSlib
import Graph
import Parse
initialise header_a1El
  = header_a1El ++ "/SMALL /Helvetica findfont 4 scalefont def\n" ++
      "/SMALLBOLD /Helvetica-Bold findfont 4 scalefont def\n"
      ++ "/SMALLITALIC /Helvetica-Oblique findfont 4 scalefont def\n"
      ++ "/NORM /Helvetica findfont 5 scalefont def\n"
      ++ "/BOLD /Helvetica-Bold findfont 5 scalefont def\n"
      ++ "/LARGE /Helvetica-Bold findfont 11 scalefont def\n"
      ++ "NORM setfont\n"
      ++ setcms
      ++ stdProcedures
      ++ thinlines
setfont str_a1Em = str_a1Em ++ " setfont\n"

stdheader :: Postscript
stdheader = "%!PS-Adobe-2.0\n%%Created by Haskell Graph Package\n"
gslandscape = ""
landscape
  = translate 8 290 ++ rotate 270 ++ translate 20 10 ++
      "0.9 0.9 scale\n"
portrait = ""
stdProcedures = rightshow ++ centreshow

drawObject :: [Point] -> Postscript
drawObject (pts_a1En)
  = newpath ++ moveto (Pt 0 0) ++ concat (map lineto pts_a1En) ++
      thinlines
      ++ stroke

fillObject :: [Point] -> Postscript
fillObject (investigate@(pts_a1Xe))
  = newpath ++ moveto (Pt 0 0) ++ concat (map lineto pts_a1Xe) ++
      closepath
      ++ fill
      ++ stroke

fillBox :: Point -> Int -> Int -> Int -> Postscript
fillBox pt_a1Xf (!dx_a1Xg) dy_a1Xh (!c_a1Xi)
  = newpath ++ moveto pt_a1Xf ++ rlineto 0 dy_a1Xh ++
      rlineto dx_a1Xg 0
      ++ rlineto 0 (-dy_a1Xh)
      ++ closepath
      ++ setgray c_a1Xi
      ++ fill

drawBox :: Point -> Int -> Int -> Postscript
drawBox (!pt_a1Xj) (!dx_a1Xk) dy_a1Xl
  = thinlines ++ newpath ++ moveto pt_a1Xj ++ rlineto 0 dy_a1Xl ++
      rlineto dx_a1Xk 0
      ++ rlineto 0 (-dy_a1Xl)
      ++ closepath
      ++ stroke
rjustify (!str_a1Xm) = "(" ++ str_a1Xm ++ ") rightshow\n"
cjustify (!str_a1Xn) = "(" ++ str_a1Xn ++ ") centreshow\n"
rightshow
  = "/rightshow\n{dup stringwidth pop\n0 exch sub\n0 rmoveto\nshow } def \n"
centreshow
  = "/centreshow\n{dup stringwidth pop\n0 exch sub\n2 div\n0 rmoveto\nshow } def \n"
fill = "fill\n"
stroke = "stroke\n"
closepath = "closepath\n"
newpath = "newpath\n"
showpage = "showpage\n\n"
gsave = "gsave\n"
grestore = "grestore\n"
text (!t_a1Xo) = setgray 0 ++ "(" ++ t_a1Xo ++ ") show\n"
setgray 0 = "0 setgray\n"
setgray 10 = "1 setgray\n"
setgray (investigate@n_a1Xp) = "." ++ show n_a1Xp ++ " setgray\n"
moveto (Pt x_a1Xq y_a1Xr) = psCommand "moveto" [x_a1Xq, y_a1Xr]
rmoveto x_a1Xs (!y_a1Xt) = psCommand "rmoveto" [x_a1Xs, y_a1Xt]

lineto :: Point -> Postscript
lineto (investigate@((investigate@(Pt x_a1Xu y_a1Xv))))
  = psCommand "lineto" [x_a1Xu, y_a1Xv]
rlineto x_a1Xw (!y_a1Xx) = psCommand "rlineto" [x_a1Xw, y_a1Xx]
setlinewidth n_a1Xy = psCommand "setlinewidth" [n_a1Xy]
thinlines = "0.2 setlinewidth\n"
rotate n_a1Xz = psCommand "rotate" [n_a1Xz]
psCommand c_a1XA (!args_a1XB)
  = concat (map f_a1XC args_a1XB) ++ c_a1XA ++ "\n"
  where f_a1XC (investigate@x_a1XD) = show x_a1XD ++ " "
translate (!x_a1XE) y_a1XF = psCommand "translate" [x_a1XE, y_a1XF]
scale x_a1XG y_a1XH = psCommand "scale" [x_a1XG, y_a1XH]
setcms = "2.84584 2.84584 scale\n"

type Postscript = String

data Point = Pt Int Int
           deriving (Eq, Show)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.initialise header_a1El
  = header_a1El
    ++
      "/SMALL /Helvetica findfont 4 scalefont def\n"
      ++
        "/SMALLBOLD /Helvetica-Bold findfont 4 scalefont def\n"
        ++
          "/SMALLITALIC /Helvetica-Oblique findfont 4 scalefont def\n"
          ++
            "/NORM /Helvetica findfont 5 scalefont def\n"
            ++
              "/BOLD /Helvetica-Bold findfont 5 scalefont def\n"
              ++
                "/LARGE /Helvetica-Bold findfont 11 scalefont def\n"
                ++
                  "NORM setfont\n"
                  ++ Dum.setcms ++ Dum.stdProcedures ++ Dum.thinlines
Dum.setfont str_a1Em = str_a1Em ++ " setfont\n"
Dum.stdheader :: Dum.Postscript
Dum.stdheader
  = "%!PS-Adobe-2.0\n\
    \%%Created by Haskell Graph Package\n"
Dum.gslandscape = ""
Dum.landscape
  = Dum.translate 8 290
    ++ Dum.rotate 270 ++ Dum.translate 20 10 ++ "0.9 0.9 scale\n"
Dum.portrait = ""
Dum.stdProcedures = Dum.rightshow ++ Dum.centreshow
Dum.drawObject :: [Dum.Point] -> Dum.Postscript
Dum.drawObject (pts_a1En)
  = Dum.newpath
    ++
      Dum.moveto (Dum.Pt 0 0)
      ++ concat (map Dum.lineto pts_a1En) ++ Dum.thinlines ++ Dum.stroke
Dum.fillObject :: [Dum.Point] -> Dum.Postscript
Dum.fillObject (!(pts_a1Xe))
  = Dum.newpath
    ++
      Dum.moveto (Dum.Pt 0 0)
      ++
        concat (map Dum.lineto pts_a1Xe)
        ++ Dum.closepath ++ Dum.fill ++ Dum.stroke
Dum.fillBox :: Dum.Point -> Int -> Int -> Int -> Dum.Postscript
Dum.fillBox pt_a1Xf (!dx_a1Xg) dy_a1Xh (!c_a1Xi)
  = Dum.newpath
    ++
      Dum.moveto pt_a1Xf
      ++
        Dum.rlineto 0 dy_a1Xh
        ++
          Dum.rlineto dx_a1Xg 0
          ++
            Dum.rlineto 0 (- dy_a1Xh)
            ++ Dum.closepath ++ Dum.setgray c_a1Xi ++ Dum.fill
Dum.drawBox :: Dum.Point -> Int -> Int -> Dum.Postscript
Dum.drawBox (!pt_a1Xj) (!dx_a1Xk) dy_a1Xl
  = Dum.thinlines
    ++
      Dum.newpath
      ++
        Dum.moveto pt_a1Xj
        ++
          Dum.rlineto 0 dy_a1Xl
          ++
            Dum.rlineto dx_a1Xk 0
            ++ Dum.rlineto 0 (- dy_a1Xl) ++ Dum.closepath ++ Dum.stroke
Dum.rjustify (!str_a1Xm) = "(" ++ str_a1Xm ++ ") rightshow\n"
Dum.cjustify (!str_a1Xn) = "(" ++ str_a1Xn ++ ") centreshow\n"
Dum.rightshow
  = "/rightshow\n\
    \{dup stringwidth pop\n\
    \0 exch sub\n\
    \0 rmoveto\n\
    \show } def \n"
Dum.centreshow
  = "/centreshow\n\
    \{dup stringwidth pop\n\
    \0 exch sub\n\
    \2 div\n\
    \0 rmoveto\n\
    \show } def \n"
Dum.fill = "fill\n"
Dum.stroke = "stroke\n"
Dum.closepath = "closepath\n"
Dum.newpath = "newpath\n"
Dum.showpage
  = "showpage\n\
    \\n"
Dum.gsave = "gsave\n"
Dum.grestore = "grestore\n"
Dum.text (!t_a1Xo) = Dum.setgray 0 ++ "(" ++ t_a1Xo ++ ") show\n"
Dum.setgray 0 = "0 setgray\n"
Dum.setgray 10 = "1 setgray\n"
Dum.setgray (!n_a1Xp) = "." ++ show n_a1Xp ++ " setgray\n"
Dum.moveto (Dum.Pt x_a1Xq y_a1Xr)
  = Dum.psCommand "moveto" [x_a1Xq, y_a1Xr]
Dum.rmoveto x_a1Xs (!y_a1Xt)
  = Dum.psCommand "rmoveto" [x_a1Xs, y_a1Xt]
Dum.lineto :: Dum.Point -> Dum.Postscript
Dum.lineto (!((!(Dum.Pt x_a1Xu y_a1Xv))))
  = Dum.psCommand "lineto" [x_a1Xu, y_a1Xv]
Dum.rlineto x_a1Xw (!y_a1Xx)
  = Dum.psCommand "rlineto" [x_a1Xw, y_a1Xx]
Dum.setlinewidth n_a1Xy = Dum.psCommand "setlinewidth" [n_a1Xy]
Dum.thinlines = "0.2 setlinewidth\n"
Dum.rotate n_a1Xz = Dum.psCommand "rotate" [n_a1Xz]
Dum.psCommand c_a1XA (!args_a1XB)
  = concat (map f_a1XC args_a1XB) ++ c_a1XA ++ "\n"
  where
      f_a1XC (!x_a1XD) = show x_a1XD ++ " "
Dum.translate (!x_a1XE) y_a1XF
  = Dum.psCommand "translate" [x_a1XE, y_a1XF]
Dum.scale x_a1XG y_a1XH = Dum.psCommand "scale" [x_a1XG, y_a1XH]
Dum.setcms = "2.84584 2.84584 scale\n"

type Dum.Postscript = String
data Dum.Point
  = Dum.Pt Int Int
  deriving (Eq, Show)


["header_a1El","str_a1Em","stdheader","gslandscape","landscape","portrait","stdProcedures","pts_a1En","(pts_a1En)","pts_a1Xe","(pts_a1Xe)","!(pts_a1Xe)","(!(pts_a1Xe))","pt_a1Xf","dx_a1Xg","safebang@!dx_a1Xg","(!dx_a1Xg)","dy_a1Xh","c_a1Xi","safebang@!c_a1Xi","(!c_a1Xi)","pt_a1Xj","safebang@!pt_a1Xj","(!pt_a1Xj)","dx_a1Xk","safebang@!dx_a1Xk","(!dx_a1Xk)","dy_a1Xl","str_a1Xm","safebang@!str_a1Xm","(!str_a1Xm)","str_a1Xn","safebang@!str_a1Xn","(!str_a1Xn)","rightshow","centreshow","fill","stroke","closepath","newpath","showpage","gsave","grestore","t_a1Xo","safebang@!t_a1Xo","(!t_a1Xo)","0","10","n_a1Xp","!n_a1Xp","(!n_a1Xp)","x_a1Xq","y_a1Xr","Pt x_a1Xq y_a1Xr","(Pt x_a1Xq y_a1Xr)","x_a1Xs","y_a1Xt","safebang@!y_a1Xt","(!y_a1Xt)","x_a1Xu","y_a1Xv","Pt x_a1Xu y_a1Xv","(Pt x_a1Xu y_a1Xv)","!(Pt x_a1Xu y_a1Xv)","(!(Pt x_a1Xu y_a1Xv))","((!(Pt x_a1Xu y_a1Xv)))","!((!(Pt x_a1Xu y_a1Xv)))","(!((!(Pt x_a1Xu y_a1Xv))))","x_a1Xw","y_a1Xx","safebang@!y_a1Xx","(!y_a1Xx)","n_a1Xy","thinlines","n_a1Xz","c_a1XA","args_a1XB","safebang@!args_a1XB","(!args_a1XB)","x_a1XD","!x_a1XD","(!x_a1XD)","x_a1XE","safebang@!x_a1XE","(!x_a1XE)","y_a1XF","x_a1XG","y_a1XH","setcms"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Char
import StdLib
initialise header_a1El
  = header_a1El ++ "/SMALL /Helvetica findfont 4 scalefont def\n" ++
      "/SMALLBOLD /Helvetica-Bold findfont 4 scalefont def\n"
      ++ "/SMALLITALIC /Helvetica-Oblique findfont 4 scalefont def\n"
      ++ "/NORM /Helvetica findfont 5 scalefont def\n"
      ++ "/BOLD /Helvetica-Bold findfont 5 scalefont def\n"
      ++ "/LARGE /Helvetica-Bold findfont 11 scalefont def\n"
      ++ "NORM setfont\n"
      ++ setcms
      ++ stdProcedures
      ++ thinlines
setfont str_a1Em = str_a1Em ++ " setfont\n"

stdheader :: Postscript
stdheader = "%!PS-Adobe-2.0\n%%Created by Haskell Graph Package\n"
gslandscape = ""
landscape
  = translate 8 290 ++ rotate 270 ++ translate 20 10 ++
      "0.9 0.9 scale\n"
portrait = ""
stdProcedures = rightshow ++ centreshow

drawObject :: [Point] -> Postscript
drawObject (pts_a1En)
  = newpath ++ moveto (Pt 0 0) ++ concat (map lineto pts_a1En) ++
      thinlines
      ++ stroke

fillObject :: [Point] -> Postscript
fillObject (investigate@(pts_a1Xe))
  = newpath ++ moveto (Pt 0 0) ++ concat (map lineto pts_a1Xe) ++
      closepath
      ++ fill
      ++ stroke

fillBox :: Point -> Int -> Int -> Int -> Postscript
fillBox pt_a1Xf (!dx_a1Xg) dy_a1Xh (!c_a1Xi)
  = newpath ++ moveto pt_a1Xf ++ rlineto 0 dy_a1Xh ++
      rlineto dx_a1Xg 0
      ++ rlineto 0 (-dy_a1Xh)
      ++ closepath
      ++ setgray c_a1Xi
      ++ fill

drawBox :: Point -> Int -> Int -> Postscript
drawBox (!pt_a1Xj) (!dx_a1Xk) dy_a1Xl
  = thinlines ++ newpath ++ moveto pt_a1Xj ++ rlineto 0 dy_a1Xl ++
      rlineto dx_a1Xk 0
      ++ rlineto 0 (-dy_a1Xl)
      ++ closepath
      ++ stroke
rjustify (!str_a1Xm) = "(" ++ str_a1Xm ++ ") rightshow\n"
cjustify (!str_a1Xn) = "(" ++ str_a1Xn ++ ") centreshow\n"
rightshow
  = "/rightshow\n{dup stringwidth pop\n0 exch sub\n0 rmoveto\nshow } def \n"
centreshow
  = "/centreshow\n{dup stringwidth pop\n0 exch sub\n2 div\n0 rmoveto\nshow } def \n"
fill = "fill\n"
stroke = "stroke\n"
closepath = "closepath\n"
newpath = "newpath\n"
showpage = "showpage\n\n"
gsave = "gsave\n"
grestore = "grestore\n"
text (!t_a1Xo) = setgray 0 ++ "(" ++ t_a1Xo ++ ") show\n"
setgray 0 = "0 setgray\n"
setgray 10 = "1 setgray\n"
setgray (investigate@n_a1Xp) = "." ++ show n_a1Xp ++ " setgray\n"
moveto (Pt x_a1Xq y_a1Xr) = psCommand "moveto" [x_a1Xq, y_a1Xr]
rmoveto x_a1Xs (!y_a1Xt) = psCommand "rmoveto" [x_a1Xs, y_a1Xt]

lineto :: Point -> Postscript
lineto (investigate@((investigate@(Pt x_a1Xu y_a1Xv))))
  = psCommand "lineto" [x_a1Xu, y_a1Xv]
rlineto x_a1Xw (!y_a1Xx) = psCommand "rlineto" [x_a1Xw, y_a1Xx]
setlinewidth n_a1Xy = psCommand "setlinewidth" [n_a1Xy]
thinlines = "0.2 setlinewidth\n"
rotate n_a1Xz = psCommand "rotate" [n_a1Xz]
psCommand c_a1XA (!args_a1XB)
  = concat (map f_a1XC args_a1XB) ++ c_a1XA ++ "\n"
  where f_a1XC (investigate@x_a1XD) = show x_a1XD ++ " "
translate (!x_a1XE) y_a1XF = psCommand "translate" [x_a1XE, y_a1XF]
scale x_a1XG y_a1XH = psCommand "scale" [x_a1XG, y_a1XH]
setcms = "2.84584 2.84584 scale\n"

type Postscript = String

data Point = Pt Int Int
           deriving (Eq, Show)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.pair :: a_a1vm -> b_a1vn -> (a_a1vm, b_a1vn)
Dum.pair a_a1vo b_a1vp = (a_a1vo, b_a1vp)
Dum.fstcons :: a_a1vk -> ([a_a1vk], b_a1vl) -> ([a_a1vk], b_a1vl)
Dum.fstcons a_a1vq ((!as_a1vr), (!b_a1vs))
  = (a_a1vq : as_a1vr, b_a1vs)
Dum.sndcons :: b_a1vi -> (a_a1vj, [b_a1vi]) -> (a_a1vj, [b_a1vi])
Dum.sndcons b_a1vt (a_a1vu, bs_a1vv) = (a_a1vu, b_a1vt : bs_a1vv)
Dum.map2 (!f_a1vw) [] (!_) = []
Dum.map2 f_a1vx (!_) (![]) = []
Dum.map2
  (!f_a1vy)
  ((!(a_a1vz : (!l_a1vA))))
  ((!((!b_a1vB) : k_a1vC)))
  = f_a1vy a_a1vz b_a1vB : Dum.map2 f_a1vy l_a1vA k_a1vC
Dum.mapcat :: (a_a1vg -> [b_a1vh]) -> [a_a1vg] -> [b_a1vh]
Dum.mapcat f_a1vD [] = []
Dum.mapcat f_a1vE ((!a_a1vF) : (!l_a1vG))
  = f_a1vE a_a1vF ++ Dum.mapcat f_a1vE l_a1vG
Dum.sort :: Ord a_a1vf => [a_a1vf] -> [a_a1vf]
Dum.sort (![]) = []
Dum.sort (a_a1vH : l_a1vI)
  = (Dum.sort low_a1vJ) ++ [a_a1vH] ++ (Dum.sort high_a1vK)
  where
      (low_a1vJ, (!high_a1vK)) = Dum.group a_a1vH l_a1vI
Dum.group ::
  Ord a_a1ve => a_a1ve -> [a_a1ve] -> ([a_a1ve], [a_a1ve])
Dum.group _ (![]) = ([], [])
Dum.group (!i_a1vL) (a_a1vM : (!l_a1vN))
  = f_a1vO (Dum.group i_a1vL l_a1vN)
  where
      f_a1vO (!(low_a1vP, high_a1vQ))
        | a_a1vM < i_a1vL = (a_a1vM : low_a1vP, high_a1vQ)
        | otherwise = (low_a1vP, a_a1vM : high_a1vQ)
Dum.insert :: Ord a_a1vd => a_a1vd -> [a_a1vd] -> [a_a1vd]
Dum.insert (!a_a1vR) (![]) = [a_a1vR]
Dum.insert a_a1vS as_a1vT@(!(x_a1vU : xs_a1vV))
  | x_a1vU > a_a1vS = a_a1vS : as_a1vT
  | otherwise = x_a1vU : Dum.insert a_a1vS xs_a1vV
Dum.replace :: Eq a_a1vc => a_a1vc -> [a_a1vc] -> [a_a1vc]
Dum.replace a_a1vW [] = []
Dum.replace a_a1vX (x_a1vY : (!xs_a1vZ))
  | a_a1vX == x_a1vY = a_a1vX : xs_a1vZ
  | otherwise = x_a1vY : Dum.replace a_a1vX xs_a1vZ
Dum.remove :: Eq a_a1vb => a_a1vb -> [a_a1vb] -> [a_a1vb]
Dum.remove a_a1w0 (![]) = []
Dum.remove (!a_a1w1) (!(x_a1w2 : (!xs_a1w3)))
  | a_a1w1 == x_a1w2 = xs_a1w3
  | otherwise = x_a1w2 : Dum.remove a_a1w1 xs_a1w3
Dum.collect ::
  Ord a_azq => (b_azr -> a_azq) -> [a_azq] -> [b_azr] -> [b_azr]
Dum.collect (!_) (![]) (!_) = []
Dum.collect (!_) (!_) [] = []
Dum.collect
  (!p_a1w4)
  as_a1w5@(!((!a_a1w6) : l_a1w7))
  bs_a1w8@(!((!b_a1w9) : k_a1wa))
  | a_a1w6 == p_a1w4 b_a1w9
  = b_a1w9 : Dum.collect p_a1w4 l_a1w7 k_a1wa
  | p_a1w4 b_a1w9 > a_a1w6 = Dum.collect p_a1w4 l_a1w7 bs_a1w8
  | otherwise = Dum.collect p_a1w4 as_a1w5 k_a1wa
Dum.span' :: (a_azp -> Bool) -> [a_azp] -> ([a_azp], [a_azp])
Dum.span' p_a1wb (![]) = ([], [])
Dum.span' (!p_a1wc) (!(x_a1wd : xs'_a1we))
  | p_a1wc x_a1wd = fixLeak_a1wf x_a1wd (Dum.span' p_a1wc xs'_a1we)
  where
      fixLeak_a1wf (!x_a1wg) (xs_a1wh, ys_a1wi)
        = (x_a1wg : xs_a1wh, ys_a1wi)
Dum.span' (!_) (!xs_a1wj) = ([], xs_a1wj)
Dum.lines' :: [Char] -> [[Char]]
Dum.lines' (!"") = []
Dum.lines' s_a1wk
  = plumb_a1wl (Dum.span' ((/=) '\n') s_a1wk)
  where
      plumb_a1wl (l_a1wm, s'_a1wn)
        = l_a1wm : if null s'_a1wn then [] else Dum.lines' (tail s'_a1wn)
Dum.strToInt :: String -> Int
Dum.strToInt (!x_a1SV)
  = strToInt'_a1SW (length x_a1SV - 1) x_a1SV
  where
      strToInt'_a1SW _ [] = 0
      strToInt'_a1SW (!x_a1SX) ((!a_a1SY) : (!l_a1SZ))
        = (Dum.charToInt a_a1SY) * (10 ^ x_a1SX)
          + (strToInt'_a1SW (x_a1SX - 1) l_a1SZ)
Dum.charToInt :: Char -> Int
Dum.charToInt x_a23O = (fromEnum x_a23O - fromEnum '0')


["a_a1vo","b_a1vp","a_a1vq","as_a1vr","safebang@!as_a1vr","(!as_a1vr)","b_a1vs","safebang@!b_a1vs","(!b_a1vs)","((!as_a1vr), (!b_a1vs))","b_a1vt","a_a1vu","bs_a1vv","(a_a1vu, bs_a1vv)","f_a1vw","safebang@!f_a1vw","(!f_a1vw)","[]","_","!_","(!_)","f_a1vx","_","!_","(!_)","[]","![]","(![])","f_a1vy","!f_a1vy","(!f_a1vy)","a_a1vz","l_a1vA","!l_a1vA","(!l_a1vA)","a_a1vz : (!l_a1vA)","(a_a1vz : (!l_a1vA))","!(a_a1vz : (!l_a1vA))","(!(a_a1vz : (!l_a1vA)))","((!(a_a1vz : (!l_a1vA))))","b_a1vB","!b_a1vB","(!b_a1vB)","k_a1vC","(!b_a1vB) : k_a1vC","((!b_a1vB) : k_a1vC)","!((!b_a1vB) : k_a1vC)","(!((!b_a1vB) : k_a1vC))","((!((!b_a1vB) : k_a1vC)))","f_a1vD","[]","f_a1vE","a_a1vF","safebang@!a_a1vF","(!a_a1vF)","l_a1vG","safebang@!l_a1vG","(!l_a1vG)","(!a_a1vF) : (!l_a1vG)","((!a_a1vF) : (!l_a1vG))","[]","![]","(![])","a_a1vH","l_a1vI","a_a1vH : l_a1vI","(a_a1vH : l_a1vI)","low_a1vJ","high_a1vK","!high_a1vK","(!high_a1vK)","(low_a1vJ, (!high_a1vK))","_","[]","![]","(![])","i_a1vL","!i_a1vL","(!i_a1vL)","a_a1vM","l_a1vN","!l_a1vN","(!l_a1vN)","a_a1vM : (!l_a1vN)","(a_a1vM : (!l_a1vN))","low_a1vP","high_a1vQ","(low_a1vP, high_a1vQ)","!(low_a1vP, high_a1vQ)","(!(low_a1vP, high_a1vQ))","a_a1vR","safebang@!a_a1vR","(!a_a1vR)","[]","![]","(![])","a_a1vS","x_a1vU","xs_a1vV","x_a1vU : xs_a1vV","(x_a1vU : xs_a1vV)","!(x_a1vU : xs_a1vV)","(!(x_a1vU : xs_a1vV))","as_a1vT@(!(x_a1vU : xs_a1vV))","a_a1vW","[]","a_a1vX","x_a1vY","xs_a1vZ","safebang@!xs_a1vZ","(!xs_a1vZ)","x_a1vY : (!xs_a1vZ)","(x_a1vY : (!xs_a1vZ))","a_a1w0","[]","![]","(![])","a_a1w1","!a_a1w1","(!a_a1w1)","x_a1w2","xs_a1w3","!xs_a1w3","(!xs_a1w3)","x_a1w2 : (!xs_a1w3)","(x_a1w2 : (!xs_a1w3))","!(x_a1w2 : (!xs_a1w3))","(!(x_a1w2 : (!xs_a1w3)))","_","!_","(!_)","[]","![]","(![])","_","!_","(!_)","_","!_","(!_)","_","!_","(!_)","[]","p_a1w4","!p_a1w4","(!p_a1w4)","a_a1w6","!a_a1w6","(!a_a1w6)","l_a1w7","(!a_a1w6) : l_a1w7","((!a_a1w6) : l_a1w7)","!((!a_a1w6) : l_a1w7)","(!((!a_a1w6) : l_a1w7))","as_a1w5@(!((!a_a1w6) : l_a1w7))","b_a1w9","!b_a1w9","(!b_a1w9)","k_a1wa","(!b_a1w9) : k_a1wa","((!b_a1w9) : k_a1wa)","!((!b_a1w9) : k_a1wa)","(!((!b_a1w9) : k_a1wa))","bs_a1w8@(!((!b_a1w9) : k_a1wa))","p_a1wb","[]","![]","(![])","p_a1wc","!p_a1wc","(!p_a1wc)","x_a1wd","xs'_a1we","x_a1wd : xs'_a1we","(x_a1wd : xs'_a1we)","!(x_a1wd : xs'_a1we)","(!(x_a1wd : xs'_a1we))","x_a1wg","!x_a1wg","(!x_a1wg)","xs_a1wh","ys_a1wi","(xs_a1wh, ys_a1wi)","_","!_","(!_)","xs_a1wj","!xs_a1wj","(!xs_a1wj)","\"\"","!\"\"","(!\"\")","s_a1wk","l_a1wm","s'_a1wn","(l_a1wm, s'_a1wn)","x_a1SV","safebang@!x_a1SV","(!x_a1SV)","_","[]","x_a1SX","!x_a1SX","(!x_a1SX)","a_a1SY","!a_a1SY","(!a_a1SY)","l_a1SZ","!l_a1SZ","(!l_a1SZ)","(!a_a1SY) : (!l_a1SZ)","((!a_a1SY) : (!l_a1SZ))","x_a23O"]
{-# LANGUAGE BangPatterns #-}
module Dum where

pair :: a_a1vm -> b_a1vn -> (a_a1vm, b_a1vn)
pair a_a1vo b_a1vp = (a_a1vo, b_a1vp)

fstcons :: a_a1vk -> ([a_a1vk], b_a1vl) -> ([a_a1vk], b_a1vl)
fstcons a_a1vq ((!as_a1vr), (!b_a1vs)) = (a_a1vq : as_a1vr, b_a1vs)

sndcons :: b_a1vi -> (a_a1vj, [b_a1vi]) -> (a_a1vj, [b_a1vi])
sndcons b_a1vt (a_a1vu, bs_a1vv) = (a_a1vu, b_a1vt : bs_a1vv)
map2 (!f_a1vw) [] (investigate@_) = []
map2 f_a1vx (investigate@_) (investigate@[]) = []
map2 (investigate@f_a1vy)
  ((investigate@(a_a1vz : (investigate@l_a1vA))))
  ((investigate@((investigate@b_a1vB) : k_a1vC)))
  = f_a1vy a_a1vz b_a1vB : map2 f_a1vy l_a1vA k_a1vC

mapcat :: (a_a1vg -> [b_a1vh]) -> [a_a1vg] -> [b_a1vh]
mapcat f_a1vD [] = []
mapcat f_a1vE ((!a_a1vF) : (!l_a1vG))
  = f_a1vE a_a1vF ++ mapcat f_a1vE l_a1vG

sort :: Ord a_a1vf => [a_a1vf] -> [a_a1vf]
sort (investigate@[]) = []
sort (a_a1vH : l_a1vI)
  = (sort low_a1vJ) ++ [a_a1vH] ++ (sort high_a1vK)
  where (low_a1vJ, (investigate@high_a1vK)) = group a_a1vH l_a1vI

group :: Ord a_a1ve => a_a1ve -> [a_a1ve] -> ([a_a1ve], [a_a1ve])
group _ (investigate@[]) = ([], [])
group (investigate@i_a1vL) (a_a1vM : (investigate@l_a1vN))
  = f_a1vO (group i_a1vL l_a1vN)
  where f_a1vO (investigate@(low_a1vP, high_a1vQ))
          | a_a1vM < i_a1vL = (a_a1vM : low_a1vP, high_a1vQ)
          | otherwise = (low_a1vP, a_a1vM : high_a1vQ)

insert :: Ord a_a1vd => a_a1vd -> [a_a1vd] -> [a_a1vd]
insert (!a_a1vR) (investigate@[]) = [a_a1vR]
insert a_a1vS as_a1vT@(investigate@(x_a1vU : xs_a1vV))
  | x_a1vU > a_a1vS = a_a1vS : as_a1vT
  | otherwise = x_a1vU : insert a_a1vS xs_a1vV

replace :: Eq a_a1vc => a_a1vc -> [a_a1vc] -> [a_a1vc]
replace a_a1vW [] = []
replace a_a1vX (x_a1vY : (!xs_a1vZ))
  | a_a1vX == x_a1vY = a_a1vX : xs_a1vZ
  | otherwise = x_a1vY : replace a_a1vX xs_a1vZ

remove :: Eq a_a1vb => a_a1vb -> [a_a1vb] -> [a_a1vb]
remove a_a1w0 (investigate@[]) = []
remove (investigate@a_a1w1)
  (investigate@(x_a1w2 : (investigate@xs_a1w3)))
  | a_a1w1 == x_a1w2 = xs_a1w3
  | otherwise = x_a1w2 : remove a_a1w1 xs_a1w3

collect ::
          Ord a_azq => (b_azr -> a_azq) -> [a_azq] -> [b_azr] -> [b_azr]
collect (investigate@_) (investigate@[]) (investigate@_) = []
collect (investigate@_) (investigate@_) [] = []
collect (investigate@p_a1w4)
  as_a1w5@(investigate@((investigate@a_a1w6) : l_a1w7))
  bs_a1w8@(investigate@((investigate@b_a1w9) : k_a1wa))
  | a_a1w6 == p_a1w4 b_a1w9 = b_a1w9 : collect p_a1w4 l_a1w7 k_a1wa
  | p_a1w4 b_a1w9 > a_a1w6 = collect p_a1w4 l_a1w7 bs_a1w8
  | otherwise = collect p_a1w4 as_a1w5 k_a1wa

span' :: (a_azp -> Bool) -> [a_azp] -> ([a_azp], [a_azp])
span' p_a1wb (investigate@[]) = ([], [])
span' (investigate@p_a1wc) (investigate@(x_a1wd : xs'_a1we))
  | p_a1wc x_a1wd = fixLeak_a1wf x_a1wd (span' p_a1wc xs'_a1we)
  where fixLeak_a1wf (investigate@x_a1wg) (xs_a1wh, ys_a1wi)
          = (x_a1wg : xs_a1wh, ys_a1wi)
span' (investigate@_) (investigate@xs_a1wj) = ([], xs_a1wj)

lines' :: [Char] -> [[Char]]
lines' (investigate@"") = []
lines' s_a1wk = plumb_a1wl (span' ((/=) '\n') s_a1wk)
  where plumb_a1wl (l_a1wm, s'_a1wn)
          = l_a1wm : if null s'_a1wn then [] else lines' (tail s'_a1wn)

strToInt :: String -> Int
strToInt (!x_a1SV) = strToInt'_a1SW (length x_a1SV - 1) x_a1SV
  where strToInt'_a1SW _ [] = 0
        strToInt'_a1SW (investigate@x_a1SX)
          ((investigate@a_a1SY) : (investigate@l_a1SZ))
          = (charToInt a_a1SY) * (10 ^ x_a1SX) +
              (strToInt'_a1SW (x_a1SX - 1) l_a1SZ)

charToInt :: Char -> Int
charToInt x_a23O = (fromEnum x_a23O - fromEnum '0')
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.pair :: a_a1vm -> b_a1vn -> (a_a1vm, b_a1vn)
Dum.pair a_a1vo b_a1vp = (a_a1vo, b_a1vp)
Dum.fstcons :: a_a1vk -> ([a_a1vk], b_a1vl) -> ([a_a1vk], b_a1vl)
Dum.fstcons a_a1vq ((!as_a1vr), (!b_a1vs))
  = (a_a1vq : as_a1vr, b_a1vs)
Dum.sndcons :: b_a1vi -> (a_a1vj, [b_a1vi]) -> (a_a1vj, [b_a1vi])
Dum.sndcons b_a1vt (a_a1vu, bs_a1vv) = (a_a1vu, b_a1vt : bs_a1vv)
Dum.map2 (!f_a1vw) [] (!_) = []
Dum.map2 f_a1vx (!_) (![]) = []
Dum.map2
  (!f_a1vy)
  ((!(a_a1vz : (!l_a1vA))))
  ((!((!b_a1vB) : k_a1vC)))
  = f_a1vy a_a1vz b_a1vB : Dum.map2 f_a1vy l_a1vA k_a1vC
Dum.mapcat :: (a_a1vg -> [b_a1vh]) -> [a_a1vg] -> [b_a1vh]
Dum.mapcat f_a1vD [] = []
Dum.mapcat f_a1vE ((!a_a1vF) : (!l_a1vG))
  = f_a1vE a_a1vF ++ Dum.mapcat f_a1vE l_a1vG
Dum.sort :: Ord a_a1vf => [a_a1vf] -> [a_a1vf]
Dum.sort (![]) = []
Dum.sort (a_a1vH : l_a1vI)
  = (Dum.sort low_a1vJ) ++ [a_a1vH] ++ (Dum.sort high_a1vK)
  where
      (low_a1vJ, (!high_a1vK)) = Dum.group a_a1vH l_a1vI
Dum.group ::
  Ord a_a1ve => a_a1ve -> [a_a1ve] -> ([a_a1ve], [a_a1ve])
Dum.group _ (![]) = ([], [])
Dum.group (!i_a1vL) (a_a1vM : (!l_a1vN))
  = f_a1vO (Dum.group i_a1vL l_a1vN)
  where
      f_a1vO (!(low_a1vP, high_a1vQ))
        | a_a1vM < i_a1vL = (a_a1vM : low_a1vP, high_a1vQ)
        | otherwise = (low_a1vP, a_a1vM : high_a1vQ)
Dum.insert :: Ord a_a1vd => a_a1vd -> [a_a1vd] -> [a_a1vd]
Dum.insert (!a_a1vR) (![]) = [a_a1vR]
Dum.insert a_a1vS as_a1vT@(!(x_a1vU : xs_a1vV))
  | x_a1vU > a_a1vS = a_a1vS : as_a1vT
  | otherwise = x_a1vU : Dum.insert a_a1vS xs_a1vV
Dum.replace :: Eq a_a1vc => a_a1vc -> [a_a1vc] -> [a_a1vc]
Dum.replace a_a1vW [] = []
Dum.replace a_a1vX (x_a1vY : (!xs_a1vZ))
  | a_a1vX == x_a1vY = a_a1vX : xs_a1vZ
  | otherwise = x_a1vY : Dum.replace a_a1vX xs_a1vZ
Dum.remove :: Eq a_a1vb => a_a1vb -> [a_a1vb] -> [a_a1vb]
Dum.remove a_a1w0 (![]) = []
Dum.remove (!a_a1w1) (!(x_a1w2 : (!xs_a1w3)))
  | a_a1w1 == x_a1w2 = xs_a1w3
  | otherwise = x_a1w2 : Dum.remove a_a1w1 xs_a1w3
Dum.collect ::
  Ord a_azq => (b_azr -> a_azq) -> [a_azq] -> [b_azr] -> [b_azr]
Dum.collect (!_) (![]) (!_) = []
Dum.collect (!_) (!_) [] = []
Dum.collect
  (!p_a1w4)
  as_a1w5@(!((!a_a1w6) : l_a1w7))
  bs_a1w8@(!((!b_a1w9) : k_a1wa))
  | a_a1w6 == p_a1w4 b_a1w9
  = b_a1w9 : Dum.collect p_a1w4 l_a1w7 k_a1wa
  | p_a1w4 b_a1w9 > a_a1w6 = Dum.collect p_a1w4 l_a1w7 bs_a1w8
  | otherwise = Dum.collect p_a1w4 as_a1w5 k_a1wa
Dum.span' :: (a_azp -> Bool) -> [a_azp] -> ([a_azp], [a_azp])
Dum.span' p_a1wb (![]) = ([], [])
Dum.span' (!p_a1wc) (!(x_a1wd : xs'_a1we))
  | p_a1wc x_a1wd = fixLeak_a1wf x_a1wd (Dum.span' p_a1wc xs'_a1we)
  where
      fixLeak_a1wf (!x_a1wg) (xs_a1wh, ys_a1wi)
        = (x_a1wg : xs_a1wh, ys_a1wi)
Dum.span' (!_) (!xs_a1wj) = ([], xs_a1wj)
Dum.lines' :: [Char] -> [[Char]]
Dum.lines' (!"") = []
Dum.lines' s_a1wk
  = plumb_a1wl (Dum.span' ((/=) '\n') s_a1wk)
  where
      plumb_a1wl (l_a1wm, s'_a1wn)
        = l_a1wm : if null s'_a1wn then [] else Dum.lines' (tail s'_a1wn)
Dum.strToInt :: String -> Int
Dum.strToInt (!x_a1SV)
  = strToInt'_a1SW (length x_a1SV - 1) x_a1SV
  where
      strToInt'_a1SW _ [] = 0
      strToInt'_a1SW (!x_a1SX) ((!a_a1SY) : (!l_a1SZ))
        = (Dum.charToInt a_a1SY) * (10 ^ x_a1SX)
          + (strToInt'_a1SW (x_a1SX - 1) l_a1SZ)
Dum.charToInt :: Char -> Int
Dum.charToInt x_a23O = (fromEnum x_a23O - fromEnum '0')


["a_a1vo","b_a1vp","a_a1vq","as_a1vr","safebang@!as_a1vr","(!as_a1vr)","b_a1vs","safebang@!b_a1vs","(!b_a1vs)","((!as_a1vr), (!b_a1vs))","b_a1vt","a_a1vu","bs_a1vv","(a_a1vu, bs_a1vv)","f_a1vw","safebang@!f_a1vw","(!f_a1vw)","[]","_","!_","(!_)","f_a1vx","_","!_","(!_)","[]","![]","(![])","f_a1vy","!f_a1vy","(!f_a1vy)","a_a1vz","l_a1vA","!l_a1vA","(!l_a1vA)","a_a1vz : (!l_a1vA)","(a_a1vz : (!l_a1vA))","!(a_a1vz : (!l_a1vA))","(!(a_a1vz : (!l_a1vA)))","((!(a_a1vz : (!l_a1vA))))","b_a1vB","!b_a1vB","(!b_a1vB)","k_a1vC","(!b_a1vB) : k_a1vC","((!b_a1vB) : k_a1vC)","!((!b_a1vB) : k_a1vC)","(!((!b_a1vB) : k_a1vC))","((!((!b_a1vB) : k_a1vC)))","f_a1vD","[]","f_a1vE","a_a1vF","safebang@!a_a1vF","(!a_a1vF)","l_a1vG","safebang@!l_a1vG","(!l_a1vG)","(!a_a1vF) : (!l_a1vG)","((!a_a1vF) : (!l_a1vG))","[]","![]","(![])","a_a1vH","l_a1vI","a_a1vH : l_a1vI","(a_a1vH : l_a1vI)","low_a1vJ","high_a1vK","!high_a1vK","(!high_a1vK)","(low_a1vJ, (!high_a1vK))","_","[]","![]","(![])","i_a1vL","!i_a1vL","(!i_a1vL)","a_a1vM","l_a1vN","!l_a1vN","(!l_a1vN)","a_a1vM : (!l_a1vN)","(a_a1vM : (!l_a1vN))","low_a1vP","high_a1vQ","(low_a1vP, high_a1vQ)","!(low_a1vP, high_a1vQ)","(!(low_a1vP, high_a1vQ))","a_a1vR","safebang@!a_a1vR","(!a_a1vR)","[]","![]","(![])","a_a1vS","x_a1vU","xs_a1vV","x_a1vU : xs_a1vV","(x_a1vU : xs_a1vV)","!(x_a1vU : xs_a1vV)","(!(x_a1vU : xs_a1vV))","as_a1vT@(!(x_a1vU : xs_a1vV))","a_a1vW","[]","a_a1vX","x_a1vY","xs_a1vZ","safebang@!xs_a1vZ","(!xs_a1vZ)","x_a1vY : (!xs_a1vZ)","(x_a1vY : (!xs_a1vZ))","a_a1w0","[]","![]","(![])","a_a1w1","!a_a1w1","(!a_a1w1)","x_a1w2","xs_a1w3","!xs_a1w3","(!xs_a1w3)","x_a1w2 : (!xs_a1w3)","(x_a1w2 : (!xs_a1w3))","!(x_a1w2 : (!xs_a1w3))","(!(x_a1w2 : (!xs_a1w3)))","_","!_","(!_)","[]","![]","(![])","_","!_","(!_)","_","!_","(!_)","_","!_","(!_)","[]","p_a1w4","!p_a1w4","(!p_a1w4)","a_a1w6","!a_a1w6","(!a_a1w6)","l_a1w7","(!a_a1w6) : l_a1w7","((!a_a1w6) : l_a1w7)","!((!a_a1w6) : l_a1w7)","(!((!a_a1w6) : l_a1w7))","as_a1w5@(!((!a_a1w6) : l_a1w7))","b_a1w9","!b_a1w9","(!b_a1w9)","k_a1wa","(!b_a1w9) : k_a1wa","((!b_a1w9) : k_a1wa)","!((!b_a1w9) : k_a1wa)","(!((!b_a1w9) : k_a1wa))","bs_a1w8@(!((!b_a1w9) : k_a1wa))","p_a1wb","[]","![]","(![])","p_a1wc","!p_a1wc","(!p_a1wc)","x_a1wd","xs'_a1we","x_a1wd : xs'_a1we","(x_a1wd : xs'_a1we)","!(x_a1wd : xs'_a1we)","(!(x_a1wd : xs'_a1we))","x_a1wg","!x_a1wg","(!x_a1wg)","xs_a1wh","ys_a1wi","(xs_a1wh, ys_a1wi)","_","!_","(!_)","xs_a1wj","!xs_a1wj","(!xs_a1wj)","\"\"","!\"\"","(!\"\")","s_a1wk","l_a1wm","s'_a1wn","(l_a1wm, s'_a1wn)","x_a1SV","safebang@!x_a1SV","(!x_a1SV)","_","[]","x_a1SX","!x_a1SX","(!x_a1SX)","a_a1SY","!a_a1SY","(!a_a1SY)","l_a1SZ","!l_a1SZ","(!l_a1SZ)","(!a_a1SY) : (!l_a1SZ)","((!a_a1SY) : (!l_a1SZ))","x_a23O"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import PSlib
import StdLib
import Parse

pair :: a_a1vm -> b_a1vn -> (a_a1vm, b_a1vn)
pair a_a1vo b_a1vp = (a_a1vo, b_a1vp)

fstcons :: a_a1vk -> ([a_a1vk], b_a1vl) -> ([a_a1vk], b_a1vl)
fstcons a_a1vq ((!as_a1vr), (!b_a1vs)) = (a_a1vq : as_a1vr, b_a1vs)

sndcons :: b_a1vi -> (a_a1vj, [b_a1vi]) -> (a_a1vj, [b_a1vi])
sndcons b_a1vt (a_a1vu, bs_a1vv) = (a_a1vu, b_a1vt : bs_a1vv)
map2 (!f_a1vw) [] (investigate@_) = []
map2 f_a1vx (investigate@_) (investigate@[]) = []
map2 (investigate@f_a1vy)
  ((investigate@(a_a1vz : (investigate@l_a1vA))))
  ((investigate@((investigate@b_a1vB) : k_a1vC)))
  = f_a1vy a_a1vz b_a1vB : map2 f_a1vy l_a1vA k_a1vC

mapcat :: (a_a1vg -> [b_a1vh]) -> [a_a1vg] -> [b_a1vh]
mapcat f_a1vD [] = []
mapcat f_a1vE ((!a_a1vF) : (!l_a1vG))
  = f_a1vE a_a1vF ++ mapcat f_a1vE l_a1vG

sort :: Ord a_a1vf => [a_a1vf] -> [a_a1vf]
sort (investigate@[]) = []
sort (a_a1vH : l_a1vI)
  = (sort low_a1vJ) ++ [a_a1vH] ++ (sort high_a1vK)
  where (low_a1vJ, (investigate@high_a1vK)) = group a_a1vH l_a1vI

group :: Ord a_a1ve => a_a1ve -> [a_a1ve] -> ([a_a1ve], [a_a1ve])
group _ (investigate@[]) = ([], [])
group (investigate@i_a1vL) (a_a1vM : (investigate@l_a1vN))
  = f_a1vO (group i_a1vL l_a1vN)
  where f_a1vO (investigate@(low_a1vP, high_a1vQ))
          | a_a1vM < i_a1vL = (a_a1vM : low_a1vP, high_a1vQ)
          | otherwise = (low_a1vP, a_a1vM : high_a1vQ)

insert :: Ord a_a1vd => a_a1vd -> [a_a1vd] -> [a_a1vd]
insert (!a_a1vR) (investigate@[]) = [a_a1vR]
insert a_a1vS as_a1vT@(investigate@(x_a1vU : xs_a1vV))
  | x_a1vU > a_a1vS = a_a1vS : as_a1vT
  | otherwise = x_a1vU : insert a_a1vS xs_a1vV

replace :: Eq a_a1vc => a_a1vc -> [a_a1vc] -> [a_a1vc]
replace a_a1vW [] = []
replace a_a1vX (x_a1vY : (!xs_a1vZ))
  | a_a1vX == x_a1vY = a_a1vX : xs_a1vZ
  | otherwise = x_a1vY : replace a_a1vX xs_a1vZ

remove :: Eq a_a1vb => a_a1vb -> [a_a1vb] -> [a_a1vb]
remove a_a1w0 (investigate@[]) = []
remove (investigate@a_a1w1)
  (investigate@(x_a1w2 : (investigate@xs_a1w3)))
  | a_a1w1 == x_a1w2 = xs_a1w3
  | otherwise = x_a1w2 : remove a_a1w1 xs_a1w3

collect ::
          Ord a_azq => (b_azr -> a_azq) -> [a_azq] -> [b_azr] -> [b_azr]
collect (investigate@_) (investigate@[]) (investigate@_) = []
collect (investigate@_) (investigate@_) [] = []
collect (investigate@p_a1w4)
  as_a1w5@(investigate@((investigate@a_a1w6) : l_a1w7))
  bs_a1w8@(investigate@((investigate@b_a1w9) : k_a1wa))
  | a_a1w6 == p_a1w4 b_a1w9 = b_a1w9 : collect p_a1w4 l_a1w7 k_a1wa
  | p_a1w4 b_a1w9 > a_a1w6 = collect p_a1w4 l_a1w7 bs_a1w8
  | otherwise = collect p_a1w4 as_a1w5 k_a1wa

span' :: (a_azp -> Bool) -> [a_azp] -> ([a_azp], [a_azp])
span' p_a1wb (investigate@[]) = ([], [])
span' (investigate@p_a1wc) (investigate@(x_a1wd : xs'_a1we))
  | p_a1wc x_a1wd = fixLeak_a1wf x_a1wd (span' p_a1wc xs'_a1we)
  where fixLeak_a1wf (investigate@x_a1wg) (xs_a1wh, ys_a1wi)
          = (x_a1wg : xs_a1wh, ys_a1wi)
span' (investigate@_) (investigate@xs_a1wj) = ([], xs_a1wj)

lines' :: [Char] -> [[Char]]
lines' (investigate@"") = []
lines' s_a1wk = plumb_a1wl (span' ((/=) '\n') s_a1wk)
  where plumb_a1wl (l_a1wm, s'_a1wn)
          = l_a1wm : if null s'_a1wn then [] else lines' (tail s'_a1wn)

strToInt :: String -> Int
strToInt (!x_a1SV) = strToInt'_a1SW (length x_a1SV - 1) x_a1SV
  where strToInt'_a1SW _ [] = 0
        strToInt'_a1SW (investigate@x_a1SX)
          ((investigate@a_a1SY) : (investigate@l_a1SZ))
          = (charToInt a_a1SY) * (10 ^ x_a1SX) +
              (strToInt'_a1SW (x_a1SX - 1) l_a1SZ)

charToInt :: Char -> Int
charToInt x_a23O = (fromEnum x_a23O - fromEnum '0')
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.pair :: a_a1vm -> b_a1vn -> (a_a1vm, b_a1vn)
Dum.pair a_a1vo b_a1vp = (a_a1vo, b_a1vp)
Dum.fstcons :: a_a1vk -> ([a_a1vk], b_a1vl) -> ([a_a1vk], b_a1vl)
Dum.fstcons a_a1vq ((!as_a1vr), (!b_a1vs))
  = (a_a1vq : as_a1vr, b_a1vs)
Dum.sndcons :: b_a1vi -> (a_a1vj, [b_a1vi]) -> (a_a1vj, [b_a1vi])
Dum.sndcons b_a1vt (a_a1vu, bs_a1vv) = (a_a1vu, b_a1vt : bs_a1vv)
Dum.map2 (!f_a1vw) [] (!_) = []
Dum.map2 f_a1vx (!_) (![]) = []
Dum.map2
  (!f_a1vy)
  ((!(a_a1vz : (!l_a1vA))))
  ((!((!b_a1vB) : k_a1vC)))
  = f_a1vy a_a1vz b_a1vB : Dum.map2 f_a1vy l_a1vA k_a1vC
Dum.mapcat :: (a_a1vg -> [b_a1vh]) -> [a_a1vg] -> [b_a1vh]
Dum.mapcat f_a1vD [] = []
Dum.mapcat f_a1vE ((!a_a1vF) : (!l_a1vG))
  = f_a1vE a_a1vF ++ Dum.mapcat f_a1vE l_a1vG
Dum.sort :: Ord a_a1vf => [a_a1vf] -> [a_a1vf]
Dum.sort (![]) = []
Dum.sort (a_a1vH : l_a1vI)
  = (Dum.sort low_a1vJ) ++ [a_a1vH] ++ (Dum.sort high_a1vK)
  where
      (low_a1vJ, (!high_a1vK)) = Dum.group a_a1vH l_a1vI
Dum.group ::
  Ord a_a1ve => a_a1ve -> [a_a1ve] -> ([a_a1ve], [a_a1ve])
Dum.group _ (![]) = ([], [])
Dum.group (!i_a1vL) (a_a1vM : (!l_a1vN))
  = f_a1vO (Dum.group i_a1vL l_a1vN)
  where
      f_a1vO (!(low_a1vP, high_a1vQ))
        | a_a1vM < i_a1vL = (a_a1vM : low_a1vP, high_a1vQ)
        | otherwise = (low_a1vP, a_a1vM : high_a1vQ)
Dum.insert :: Ord a_a1vd => a_a1vd -> [a_a1vd] -> [a_a1vd]
Dum.insert (!a_a1vR) (![]) = [a_a1vR]
Dum.insert a_a1vS as_a1vT@(!(x_a1vU : xs_a1vV))
  | x_a1vU > a_a1vS = a_a1vS : as_a1vT
  | otherwise = x_a1vU : Dum.insert a_a1vS xs_a1vV
Dum.replace :: Eq a_a1vc => a_a1vc -> [a_a1vc] -> [a_a1vc]
Dum.replace a_a1vW [] = []
Dum.replace a_a1vX (x_a1vY : (!xs_a1vZ))
  | a_a1vX == x_a1vY = a_a1vX : xs_a1vZ
  | otherwise = x_a1vY : Dum.replace a_a1vX xs_a1vZ
Dum.remove :: Eq a_a1vb => a_a1vb -> [a_a1vb] -> [a_a1vb]
Dum.remove a_a1w0 (![]) = []
Dum.remove (!a_a1w1) (!(x_a1w2 : (!xs_a1w3)))
  | a_a1w1 == x_a1w2 = xs_a1w3
  | otherwise = x_a1w2 : Dum.remove a_a1w1 xs_a1w3
Dum.collect ::
  Ord a_azq => (b_azr -> a_azq) -> [a_azq] -> [b_azr] -> [b_azr]
Dum.collect (!_) (![]) (!_) = []
Dum.collect (!_) (!_) [] = []
Dum.collect
  (!p_a1w4)
  as_a1w5@(!((!a_a1w6) : l_a1w7))
  bs_a1w8@(!((!b_a1w9) : k_a1wa))
  | a_a1w6 == p_a1w4 b_a1w9
  = b_a1w9 : Dum.collect p_a1w4 l_a1w7 k_a1wa
  | p_a1w4 b_a1w9 > a_a1w6 = Dum.collect p_a1w4 l_a1w7 bs_a1w8
  | otherwise = Dum.collect p_a1w4 as_a1w5 k_a1wa
Dum.span' :: (a_azp -> Bool) -> [a_azp] -> ([a_azp], [a_azp])
Dum.span' p_a1wb (![]) = ([], [])
Dum.span' (!p_a1wc) (!(x_a1wd : xs'_a1we))
  | p_a1wc x_a1wd = fixLeak_a1wf x_a1wd (Dum.span' p_a1wc xs'_a1we)
  where
      fixLeak_a1wf (!x_a1wg) (xs_a1wh, ys_a1wi)
        = (x_a1wg : xs_a1wh, ys_a1wi)
Dum.span' (!_) (!xs_a1wj) = ([], xs_a1wj)
Dum.lines' :: [Char] -> [[Char]]
Dum.lines' (!"") = []
Dum.lines' s_a1wk
  = plumb_a1wl (Dum.span' ((/=) '\n') s_a1wk)
  where
      plumb_a1wl (l_a1wm, s'_a1wn)
        = l_a1wm : if null s'_a1wn then [] else Dum.lines' (tail s'_a1wn)
Dum.strToInt :: String -> Int
Dum.strToInt (!x_a1SV)
  = strToInt'_a1SW (length x_a1SV - 1) x_a1SV
  where
      strToInt'_a1SW _ [] = 0
      strToInt'_a1SW (!x_a1SX) ((!a_a1SY) : (!l_a1SZ))
        = (Dum.charToInt a_a1SY) * (10 ^ x_a1SX)
          + (strToInt'_a1SW (x_a1SX - 1) l_a1SZ)
Dum.charToInt :: Char -> Int
Dum.charToInt x_a23O = (fromEnum x_a23O - fromEnum '0')


["a_a1vo","b_a1vp","a_a1vq","as_a1vr","safebang@!as_a1vr","(!as_a1vr)","b_a1vs","safebang@!b_a1vs","(!b_a1vs)","((!as_a1vr), (!b_a1vs))","b_a1vt","a_a1vu","bs_a1vv","(a_a1vu, bs_a1vv)","f_a1vw","safebang@!f_a1vw","(!f_a1vw)","[]","_","!_","(!_)","f_a1vx","_","!_","(!_)","[]","![]","(![])","f_a1vy","!f_a1vy","(!f_a1vy)","a_a1vz","l_a1vA","!l_a1vA","(!l_a1vA)","a_a1vz : (!l_a1vA)","(a_a1vz : (!l_a1vA))","!(a_a1vz : (!l_a1vA))","(!(a_a1vz : (!l_a1vA)))","((!(a_a1vz : (!l_a1vA))))","b_a1vB","!b_a1vB","(!b_a1vB)","k_a1vC","(!b_a1vB) : k_a1vC","((!b_a1vB) : k_a1vC)","!((!b_a1vB) : k_a1vC)","(!((!b_a1vB) : k_a1vC))","((!((!b_a1vB) : k_a1vC)))","f_a1vD","[]","f_a1vE","a_a1vF","safebang@!a_a1vF","(!a_a1vF)","l_a1vG","safebang@!l_a1vG","(!l_a1vG)","(!a_a1vF) : (!l_a1vG)","((!a_a1vF) : (!l_a1vG))","[]","![]","(![])","a_a1vH","l_a1vI","a_a1vH : l_a1vI","(a_a1vH : l_a1vI)","low_a1vJ","high_a1vK","!high_a1vK","(!high_a1vK)","(low_a1vJ, (!high_a1vK))","_","[]","![]","(![])","i_a1vL","!i_a1vL","(!i_a1vL)","a_a1vM","l_a1vN","!l_a1vN","(!l_a1vN)","a_a1vM : (!l_a1vN)","(a_a1vM : (!l_a1vN))","low_a1vP","high_a1vQ","(low_a1vP, high_a1vQ)","!(low_a1vP, high_a1vQ)","(!(low_a1vP, high_a1vQ))","a_a1vR","safebang@!a_a1vR","(!a_a1vR)","[]","![]","(![])","a_a1vS","x_a1vU","xs_a1vV","x_a1vU : xs_a1vV","(x_a1vU : xs_a1vV)","!(x_a1vU : xs_a1vV)","(!(x_a1vU : xs_a1vV))","as_a1vT@(!(x_a1vU : xs_a1vV))","a_a1vW","[]","a_a1vX","x_a1vY","xs_a1vZ","safebang@!xs_a1vZ","(!xs_a1vZ)","x_a1vY : (!xs_a1vZ)","(x_a1vY : (!xs_a1vZ))","a_a1w0","[]","![]","(![])","a_a1w1","!a_a1w1","(!a_a1w1)","x_a1w2","xs_a1w3","!xs_a1w3","(!xs_a1w3)","x_a1w2 : (!xs_a1w3)","(x_a1w2 : (!xs_a1w3))","!(x_a1w2 : (!xs_a1w3))","(!(x_a1w2 : (!xs_a1w3)))","_","!_","(!_)","[]","![]","(![])","_","!_","(!_)","_","!_","(!_)","_","!_","(!_)","[]","p_a1w4","!p_a1w4","(!p_a1w4)","a_a1w6","!a_a1w6","(!a_a1w6)","l_a1w7","(!a_a1w6) : l_a1w7","((!a_a1w6) : l_a1w7)","!((!a_a1w6) : l_a1w7)","(!((!a_a1w6) : l_a1w7))","as_a1w5@(!((!a_a1w6) : l_a1w7))","b_a1w9","!b_a1w9","(!b_a1w9)","k_a1wa","(!b_a1w9) : k_a1wa","((!b_a1w9) : k_a1wa)","!((!b_a1w9) : k_a1wa)","(!((!b_a1w9) : k_a1wa))","bs_a1w8@(!((!b_a1w9) : k_a1wa))","p_a1wb","[]","![]","(![])","p_a1wc","!p_a1wc","(!p_a1wc)","x_a1wd","xs'_a1we","x_a1wd : xs'_a1we","(x_a1wd : xs'_a1we)","!(x_a1wd : xs'_a1we)","(!(x_a1wd : xs'_a1we))","x_a1wg","!x_a1wg","(!x_a1wg)","xs_a1wh","ys_a1wi","(xs_a1wh, ys_a1wi)","_","!_","(!_)","xs_a1wj","!xs_a1wj","(!xs_a1wj)","\"\"","!\"\"","(!\"\")","s_a1wk","l_a1wm","s'_a1wn","(l_a1wm, s'_a1wn)","x_a1SV","safebang@!x_a1SV","(!x_a1SV)","_","[]","x_a1SX","!x_a1SX","(!x_a1SX)","a_a1SY","!a_a1SY","(!a_a1SY)","l_a1SZ","!l_a1SZ","(!l_a1SZ)","(!a_a1SY) : (!l_a1SZ)","((!a_a1SY) : (!l_a1SZ))","x_a23O"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import StdLib
import GRIP
import PSlib
import Graph
import Parse

pair :: a_a1vm -> b_a1vn -> (a_a1vm, b_a1vn)
pair a_a1vo b_a1vp = (a_a1vo, b_a1vp)

fstcons :: a_a1vk -> ([a_a1vk], b_a1vl) -> ([a_a1vk], b_a1vl)
fstcons a_a1vq ((!as_a1vr), (!b_a1vs)) = (a_a1vq : as_a1vr, b_a1vs)

sndcons :: b_a1vi -> (a_a1vj, [b_a1vi]) -> (a_a1vj, [b_a1vi])
sndcons b_a1vt (a_a1vu, bs_a1vv) = (a_a1vu, b_a1vt : bs_a1vv)
map2 (!f_a1vw) [] (investigate@_) = []
map2 f_a1vx (investigate@_) (investigate@[]) = []
map2 (investigate@f_a1vy)
  ((investigate@(a_a1vz : (investigate@l_a1vA))))
  ((investigate@((investigate@b_a1vB) : k_a1vC)))
  = f_a1vy a_a1vz b_a1vB : map2 f_a1vy l_a1vA k_a1vC

mapcat :: (a_a1vg -> [b_a1vh]) -> [a_a1vg] -> [b_a1vh]
mapcat f_a1vD [] = []
mapcat f_a1vE ((!a_a1vF) : (!l_a1vG))
  = f_a1vE a_a1vF ++ mapcat f_a1vE l_a1vG

sort :: Ord a_a1vf => [a_a1vf] -> [a_a1vf]
sort (investigate@[]) = []
sort (a_a1vH : l_a1vI)
  = (sort low_a1vJ) ++ [a_a1vH] ++ (sort high_a1vK)
  where (low_a1vJ, (investigate@high_a1vK)) = group a_a1vH l_a1vI

group :: Ord a_a1ve => a_a1ve -> [a_a1ve] -> ([a_a1ve], [a_a1ve])
group _ (investigate@[]) = ([], [])
group (investigate@i_a1vL) (a_a1vM : (investigate@l_a1vN))
  = f_a1vO (group i_a1vL l_a1vN)
  where f_a1vO (investigate@(low_a1vP, high_a1vQ))
          | a_a1vM < i_a1vL = (a_a1vM : low_a1vP, high_a1vQ)
          | otherwise = (low_a1vP, a_a1vM : high_a1vQ)

insert :: Ord a_a1vd => a_a1vd -> [a_a1vd] -> [a_a1vd]
insert (!a_a1vR) (investigate@[]) = [a_a1vR]
insert a_a1vS as_a1vT@(investigate@(x_a1vU : xs_a1vV))
  | x_a1vU > a_a1vS = a_a1vS : as_a1vT
  | otherwise = x_a1vU : insert a_a1vS xs_a1vV

replace :: Eq a_a1vc => a_a1vc -> [a_a1vc] -> [a_a1vc]
replace a_a1vW [] = []
replace a_a1vX (x_a1vY : (!xs_a1vZ))
  | a_a1vX == x_a1vY = a_a1vX : xs_a1vZ
  | otherwise = x_a1vY : replace a_a1vX xs_a1vZ

remove :: Eq a_a1vb => a_a1vb -> [a_a1vb] -> [a_a1vb]
remove a_a1w0 (investigate@[]) = []
remove (investigate@a_a1w1)
  (investigate@(x_a1w2 : (investigate@xs_a1w3)))
  | a_a1w1 == x_a1w2 = xs_a1w3
  | otherwise = x_a1w2 : remove a_a1w1 xs_a1w3

collect ::
          Ord a_azq => (b_azr -> a_azq) -> [a_azq] -> [b_azr] -> [b_azr]
collect (investigate@_) (investigate@[]) (investigate@_) = []
collect (investigate@_) (investigate@_) [] = []
collect (investigate@p_a1w4)
  as_a1w5@(investigate@((investigate@a_a1w6) : l_a1w7))
  bs_a1w8@(investigate@((investigate@b_a1w9) : k_a1wa))
  | a_a1w6 == p_a1w4 b_a1w9 = b_a1w9 : collect p_a1w4 l_a1w7 k_a1wa
  | p_a1w4 b_a1w9 > a_a1w6 = collect p_a1w4 l_a1w7 bs_a1w8
  | otherwise = collect p_a1w4 as_a1w5 k_a1wa

span' :: (a_azp -> Bool) -> [a_azp] -> ([a_azp], [a_azp])
span' p_a1wb (investigate@[]) = ([], [])
span' (investigate@p_a1wc) (investigate@(x_a1wd : xs'_a1we))
  | p_a1wc x_a1wd = fixLeak_a1wf x_a1wd (span' p_a1wc xs'_a1we)
  where fixLeak_a1wf (investigate@x_a1wg) (xs_a1wh, ys_a1wi)
          = (x_a1wg : xs_a1wh, ys_a1wi)
span' (investigate@_) (investigate@xs_a1wj) = ([], xs_a1wj)

lines' :: [Char] -> [[Char]]
lines' (investigate@"") = []
lines' s_a1wk = plumb_a1wl (span' ((/=) '\n') s_a1wk)
  where plumb_a1wl (l_a1wm, s'_a1wn)
          = l_a1wm : if null s'_a1wn then [] else lines' (tail s'_a1wn)

strToInt :: String -> Int
strToInt (!x_a1SV) = strToInt'_a1SW (length x_a1SV - 1) x_a1SV
  where strToInt'_a1SW _ [] = 0
        strToInt'_a1SW (investigate@x_a1SX)
          ((investigate@a_a1SY) : (investigate@l_a1SZ))
          = (charToInt a_a1SY) * (10 ^ x_a1SX) +
              (strToInt'_a1SW (x_a1SX - 1) l_a1SZ)

charToInt :: Char -> Int
charToInt x_a23O = (fromEnum x_a23O - fromEnum '0')
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.pair :: a_a1vm -> b_a1vn -> (a_a1vm, b_a1vn)
Dum.pair a_a1vo b_a1vp = (a_a1vo, b_a1vp)
Dum.fstcons :: a_a1vk -> ([a_a1vk], b_a1vl) -> ([a_a1vk], b_a1vl)
Dum.fstcons a_a1vq ((!as_a1vr), (!b_a1vs))
  = (a_a1vq : as_a1vr, b_a1vs)
Dum.sndcons :: b_a1vi -> (a_a1vj, [b_a1vi]) -> (a_a1vj, [b_a1vi])
Dum.sndcons b_a1vt (a_a1vu, bs_a1vv) = (a_a1vu, b_a1vt : bs_a1vv)
Dum.map2 (!f_a1vw) [] (!_) = []
Dum.map2 f_a1vx (!_) (![]) = []
Dum.map2
  (!f_a1vy)
  ((!(a_a1vz : (!l_a1vA))))
  ((!((!b_a1vB) : k_a1vC)))
  = f_a1vy a_a1vz b_a1vB : Dum.map2 f_a1vy l_a1vA k_a1vC
Dum.mapcat :: (a_a1vg -> [b_a1vh]) -> [a_a1vg] -> [b_a1vh]
Dum.mapcat f_a1vD [] = []
Dum.mapcat f_a1vE ((!a_a1vF) : (!l_a1vG))
  = f_a1vE a_a1vF ++ Dum.mapcat f_a1vE l_a1vG
Dum.sort :: Ord a_a1vf => [a_a1vf] -> [a_a1vf]
Dum.sort (![]) = []
Dum.sort (a_a1vH : l_a1vI)
  = (Dum.sort low_a1vJ) ++ [a_a1vH] ++ (Dum.sort high_a1vK)
  where
      (low_a1vJ, (!high_a1vK)) = Dum.group a_a1vH l_a1vI
Dum.group ::
  Ord a_a1ve => a_a1ve -> [a_a1ve] -> ([a_a1ve], [a_a1ve])
Dum.group _ (![]) = ([], [])
Dum.group (!i_a1vL) (a_a1vM : (!l_a1vN))
  = f_a1vO (Dum.group i_a1vL l_a1vN)
  where
      f_a1vO (!(low_a1vP, high_a1vQ))
        | a_a1vM < i_a1vL = (a_a1vM : low_a1vP, high_a1vQ)
        | otherwise = (low_a1vP, a_a1vM : high_a1vQ)
Dum.insert :: Ord a_a1vd => a_a1vd -> [a_a1vd] -> [a_a1vd]
Dum.insert (!a_a1vR) (![]) = [a_a1vR]
Dum.insert a_a1vS as_a1vT@(!(x_a1vU : xs_a1vV))
  | x_a1vU > a_a1vS = a_a1vS : as_a1vT
  | otherwise = x_a1vU : Dum.insert a_a1vS xs_a1vV
Dum.replace :: Eq a_a1vc => a_a1vc -> [a_a1vc] -> [a_a1vc]
Dum.replace a_a1vW [] = []
Dum.replace a_a1vX (x_a1vY : (!xs_a1vZ))
  | a_a1vX == x_a1vY = a_a1vX : xs_a1vZ
  | otherwise = x_a1vY : Dum.replace a_a1vX xs_a1vZ
Dum.remove :: Eq a_a1vb => a_a1vb -> [a_a1vb] -> [a_a1vb]
Dum.remove a_a1w0 (![]) = []
Dum.remove (!a_a1w1) (!(x_a1w2 : (!xs_a1w3)))
  | a_a1w1 == x_a1w2 = xs_a1w3
  | otherwise = x_a1w2 : Dum.remove a_a1w1 xs_a1w3
Dum.collect ::
  Ord a_azq => (b_azr -> a_azq) -> [a_azq] -> [b_azr] -> [b_azr]
Dum.collect (!_) (![]) (!_) = []
Dum.collect (!_) (!_) [] = []
Dum.collect
  (!p_a1w4)
  as_a1w5@(!((!a_a1w6) : l_a1w7))
  bs_a1w8@(!((!b_a1w9) : k_a1wa))
  | a_a1w6 == p_a1w4 b_a1w9
  = b_a1w9 : Dum.collect p_a1w4 l_a1w7 k_a1wa
  | p_a1w4 b_a1w9 > a_a1w6 = Dum.collect p_a1w4 l_a1w7 bs_a1w8
  | otherwise = Dum.collect p_a1w4 as_a1w5 k_a1wa
Dum.span' :: (a_azp -> Bool) -> [a_azp] -> ([a_azp], [a_azp])
Dum.span' p_a1wb (![]) = ([], [])
Dum.span' (!p_a1wc) (!(x_a1wd : xs'_a1we))
  | p_a1wc x_a1wd = fixLeak_a1wf x_a1wd (Dum.span' p_a1wc xs'_a1we)
  where
      fixLeak_a1wf (!x_a1wg) (xs_a1wh, ys_a1wi)
        = (x_a1wg : xs_a1wh, ys_a1wi)
Dum.span' (!_) (!xs_a1wj) = ([], xs_a1wj)
Dum.lines' :: [Char] -> [[Char]]
Dum.lines' (!"") = []
Dum.lines' s_a1wk
  = plumb_a1wl (Dum.span' ((/=) '\n') s_a1wk)
  where
      plumb_a1wl (l_a1wm, s'_a1wn)
        = l_a1wm : if null s'_a1wn then [] else Dum.lines' (tail s'_a1wn)
Dum.strToInt :: String -> Int
Dum.strToInt (!x_a1SV)
  = strToInt'_a1SW (length x_a1SV - 1) x_a1SV
  where
      strToInt'_a1SW _ [] = 0
      strToInt'_a1SW (!x_a1SX) ((!a_a1SY) : (!l_a1SZ))
        = (Dum.charToInt a_a1SY) * (10 ^ x_a1SX)
          + (strToInt'_a1SW (x_a1SX - 1) l_a1SZ)
Dum.charToInt :: Char -> Int
Dum.charToInt x_a23O = (fromEnum x_a23O - fromEnum '0')


["a_a1vo","b_a1vp","a_a1vq","as_a1vr","safebang@!as_a1vr","(!as_a1vr)","b_a1vs","safebang@!b_a1vs","(!b_a1vs)","((!as_a1vr), (!b_a1vs))","b_a1vt","a_a1vu","bs_a1vv","(a_a1vu, bs_a1vv)","f_a1vw","safebang@!f_a1vw","(!f_a1vw)","[]","_","!_","(!_)","f_a1vx","_","!_","(!_)","[]","![]","(![])","f_a1vy","!f_a1vy","(!f_a1vy)","a_a1vz","l_a1vA","!l_a1vA","(!l_a1vA)","a_a1vz : (!l_a1vA)","(a_a1vz : (!l_a1vA))","!(a_a1vz : (!l_a1vA))","(!(a_a1vz : (!l_a1vA)))","((!(a_a1vz : (!l_a1vA))))","b_a1vB","!b_a1vB","(!b_a1vB)","k_a1vC","(!b_a1vB) : k_a1vC","((!b_a1vB) : k_a1vC)","!((!b_a1vB) : k_a1vC)","(!((!b_a1vB) : k_a1vC))","((!((!b_a1vB) : k_a1vC)))","f_a1vD","[]","f_a1vE","a_a1vF","safebang@!a_a1vF","(!a_a1vF)","l_a1vG","safebang@!l_a1vG","(!l_a1vG)","(!a_a1vF) : (!l_a1vG)","((!a_a1vF) : (!l_a1vG))","[]","![]","(![])","a_a1vH","l_a1vI","a_a1vH : l_a1vI","(a_a1vH : l_a1vI)","low_a1vJ","high_a1vK","!high_a1vK","(!high_a1vK)","(low_a1vJ, (!high_a1vK))","_","[]","![]","(![])","i_a1vL","!i_a1vL","(!i_a1vL)","a_a1vM","l_a1vN","!l_a1vN","(!l_a1vN)","a_a1vM : (!l_a1vN)","(a_a1vM : (!l_a1vN))","low_a1vP","high_a1vQ","(low_a1vP, high_a1vQ)","!(low_a1vP, high_a1vQ)","(!(low_a1vP, high_a1vQ))","a_a1vR","safebang@!a_a1vR","(!a_a1vR)","[]","![]","(![])","a_a1vS","x_a1vU","xs_a1vV","x_a1vU : xs_a1vV","(x_a1vU : xs_a1vV)","!(x_a1vU : xs_a1vV)","(!(x_a1vU : xs_a1vV))","as_a1vT@(!(x_a1vU : xs_a1vV))","a_a1vW","[]","a_a1vX","x_a1vY","xs_a1vZ","safebang@!xs_a1vZ","(!xs_a1vZ)","x_a1vY : (!xs_a1vZ)","(x_a1vY : (!xs_a1vZ))","a_a1w0","[]","![]","(![])","a_a1w1","!a_a1w1","(!a_a1w1)","x_a1w2","xs_a1w3","!xs_a1w3","(!xs_a1w3)","x_a1w2 : (!xs_a1w3)","(x_a1w2 : (!xs_a1w3))","!(x_a1w2 : (!xs_a1w3))","(!(x_a1w2 : (!xs_a1w3)))","_","!_","(!_)","[]","![]","(![])","_","!_","(!_)","_","!_","(!_)","_","!_","(!_)","[]","p_a1w4","!p_a1w4","(!p_a1w4)","a_a1w6","!a_a1w6","(!a_a1w6)","l_a1w7","(!a_a1w6) : l_a1w7","((!a_a1w6) : l_a1w7)","!((!a_a1w6) : l_a1w7)","(!((!a_a1w6) : l_a1w7))","as_a1w5@(!((!a_a1w6) : l_a1w7))","b_a1w9","!b_a1w9","(!b_a1w9)","k_a1wa","(!b_a1w9) : k_a1wa","((!b_a1w9) : k_a1wa)","!((!b_a1w9) : k_a1wa)","(!((!b_a1w9) : k_a1wa))","bs_a1w8@(!((!b_a1w9) : k_a1wa))","p_a1wb","[]","![]","(![])","p_a1wc","!p_a1wc","(!p_a1wc)","x_a1wd","xs'_a1we","x_a1wd : xs'_a1we","(x_a1wd : xs'_a1we)","!(x_a1wd : xs'_a1we)","(!(x_a1wd : xs'_a1we))","x_a1wg","!x_a1wg","(!x_a1wg)","xs_a1wh","ys_a1wi","(xs_a1wh, ys_a1wi)","_","!_","(!_)","xs_a1wj","!xs_a1wj","(!xs_a1wj)","\"\"","!\"\"","(!\"\")","s_a1wk","l_a1wm","s'_a1wn","(l_a1wm, s'_a1wn)","x_a1SV","safebang@!x_a1SV","(!x_a1SV)","_","[]","x_a1SX","!x_a1SX","(!x_a1SX)","a_a1SY","!a_a1SY","(!a_a1SY)","l_a1SZ","!l_a1SZ","(!l_a1SZ)","(!a_a1SY) : (!l_a1SZ)","((!a_a1SY) : (!l_a1SZ))","x_a23O"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Array
import System.Environment
import Parse
import Simulate
import Types

pair :: a_a1vm -> b_a1vn -> (a_a1vm, b_a1vn)
pair a_a1vo b_a1vp = (a_a1vo, b_a1vp)

fstcons :: a_a1vk -> ([a_a1vk], b_a1vl) -> ([a_a1vk], b_a1vl)
fstcons a_a1vq ((!as_a1vr), (!b_a1vs)) = (a_a1vq : as_a1vr, b_a1vs)

sndcons :: b_a1vi -> (a_a1vj, [b_a1vi]) -> (a_a1vj, [b_a1vi])
sndcons b_a1vt (a_a1vu, bs_a1vv) = (a_a1vu, b_a1vt : bs_a1vv)
map2 (!f_a1vw) [] (investigate@_) = []
map2 f_a1vx (investigate@_) (investigate@[]) = []
map2 (investigate@f_a1vy)
  ((investigate@(a_a1vz : (investigate@l_a1vA))))
  ((investigate@((investigate@b_a1vB) : k_a1vC)))
  = f_a1vy a_a1vz b_a1vB : map2 f_a1vy l_a1vA k_a1vC

mapcat :: (a_a1vg -> [b_a1vh]) -> [a_a1vg] -> [b_a1vh]
mapcat f_a1vD [] = []
mapcat f_a1vE ((!a_a1vF) : (!l_a1vG))
  = f_a1vE a_a1vF ++ mapcat f_a1vE l_a1vG

sort :: Ord a_a1vf => [a_a1vf] -> [a_a1vf]
sort (investigate@[]) = []
sort (a_a1vH : l_a1vI)
  = (sort low_a1vJ) ++ [a_a1vH] ++ (sort high_a1vK)
  where (low_a1vJ, (investigate@high_a1vK)) = group a_a1vH l_a1vI

group :: Ord a_a1ve => a_a1ve -> [a_a1ve] -> ([a_a1ve], [a_a1ve])
group _ (investigate@[]) = ([], [])
group (investigate@i_a1vL) (a_a1vM : (investigate@l_a1vN))
  = f_a1vO (group i_a1vL l_a1vN)
  where f_a1vO (investigate@(low_a1vP, high_a1vQ))
          | a_a1vM < i_a1vL = (a_a1vM : low_a1vP, high_a1vQ)
          | otherwise = (low_a1vP, a_a1vM : high_a1vQ)

insert :: Ord a_a1vd => a_a1vd -> [a_a1vd] -> [a_a1vd]
insert (!a_a1vR) (investigate@[]) = [a_a1vR]
insert a_a1vS as_a1vT@(investigate@(x_a1vU : xs_a1vV))
  | x_a1vU > a_a1vS = a_a1vS : as_a1vT
  | otherwise = x_a1vU : insert a_a1vS xs_a1vV

replace :: Eq a_a1vc => a_a1vc -> [a_a1vc] -> [a_a1vc]
replace a_a1vW [] = []
replace a_a1vX (x_a1vY : (!xs_a1vZ))
  | a_a1vX == x_a1vY = a_a1vX : xs_a1vZ
  | otherwise = x_a1vY : replace a_a1vX xs_a1vZ

remove :: Eq a_a1vb => a_a1vb -> [a_a1vb] -> [a_a1vb]
remove a_a1w0 (investigate@[]) = []
remove (investigate@a_a1w1)
  (investigate@(x_a1w2 : (investigate@xs_a1w3)))
  | a_a1w1 == x_a1w2 = xs_a1w3
  | otherwise = x_a1w2 : remove a_a1w1 xs_a1w3

collect ::
          Ord a_azq => (b_azr -> a_azq) -> [a_azq] -> [b_azr] -> [b_azr]
collect (investigate@_) (investigate@[]) (investigate@_) = []
collect (investigate@_) (investigate@_) [] = []
collect (investigate@p_a1w4)
  as_a1w5@(investigate@((investigate@a_a1w6) : l_a1w7))
  bs_a1w8@(investigate@((investigate@b_a1w9) : k_a1wa))
  | a_a1w6 == p_a1w4 b_a1w9 = b_a1w9 : collect p_a1w4 l_a1w7 k_a1wa
  | p_a1w4 b_a1w9 > a_a1w6 = collect p_a1w4 l_a1w7 bs_a1w8
  | otherwise = collect p_a1w4 as_a1w5 k_a1wa

span' :: (a_azp -> Bool) -> [a_azp] -> ([a_azp], [a_azp])
span' p_a1wb (investigate@[]) = ([], [])
span' (investigate@p_a1wc) (investigate@(x_a1wd : xs'_a1we))
  | p_a1wc x_a1wd = fixLeak_a1wf x_a1wd (span' p_a1wc xs'_a1we)
  where fixLeak_a1wf (investigate@x_a1wg) (xs_a1wh, ys_a1wi)
          = (x_a1wg : xs_a1wh, ys_a1wi)
span' (investigate@_) (investigate@xs_a1wj) = ([], xs_a1wj)

lines' :: [Char] -> [[Char]]
lines' (investigate@"") = []
lines' s_a1wk = plumb_a1wl (span' ((/=) '\n') s_a1wk)
  where plumb_a1wl (l_a1wm, s'_a1wn)
          = l_a1wm : if null s'_a1wn then [] else lines' (tail s'_a1wn)

strToInt :: String -> Int
strToInt (!x_a1SV) = strToInt'_a1SW (length x_a1SV - 1) x_a1SV
  where strToInt'_a1SW _ [] = 0
        strToInt'_a1SW (investigate@x_a1SX)
          ((investigate@a_a1SY) : (investigate@l_a1SZ))
          = (charToInt a_a1SY) * (10 ^ x_a1SX) +
              (strToInt'_a1SW (x_a1SX - 1) l_a1SZ)

charToInt :: Char -> Int
charToInt x_a23O = (fromEnum x_a23O - fromEnum '0')
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.pair :: a_a1vm -> b_a1vn -> (a_a1vm, b_a1vn)
Dum.pair a_a1vo b_a1vp = (a_a1vo, b_a1vp)
Dum.fstcons :: a_a1vk -> ([a_a1vk], b_a1vl) -> ([a_a1vk], b_a1vl)
Dum.fstcons a_a1vq ((!as_a1vr), (!b_a1vs))
  = (a_a1vq : as_a1vr, b_a1vs)
Dum.sndcons :: b_a1vi -> (a_a1vj, [b_a1vi]) -> (a_a1vj, [b_a1vi])
Dum.sndcons b_a1vt (a_a1vu, bs_a1vv) = (a_a1vu, b_a1vt : bs_a1vv)
Dum.map2 (!f_a1vw) [] (!_) = []
Dum.map2 f_a1vx (!_) (![]) = []
Dum.map2
  (!f_a1vy)
  ((!(a_a1vz : (!l_a1vA))))
  ((!((!b_a1vB) : k_a1vC)))
  = f_a1vy a_a1vz b_a1vB : Dum.map2 f_a1vy l_a1vA k_a1vC
Dum.mapcat :: (a_a1vg -> [b_a1vh]) -> [a_a1vg] -> [b_a1vh]
Dum.mapcat f_a1vD [] = []
Dum.mapcat f_a1vE ((!a_a1vF) : (!l_a1vG))
  = f_a1vE a_a1vF ++ Dum.mapcat f_a1vE l_a1vG
Dum.sort :: Ord a_a1vf => [a_a1vf] -> [a_a1vf]
Dum.sort (![]) = []
Dum.sort (a_a1vH : l_a1vI)
  = (Dum.sort low_a1vJ) ++ [a_a1vH] ++ (Dum.sort high_a1vK)
  where
      (low_a1vJ, (!high_a1vK)) = Dum.group a_a1vH l_a1vI
Dum.group ::
  Ord a_a1ve => a_a1ve -> [a_a1ve] -> ([a_a1ve], [a_a1ve])
Dum.group _ (![]) = ([], [])
Dum.group (!i_a1vL) (a_a1vM : (!l_a1vN))
  = f_a1vO (Dum.group i_a1vL l_a1vN)
  where
      f_a1vO (!(low_a1vP, high_a1vQ))
        | a_a1vM < i_a1vL = (a_a1vM : low_a1vP, high_a1vQ)
        | otherwise = (low_a1vP, a_a1vM : high_a1vQ)
Dum.insert :: Ord a_a1vd => a_a1vd -> [a_a1vd] -> [a_a1vd]
Dum.insert (!a_a1vR) (![]) = [a_a1vR]
Dum.insert a_a1vS as_a1vT@(!(x_a1vU : xs_a1vV))
  | x_a1vU > a_a1vS = a_a1vS : as_a1vT
  | otherwise = x_a1vU : Dum.insert a_a1vS xs_a1vV
Dum.replace :: Eq a_a1vc => a_a1vc -> [a_a1vc] -> [a_a1vc]
Dum.replace a_a1vW [] = []
Dum.replace a_a1vX (x_a1vY : (!xs_a1vZ))
  | a_a1vX == x_a1vY = a_a1vX : xs_a1vZ
  | otherwise = x_a1vY : Dum.replace a_a1vX xs_a1vZ
Dum.remove :: Eq a_a1vb => a_a1vb -> [a_a1vb] -> [a_a1vb]
Dum.remove a_a1w0 (![]) = []
Dum.remove (!a_a1w1) (!(x_a1w2 : (!xs_a1w3)))
  | a_a1w1 == x_a1w2 = xs_a1w3
  | otherwise = x_a1w2 : Dum.remove a_a1w1 xs_a1w3
Dum.collect ::
  Ord a_azq => (b_azr -> a_azq) -> [a_azq] -> [b_azr] -> [b_azr]
Dum.collect (!_) (![]) (!_) = []
Dum.collect (!_) (!_) [] = []
Dum.collect
  (!p_a1w4)
  as_a1w5@(!((!a_a1w6) : l_a1w7))
  bs_a1w8@(!((!b_a1w9) : k_a1wa))
  | a_a1w6 == p_a1w4 b_a1w9
  = b_a1w9 : Dum.collect p_a1w4 l_a1w7 k_a1wa
  | p_a1w4 b_a1w9 > a_a1w6 = Dum.collect p_a1w4 l_a1w7 bs_a1w8
  | otherwise = Dum.collect p_a1w4 as_a1w5 k_a1wa
Dum.span' :: (a_azp -> Bool) -> [a_azp] -> ([a_azp], [a_azp])
Dum.span' p_a1wb (![]) = ([], [])
Dum.span' (!p_a1wc) (!(x_a1wd : xs'_a1we))
  | p_a1wc x_a1wd = fixLeak_a1wf x_a1wd (Dum.span' p_a1wc xs'_a1we)
  where
      fixLeak_a1wf (!x_a1wg) (xs_a1wh, ys_a1wi)
        = (x_a1wg : xs_a1wh, ys_a1wi)
Dum.span' (!_) (!xs_a1wj) = ([], xs_a1wj)
Dum.lines' :: [Char] -> [[Char]]
Dum.lines' (!"") = []
Dum.lines' s_a1wk
  = plumb_a1wl (Dum.span' ((/=) '\n') s_a1wk)
  where
      plumb_a1wl (l_a1wm, s'_a1wn)
        = l_a1wm : if null s'_a1wn then [] else Dum.lines' (tail s'_a1wn)
Dum.strToInt :: String -> Int
Dum.strToInt (!x_a1SV)
  = strToInt'_a1SW (length x_a1SV - 1) x_a1SV
  where
      strToInt'_a1SW _ [] = 0
      strToInt'_a1SW (!x_a1SX) ((!a_a1SY) : (!l_a1SZ))
        = (Dum.charToInt a_a1SY) * (10 ^ x_a1SX)
          + (strToInt'_a1SW (x_a1SX - 1) l_a1SZ)
Dum.charToInt :: Char -> Int
Dum.charToInt x_a23O = (fromEnum x_a23O - fromEnum '0')


["a_a1vo","b_a1vp","a_a1vq","as_a1vr","safebang@!as_a1vr","(!as_a1vr)","b_a1vs","safebang@!b_a1vs","(!b_a1vs)","((!as_a1vr), (!b_a1vs))","b_a1vt","a_a1vu","bs_a1vv","(a_a1vu, bs_a1vv)","f_a1vw","safebang@!f_a1vw","(!f_a1vw)","[]","_","!_","(!_)","f_a1vx","_","!_","(!_)","[]","![]","(![])","f_a1vy","!f_a1vy","(!f_a1vy)","a_a1vz","l_a1vA","!l_a1vA","(!l_a1vA)","a_a1vz : (!l_a1vA)","(a_a1vz : (!l_a1vA))","!(a_a1vz : (!l_a1vA))","(!(a_a1vz : (!l_a1vA)))","((!(a_a1vz : (!l_a1vA))))","b_a1vB","!b_a1vB","(!b_a1vB)","k_a1vC","(!b_a1vB) : k_a1vC","((!b_a1vB) : k_a1vC)","!((!b_a1vB) : k_a1vC)","(!((!b_a1vB) : k_a1vC))","((!((!b_a1vB) : k_a1vC)))","f_a1vD","[]","f_a1vE","a_a1vF","safebang@!a_a1vF","(!a_a1vF)","l_a1vG","safebang@!l_a1vG","(!l_a1vG)","(!a_a1vF) : (!l_a1vG)","((!a_a1vF) : (!l_a1vG))","[]","![]","(![])","a_a1vH","l_a1vI","a_a1vH : l_a1vI","(a_a1vH : l_a1vI)","low_a1vJ","high_a1vK","!high_a1vK","(!high_a1vK)","(low_a1vJ, (!high_a1vK))","_","[]","![]","(![])","i_a1vL","!i_a1vL","(!i_a1vL)","a_a1vM","l_a1vN","!l_a1vN","(!l_a1vN)","a_a1vM : (!l_a1vN)","(a_a1vM : (!l_a1vN))","low_a1vP","high_a1vQ","(low_a1vP, high_a1vQ)","!(low_a1vP, high_a1vQ)","(!(low_a1vP, high_a1vQ))","a_a1vR","safebang@!a_a1vR","(!a_a1vR)","[]","![]","(![])","a_a1vS","x_a1vU","xs_a1vV","x_a1vU : xs_a1vV","(x_a1vU : xs_a1vV)","!(x_a1vU : xs_a1vV)","(!(x_a1vU : xs_a1vV))","as_a1vT@(!(x_a1vU : xs_a1vV))","a_a1vW","[]","a_a1vX","x_a1vY","xs_a1vZ","safebang@!xs_a1vZ","(!xs_a1vZ)","x_a1vY : (!xs_a1vZ)","(x_a1vY : (!xs_a1vZ))","a_a1w0","[]","![]","(![])","a_a1w1","!a_a1w1","(!a_a1w1)","x_a1w2","xs_a1w3","!xs_a1w3","(!xs_a1w3)","x_a1w2 : (!xs_a1w3)","(x_a1w2 : (!xs_a1w3))","!(x_a1w2 : (!xs_a1w3))","(!(x_a1w2 : (!xs_a1w3)))","_","!_","(!_)","[]","![]","(![])","_","!_","(!_)","_","!_","(!_)","_","!_","(!_)","[]","p_a1w4","!p_a1w4","(!p_a1w4)","a_a1w6","!a_a1w6","(!a_a1w6)","l_a1w7","(!a_a1w6) : l_a1w7","((!a_a1w6) : l_a1w7)","!((!a_a1w6) : l_a1w7)","(!((!a_a1w6) : l_a1w7))","as_a1w5@(!((!a_a1w6) : l_a1w7))","b_a1w9","!b_a1w9","(!b_a1w9)","k_a1wa","(!b_a1w9) : k_a1wa","((!b_a1w9) : k_a1wa)","!((!b_a1w9) : k_a1wa)","(!((!b_a1w9) : k_a1wa))","bs_a1w8@(!((!b_a1w9) : k_a1wa))","p_a1wb","[]","![]","(![])","p_a1wc","!p_a1wc","(!p_a1wc)","x_a1wd","xs'_a1we","x_a1wd : xs'_a1we","(x_a1wd : xs'_a1we)","!(x_a1wd : xs'_a1we)","(!(x_a1wd : xs'_a1we))","x_a1wg","!x_a1wg","(!x_a1wg)","xs_a1wh","ys_a1wi","(xs_a1wh, ys_a1wi)","_","!_","(!_)","xs_a1wj","!xs_a1wj","(!xs_a1wj)","\"\"","!\"\"","(!\"\")","s_a1wk","l_a1wm","s'_a1wn","(l_a1wm, s'_a1wn)","x_a1SV","safebang@!x_a1SV","(!x_a1SV)","_","[]","x_a1SX","!x_a1SX","(!x_a1SX)","a_a1SY","!a_a1SY","(!a_a1SY)","l_a1SZ","!l_a1SZ","(!l_a1SZ)","(!a_a1SY) : (!l_a1SZ)","((!a_a1SY) : (!l_a1SZ))","x_a23O"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Array
import Data.List
import Types

pair :: a_a1vm -> b_a1vn -> (a_a1vm, b_a1vn)
pair a_a1vo b_a1vp = (a_a1vo, b_a1vp)

fstcons :: a_a1vk -> ([a_a1vk], b_a1vl) -> ([a_a1vk], b_a1vl)
fstcons a_a1vq ((!as_a1vr), (!b_a1vs)) = (a_a1vq : as_a1vr, b_a1vs)

sndcons :: b_a1vi -> (a_a1vj, [b_a1vi]) -> (a_a1vj, [b_a1vi])
sndcons b_a1vt (a_a1vu, bs_a1vv) = (a_a1vu, b_a1vt : bs_a1vv)
map2 (!f_a1vw) [] (investigate@_) = []
map2 f_a1vx (investigate@_) (investigate@[]) = []
map2 (investigate@f_a1vy)
  ((investigate@(a_a1vz : (investigate@l_a1vA))))
  ((investigate@((investigate@b_a1vB) : k_a1vC)))
  = f_a1vy a_a1vz b_a1vB : map2 f_a1vy l_a1vA k_a1vC

mapcat :: (a_a1vg -> [b_a1vh]) -> [a_a1vg] -> [b_a1vh]
mapcat f_a1vD [] = []
mapcat f_a1vE ((!a_a1vF) : (!l_a1vG))
  = f_a1vE a_a1vF ++ mapcat f_a1vE l_a1vG

sort :: Ord a_a1vf => [a_a1vf] -> [a_a1vf]
sort (investigate@[]) = []
sort (a_a1vH : l_a1vI)
  = (sort low_a1vJ) ++ [a_a1vH] ++ (sort high_a1vK)
  where (low_a1vJ, (investigate@high_a1vK)) = group a_a1vH l_a1vI

group :: Ord a_a1ve => a_a1ve -> [a_a1ve] -> ([a_a1ve], [a_a1ve])
group _ (investigate@[]) = ([], [])
group (investigate@i_a1vL) (a_a1vM : (investigate@l_a1vN))
  = f_a1vO (group i_a1vL l_a1vN)
  where f_a1vO (investigate@(low_a1vP, high_a1vQ))
          | a_a1vM < i_a1vL = (a_a1vM : low_a1vP, high_a1vQ)
          | otherwise = (low_a1vP, a_a1vM : high_a1vQ)

insert :: Ord a_a1vd => a_a1vd -> [a_a1vd] -> [a_a1vd]
insert (!a_a1vR) (investigate@[]) = [a_a1vR]
insert a_a1vS as_a1vT@(investigate@(x_a1vU : xs_a1vV))
  | x_a1vU > a_a1vS = a_a1vS : as_a1vT
  | otherwise = x_a1vU : insert a_a1vS xs_a1vV

replace :: Eq a_a1vc => a_a1vc -> [a_a1vc] -> [a_a1vc]
replace a_a1vW [] = []
replace a_a1vX (x_a1vY : (!xs_a1vZ))
  | a_a1vX == x_a1vY = a_a1vX : xs_a1vZ
  | otherwise = x_a1vY : replace a_a1vX xs_a1vZ

remove :: Eq a_a1vb => a_a1vb -> [a_a1vb] -> [a_a1vb]
remove a_a1w0 (investigate@[]) = []
remove (investigate@a_a1w1)
  (investigate@(x_a1w2 : (investigate@xs_a1w3)))
  | a_a1w1 == x_a1w2 = xs_a1w3
  | otherwise = x_a1w2 : remove a_a1w1 xs_a1w3

collect ::
          Ord a_azq => (b_azr -> a_azq) -> [a_azq] -> [b_azr] -> [b_azr]
collect (investigate@_) (investigate@[]) (investigate@_) = []
collect (investigate@_) (investigate@_) [] = []
collect (investigate@p_a1w4)
  as_a1w5@(investigate@((investigate@a_a1w6) : l_a1w7))
  bs_a1w8@(investigate@((investigate@b_a1w9) : k_a1wa))
  | a_a1w6 == p_a1w4 b_a1w9 = b_a1w9 : collect p_a1w4 l_a1w7 k_a1wa
  | p_a1w4 b_a1w9 > a_a1w6 = collect p_a1w4 l_a1w7 bs_a1w8
  | otherwise = collect p_a1w4 as_a1w5 k_a1wa

span' :: (a_azp -> Bool) -> [a_azp] -> ([a_azp], [a_azp])
span' p_a1wb (investigate@[]) = ([], [])
span' (investigate@p_a1wc) (investigate@(x_a1wd : xs'_a1we))
  | p_a1wc x_a1wd = fixLeak_a1wf x_a1wd (span' p_a1wc xs'_a1we)
  where fixLeak_a1wf (investigate@x_a1wg) (xs_a1wh, ys_a1wi)
          = (x_a1wg : xs_a1wh, ys_a1wi)
span' (investigate@_) (investigate@xs_a1wj) = ([], xs_a1wj)

lines' :: [Char] -> [[Char]]
lines' (investigate@"") = []
lines' s_a1wk = plumb_a1wl (span' ((/=) '\n') s_a1wk)
  where plumb_a1wl (l_a1wm, s'_a1wn)
          = l_a1wm : if null s'_a1wn then [] else lines' (tail s'_a1wn)

strToInt :: String -> Int
strToInt (!x_a1SV) = strToInt'_a1SW (length x_a1SV - 1) x_a1SV
  where strToInt'_a1SW _ [] = 0
        strToInt'_a1SW (investigate@x_a1SX)
          ((investigate@a_a1SY) : (investigate@l_a1SZ))
          = (charToInt a_a1SY) * (10 ^ x_a1SX) +
              (strToInt'_a1SW (x_a1SX - 1) l_a1SZ)

charToInt :: Char -> Int
charToInt x_a23O = (fromEnum x_a23O - fromEnum '0')
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.pair :: a_a1vm -> b_a1vn -> (a_a1vm, b_a1vn)
Dum.pair a_a1vo b_a1vp = (a_a1vo, b_a1vp)
Dum.fstcons :: a_a1vk -> ([a_a1vk], b_a1vl) -> ([a_a1vk], b_a1vl)
Dum.fstcons a_a1vq ((!as_a1vr), (!b_a1vs))
  = (a_a1vq : as_a1vr, b_a1vs)
Dum.sndcons :: b_a1vi -> (a_a1vj, [b_a1vi]) -> (a_a1vj, [b_a1vi])
Dum.sndcons b_a1vt (a_a1vu, bs_a1vv) = (a_a1vu, b_a1vt : bs_a1vv)
Dum.map2 (!f_a1vw) [] (!_) = []
Dum.map2 f_a1vx (!_) (![]) = []
Dum.map2
  (!f_a1vy)
  ((!(a_a1vz : (!l_a1vA))))
  ((!((!b_a1vB) : k_a1vC)))
  = f_a1vy a_a1vz b_a1vB : Dum.map2 f_a1vy l_a1vA k_a1vC
Dum.mapcat :: (a_a1vg -> [b_a1vh]) -> [a_a1vg] -> [b_a1vh]
Dum.mapcat f_a1vD [] = []
Dum.mapcat f_a1vE ((!a_a1vF) : (!l_a1vG))
  = f_a1vE a_a1vF ++ Dum.mapcat f_a1vE l_a1vG
Dum.sort :: Ord a_a1vf => [a_a1vf] -> [a_a1vf]
Dum.sort (![]) = []
Dum.sort (a_a1vH : l_a1vI)
  = (Dum.sort low_a1vJ) ++ [a_a1vH] ++ (Dum.sort high_a1vK)
  where
      (low_a1vJ, (!high_a1vK)) = Dum.group a_a1vH l_a1vI
Dum.group ::
  Ord a_a1ve => a_a1ve -> [a_a1ve] -> ([a_a1ve], [a_a1ve])
Dum.group _ (![]) = ([], [])
Dum.group (!i_a1vL) (a_a1vM : (!l_a1vN))
  = f_a1vO (Dum.group i_a1vL l_a1vN)
  where
      f_a1vO (!(low_a1vP, high_a1vQ))
        | a_a1vM < i_a1vL = (a_a1vM : low_a1vP, high_a1vQ)
        | otherwise = (low_a1vP, a_a1vM : high_a1vQ)
Dum.insert :: Ord a_a1vd => a_a1vd -> [a_a1vd] -> [a_a1vd]
Dum.insert (!a_a1vR) (![]) = [a_a1vR]
Dum.insert a_a1vS as_a1vT@(!(x_a1vU : xs_a1vV))
  | x_a1vU > a_a1vS = a_a1vS : as_a1vT
  | otherwise = x_a1vU : Dum.insert a_a1vS xs_a1vV
Dum.replace :: Eq a_a1vc => a_a1vc -> [a_a1vc] -> [a_a1vc]
Dum.replace a_a1vW [] = []
Dum.replace a_a1vX (x_a1vY : (!xs_a1vZ))
  | a_a1vX == x_a1vY = a_a1vX : xs_a1vZ
  | otherwise = x_a1vY : Dum.replace a_a1vX xs_a1vZ
Dum.remove :: Eq a_a1vb => a_a1vb -> [a_a1vb] -> [a_a1vb]
Dum.remove a_a1w0 (![]) = []
Dum.remove (!a_a1w1) (!(x_a1w2 : (!xs_a1w3)))
  | a_a1w1 == x_a1w2 = xs_a1w3
  | otherwise = x_a1w2 : Dum.remove a_a1w1 xs_a1w3
Dum.collect ::
  Ord a_azq => (b_azr -> a_azq) -> [a_azq] -> [b_azr] -> [b_azr]
Dum.collect (!_) (![]) (!_) = []
Dum.collect (!_) (!_) [] = []
Dum.collect
  (!p_a1w4)
  as_a1w5@(!((!a_a1w6) : l_a1w7))
  bs_a1w8@(!((!b_a1w9) : k_a1wa))
  | a_a1w6 == p_a1w4 b_a1w9
  = b_a1w9 : Dum.collect p_a1w4 l_a1w7 k_a1wa
  | p_a1w4 b_a1w9 > a_a1w6 = Dum.collect p_a1w4 l_a1w7 bs_a1w8
  | otherwise = Dum.collect p_a1w4 as_a1w5 k_a1wa
Dum.span' :: (a_azp -> Bool) -> [a_azp] -> ([a_azp], [a_azp])
Dum.span' p_a1wb (![]) = ([], [])
Dum.span' (!p_a1wc) (!(x_a1wd : xs'_a1we))
  | p_a1wc x_a1wd = fixLeak_a1wf x_a1wd (Dum.span' p_a1wc xs'_a1we)
  where
      fixLeak_a1wf (!x_a1wg) (xs_a1wh, ys_a1wi)
        = (x_a1wg : xs_a1wh, ys_a1wi)
Dum.span' (!_) (!xs_a1wj) = ([], xs_a1wj)
Dum.lines' :: [Char] -> [[Char]]
Dum.lines' (!"") = []
Dum.lines' s_a1wk
  = plumb_a1wl (Dum.span' ((/=) '\n') s_a1wk)
  where
      plumb_a1wl (l_a1wm, s'_a1wn)
        = l_a1wm : if null s'_a1wn then [] else Dum.lines' (tail s'_a1wn)
Dum.strToInt :: String -> Int
Dum.strToInt (!x_a1SV)
  = strToInt'_a1SW (length x_a1SV - 1) x_a1SV
  where
      strToInt'_a1SW _ [] = 0
      strToInt'_a1SW (!x_a1SX) ((!a_a1SY) : (!l_a1SZ))
        = (Dum.charToInt a_a1SY) * (10 ^ x_a1SX)
          + (strToInt'_a1SW (x_a1SX - 1) l_a1SZ)
Dum.charToInt :: Char -> Int
Dum.charToInt x_a23O = (fromEnum x_a23O - fromEnum '0')


["a_a1vo","b_a1vp","a_a1vq","as_a1vr","safebang@!as_a1vr","(!as_a1vr)","b_a1vs","safebang@!b_a1vs","(!b_a1vs)","((!as_a1vr), (!b_a1vs))","b_a1vt","a_a1vu","bs_a1vv","(a_a1vu, bs_a1vv)","f_a1vw","safebang@!f_a1vw","(!f_a1vw)","[]","_","!_","(!_)","f_a1vx","_","!_","(!_)","[]","![]","(![])","f_a1vy","!f_a1vy","(!f_a1vy)","a_a1vz","l_a1vA","!l_a1vA","(!l_a1vA)","a_a1vz : (!l_a1vA)","(a_a1vz : (!l_a1vA))","!(a_a1vz : (!l_a1vA))","(!(a_a1vz : (!l_a1vA)))","((!(a_a1vz : (!l_a1vA))))","b_a1vB","!b_a1vB","(!b_a1vB)","k_a1vC","(!b_a1vB) : k_a1vC","((!b_a1vB) : k_a1vC)","!((!b_a1vB) : k_a1vC)","(!((!b_a1vB) : k_a1vC))","((!((!b_a1vB) : k_a1vC)))","f_a1vD","[]","f_a1vE","a_a1vF","safebang@!a_a1vF","(!a_a1vF)","l_a1vG","safebang@!l_a1vG","(!l_a1vG)","(!a_a1vF) : (!l_a1vG)","((!a_a1vF) : (!l_a1vG))","[]","![]","(![])","a_a1vH","l_a1vI","a_a1vH : l_a1vI","(a_a1vH : l_a1vI)","low_a1vJ","high_a1vK","!high_a1vK","(!high_a1vK)","(low_a1vJ, (!high_a1vK))","_","[]","![]","(![])","i_a1vL","!i_a1vL","(!i_a1vL)","a_a1vM","l_a1vN","!l_a1vN","(!l_a1vN)","a_a1vM : (!l_a1vN)","(a_a1vM : (!l_a1vN))","low_a1vP","high_a1vQ","(low_a1vP, high_a1vQ)","!(low_a1vP, high_a1vQ)","(!(low_a1vP, high_a1vQ))","a_a1vR","safebang@!a_a1vR","(!a_a1vR)","[]","![]","(![])","a_a1vS","x_a1vU","xs_a1vV","x_a1vU : xs_a1vV","(x_a1vU : xs_a1vV)","!(x_a1vU : xs_a1vV)","(!(x_a1vU : xs_a1vV))","as_a1vT@(!(x_a1vU : xs_a1vV))","a_a1vW","[]","a_a1vX","x_a1vY","xs_a1vZ","safebang@!xs_a1vZ","(!xs_a1vZ)","x_a1vY : (!xs_a1vZ)","(x_a1vY : (!xs_a1vZ))","a_a1w0","[]","![]","(![])","a_a1w1","!a_a1w1","(!a_a1w1)","x_a1w2","xs_a1w3","!xs_a1w3","(!xs_a1w3)","x_a1w2 : (!xs_a1w3)","(x_a1w2 : (!xs_a1w3))","!(x_a1w2 : (!xs_a1w3))","(!(x_a1w2 : (!xs_a1w3)))","_","!_","(!_)","[]","![]","(![])","_","!_","(!_)","_","!_","(!_)","_","!_","(!_)","[]","p_a1w4","!p_a1w4","(!p_a1w4)","a_a1w6","!a_a1w6","(!a_a1w6)","l_a1w7","(!a_a1w6) : l_a1w7","((!a_a1w6) : l_a1w7)","!((!a_a1w6) : l_a1w7)","(!((!a_a1w6) : l_a1w7))","as_a1w5@(!((!a_a1w6) : l_a1w7))","b_a1w9","!b_a1w9","(!b_a1w9)","k_a1wa","(!b_a1w9) : k_a1wa","((!b_a1w9) : k_a1wa)","!((!b_a1w9) : k_a1wa)","(!((!b_a1w9) : k_a1wa))","bs_a1w8@(!((!b_a1w9) : k_a1wa))","p_a1wb","[]","![]","(![])","p_a1wc","!p_a1wc","(!p_a1wc)","x_a1wd","xs'_a1we","x_a1wd : xs'_a1we","(x_a1wd : xs'_a1we)","!(x_a1wd : xs'_a1we)","(!(x_a1wd : xs'_a1we))","x_a1wg","!x_a1wg","(!x_a1wg)","xs_a1wh","ys_a1wi","(xs_a1wh, ys_a1wi)","_","!_","(!_)","xs_a1wj","!xs_a1wj","(!xs_a1wj)","\"\"","!\"\"","(!\"\")","s_a1wk","l_a1wm","s'_a1wn","(l_a1wm, s'_a1wn)","x_a1SV","safebang@!x_a1SV","(!x_a1SV)","_","[]","x_a1SX","!x_a1SX","(!x_a1SX)","a_a1SY","!a_a1SY","(!a_a1SY)","l_a1SZ","!l_a1SZ","(!l_a1SZ)","(!a_a1SY) : (!l_a1SZ)","((!a_a1SY) : (!l_a1SZ))","x_a23O"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Array
import Data.List
import Data.Ratio
import RandomFix
import LinearAlgebra
import Types

pair :: a_a1vm -> b_a1vn -> (a_a1vm, b_a1vn)
pair a_a1vo b_a1vp = (a_a1vo, b_a1vp)

fstcons :: a_a1vk -> ([a_a1vk], b_a1vl) -> ([a_a1vk], b_a1vl)
fstcons a_a1vq ((!as_a1vr), (!b_a1vs)) = (a_a1vq : as_a1vr, b_a1vs)

sndcons :: b_a1vi -> (a_a1vj, [b_a1vi]) -> (a_a1vj, [b_a1vi])
sndcons b_a1vt (a_a1vu, bs_a1vv) = (a_a1vu, b_a1vt : bs_a1vv)
map2 (!f_a1vw) [] (investigate@_) = []
map2 f_a1vx (investigate@_) (investigate@[]) = []
map2 (investigate@f_a1vy)
  ((investigate@(a_a1vz : (investigate@l_a1vA))))
  ((investigate@((investigate@b_a1vB) : k_a1vC)))
  = f_a1vy a_a1vz b_a1vB : map2 f_a1vy l_a1vA k_a1vC

mapcat :: (a_a1vg -> [b_a1vh]) -> [a_a1vg] -> [b_a1vh]
mapcat f_a1vD [] = []
mapcat f_a1vE ((!a_a1vF) : (!l_a1vG))
  = f_a1vE a_a1vF ++ mapcat f_a1vE l_a1vG

sort :: Ord a_a1vf => [a_a1vf] -> [a_a1vf]
sort (investigate@[]) = []
sort (a_a1vH : l_a1vI)
  = (sort low_a1vJ) ++ [a_a1vH] ++ (sort high_a1vK)
  where (low_a1vJ, (investigate@high_a1vK)) = group a_a1vH l_a1vI

group :: Ord a_a1ve => a_a1ve -> [a_a1ve] -> ([a_a1ve], [a_a1ve])
group _ (investigate@[]) = ([], [])
group (investigate@i_a1vL) (a_a1vM : (investigate@l_a1vN))
  = f_a1vO (group i_a1vL l_a1vN)
  where f_a1vO (investigate@(low_a1vP, high_a1vQ))
          | a_a1vM < i_a1vL = (a_a1vM : low_a1vP, high_a1vQ)
          | otherwise = (low_a1vP, a_a1vM : high_a1vQ)

insert :: Ord a_a1vd => a_a1vd -> [a_a1vd] -> [a_a1vd]
insert (!a_a1vR) (investigate@[]) = [a_a1vR]
insert a_a1vS as_a1vT@(investigate@(x_a1vU : xs_a1vV))
  | x_a1vU > a_a1vS = a_a1vS : as_a1vT
  | otherwise = x_a1vU : insert a_a1vS xs_a1vV

replace :: Eq a_a1vc => a_a1vc -> [a_a1vc] -> [a_a1vc]
replace a_a1vW [] = []
replace a_a1vX (x_a1vY : (!xs_a1vZ))
  | a_a1vX == x_a1vY = a_a1vX : xs_a1vZ
  | otherwise = x_a1vY : replace a_a1vX xs_a1vZ

remove :: Eq a_a1vb => a_a1vb -> [a_a1vb] -> [a_a1vb]
remove a_a1w0 (investigate@[]) = []
remove (investigate@a_a1w1)
  (investigate@(x_a1w2 : (investigate@xs_a1w3)))
  | a_a1w1 == x_a1w2 = xs_a1w3
  | otherwise = x_a1w2 : remove a_a1w1 xs_a1w3

collect ::
          Ord a_azq => (b_azr -> a_azq) -> [a_azq] -> [b_azr] -> [b_azr]
collect (investigate@_) (investigate@[]) (investigate@_) = []
collect (investigate@_) (investigate@_) [] = []
collect (investigate@p_a1w4)
  as_a1w5@(investigate@((investigate@a_a1w6) : l_a1w7))
  bs_a1w8@(investigate@((investigate@b_a1w9) : k_a1wa))
  | a_a1w6 == p_a1w4 b_a1w9 = b_a1w9 : collect p_a1w4 l_a1w7 k_a1wa
  | p_a1w4 b_a1w9 > a_a1w6 = collect p_a1w4 l_a1w7 bs_a1w8
  | otherwise = collect p_a1w4 as_a1w5 k_a1wa

span' :: (a_azp -> Bool) -> [a_azp] -> ([a_azp], [a_azp])
span' p_a1wb (investigate@[]) = ([], [])
span' (investigate@p_a1wc) (investigate@(x_a1wd : xs'_a1we))
  | p_a1wc x_a1wd = fixLeak_a1wf x_a1wd (span' p_a1wc xs'_a1we)
  where fixLeak_a1wf (investigate@x_a1wg) (xs_a1wh, ys_a1wi)
          = (x_a1wg : xs_a1wh, ys_a1wi)
span' (investigate@_) (investigate@xs_a1wj) = ([], xs_a1wj)

lines' :: [Char] -> [[Char]]
lines' (investigate@"") = []
lines' s_a1wk = plumb_a1wl (span' ((/=) '\n') s_a1wk)
  where plumb_a1wl (l_a1wm, s'_a1wn)
          = l_a1wm : if null s'_a1wn then [] else lines' (tail s'_a1wn)

strToInt :: String -> Int
strToInt (!x_a1SV) = strToInt'_a1SW (length x_a1SV - 1) x_a1SV
  where strToInt'_a1SW _ [] = 0
        strToInt'_a1SW (investigate@x_a1SX)
          ((investigate@a_a1SY) : (investigate@l_a1SZ))
          = (charToInt a_a1SY) * (10 ^ x_a1SX) +
              (strToInt'_a1SW (x_a1SX - 1) l_a1SZ)

charToInt :: Char -> Int
charToInt x_a23O = (fromEnum x_a23O - fromEnum '0')
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.random :: (Integer, Integer) -> Integer -> [Integer]
Dum.random (l_aHb, h_aHc) s_aHd
  = if l_aHb > h_aHc then
        error "Random.random: Empty interval"
    else
        if s_aHd < 0 then
            Dum.random (l_aHb, h_aHc) (- s_aHd)
        else
            let
              (q_a1Dy, s1_a1Dz) = s_aHd `divMod` 2147483562
              s2_a1DA = q_a1Dy `mod` 2147483398
              k_a1DB = h_aHc - l_aHb + 1
              b_a1DC = 2147483561
              n_a1DD = Dum.iLogBase b_a1DC k_a1DB
              f_a1DE is_a1Oi
                = let (xs_a1Oj, is'_a1Ok) = splitAt n_a1DD is_a1Oi
                  in
                    foldr
                      (\ i_a2aR r_a2aS -> fromIntegral i_a2aR + r_a2aS * b_a1DC)
                      0
                      xs_a1Oj
                    `mod` k_a1DB
                    + l_aHb
                    : f_a1DE is'_a1Ok
            in
              f_a1DE
                (Dum.randomInts
                   (fromIntegral (s1_a1Dz + 1)) (fromIntegral (s2_a1DA + 1)))
Dum.iLogBase b_a2aT i_a2aU
  = if i_a2aU < b_a2aT then
        1
    else
        1 + Dum.iLogBase b_a2aT (i_a2aU `div` b_a2aT)
Dum.randomInts :: Int -> Int -> [Int]
Dum.randomInts s1_a2aV s2_a2aW
  = if 1 <= s1_a2aV && s1_a2aV <= 2147483562 then
        if 1 <= s2_a2aW && s2_a2aW <= 2147483398 then
            Dum.rands s1_a2aV s2_a2aW
        else
            error "randomInts: Bad second seed."
    else
        error "randomInts: Bad first seed."
Dum.rands :: Int -> Int -> [Int]
Dum.rands s1_a2aX s2_a2aY
  = z'_a2aZ : Dum.rands s1''_a2b3 s2''_a2b6
  where
      z'_a2aZ = if z_a2b0 < 1 then z_a2b0 + 2147483562 else z_a2b0
      z_a2b0 = s1''_a2b3 - s2''_a2b6
      k_a2b1 = s1_a2aX `quot` 53668
      s1'_a2b2 = 40014 * (s1_a2aX - k_a2b1 * 53668) - k_a2b1 * 12211
      s1''_a2b3
        = if s1'_a2b2 < 0 then s1'_a2b2 + 2147483563 else s1'_a2b2
      k'_a2b4 = s2_a2aY `quot` 52774
      s2'_a2b5 = 40692 * (s2_a2aY - k'_a2b4 * 52774) - k'_a2b4 * 3791
      s2''_a2b6
        = if s2'_a2b5 < 0 then s2'_a2b5 + 2147483399 else s2'_a2b5


["l_aHb","h_aHc","(l_aHb, h_aHc)","s_aHd","q_a1Dy","s1_a1Dz","(q_a1Dy, s1_a1Dz)","s2_a1DA","k_a1DB","b_a1DC","n_a1DD","is_a1Oi","xs_a1Oj","is'_a1Ok","(xs_a1Oj, is'_a1Ok)","i_a2aR","r_a2aS","b_a2aT","i_a2aU","s1_a2aV","s2_a2aW","s1_a2aX","s2_a2aY","z'_a2aZ","z_a2b0","k_a2b1","s1'_a2b2","s1''_a2b3","k'_a2b4","s2'_a2b5","s2''_a2b6"]
{-# LANGUAGE BangPatterns #-}
module Dum where

random :: (Integer, Integer) -> Integer -> [Integer]
random (l_aHb, h_aHc) s_aHd
  = if l_aHb > h_aHc then error "Random.random: Empty interval" else
      if s_aHd < 0 then random (l_aHb, h_aHc) (-s_aHd) else
        let (q_a1Dy, s1_a1Dz) = s_aHd `divMod` 2147483562
            s2_a1DA = q_a1Dy `mod` 2147483398
            k_a1DB = h_aHc - l_aHb + 1
            b_a1DC = 2147483561
            n_a1DD = iLogBase b_a1DC k_a1DB
            f_a1DE is_a1Oi
              = let (xs_a1Oj, is'_a1Ok) = splitAt n_a1DD is_a1Oi in
                  foldr (\ i_a2aR r_a2aS -> fromIntegral i_a2aR + r_a2aS * b_a1DC) 0
                    xs_a1Oj
                    `mod` k_a1DB
                    + l_aHb
                    : f_a1DE is'_a1Ok
          in
          f_a1DE
            (randomInts (fromIntegral (s1_a1Dz + 1))
               (fromIntegral (s2_a1DA + 1)))
iLogBase b_a2aT i_a2aU
  = if i_a2aU < b_a2aT then 1 else
      1 + iLogBase b_a2aT (i_a2aU `div` b_a2aT)

randomInts :: Int -> Int -> [Int]
randomInts s1_a2aV s2_a2aW
  = if 1 <= s1_a2aV && s1_a2aV <= 2147483562 then
      if 1 <= s2_a2aW && s2_a2aW <= 2147483398 then rands s1_a2aV s2_a2aW
        else error "randomInts: Bad second seed."
      else error "randomInts: Bad first seed."

rands :: Int -> Int -> [Int]
rands s1_a2aX s2_a2aY = z'_a2aZ : rands s1''_a2b3 s2''_a2b6
  where z'_a2aZ = if z_a2b0 < 1 then z_a2b0 + 2147483562 else z_a2b0
        z_a2b0 = s1''_a2b3 - s2''_a2b6
        k_a2b1 = s1_a2aX `quot` 53668
        s1'_a2b2 = 40014 * (s1_a2aX - k_a2b1 * 53668) - k_a2b1 * 12211
        s1''_a2b3
          = if s1'_a2b2 < 0 then s1'_a2b2 + 2147483563 else s1'_a2b2
        k'_a2b4 = s2_a2aY `quot` 52774
        s2'_a2b5 = 40692 * (s2_a2aY - k'_a2b4 * 52774) - k'_a2b4 * 3791
        s2''_a2b6
          = if s2'_a2b5 < 0 then s2'_a2b5 + 2147483399 else s2'_a2b5
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.random :: (Integer, Integer) -> Integer -> [Integer]
Dum.random (l_aHb, h_aHc) s_aHd
  = if l_aHb > h_aHc then
        error "Random.random: Empty interval"
    else
        if s_aHd < 0 then
            Dum.random (l_aHb, h_aHc) (- s_aHd)
        else
            let
              (q_a1Dy, s1_a1Dz) = s_aHd `divMod` 2147483562
              s2_a1DA = q_a1Dy `mod` 2147483398
              k_a1DB = h_aHc - l_aHb + 1
              b_a1DC = 2147483561
              n_a1DD = Dum.iLogBase b_a1DC k_a1DB
              f_a1DE is_a1Oi
                = let (xs_a1Oj, is'_a1Ok) = splitAt n_a1DD is_a1Oi
                  in
                    foldr
                      (\ i_a2aR r_a2aS -> fromIntegral i_a2aR + r_a2aS * b_a1DC)
                      0
                      xs_a1Oj
                    `mod` k_a1DB
                    + l_aHb
                    : f_a1DE is'_a1Ok
            in
              f_a1DE
                (Dum.randomInts
                   (fromIntegral (s1_a1Dz + 1)) (fromIntegral (s2_a1DA + 1)))
Dum.iLogBase b_a2aT i_a2aU
  = if i_a2aU < b_a2aT then
        1
    else
        1 + Dum.iLogBase b_a2aT (i_a2aU `div` b_a2aT)
Dum.randomInts :: Int -> Int -> [Int]
Dum.randomInts s1_a2aV s2_a2aW
  = if 1 <= s1_a2aV && s1_a2aV <= 2147483562 then
        if 1 <= s2_a2aW && s2_a2aW <= 2147483398 then
            Dum.rands s1_a2aV s2_a2aW
        else
            error "randomInts: Bad second seed."
    else
        error "randomInts: Bad first seed."
Dum.rands :: Int -> Int -> [Int]
Dum.rands s1_a2aX s2_a2aY
  = z'_a2aZ : Dum.rands s1''_a2b3 s2''_a2b6
  where
      z'_a2aZ = if z_a2b0 < 1 then z_a2b0 + 2147483562 else z_a2b0
      z_a2b0 = s1''_a2b3 - s2''_a2b6
      k_a2b1 = s1_a2aX `quot` 53668
      s1'_a2b2 = 40014 * (s1_a2aX - k_a2b1 * 53668) - k_a2b1 * 12211
      s1''_a2b3
        = if s1'_a2b2 < 0 then s1'_a2b2 + 2147483563 else s1'_a2b2
      k'_a2b4 = s2_a2aY `quot` 52774
      s2'_a2b5 = 40692 * (s2_a2aY - k'_a2b4 * 52774) - k'_a2b4 * 3791
      s2''_a2b6
        = if s2'_a2b5 < 0 then s2'_a2b5 + 2147483399 else s2'_a2b5


["l_aHb","h_aHc","(l_aHb, h_aHc)","s_aHd","q_a1Dy","s1_a1Dz","(q_a1Dy, s1_a1Dz)","s2_a1DA","k_a1DB","b_a1DC","n_a1DD","is_a1Oi","xs_a1Oj","is'_a1Ok","(xs_a1Oj, is'_a1Ok)","i_a2aR","r_a2aS","b_a2aT","i_a2aU","s1_a2aV","s2_a2aW","s1_a2aX","s2_a2aY","z'_a2aZ","z_a2b0","k_a2b1","s1'_a2b2","s1''_a2b3","k'_a2b4","s2'_a2b5","s2''_a2b6"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Char
import Data.List
import Data.Maybe
import Data.Ratio
import Types
import ParseLib

random :: (Integer, Integer) -> Integer -> [Integer]
random (l_aHb, h_aHc) s_aHd
  = if l_aHb > h_aHc then error "Random.random: Empty interval" else
      if s_aHd < 0 then random (l_aHb, h_aHc) (-s_aHd) else
        let (q_a1Dy, s1_a1Dz) = s_aHd `divMod` 2147483562
            s2_a1DA = q_a1Dy `mod` 2147483398
            k_a1DB = h_aHc - l_aHb + 1
            b_a1DC = 2147483561
            n_a1DD = iLogBase b_a1DC k_a1DB
            f_a1DE is_a1Oi
              = let (xs_a1Oj, is'_a1Ok) = splitAt n_a1DD is_a1Oi in
                  foldr (\ i_a2aR r_a2aS -> fromIntegral i_a2aR + r_a2aS * b_a1DC) 0
                    xs_a1Oj
                    `mod` k_a1DB
                    + l_aHb
                    : f_a1DE is'_a1Ok
          in
          f_a1DE
            (randomInts (fromIntegral (s1_a1Dz + 1))
               (fromIntegral (s2_a1DA + 1)))
iLogBase b_a2aT i_a2aU
  = if i_a2aU < b_a2aT then 1 else
      1 + iLogBase b_a2aT (i_a2aU `div` b_a2aT)

randomInts :: Int -> Int -> [Int]
randomInts s1_a2aV s2_a2aW
  = if 1 <= s1_a2aV && s1_a2aV <= 2147483562 then
      if 1 <= s2_a2aW && s2_a2aW <= 2147483398 then rands s1_a2aV s2_a2aW
        else error "randomInts: Bad second seed."
      else error "randomInts: Bad first seed."

rands :: Int -> Int -> [Int]
rands s1_a2aX s2_a2aY = z'_a2aZ : rands s1''_a2b3 s2''_a2b6
  where z'_a2aZ = if z_a2b0 < 1 then z_a2b0 + 2147483562 else z_a2b0
        z_a2b0 = s1''_a2b3 - s2''_a2b6
        k_a2b1 = s1_a2aX `quot` 53668
        s1'_a2b2 = 40014 * (s1_a2aX - k_a2b1 * 53668) - k_a2b1 * 12211
        s1''_a2b3
          = if s1'_a2b2 < 0 then s1'_a2b2 + 2147483563 else s1'_a2b2
        k'_a2b4 = s2_a2aY `quot` 52774
        s2'_a2b5 = 40692 * (s2_a2aY - k'_a2b4 * 52774) - k'_a2b4 * 3791
        s2''_a2b6
          = if s2'_a2b5 < 0 then s2'_a2b5 + 2147483399 else s2'_a2b5
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.empty :: Dum.Parser [a_azD]
Dum.empty = (\ x_azE -> [([], x_azE)])
Dum.character' :: Char -> Dum.Parser Char
Dum.character' c_azF x_azG
  | null x_azG = []
  | c_azF == head x_azG = [(head x_azG, tail x_azG)]
  | otherwise = []
Dum.parse_if' :: (Char -> Bool) -> Dum.Parser Char
Dum.parse_if' p_a1RX x_a1RY
  | null x_a1RY = []
  | p_a1RX (head x_a1RY) = [(head x_a1RY, tail x_a1RY)]
  | otherwise = []
Dum.string' :: String -> Dum.Parser String
Dum.string' s_a1RZ x_a1S0
  | s_a1RZ == fst split_a1S1 = [split_a1S1]
  | otherwise = []
  where
      split_a1S1 = splitAt (length s_a1RZ) x_a1S0
Dum.parse_while' :: (Char -> Bool) -> Dum.Parser String
Dum.parse_while' p_a1Se x_a1Sf
  | null x_a1Sf = []
  | p_a1Se (head x_a1Sf) = [span p_a1Se x_a1Sf]
  | otherwise = []
Dum.choice :: [Dum.Parser r_azC] -> Dum.Parser r_azC
Dum.choice ps_a1Sg x_a1Sh
  = [r_a1Sj | p_a1Si <- ps_a1Sg, r_a1Sj <- p_a1Si x_a1Sh]
Dum.sequence2 ::
  Dum.Parser r1_azA
  -> Dum.Parser r2_azB -> Dum.Parser (r1_azA, r2_azB)
Dum.sequence2 p1_a1Sk p2_a1Sl x0_a1Sm
  = [((r1_a1Sn, r2_a1Sp), x2_a1Sq) |
       (r1_a1Sn, x1_a1So) <- p1_a1Sk x0_a1Sm,
       (r2_a1Sp, x2_a1Sq) <- p2_a1Sl x1_a1So]
Dum.sequence3 ::
  Dum.Parser r1_azx
  -> Dum.Parser r2_azy
     -> Dum.Parser r3_azz -> Dum.Parser (r1_azx, r2_azy, r3_azz)
Dum.sequence3 p1_a1Sr p2_a1Ss p3_a1St x0_a1Su
  = [((r1_a1Sv, r2_a1Sx, r3_a1Sz), x3_a1SA) |
       (r1_a1Sv, x1_a1Sw) <- p1_a1Sr x0_a1Su,
       (r2_a1Sx, x2_a1Sy) <- p2_a1Ss x1_a1Sw,
       (r3_a1Sz, x3_a1SA) <- p3_a1St x2_a1Sy]
Dum.transform ::
  (a_azv -> b_azw) -> Dum.Parser a_azv -> Dum.Parser b_azw
Dum.transform f_a1SB p_a1SC s_a1SD
  = [(f_a1SB r_a1SE, x_a1SF) | (r_a1SE, x_a1SF) <- p_a1SC s_a1SD]
Dum.allow_null :: Dum.Parser [a_azu] -> Dum.Parser [a_azu]
Dum.allow_null p_a1SG x_a1SH
  | null result_a1SI = [([], x_a1SH)]
  | otherwise = result_a1SI
  where
      result_a1SI = p_a1SG x_a1SH
Dum.forbid_null :: Dum.Parser [a_azt] -> Dum.Parser [a_azt]
Dum.forbid_null p_a1SJ
  = filter (\ (r_a1SK, x_a1SL) -> (not . null) r_a1SK) . p_a1SJ
Dum.cons ::
  Dum.Parser a_azs -> Dum.Parser [a_azs] -> Dum.Parser [a_azs]
Dum.cons p_a1SM ps_a1SN
  = Dum.transform
      (\ (a_a1SO, as_a1SP) -> a_a1SO : as_a1SP)
      (Dum.sequence2 p_a1SM ps_a1SN)
Dum.repetition0 :: Dum.Parser a_azr -> Dum.Parser [a_azr]
Dum.repetition0 p_a1SQ
  = Dum.allow_null (Dum.cons p_a1SQ (Dum.repetition0 p_a1SQ))
Dum.repetition1 :: Dum.Parser a_azq -> Dum.Parser [a_azq]
Dum.repetition1 p_a1SR = (Dum.cons p_a1SR (Dum.repetition0 p_a1SR))
Dum.option :: Dum.Parser a_azp -> Dum.Parser [a_azp]
Dum.option p_a1SS
  = Dum.choice
      [Dum.transform (\ a_a1ST -> [a_a1ST]) p_a1SS, Dum.empty]
Dum.remove_left ::
  Dum.Parser a_azn -> Dum.Parser b_azo -> Dum.Parser b_azo
Dum.remove_left p1_a1SU p2_a1SV
  = Dum.transform snd (Dum.sequence2 p1_a1SU p2_a1SV)
Dum.remove_right ::
  Dum.Parser a_azl -> Dum.Parser b_azm -> Dum.Parser a_azl
Dum.remove_right p1_a1SW p2_a1SX
  = Dum.transform fst (Dum.sequence2 p1_a1SW p2_a1SX)
Dum.enclose ::
  Dum.Parser a_azi
  -> Dum.Parser b_azj -> Dum.Parser c_azk -> Dum.Parser b_azj
Dum.enclose p1_a1SY p2_a1SZ p3_a1T0
  = Dum.transform
      take_mid_a1T1 (Dum.sequence3 p1_a1SY p2_a1SZ p3_a1T0)
  where
      take_mid_a1T1 (a_a1T2, b_a1T3, c_a1T4) = b_a1T3
Dum.glue ::
  Dum.Parser a_azf
  -> Dum.Parser b_azg
     -> Dum.Parser c_azh -> Dum.Parser (a_azf, c_azh)
Dum.glue p1_a1T5 p2_a1T6 p3_a1T7
  = Dum.transform
      drop_mid_a1T8 (Dum.sequence3 p1_a1T5 p2_a1T6 p3_a1T7)
  where
      drop_mid_a1T8 (a_a1T9, b_a1Ta, c_a1Tb) = (a_a1T9, c_a1Tb)
Dum.whitespace :: Dum.Parser String
Dum.whitespace = Dum.allow_null (Dum.parse_while' isSpace)
Dum.character :: Char -> Dum.Parser Char
Dum.character c_a1XK
  = Dum.remove_left Dum.whitespace (Dum.character' c_a1XK)
Dum.parse_if :: (Char -> Bool) -> Dum.Parser Char
Dum.parse_if p_a1XL
  = Dum.remove_left Dum.whitespace (Dum.parse_if' p_a1XL)
Dum.string :: String -> Dum.Parser String
Dum.string s_a1XM
  = Dum.remove_left Dum.whitespace (Dum.string' s_a1XM)
Dum.parse_while :: (Char -> Bool) -> Dum.Parser String
Dum.parse_while p_a1XN
  = Dum.remove_left Dum.whitespace (Dum.parse_while' p_a1XN)
Dum.parse :: Dum.Parser a_asa -> String -> [a_asa]
Dum.parse parser_a1XO = map fst . filter (null . snd) . parser_a1XO

type Dum.Parser a_as9 = String -> [(a_as9, String)]


["empty","x_azE","c_azF","x_azG","p_a1RX","x_a1RY","s_a1RZ","x_a1S0","split_a1S1","p_a1Se","x_a1Sf","ps_a1Sg","x_a1Sh","p_a1Si","r_a1Sj","p1_a1Sk","p2_a1Sl","x0_a1Sm","r1_a1Sn","x1_a1So","(r1_a1Sn, x1_a1So)","r2_a1Sp","x2_a1Sq","(r2_a1Sp, x2_a1Sq)","p1_a1Sr","p2_a1Ss","p3_a1St","x0_a1Su","r1_a1Sv","x1_a1Sw","(r1_a1Sv, x1_a1Sw)","r2_a1Sx","x2_a1Sy","(r2_a1Sx, x2_a1Sy)","r3_a1Sz","x3_a1SA","(r3_a1Sz, x3_a1SA)","f_a1SB","p_a1SC","s_a1SD","r_a1SE","x_a1SF","(r_a1SE, x_a1SF)","p_a1SG","x_a1SH","result_a1SI","p_a1SJ","r_a1SK","x_a1SL","(r_a1SK, x_a1SL)","p_a1SM","ps_a1SN","a_a1SO","as_a1SP","(a_a1SO, as_a1SP)","p_a1SQ","p_a1SR","p_a1SS","a_a1ST","p1_a1SU","p2_a1SV","p1_a1SW","p2_a1SX","p1_a1SY","p2_a1SZ","p3_a1T0","a_a1T2","b_a1T3","c_a1T4","(a_a1T2, b_a1T3, c_a1T4)","p1_a1T5","p2_a1T6","p3_a1T7","a_a1T9","b_a1Ta","c_a1Tb","(a_a1T9, b_a1Ta, c_a1Tb)","whitespace","c_a1XK","p_a1XL","s_a1XM","p_a1XN","parser_a1XO"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Char

empty :: Parser [a_azD]
empty = (\ x_azE -> [([], x_azE)])

character' :: Char -> Parser Char
character' c_azF x_azG
  | null x_azG = []
  | c_azF == head x_azG = [(head x_azG, tail x_azG)]
  | otherwise = []

parse_if' :: (Char -> Bool) -> Parser Char
parse_if' p_a1RX x_a1RY
  | null x_a1RY = []
  | p_a1RX (head x_a1RY) = [(head x_a1RY, tail x_a1RY)]
  | otherwise = []

string' :: String -> Parser String
string' s_a1RZ x_a1S0
  | s_a1RZ == fst split_a1S1 = [split_a1S1]
  | otherwise = []
  where split_a1S1 = splitAt (length s_a1RZ) x_a1S0

parse_while' :: (Char -> Bool) -> Parser String
parse_while' p_a1Se x_a1Sf
  | null x_a1Sf = []
  | p_a1Se (head x_a1Sf) = [span p_a1Se x_a1Sf]
  | otherwise = []

choice :: [Parser r_azC] -> Parser r_azC
choice ps_a1Sg x_a1Sh
  = [r_a1Sj | p_a1Si <- ps_a1Sg, r_a1Sj <- p_a1Si x_a1Sh]

sequence2 ::
          Parser r1_azA -> Parser r2_azB -> Parser (r1_azA, r2_azB)
sequence2 p1_a1Sk p2_a1Sl x0_a1Sm
  = [((r1_a1Sn, r2_a1Sp), x2_a1Sq) |
     (r1_a1Sn, x1_a1So) <- p1_a1Sk x0_a1Sm,
     (r2_a1Sp, x2_a1Sq) <- p2_a1Sl x1_a1So]

sequence3 ::
          Parser r1_azx ->
            Parser r2_azy -> Parser r3_azz -> Parser (r1_azx, r2_azy, r3_azz)
sequence3 p1_a1Sr p2_a1Ss p3_a1St x0_a1Su
  = [((r1_a1Sv, r2_a1Sx, r3_a1Sz), x3_a1SA) |
     (r1_a1Sv, x1_a1Sw) <- p1_a1Sr x0_a1Su,
     (r2_a1Sx, x2_a1Sy) <- p2_a1Ss x1_a1Sw,
     (r3_a1Sz, x3_a1SA) <- p3_a1St x2_a1Sy]

transform :: (a_azv -> b_azw) -> Parser a_azv -> Parser b_azw
transform f_a1SB p_a1SC s_a1SD
  = [(f_a1SB r_a1SE, x_a1SF) | (r_a1SE, x_a1SF) <- p_a1SC s_a1SD]

allow_null :: Parser [a_azu] -> Parser [a_azu]
allow_null p_a1SG x_a1SH
  | null result_a1SI = [([], x_a1SH)]
  | otherwise = result_a1SI
  where result_a1SI = p_a1SG x_a1SH

forbid_null :: Parser [a_azt] -> Parser [a_azt]
forbid_null p_a1SJ
  = filter (\ (r_a1SK, x_a1SL) -> (not . null) r_a1SK) . p_a1SJ

cons :: Parser a_azs -> Parser [a_azs] -> Parser [a_azs]
cons p_a1SM ps_a1SN
  = transform (\ (a_a1SO, as_a1SP) -> a_a1SO : as_a1SP)
      (sequence2 p_a1SM ps_a1SN)

repetition0 :: Parser a_azr -> Parser [a_azr]
repetition0 p_a1SQ = allow_null (cons p_a1SQ (repetition0 p_a1SQ))

repetition1 :: Parser a_azq -> Parser [a_azq]
repetition1 p_a1SR = (cons p_a1SR (repetition0 p_a1SR))

option :: Parser a_azp -> Parser [a_azp]
option p_a1SS
  = choice [transform (\ a_a1ST -> [a_a1ST]) p_a1SS, empty]

remove_left :: Parser a_azn -> Parser b_azo -> Parser b_azo
remove_left p1_a1SU p2_a1SV
  = transform snd (sequence2 p1_a1SU p2_a1SV)

remove_right :: Parser a_azl -> Parser b_azm -> Parser a_azl
remove_right p1_a1SW p2_a1SX
  = transform fst (sequence2 p1_a1SW p2_a1SX)

enclose ::
        Parser a_azi -> Parser b_azj -> Parser c_azk -> Parser b_azj
enclose p1_a1SY p2_a1SZ p3_a1T0
  = transform take_mid_a1T1 (sequence3 p1_a1SY p2_a1SZ p3_a1T0)
  where take_mid_a1T1 (a_a1T2, b_a1T3, c_a1T4) = b_a1T3

glue ::
     Parser a_azf ->
       Parser b_azg -> Parser c_azh -> Parser (a_azf, c_azh)
glue p1_a1T5 p2_a1T6 p3_a1T7
  = transform drop_mid_a1T8 (sequence3 p1_a1T5 p2_a1T6 p3_a1T7)
  where drop_mid_a1T8 (a_a1T9, b_a1Ta, c_a1Tb) = (a_a1T9, c_a1Tb)

whitespace :: Parser String
whitespace = allow_null (parse_while' isSpace)

character :: Char -> Parser Char
character c_a1XK = remove_left whitespace (character' c_a1XK)

parse_if :: (Char -> Bool) -> Parser Char
parse_if p_a1XL = remove_left whitespace (parse_if' p_a1XL)

string :: String -> Parser String
string s_a1XM = remove_left whitespace (string' s_a1XM)

parse_while :: (Char -> Bool) -> Parser String
parse_while p_a1XN = remove_left whitespace (parse_while' p_a1XN)

parse :: Parser a_asa -> String -> [a_asa]
parse parser_a1XO = map fst . filter (null . snd) . parser_a1XO

type Parser a_as9 = String -> [(a_as9, String)]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.circa :: Dum.Exact -> Dum.Approx
Dum.circa = fromRational

type Dum.Name = String
type Dum.Seed = Integer
type Dum.Index = Int
type Dum.Vector a_aRZ = Array Dum.Index a_aRZ
type Dum.Matrix a_aIt = Array (Dum.Index, Dum.Index) a_aIt
type Dum.Exact = Rational
type Dum.Time = Dum.Exact
type Dum.Approx = Double
type Dum.List = [(Dum.Approx, Dum.Approx)]
data Dum.Element
  = Dum.Conductor Dum.Exact |
    Dum.Resistor Dum.Exact |
    Dum.Capacitor (Dum.Exact, Dum.Exact) |
    Dum.Inductor (Dum.Exact, Dum.Exact) |
    Dum.Vsource Dum.List |
    Dum.Isource Dum.List |
    Dum.Junction (Dum.Exact, Dum.Exact, Dum.Exact)
  deriving (Show)
type Dum.Circuit = [(Dum.Index, Dum.Index, Dum.Index, Dum.Element)]
type Dum.Random = [Dum.Approx]
type Dum.Output = Dum.Vector Dum.Approx
type Dum.State = Dum.Vector Dum.Approx
type Dum.RBC = Dum.Approx
type Dum.Temperature = Dum.Approx


["circa"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Array

circa :: Exact -> Approx
circa = fromRational

type Name = String

type Seed = Integer

type Index = Int

type Vector a_aRZ = Array Index a_aRZ

type Matrix a_aIt = Array (Index, Index) a_aIt

type Exact = Rational

type Time = Exact

type Approx = Double

type List = [(Approx, Approx)]

data Element = Conductor Exact
             | Resistor Exact
             | Capacitor (Exact, Exact)
             | Inductor (Exact, Exact)
             | Vsource List
             | Isource List
             | Junction (Exact, Exact, Exact)
             deriving Show

type Circuit = [(Index, Index, Index, Element)]

type Random = [Approx]

type Output = Vector Approx

type State = Vector Approx

type RBC = Approx

type Temperature = Approx
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.circa :: Dum.Exact -> Dum.Approx
Dum.circa = fromRational

type Dum.Name = String
type Dum.Seed = Integer
type Dum.Index = Int
type Dum.Vector a_aRZ = Array Dum.Index a_aRZ
type Dum.Matrix a_aIt = Array (Dum.Index, Dum.Index) a_aIt
type Dum.Exact = Rational
type Dum.Time = Dum.Exact
type Dum.Approx = Double
type Dum.List = [(Dum.Approx, Dum.Approx)]
data Dum.Element
  = Dum.Conductor Dum.Exact |
    Dum.Resistor Dum.Exact |
    Dum.Capacitor (Dum.Exact, Dum.Exact) |
    Dum.Inductor (Dum.Exact, Dum.Exact) |
    Dum.Vsource Dum.List |
    Dum.Isource Dum.List |
    Dum.Junction (Dum.Exact, Dum.Exact, Dum.Exact)
  deriving (Show)
type Dum.Circuit = [(Dum.Index, Dum.Index, Dum.Index, Dum.Element)]
type Dum.Random = [Dum.Approx]
type Dum.Output = Dum.Vector Dum.Approx
type Dum.State = Dum.Vector Dum.Approx
type Dum.RBC = Dum.Approx
type Dum.Temperature = Dum.Approx


["circa"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import GamtebMain
import System.IO

circa :: Exact -> Approx
circa = fromRational

type Name = String

type Seed = Integer

type Index = Int

type Vector a_aRZ = Array Index a_aRZ

type Matrix a_aIt = Array (Index, Index) a_aIt

type Exact = Rational

type Time = Exact

type Approx = Double

type List = [(Approx, Approx)]

data Element = Conductor Exact
             | Resistor Exact
             | Capacitor (Exact, Exact)
             | Inductor (Exact, Exact)
             | Vsource List
             | Isource List
             | Junction (Exact, Exact, Exact)
             deriving Show

type Circuit = [(Index, Index, Index, Element)]

type Random = [Approx]

type Output = Vector Approx

type State = Vector Approx

type RBC = Approx

type Temperature = Approx
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.cylLen, Dum.cylLen2, Dum.cylRad, Dum.cylRad2, Dum.wgtCut, Dum.wgtCut2, Dum.ergCut, Dum.big, Dum.small, Dum.nothing ::
  Double
Dum.cylLen = 20.0
Dum.cylLen2 = Dum.cylLen + 10.0
Dum.cylRad = 1.0
Dum.cylRad2 = Dum.cylRad * Dum.cylRad
Dum.big = 100.0
Dum.small = 1.0e-7
Dum.nothing = - 30.0
Dum.wgtCut = 0.5
Dum.wgtCut2 = Dum.wgtCut * Dum.wgtCut
Dum.ergCut = 1.0e-3
Dum.scatter, Dum.escape, Dum.transit, Dum.numExit, Dum.numLev, Dum.numStat ::
  Int
Dum.ne, Dum.nt, Dum.ns, Dum.nek, Dum.nwk, Dum.nr, Dum.nsp, Dum.nc, Dum.nnc, Dum.nrk, Dum.wrl, Dum.wrg ::
  Int
Dum.scatter = 1
Dum.escape = 2
Dum.transit = 3
Dum.numExit = 3
Dum.numLev = 35
Dum.numStat = 12
Dum.ne = 1
Dum.nt = 2
Dum.ns = 3
Dum.nek = 4
Dum.nwk = 5
Dum.nr = 6
Dum.nsp = 7
Dum.nc = 8
Dum.nnc = 9
Dum.nrk = 10
Dum.wrl = 11
Dum.wrg = 12


["cylLen","cylLen2","cylRad","cylRad2","big","small","nothing","wgtCut","wgtCut2","ergCut","scatter","escape","transit","numExit","numLev","numStat","ne","nt","ns","nek","nwk","nr","nsp","nc","nnc","nrk","wrl","wrg"]
{-# LANGUAGE BangPatterns #-}
module Dum where

cylLen, cylLen2, cylRad, cylRad2, wgtCut, wgtCut2, ergCut, big,
        small, nothing :: Double
cylLen = 20.0
cylLen2 = cylLen + 10.0
cylRad = 1.0
cylRad2 = cylRad * cylRad
big = 100.0
small = 1.0e-7
nothing = -30.0
wgtCut = 0.5
wgtCut2 = wgtCut * wgtCut
ergCut = 1.0e-3

scatter, escape, transit, numExit, numLev, numStat :: Int

ne, nt, ns, nek, nwk, nr, nsp, nc, nnc, nrk, wrl, wrg :: Int
scatter = 1
escape = 2
transit = 3
numExit = 3
numLev = 35
numStat = 12
ne = 1
nt = 2
ns = 3
nek = 4
nwk = 5
nr = 6
nsp = 7
nc = 8
nnc = 9
nrk = 10
wrl = 11
wrg = 12
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.cylLen, Dum.cylLen2, Dum.cylRad, Dum.cylRad2, Dum.wgtCut, Dum.wgtCut2, Dum.ergCut, Dum.big, Dum.small, Dum.nothing ::
  Double
Dum.cylLen = 20.0
Dum.cylLen2 = Dum.cylLen + 10.0
Dum.cylRad = 1.0
Dum.cylRad2 = Dum.cylRad * Dum.cylRad
Dum.big = 100.0
Dum.small = 1.0e-7
Dum.nothing = - 30.0
Dum.wgtCut = 0.5
Dum.wgtCut2 = Dum.wgtCut * Dum.wgtCut
Dum.ergCut = 1.0e-3
Dum.scatter, Dum.escape, Dum.transit, Dum.numExit, Dum.numLev, Dum.numStat ::
  Int
Dum.ne, Dum.nt, Dum.ns, Dum.nek, Dum.nwk, Dum.nr, Dum.nsp, Dum.nc, Dum.nnc, Dum.nrk, Dum.wrl, Dum.wrg ::
  Int
Dum.scatter = 1
Dum.escape = 2
Dum.transit = 3
Dum.numExit = 3
Dum.numLev = 35
Dum.numStat = 12
Dum.ne = 1
Dum.nt = 2
Dum.ns = 3
Dum.nek = 4
Dum.nwk = 5
Dum.nr = 6
Dum.nsp = 7
Dum.nc = 8
Dum.nnc = 9
Dum.nrk = 10
Dum.wrl = 11
Dum.wrg = 12


["cylLen","cylLen2","cylRad","cylRad2","big","small","nothing","wgtCut","wgtCut2","ergCut","scatter","escape","transit","numExit","numLev","numStat","ne","nt","ns","nek","nwk","nr","nsp","nc","nnc","nrk","wrl","wrg"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import GamtebType
import Consts
import Utils

cylLen, cylLen2, cylRad, cylRad2, wgtCut, wgtCut2, ergCut, big,
        small, nothing :: Double
cylLen = 20.0
cylLen2 = cylLen + 10.0
cylRad = 1.0
cylRad2 = cylRad * cylRad
big = 100.0
small = 1.0e-7
nothing = -30.0
wgtCut = 0.5
wgtCut2 = wgtCut * wgtCut
ergCut = 1.0e-3

scatter, escape, transit, numExit, numLev, numStat :: Int

ne, nt, ns, nek, nwk, nr, nsp, nc, nnc, nrk, wrl, wrg :: Int
scatter = 1
escape = 2
transit = 3
numExit = 3
numLev = 35
numStat = 12
ne = 1
nt = 2
ns = 3
nek = 4
nwk = 5
nr = 6
nsp = 7
nc = 8
nnc = 9
nrk = 10
wrl = 11
wrg = 12
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.cylLen, Dum.cylLen2, Dum.cylRad, Dum.cylRad2, Dum.wgtCut, Dum.wgtCut2, Dum.ergCut, Dum.big, Dum.small, Dum.nothing ::
  Double
Dum.cylLen = 20.0
Dum.cylLen2 = Dum.cylLen + 10.0
Dum.cylRad = 1.0
Dum.cylRad2 = Dum.cylRad * Dum.cylRad
Dum.big = 100.0
Dum.small = 1.0e-7
Dum.nothing = - 30.0
Dum.wgtCut = 0.5
Dum.wgtCut2 = Dum.wgtCut * Dum.wgtCut
Dum.ergCut = 1.0e-3
Dum.scatter, Dum.escape, Dum.transit, Dum.numExit, Dum.numLev, Dum.numStat ::
  Int
Dum.ne, Dum.nt, Dum.ns, Dum.nek, Dum.nwk, Dum.nr, Dum.nsp, Dum.nc, Dum.nnc, Dum.nrk, Dum.wrl, Dum.wrg ::
  Int
Dum.scatter = 1
Dum.escape = 2
Dum.transit = 3
Dum.numExit = 3
Dum.numLev = 35
Dum.numStat = 12
Dum.ne = 1
Dum.nt = 2
Dum.ns = 3
Dum.nek = 4
Dum.nwk = 5
Dum.nr = 6
Dum.nsp = 7
Dum.nc = 8
Dum.nnc = 9
Dum.nrk = 10
Dum.wrl = 11
Dum.wrg = 12


["cylLen","cylLen2","cylRad","cylRad2","big","small","nothing","wgtCut","wgtCut2","ergCut","scatter","escape","transit","numExit","numLev","numStat","ne","nt","ns","nek","nwk","nr","nsp","nc","nnc","nrk","wrl","wrg"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import GamtebType
import Consts
import Utils
import TransPort
import Output

cylLen, cylLen2, cylRad, cylRad2, wgtCut, wgtCut2, ergCut, big,
        small, nothing :: Double
cylLen = 20.0
cylLen2 = cylLen + 10.0
cylRad = 1.0
cylRad2 = cylRad * cylRad
big = 100.0
small = 1.0e-7
nothing = -30.0
wgtCut = 0.5
wgtCut2 = wgtCut * wgtCut
ergCut = 1.0e-3

scatter, escape, transit, numExit, numLev, numStat :: Int

ne, nt, ns, nek, nwk, nr, nsp, nc, nnc, nrk, wrl, wrg :: Int
scatter = 1
escape = 2
transit = 3
numExit = 3
numLev = 35
numStat = 12
ne = 1
nt = 2
ns = 3
nek = 4
nwk = 5
nr = 6
nsp = 7
nc = 8
nnc = 9
nrk = 10
wrl = 11
wrg = 12
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.cylLen, Dum.cylLen2, Dum.cylRad, Dum.cylRad2, Dum.wgtCut, Dum.wgtCut2, Dum.ergCut, Dum.big, Dum.small, Dum.nothing ::
  Double
Dum.cylLen = 20.0
Dum.cylLen2 = Dum.cylLen + 10.0
Dum.cylRad = 1.0
Dum.cylRad2 = Dum.cylRad * Dum.cylRad
Dum.big = 100.0
Dum.small = 1.0e-7
Dum.nothing = - 30.0
Dum.wgtCut = 0.5
Dum.wgtCut2 = Dum.wgtCut * Dum.wgtCut
Dum.ergCut = 1.0e-3
Dum.scatter, Dum.escape, Dum.transit, Dum.numExit, Dum.numLev, Dum.numStat ::
  Int
Dum.ne, Dum.nt, Dum.ns, Dum.nek, Dum.nwk, Dum.nr, Dum.nsp, Dum.nc, Dum.nnc, Dum.nrk, Dum.wrl, Dum.wrg ::
  Int
Dum.scatter = 1
Dum.escape = 2
Dum.transit = 3
Dum.numExit = 3
Dum.numLev = 35
Dum.numStat = 12
Dum.ne = 1
Dum.nt = 2
Dum.ns = 3
Dum.nek = 4
Dum.nwk = 5
Dum.nr = 6
Dum.nsp = 7
Dum.nc = 8
Dum.nnc = 9
Dum.nrk = 10
Dum.wrl = 11
Dum.wrg = 12


["cylLen","cylLen2","cylRad","cylRad2","big","small","nothing","wgtCut","wgtCut2","ergCut","scatter","escape","transit","numExit","numLev","numStat","ne","nt","ns","nek","nwk","nr","nsp","nc","nnc","nrk","wrl","wrg"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import GamtebType
import Consts

cylLen, cylLen2, cylRad, cylRad2, wgtCut, wgtCut2, ergCut, big,
        small, nothing :: Double
cylLen = 20.0
cylLen2 = cylLen + 10.0
cylRad = 1.0
cylRad2 = cylRad * cylRad
big = 100.0
small = 1.0e-7
nothing = -30.0
wgtCut = 0.5
wgtCut2 = wgtCut * wgtCut
ergCut = 1.0e-3

scatter, escape, transit, numExit, numLev, numStat :: Int

ne, nt, ns, nek, nwk, nr, nsp, nc, nnc, nrk, wrl, wrg :: Int
scatter = 1
escape = 2
transit = 3
numExit = 3
numLev = 35
numStat = 12
ne = 1
nt = 2
ns = 3
nek = 4
nwk = 5
nr = 6
nsp = 7
nc = 8
nnc = 9
nrk = 10
wrl = 11
wrg = 12
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.cylLen, Dum.cylLen2, Dum.cylRad, Dum.cylRad2, Dum.wgtCut, Dum.wgtCut2, Dum.ergCut, Dum.big, Dum.small, Dum.nothing ::
  Double
Dum.cylLen = 20.0
Dum.cylLen2 = Dum.cylLen + 10.0
Dum.cylRad = 1.0
Dum.cylRad2 = Dum.cylRad * Dum.cylRad
Dum.big = 100.0
Dum.small = 1.0e-7
Dum.nothing = - 30.0
Dum.wgtCut = 0.5
Dum.wgtCut2 = Dum.wgtCut * Dum.wgtCut
Dum.ergCut = 1.0e-3
Dum.scatter, Dum.escape, Dum.transit, Dum.numExit, Dum.numLev, Dum.numStat ::
  Int
Dum.ne, Dum.nt, Dum.ns, Dum.nek, Dum.nwk, Dum.nr, Dum.nsp, Dum.nc, Dum.nnc, Dum.nrk, Dum.wrl, Dum.wrg ::
  Int
Dum.scatter = 1
Dum.escape = 2
Dum.transit = 3
Dum.numExit = 3
Dum.numLev = 35
Dum.numStat = 12
Dum.ne = 1
Dum.nt = 2
Dum.ns = 3
Dum.nek = 4
Dum.nwk = 5
Dum.nr = 6
Dum.nsp = 7
Dum.nc = 8
Dum.nnc = 9
Dum.nrk = 10
Dum.wrl = 11
Dum.wrg = 12


["cylLen","cylLen2","cylRad","cylRad2","big","small","nothing","wgtCut","wgtCut2","ergCut","scatter","escape","transit","numExit","numLev","numStat","ne","nt","ns","nek","nwk","nr","nsp","nc","nnc","nrk","wrl","wrg"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import GamtebType
import Consts
import Utils

cylLen, cylLen2, cylRad, cylRad2, wgtCut, wgtCut2, ergCut, big,
        small, nothing :: Double
cylLen = 20.0
cylLen2 = cylLen + 10.0
cylRad = 1.0
cylRad2 = cylRad * cylRad
big = 100.0
small = 1.0e-7
nothing = -30.0
wgtCut = 0.5
wgtCut2 = wgtCut * wgtCut
ergCut = 1.0e-3

scatter, escape, transit, numExit, numLev, numStat :: Int

ne, nt, ns, nek, nwk, nr, nsp, nc, nnc, nrk, wrl, wrg :: Int
scatter = 1
escape = 2
transit = 3
numExit = 3
numLev = 35
numStat = 12
ne = 1
nt = 2
ns = 3
nek = 4
nwk = 5
nr = 6
nsp = 7
nc = 8
nnc = 9
nrk = 10
wrl = 11
wrg = 12
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.cylLen, Dum.cylLen2, Dum.cylRad, Dum.cylRad2, Dum.wgtCut, Dum.wgtCut2, Dum.ergCut, Dum.big, Dum.small, Dum.nothing ::
  Double
Dum.cylLen = 20.0
Dum.cylLen2 = Dum.cylLen + 10.0
Dum.cylRad = 1.0
Dum.cylRad2 = Dum.cylRad * Dum.cylRad
Dum.big = 100.0
Dum.small = 1.0e-7
Dum.nothing = - 30.0
Dum.wgtCut = 0.5
Dum.wgtCut2 = Dum.wgtCut * Dum.wgtCut
Dum.ergCut = 1.0e-3
Dum.scatter, Dum.escape, Dum.transit, Dum.numExit, Dum.numLev, Dum.numStat ::
  Int
Dum.ne, Dum.nt, Dum.ns, Dum.nek, Dum.nwk, Dum.nr, Dum.nsp, Dum.nc, Dum.nnc, Dum.nrk, Dum.wrl, Dum.wrg ::
  Int
Dum.scatter = 1
Dum.escape = 2
Dum.transit = 3
Dum.numExit = 3
Dum.numLev = 35
Dum.numStat = 12
Dum.ne = 1
Dum.nt = 2
Dum.ns = 3
Dum.nek = 4
Dum.nwk = 5
Dum.nr = 6
Dum.nsp = 7
Dum.nc = 8
Dum.nnc = 9
Dum.nrk = 10
Dum.wrl = 11
Dum.wrg = 12


["cylLen","cylLen2","cylRad","cylRad2","big","small","nothing","wgtCut","wgtCut2","ergCut","scatter","escape","transit","numExit","numLev","numStat","ne","nt","ns","nek","nwk","nr","nsp","nc","nnc","nrk","wrl","wrg"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import GamtebType
import Consts
import Utils
import Distance
import RoulSplit
import PhotoElec
import Compton
import Pair

cylLen, cylLen2, cylRad, cylRad2, wgtCut, wgtCut2, ergCut, big,
        small, nothing :: Double
cylLen = 20.0
cylLen2 = cylLen + 10.0
cylRad = 1.0
cylRad2 = cylRad * cylRad
big = 100.0
small = 1.0e-7
nothing = -30.0
wgtCut = 0.5
wgtCut2 = wgtCut * wgtCut
ergCut = 1.0e-3

scatter, escape, transit, numExit, numLev, numStat :: Int

ne, nt, ns, nek, nwk, nr, nsp, nc, nnc, nrk, wrl, wrg :: Int
scatter = 1
escape = 2
transit = 3
numExit = 3
numLev = 35
numStat = 12
ne = 1
nt = 2
ns = 3
nek = 4
nwk = 5
nr = 6
nsp = 7
nc = 8
nnc = 9
nrk = 10
wrl = 11
wrg = 12
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
type Dum.Angle = Double
type Dum.Coord = Double
type Dum.Energy = Double
type Dum.Indx = Int
type Dum.PartType = Int
type Dum.Prob = Double
type Dum.Random = Double
type Dum.StatType = Int
type Dum.Weight = Double
type Dum.Value = Double
type Dum.Result = ((Dum.PartType, Dum.Indx), Dum.Weight)
type Dum.Stat = (Dum.StatType, Dum.Value)
type Dum.Point = (Dum.Coord, Dum.Coord, Dum.Coord)
type Dum.Probability = (Dum.Prob, Dum.Prob, Dum.Prob, Dum.Prob)
data Dum.Particle
  = Dum.Part Dum.Point Dum.Point Dum.Weight Dum.Energy Dum.Indx Int Dum.Random


[]
{-# LANGUAGE BangPatterns #-}
module Dum where

type Angle = Double

type Coord = Double

type Energy = Double

type Indx = Int

type PartType = Int

type Prob = Double

type Random = Double

type StatType = Int

type Weight = Double

type Value = Double

type Result = ((PartType, Indx), Weight)

type Stat = (StatType, Value)

type Point = (Coord, Coord, Coord)

type Probability = (Prob, Prob, Prob, Prob)

data Particle = Part Point Point Weight Energy Indx Int Random
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
type Dum.Angle = Double
type Dum.Coord = Double
type Dum.Energy = Double
type Dum.Indx = Int
type Dum.PartType = Int
type Dum.Prob = Double
type Dum.Random = Double
type Dum.StatType = Int
type Dum.Weight = Double
type Dum.Value = Double
type Dum.Result = ((Dum.PartType, Dum.Indx), Dum.Weight)
type Dum.Stat = (Dum.StatType, Dum.Value)
type Dum.Point = (Dum.Coord, Dum.Coord, Dum.Coord)
type Dum.Probability = (Dum.Prob, Dum.Prob, Dum.Prob, Dum.Prob)
data Dum.Particle
  = Dum.Part Dum.Point Dum.Point Dum.Weight Dum.Energy Dum.Indx Int Dum.Random


[]
{-# LANGUAGE BangPatterns #-}
module Dum where
import GamtebType
import Consts
import InitTable
import Data.Array ((!))

type Angle = Double

type Coord = Double

type Energy = Double

type Indx = Int

type PartType = Int

type Prob = Double

type Random = Double

type StatType = Int

type Weight = Double

type Value = Double

type Result = ((PartType, Indx), Weight)

type Stat = (StatType, Value)

type Point = (Coord, Coord, Coord)

type Probability = (Prob, Prob, Prob, Prob)

data Particle = Part Point Point Weight Energy Indx Int Random
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
type Dum.Angle = Double
type Dum.Coord = Double
type Dum.Energy = Double
type Dum.Indx = Int
type Dum.PartType = Int
type Dum.Prob = Double
type Dum.Random = Double
type Dum.StatType = Int
type Dum.Weight = Double
type Dum.Value = Double
type Dum.Result = ((Dum.PartType, Dum.Indx), Dum.Weight)
type Dum.Stat = (Dum.StatType, Dum.Value)
type Dum.Point = (Dum.Coord, Dum.Coord, Dum.Coord)
type Dum.Probability = (Dum.Prob, Dum.Prob, Dum.Prob, Dum.Prob)
data Dum.Particle
  = Dum.Part Dum.Point Dum.Point Dum.Weight Dum.Energy Dum.Indx Int Dum.Random


[]
{-# LANGUAGE BangPatterns #-}
module Dum where
import GamtebType
import Consts
import Utils

type Angle = Double

type Coord = Double

type Energy = Double

type Indx = Int

type PartType = Int

type Prob = Double

type Random = Double

type StatType = Int

type Weight = Double

type Value = Double

type Result = ((PartType, Indx), Weight)

type Stat = (StatType, Value)

type Point = (Coord, Coord, Coord)

type Probability = (Prob, Prob, Prob, Prob)

data Particle = Part Point Point Weight Energy Indx Int Random
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
type Dum.Angle = Double
type Dum.Coord = Double
type Dum.Energy = Double
type Dum.Indx = Int
type Dum.PartType = Int
type Dum.Prob = Double
type Dum.Random = Double
type Dum.StatType = Int
type Dum.Weight = Double
type Dum.Value = Double
type Dum.Result = ((Dum.PartType, Dum.Indx), Dum.Weight)
type Dum.Stat = (Dum.StatType, Dum.Value)
type Dum.Point = (Dum.Coord, Dum.Coord, Dum.Coord)
type Dum.Probability = (Dum.Prob, Dum.Prob, Dum.Prob, Dum.Prob)
data Dum.Particle
  = Dum.Part Dum.Point Dum.Point Dum.Weight Dum.Energy Dum.Indx Int Dum.Random


[]
{-# LANGUAGE BangPatterns #-}
module Dum where
import GamtebType
import Consts
import Utils

type Angle = Double

type Coord = Double

type Energy = Double

type Indx = Int

type PartType = Int

type Prob = Double

type Random = Double

type StatType = Int

type Weight = Double

type Value = Double

type Result = ((PartType, Indx), Weight)

type Stat = (StatType, Value)

type Point = (Coord, Coord, Coord)

type Probability = (Prob, Prob, Prob, Prob)

data Particle = Part Point Point Weight Energy Indx Int Random
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
type Dum.Angle = Double
type Dum.Coord = Double
type Dum.Energy = Double
type Dum.Indx = Int
type Dum.PartType = Int
type Dum.Prob = Double
type Dum.Random = Double
type Dum.StatType = Int
type Dum.Weight = Double
type Dum.Value = Double
type Dum.Result = ((Dum.PartType, Dum.Indx), Dum.Weight)
type Dum.Stat = (Dum.StatType, Dum.Value)
type Dum.Point = (Dum.Coord, Dum.Coord, Dum.Coord)
type Dum.Probability = (Dum.Prob, Dum.Prob, Dum.Prob, Dum.Prob)
data Dum.Particle
  = Dum.Part Dum.Point Dum.Point Dum.Weight Dum.Energy Dum.Indx Int Dum.Random


[]
{-# LANGUAGE BangPatterns #-}
module Dum where
import GamtebType
import Consts
import Utils
import InitTable
import Data.Array

type Angle = Double

type Coord = Double

type Energy = Double

type Indx = Int

type PartType = Int

type Prob = Double

type Random = Double

type StatType = Int

type Weight = Double

type Value = Double

type Result = ((PartType, Indx), Weight)

type Stat = (StatType, Value)

type Point = (Coord, Coord, Coord)

type Probability = (Prob, Prob, Prob, Prob)

data Particle = Part Point Point Weight Energy Indx Int Random
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
type Dum.Angle = Double
type Dum.Coord = Double
type Dum.Energy = Double
type Dum.Indx = Int
type Dum.PartType = Int
type Dum.Prob = Double
type Dum.Random = Double
type Dum.StatType = Int
type Dum.Weight = Double
type Dum.Value = Double
type Dum.Result = ((Dum.PartType, Dum.Indx), Dum.Weight)
type Dum.Stat = (Dum.StatType, Dum.Value)
type Dum.Point = (Dum.Coord, Dum.Coord, Dum.Coord)
type Dum.Probability = (Dum.Prob, Dum.Prob, Dum.Prob, Dum.Prob)
data Dum.Particle
  = Dum.Part Dum.Point Dum.Point Dum.Weight Dum.Energy Dum.Indx Int Dum.Random


[]
{-# LANGUAGE BangPatterns #-}
module Dum where
import GamtebType
import Consts
import Data.Array

type Angle = Double

type Coord = Double

type Energy = Double

type Indx = Int

type PartType = Int

type Prob = Double

type Random = Double

type StatType = Int

type Weight = Double

type Value = Double

type Result = ((PartType, Indx), Weight)

type Stat = (StatType, Value)

type Point = (Coord, Coord, Coord)

type Probability = (Prob, Prob, Prob, Prob)

data Particle = Part Point Point Weight Energy Indx Int Random
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
type Dum.Angle = Double
type Dum.Coord = Double
type Dum.Energy = Double
type Dum.Indx = Int
type Dum.PartType = Int
type Dum.Prob = Double
type Dum.Random = Double
type Dum.StatType = Int
type Dum.Weight = Double
type Dum.Value = Double
type Dum.Result = ((Dum.PartType, Dum.Indx), Dum.Weight)
type Dum.Stat = (Dum.StatType, Dum.Value)
type Dum.Point = (Dum.Coord, Dum.Coord, Dum.Coord)
type Dum.Probability = (Dum.Prob, Dum.Prob, Dum.Prob, Dum.Prob)
data Dum.Particle
  = Dum.Part Dum.Point Dum.Point Dum.Weight Dum.Energy Dum.Indx Int Dum.Random


[]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Rsa

type Angle = Double

type Coord = Double

type Energy = Double

type Indx = Int

type PartType = Int

type Prob = Double

type Random = Double

type StatType = Int

type Weight = Double

type Value = Double

type Result = ((PartType, Indx), Weight)

type Stat = (StatType, Value)

type Point = (Coord, Coord, Coord)

type Probability = (Prob, Prob, Prob, Prob)

data Particle = Part Point Point Weight Energy Indx Int Random
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.encrypt, Dum.decrypt :: Integer -> Integer -> String -> String
Dum.encrypt (!n_aHe) e_aHf
  = unlines
    . map (show . Dum.power e_aHf n_aHe . Dum.code)
      . Dum.collect (Dum.size n_aHe)
Dum.decrypt (!n_aV5) (!d_aV6)
  = concat . map (Dum.decode . Dum.power d_aV6 n_aV5 . read) . lines
Dum.code :: String -> Integer
Dum.code
  = foldl accum_a1eQ 0
  where
      accum_a1eQ x_a1eR (!y_a1eS)
        = (128 * x_a1eR) + fromIntegral (fromEnum y_a1eS)
Dum.decode :: Integer -> String
Dum.decode (!n_a1xf)
  = reverse (expand_a1xg n_a1xf)
  where
      expand_a1xg 0 = []
      expand_a1xg (!x_a1xh)
        = toEnum (fromIntegral (x_a1xh `mod` 128))
          : expand_a1xg (x_a1xh `div` 128)
Dum.collect :: Int -> [a_aHd] -> [[a_aHd]]
Dum.collect 0 (!xs_a1AN) = []
Dum.collect (!n_a1AO) (![]) = []
Dum.collect (!n_a1AP) (!xs_a1AQ)
  = take n_a1AP xs_a1AQ : Dum.collect n_a1AP (drop n_a1AP xs_a1AQ)
Dum.size :: Integer -> Int
Dum.size n_a1AR = (length (show n_a1AR) * 47) `div` 100
Dum.makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)
Dum.makeKeys (!p'_a1AS) (!q'_a1AT)
  = (n_a1AW, Dum.invert phi_a1AX d_a1AY, d_a1AY)
  where
      (!p_a1AU) = Dum.nextPrime p'_a1AS
      (!q_a1AV) = Dum.nextPrime q'_a1AT
      (!n_a1AW) = p_a1AU * q_a1AV
      (!phi_a1AX) = (p_a1AU - 1) * (q_a1AV - 1)
      d_a1AY = Dum.nextPrime (p_a1AU + q_a1AV + 1)
Dum.nextPrime :: Integer -> Integer
Dum.nextPrime a_a1AZ
  = head (filter prime_a1B1 [odd_a1B0, odd_a1B0 + 2 .. ])
  where
      (!odd_a1B0)
        | even a_a1AZ = a_a1AZ + 1
        | True = a_a1AZ
      prime_a1B1 p_a1B2
        = and
            [Dum.power (p_a1B2 - 1) p_a1B2 x_a1B3 == 1 |
               (!x_a1B3) <- [3, 5, 7]]
Dum.invert :: Integer -> Integer -> Integer
Dum.invert n_a2wJ (!a_a2wK)
  = if e_a2wL < 0 then e_a2wL + n_a2wJ else e_a2wL
  where
      e_a2wL = Dum.iter n_a2wJ 0 a_a2wK 1
Dum.iter :: Integer -> Integer -> Integer -> Integer -> Integer
Dum.iter g_a2wM v_a2wN 0 w_a2wO = v_a2wN
Dum.iter (!g_a2wP) (!v_a2wQ) (!h_a2wR) (!w_a2wS)
  = Dum.iter
      h_a2wR
      w_a2wS
      (g_a2wP - fact_a2wT * h_a2wR)
      (v_a2wQ - fact_a2wT * w_a2wS)
  where
      fact_a2wT = g_a2wP `div` h_a2wR
Dum.power :: Integer -> Integer -> Integer -> Integer
Dum.power 0 (!m_a2wU) (!x_a2wV) = 1
Dum.power n_a2wW m_a2wX (!x_a2wY)
  | even n_a2wW
  = Dum.sqr (Dum.power (n_a2wW `div` 2) m_a2wX x_a2wY) `mod` m_a2wX
  | True
  = (x_a2wY * Dum.power (n_a2wW - 1) m_a2wX x_a2wY) `mod` m_a2wX
Dum.sqr :: Integer -> Integer
Dum.sqr (!x_a2wZ) = x_a2wZ * x_a2wZ


["n_aHe","safebang@!n_aHe","(!n_aHe)","e_aHf","n_aV5","safebang@!n_aV5","(!n_aV5)","d_aV6","safebang@!d_aV6","(!d_aV6)","code","x_a1eR","y_a1eS","!y_a1eS","(!y_a1eS)","n_a1xf","safebang@!n_a1xf","(!n_a1xf)","0","x_a1xh","!x_a1xh","(!x_a1xh)","0","xs_a1AN","safebang@!xs_a1AN","(!xs_a1AN)","n_a1AO","!n_a1AO","(!n_a1AO)","[]","![]","(![])","n_a1AP","!n_a1AP","(!n_a1AP)","xs_a1AQ","!xs_a1AQ","(!xs_a1AQ)","n_a1AR","p'_a1AS","safebang@!p'_a1AS","(!p'_a1AS)","q'_a1AT","safebang@!q'_a1AT","(!q'_a1AT)","p_a1AU","!p_a1AU","(!p_a1AU)","q_a1AV","!q_a1AV","(!q_a1AV)","n_a1AW","!n_a1AW","(!n_a1AW)","phi_a1AX","!phi_a1AX","(!phi_a1AX)","d_a1AY","a_a1AZ","odd_a1B0","!odd_a1B0","(!odd_a1B0)","p_a1B2","x_a1B3","!x_a1B3","(!x_a1B3)","n_a2wJ","a_a2wK","safebang@!a_a2wK","(!a_a2wK)","e_a2wL","g_a2wM","v_a2wN","0","w_a2wO","g_a2wP","!g_a2wP","(!g_a2wP)","v_a2wQ","!v_a2wQ","(!v_a2wQ)","h_a2wR","!h_a2wR","(!h_a2wR)","w_a2wS","!w_a2wS","(!w_a2wS)","fact_a2wT","0","m_a2wU","safebang@!m_a2wU","(!m_a2wU)","x_a2wV","safebang@!x_a2wV","(!x_a2wV)","n_a2wW","m_a2wX","x_a2wY","!x_a2wY","(!x_a2wY)","x_a2wZ","safebang@!x_a2wZ","(!x_a2wZ)"]
{-# LANGUAGE BangPatterns #-}
module Dum where

encrypt, decrypt :: Integer -> Integer -> String -> String
encrypt (!n_aHe) e_aHf
  = unlines . map (show . power e_aHf n_aHe . code) .
      collect (size n_aHe)
decrypt (!n_aV5) (!d_aV6)
  = concat . map (decode . power d_aV6 n_aV5 . read) . lines

code :: String -> Integer
code = foldl accum_a1eQ 0
  where accum_a1eQ x_a1eR (investigate@y_a1eS)
          = (128 * x_a1eR) + fromIntegral (fromEnum y_a1eS)

decode :: Integer -> String
decode (!n_a1xf) = reverse (expand_a1xg n_a1xf)
  where expand_a1xg 0 = []
        expand_a1xg (investigate@x_a1xh)
          = toEnum (fromIntegral (x_a1xh `mod` 128)) :
              expand_a1xg (x_a1xh `div` 128)

collect :: Int -> [a_aHd] -> [[a_aHd]]
collect 0 (!xs_a1AN) = []
collect (investigate@n_a1AO) (investigate@[]) = []
collect (investigate@n_a1AP) (investigate@xs_a1AQ)
  = take n_a1AP xs_a1AQ : collect n_a1AP (drop n_a1AP xs_a1AQ)

size :: Integer -> Int
size n_a1AR = (length (show n_a1AR) * 47) `div` 100

makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)
makeKeys (!p'_a1AS) (!q'_a1AT)
  = (n_a1AW, invert phi_a1AX d_a1AY, d_a1AY)
  where (investigate@p_a1AU) = nextPrime p'_a1AS
        (investigate@q_a1AV) = nextPrime q'_a1AT
        (investigate@n_a1AW) = p_a1AU * q_a1AV
        (investigate@phi_a1AX) = (p_a1AU - 1) * (q_a1AV - 1)
        d_a1AY = nextPrime (p_a1AU + q_a1AV + 1)

nextPrime :: Integer -> Integer
nextPrime a_a1AZ
  = head (filter prime_a1B1 [odd_a1B0, odd_a1B0 + 2 ..])
  where (investigate@odd_a1B0)
          | even a_a1AZ = a_a1AZ + 1
          | True = a_a1AZ
        prime_a1B1 p_a1B2
          = and
              [power (p_a1B2 - 1) p_a1B2 x_a1B3 == 1 |
               (investigate@x_a1B3) <- [3, 5, 7]]

invert :: Integer -> Integer -> Integer
invert n_a2wJ (!a_a2wK)
  = if e_a2wL < 0 then e_a2wL + n_a2wJ else e_a2wL
  where e_a2wL = iter n_a2wJ 0 a_a2wK 1

iter :: Integer -> Integer -> Integer -> Integer -> Integer
iter g_a2wM v_a2wN 0 w_a2wO = v_a2wN
iter (investigate@g_a2wP) (investigate@v_a2wQ) (investigate@h_a2wR)
  (investigate@w_a2wS)
  = iter h_a2wR w_a2wS (g_a2wP - fact_a2wT * h_a2wR)
      (v_a2wQ - fact_a2wT * w_a2wS)
  where fact_a2wT = g_a2wP `div` h_a2wR

power :: Integer -> Integer -> Integer -> Integer
power 0 (!m_a2wU) (!x_a2wV) = 1
power n_a2wW m_a2wX (investigate@x_a2wY)
  | even n_a2wW =
    sqr (power (n_a2wW `div` 2) m_a2wX x_a2wY) `mod` m_a2wX
  | True = (x_a2wY * power (n_a2wW - 1) m_a2wX x_a2wY) `mod` m_a2wX

sqr :: Integer -> Integer
sqr (!x_a2wZ) = x_a2wZ * x_a2wZ
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.treeFrom :: Integer -> Dum.Tree Integer
Dum.treeFrom n_aAF
  = Dum.TreeC
      n_aAF (Dum.treeFrom (2 * n_aAF - 1)) (Dum.treeFrom (2 * n_aAF - 2))
Dum.numberTree :: Dum.Tree Integer
Dum.numberTree = Dum.treeFrom 0
Dum.scale :: Integer -> Integer -> Integer
Dum.scale x_aBL n_aBM
  | n_aBM <= 0 = (x_aBL * 10 ^ (1 - n_aBM) + 5) `quot` 10
Dum.scale x_a1H6 n_a1H7
  | n_a1H7 > 0 = (x_a1H6 `quot` 10 ^ (n_a1H7 - 1) + 5) `quot` 10
Dum.msd :: Dum.Tree Integer -> Integer -> Integer
Dum.msd x_a1H8 k_a1H9
  = if (xk_a1Ha >= 1) && (xk_a1Ha < 10) then
        k_a1H9
    else
        if (xk_a1Ha == 10) then
            (k_a1H9 + 1)
        else
            if xk_a1Ha >= 1 then
                (Dum.msd x_a1H8 (k_a1H9 + 1))
            else
                (Dum.msd x_a1H8 (k_a1H9 - 1))
  where
      xk_a1Ha = abs (Dum.evalReal (Dum.RealC x_a1H8) k_a1H9)
Dum.evalReal :: Dum.RealT -> Integer -> Integer
Dum.evalReal (Dum.RealC tree_a1Hb) tol_a1Hc
  | tol_a1Hc <= 0 = Dum.lookupTree tree_a1Hb tol_a1Hc
Dum.evalReal (Dum.RealC tree_a1Hd) tol_a1He
  | tol_a1He > 0 = Dum.scale (Dum.lookupTree tree_a1Hd 0) tol_a1He
Dum.lookupTree :: Dum.Tree Integer -> Integer -> Integer
Dum.lookupTree tree_a1Hf n_a1Hg
  = followPath_a1Hi (getPath_a1Hh (1 - n_a1Hg) []) tree_a1Hf
  where
      getPath_a1Hh 1 p_a1Hj = p_a1Hj
      getPath_a1Hh n_a1Hk p_a1Hl
        | even n_a1Hk = getPath_a1Hh (n_a1Hk `quot` 2) (0 : p_a1Hl)
      getPath_a1Hh n_a1Oq p_a1Or
        | odd n_a1Oq = getPath_a1Hh (n_a1Oq `quot` 2) (1 : p_a1Or)
      followPath_a1Hi [] (Dum.TreeC x_a1Os _ _) = x_a1Os
      followPath_a1Hi (0 : ps_a1Ot) (Dum.TreeC x_a1Ou lc_a1Ov _)
        = followPath_a1Hi ps_a1Ot lc_a1Ov
      followPath_a1Hi (1 : ps_a1Ow) (Dum.TreeC x_a1Ox _ rc_a1Oy)
        = followPath_a1Hi ps_a1Ow rc_a1Oy
Dum.mapTree :: (a_aAD -> b_aAE) -> Dum.Tree a_aAD -> Dum.Tree b_aAE
Dum.mapTree f_a1Oz (Dum.TreeC x_a1OA lc_a1OB rc_a1OC)
  = Dum.TreeC
      (f_a1Oz x_a1OA)
      (Dum.mapTree f_a1Oz lc_a1OB)
      (Dum.mapTree f_a1Oz rc_a1OC)
Dum.int2Real :: Integer -> Dum.RealT
Dum.int2Real x_a1OD
  = Dum.RealC
      (Dum.mapTree (\ n_a1OE -> Dum.scale x_a1OD n_a1OE) Dum.numberTree)
Dum.addReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.addReal x_a1OF y_a1OG
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OH
            -> ((Dum.evalReal x_a1OF (n_a1OH - 1))
                + (Dum.evalReal y_a1OG (n_a1OH - 1))
                + 5)
               `quot` 10)
         Dum.numberTree)
Dum.subReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.subReal x_a1OI y_a1OJ
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OK
            -> ((Dum.evalReal x_a1OI (n_a1OK - 1))
                - (Dum.evalReal y_a1OJ (n_a1OK - 1))
                + 5)
               `quot` 10)
         Dum.numberTree)
Dum.mulReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.mulReal
  (xr_a1OL@(Dum.RealC x_a1OM))
  (yr_a1ON@(Dum.RealC y_a1OO))
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OP
            -> let
                 m_a1OQ
                   = if n_a1OP >= 0 then
                         (n_a1OP + 1) `quot` 2
                     else
                         (n_a1OP - 1) `quot` 2
                 x0_a1OR = Dum.evalReal xr_a1OL m_a1OQ
                 y0_a1OS = Dum.evalReal yr_a1ON m_a1OQ
                 mulAux_a1OT x_a1OU y_a1OV
                   = if y1_a1OW == 0 then
                         0
                     else
                         Dum.scale
                           (x1_a1OX * y1_a1OW)
                           (4 + (Dum.msd x_a1OU 0) + (Dum.msd y_a1OV 0) - n_a1OP)
                   where
                       y1_a1OW = (Dum.evalReal yr_a1ON (n_a1OP - (Dum.msd x_a1OU 0) - 2))
                       x1_a1OX = (Dum.evalReal xr_a1OL (n_a1OP - (Dum.msd y_a1OV 0) - 2))
               in
                 if (x0_a1OR == 0) && (y0_a1OS == 0) then
                     0
                 else
                     if x0_a1OR == 0 then
                         mulAux_a1OT y_a1OO x_a1OM
                     else
                         mulAux_a1OT x_a1OM y_a1OO)
         Dum.numberTree)
Dum.divReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.divReal x_a1OY y_a1OZ
  = Dum.mulReal x_a1OY (Dum.reciprocalReal y_a1OZ)
Dum.reciprocalReal :: Dum.RealT -> Dum.RealT
Dum.reciprocalReal xr_a1P0@(Dum.RealC x_a1P1)
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1P7 -> ((f_a1P3 (dx_a1P2 + n_a1P7)) + 5) `quot` 10)
         Dum.numberTree)
  where
      dx_a1P2 = Dum.msd x_a1P1 0
      f_a1P3 m_a1P4
        = if m_a1P4 >= 0 then
              0
          else
              if m_a1P4 == (- 1) then
                  10000 `quot` (Dum.evalReal xr_a1P0 (dx_a1P2 - 2))
              else
                  (Dum.scale
                     ((fm_a1P6)
                      * ((Dum.scale 2 (m_a1P4 + hm_a1P5 - 2))
                         - (Dum.evalReal xr_a1P0 (dx_a1P2 + m_a1P4 - 1)) * (fm_a1P6)))
                     (2 - 2 * hm_a1P5))
        where
            hm_a1P5 = (m_a1P4 - 1) `quot` 2
            fm_a1P6 = f_a1P3 hm_a1P5
Dum.sqrReal :: Dum.RealT -> Dum.RealT
Dum.sqrReal (xr_a1P8@(Dum.RealC x_a1P9))
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1Pa
            -> let
                 m_a1Pb
                   = if n_a1Pa >= 0 then
                         (n_a1Pa + 1) `quot` 2
                     else
                         (n_a1Pa - 1) `quot` 2
                 x0_a1Pc = Dum.evalReal xr_a1P8 m_a1Pb
                 x1_a1Pd = Dum.evalReal xr_a1P8 (n_a1Pa - (Dum.msd x_a1P9 0) - 2)
               in
                 if (x0_a1Pc == 0) then
                     0
                 else
                     Dum.scale
                       (x1_a1Pd * x1_a1Pd) (4 + 2 * (Dum.msd x_a1P9 0) - n_a1Pa))
         Dum.numberTree)
Dum.sqrtReal :: Dum.RealT -> Dum.RealT
Dum.sqrtReal xr_a1Pe@(Dum.RealC x_a1Pf)
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1Pr
            -> if (Dum.evalReal xr_a1Pe (2 * n_a1Pr)) == 0 then
                   0
               else
                   f_a1Pi
                     n_a1Pr (2 * hdx_a1Ph + 2) xr_a1Pe ((- 2) * hdx_a1Ph - 2 + n_a1Pr))
         Dum.numberTree)
  where
      dx_a1Pg = Dum.msd x_a1Pf 0
      hdx_a1Ph
        = if dx_a1Pg >= 0 then (dx_a1Pg + 1) `quot` 2 else dx_a1Pg `quot` 2
      f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl m_a1Pm
        = if m_a1Pm >= 0 then
              0
          else
              if m_a1Pm == (- 1) then
                  Dum.scale
                    ((round . sqrt . fromInteger)
                       (Dum.evalReal xr_a1Pl (dx_a1Pk - 10)))
                    (5 - hx_a1Pq + n_a1Pj)
              else
                  (fm_a1Po + xv_a1Pp `quot` fm_a1Po) `quot` 2
        where
            hm_a1Pn = (m_a1Pm - 1) `quot` 2
            fm_a1Po = (f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl hm_a1Pn)
            xv_a1Pp = Dum.evalReal xr_a1Pl (n_a1Pj + n_a1Pj)
            hx_a1Pq = dx_a1Pk `quot` 2

data Dum.Tree a_aAC
  = Dum.TreeC a_aAC (Dum.Tree a_aAC) (Dum.Tree a_aAC)
data Dum.RealT = Dum.RealC (Dum.Tree Integer)


["n_aAF","numberTree","x_aBL","n_aBM","x_a1H6","n_a1H7","x_a1H8","k_a1H9","xk_a1Ha","tree_a1Hb","RealC tree_a1Hb","(RealC tree_a1Hb)","tol_a1Hc","tree_a1Hd","RealC tree_a1Hd","(RealC tree_a1Hd)","tol_a1He","tree_a1Hf","n_a1Hg","1","p_a1Hj","n_a1Hk","p_a1Hl","n_a1Oq","p_a1Or","[]","x_a1Os","_","_","TreeC x_a1Os _ _","(TreeC x_a1Os _ _)","0","ps_a1Ot","0 : ps_a1Ot","(0 : ps_a1Ot)","x_a1Ou","lc_a1Ov","_","TreeC x_a1Ou lc_a1Ov _","(TreeC x_a1Ou lc_a1Ov _)","1","ps_a1Ow","1 : ps_a1Ow","(1 : ps_a1Ow)","x_a1Ox","_","rc_a1Oy","TreeC x_a1Ox _ rc_a1Oy","(TreeC x_a1Ox _ rc_a1Oy)","f_a1Oz","x_a1OA","lc_a1OB","rc_a1OC","TreeC x_a1OA lc_a1OB rc_a1OC","(TreeC x_a1OA lc_a1OB rc_a1OC)","x_a1OD","n_a1OE","x_a1OF","y_a1OG","n_a1OH","x_a1OI","y_a1OJ","n_a1OK","x_a1OM","RealC x_a1OM","(RealC x_a1OM)","xr_a1OL@(RealC x_a1OM)","(xr_a1OL@(RealC x_a1OM))","y_a1OO","RealC y_a1OO","(RealC y_a1OO)","yr_a1ON@(RealC y_a1OO)","(yr_a1ON@(RealC y_a1OO))","n_a1OP","m_a1OQ","x0_a1OR","y0_a1OS","x_a1OU","y_a1OV","y1_a1OW","x1_a1OX","x_a1OY","y_a1OZ","x_a1P1","RealC x_a1P1","(RealC x_a1P1)","xr_a1P0@(RealC x_a1P1)","n_a1P7","dx_a1P2","m_a1P4","hm_a1P5","fm_a1P6","x_a1P9","RealC x_a1P9","(RealC x_a1P9)","xr_a1P8@(RealC x_a1P9)","(xr_a1P8@(RealC x_a1P9))","n_a1Pa","m_a1Pb","x0_a1Pc","x1_a1Pd","x_a1Pf","RealC x_a1Pf","(RealC x_a1Pf)","xr_a1Pe@(RealC x_a1Pf)","n_a1Pr","dx_a1Pg","hdx_a1Ph","n_a1Pj","dx_a1Pk","xr_a1Pl","m_a1Pm","hm_a1Pn","fm_a1Po","xv_a1Pp","hx_a1Pq"]
{-# LANGUAGE BangPatterns #-}
module Dum where

treeFrom :: Integer -> Tree Integer
treeFrom n_aAF
  = TreeC n_aAF (treeFrom (2 * n_aAF - 1)) (treeFrom (2 * n_aAF - 2))

numberTree :: Tree Integer
numberTree = treeFrom 0

scale :: Integer -> Integer -> Integer
scale x_aBL n_aBM
  | n_aBM <= 0 = (x_aBL * 10 ^ (1 - n_aBM) + 5) `quot` 10
scale x_a1H6 n_a1H7
  | n_a1H7 > 0 = (x_a1H6 `quot` 10 ^ (n_a1H7 - 1) + 5) `quot` 10

msd :: Tree Integer -> Integer -> Integer
msd x_a1H8 k_a1H9
  = if (xk_a1Ha >= 1) && (xk_a1Ha < 10) then k_a1H9 else
      if (xk_a1Ha == 10) then (k_a1H9 + 1) else
        if xk_a1Ha >= 1 then (msd x_a1H8 (k_a1H9 + 1)) else
          (msd x_a1H8 (k_a1H9 - 1))
  where xk_a1Ha = abs (evalReal (RealC x_a1H8) k_a1H9)

evalReal :: RealT -> Integer -> Integer
evalReal (RealC tree_a1Hb) tol_a1Hc
  | tol_a1Hc <= 0 = lookupTree tree_a1Hb tol_a1Hc
evalReal (RealC tree_a1Hd) tol_a1He
  | tol_a1He > 0 = scale (lookupTree tree_a1Hd 0) tol_a1He

lookupTree :: Tree Integer -> Integer -> Integer
lookupTree tree_a1Hf n_a1Hg
  = followPath_a1Hi (getPath_a1Hh (1 - n_a1Hg) []) tree_a1Hf
  where getPath_a1Hh 1 p_a1Hj = p_a1Hj
        getPath_a1Hh n_a1Hk p_a1Hl
          | even n_a1Hk = getPath_a1Hh (n_a1Hk `quot` 2) (0 : p_a1Hl)
        getPath_a1Hh n_a1Oq p_a1Or
          | odd n_a1Oq = getPath_a1Hh (n_a1Oq `quot` 2) (1 : p_a1Or)
        followPath_a1Hi [] (TreeC x_a1Os _ _) = x_a1Os
        followPath_a1Hi (0 : ps_a1Ot) (TreeC x_a1Ou lc_a1Ov _)
          = followPath_a1Hi ps_a1Ot lc_a1Ov
        followPath_a1Hi (1 : ps_a1Ow) (TreeC x_a1Ox _ rc_a1Oy)
          = followPath_a1Hi ps_a1Ow rc_a1Oy

mapTree :: (a_aAD -> b_aAE) -> Tree a_aAD -> Tree b_aAE
mapTree f_a1Oz (TreeC x_a1OA lc_a1OB rc_a1OC)
  = TreeC (f_a1Oz x_a1OA) (mapTree f_a1Oz lc_a1OB)
      (mapTree f_a1Oz rc_a1OC)

int2Real :: Integer -> RealT
int2Real x_a1OD
  = RealC (mapTree (\ n_a1OE -> scale x_a1OD n_a1OE) numberTree)

addReal :: RealT -> RealT -> RealT
addReal x_a1OF y_a1OG
  = RealC
      (mapTree
         (\ n_a1OH ->
            ((evalReal x_a1OF (n_a1OH - 1)) + (evalReal y_a1OG (n_a1OH - 1)) +
               5)
              `quot` 10)
         numberTree)

subReal :: RealT -> RealT -> RealT
subReal x_a1OI y_a1OJ
  = RealC
      (mapTree
         (\ n_a1OK ->
            ((evalReal x_a1OI (n_a1OK - 1)) - (evalReal y_a1OJ (n_a1OK - 1)) +
               5)
              `quot` 10)
         numberTree)

mulReal :: RealT -> RealT -> RealT
mulReal (xr_a1OL@(RealC x_a1OM)) (yr_a1ON@(RealC y_a1OO))
  = RealC
      (mapTree
         (\ n_a1OP ->
            let m_a1OQ
                  = if n_a1OP >= 0 then (n_a1OP + 1) `quot` 2 else
                      (n_a1OP - 1) `quot` 2
                x0_a1OR = evalReal xr_a1OL m_a1OQ
                y0_a1OS = evalReal yr_a1ON m_a1OQ
                mulAux_a1OT x_a1OU y_a1OV
                  = if y1_a1OW == 0 then 0 else
                      scale (x1_a1OX * y1_a1OW)
                        (4 + (msd x_a1OU 0) + (msd y_a1OV 0) - n_a1OP)
                  where y1_a1OW = (evalReal yr_a1ON (n_a1OP - (msd x_a1OU 0) - 2))
                        x1_a1OX = (evalReal xr_a1OL (n_a1OP - (msd y_a1OV 0) - 2))
              in
              if (x0_a1OR == 0) && (y0_a1OS == 0) then 0 else
                if x0_a1OR == 0 then mulAux_a1OT y_a1OO x_a1OM else
                  mulAux_a1OT x_a1OM y_a1OO)
         numberTree)

divReal :: RealT -> RealT -> RealT
divReal x_a1OY y_a1OZ = mulReal x_a1OY (reciprocalReal y_a1OZ)

reciprocalReal :: RealT -> RealT
reciprocalReal xr_a1P0@(RealC x_a1P1)
  = RealC
      (mapTree (\ n_a1P7 -> ((f_a1P3 (dx_a1P2 + n_a1P7)) + 5) `quot` 10)
         numberTree)
  where dx_a1P2 = msd x_a1P1 0
        f_a1P3 m_a1P4
          = if m_a1P4 >= 0 then 0 else
              if m_a1P4 == (-1) then
                10000 `quot` (evalReal xr_a1P0 (dx_a1P2 - 2)) else
                (scale
                   ((fm_a1P6) *
                      ((scale 2 (m_a1P4 + hm_a1P5 - 2)) -
                         (evalReal xr_a1P0 (dx_a1P2 + m_a1P4 - 1))
                         * (fm_a1P6)))
                   (2 - 2 * hm_a1P5))
          where hm_a1P5 = (m_a1P4 - 1) `quot` 2
                fm_a1P6 = f_a1P3 hm_a1P5

sqrReal :: RealT -> RealT
sqrReal (xr_a1P8@(RealC x_a1P9))
  = RealC
      (mapTree
         (\ n_a1Pa ->
            let m_a1Pb
                  = if n_a1Pa >= 0 then (n_a1Pa + 1) `quot` 2 else
                      (n_a1Pa - 1) `quot` 2
                x0_a1Pc = evalReal xr_a1P8 m_a1Pb
                x1_a1Pd = evalReal xr_a1P8 (n_a1Pa - (msd x_a1P9 0) - 2)
              in
              if (x0_a1Pc == 0) then 0 else
                scale (x1_a1Pd * x1_a1Pd) (4 + 2 * (msd x_a1P9 0) - n_a1Pa))
         numberTree)

sqrtReal :: RealT -> RealT
sqrtReal xr_a1Pe@(RealC x_a1Pf)
  = RealC
      (mapTree
         (\ n_a1Pr ->
            if (evalReal xr_a1Pe (2 * n_a1Pr)) == 0 then 0 else
              f_a1Pi n_a1Pr (2 * hdx_a1Ph + 2) xr_a1Pe
                ((-2) * hdx_a1Ph - 2 + n_a1Pr))
         numberTree)
  where dx_a1Pg = msd x_a1Pf 0
        hdx_a1Ph
          = if dx_a1Pg >= 0 then (dx_a1Pg + 1) `quot` 2 else dx_a1Pg `quot` 2
        f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl m_a1Pm
          = if m_a1Pm >= 0 then 0 else
              if m_a1Pm == (-1) then
                scale
                  ((round . sqrt . fromInteger) (evalReal xr_a1Pl (dx_a1Pk - 10)))
                  (5 - hx_a1Pq + n_a1Pj)
                else (fm_a1Po + xv_a1Pp `quot` fm_a1Po) `quot` 2
          where hm_a1Pn = (m_a1Pm - 1) `quot` 2
                fm_a1Po = (f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl hm_a1Pn)
                xv_a1Pp = evalReal xr_a1Pl (n_a1Pj + n_a1Pj)
                hx_a1Pq = dx_a1Pk `quot` 2

data Tree a_aAC = TreeC a_aAC (Tree a_aAC) (Tree a_aAC)

data RealT = RealC (Tree Integer)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.treeFrom :: Integer -> Dum.Tree Integer
Dum.treeFrom n_aAF
  = Dum.TreeC
      n_aAF (Dum.treeFrom (2 * n_aAF - 1)) (Dum.treeFrom (2 * n_aAF - 2))
Dum.numberTree :: Dum.Tree Integer
Dum.numberTree = Dum.treeFrom 0
Dum.scale :: Integer -> Integer -> Integer
Dum.scale x_aBL n_aBM
  | n_aBM <= 0 = (x_aBL * 10 ^ (1 - n_aBM) + 5) `quot` 10
Dum.scale x_a1H6 n_a1H7
  | n_a1H7 > 0 = (x_a1H6 `quot` 10 ^ (n_a1H7 - 1) + 5) `quot` 10
Dum.msd :: Dum.Tree Integer -> Integer -> Integer
Dum.msd x_a1H8 k_a1H9
  = if (xk_a1Ha >= 1) && (xk_a1Ha < 10) then
        k_a1H9
    else
        if (xk_a1Ha == 10) then
            (k_a1H9 + 1)
        else
            if xk_a1Ha >= 1 then
                (Dum.msd x_a1H8 (k_a1H9 + 1))
            else
                (Dum.msd x_a1H8 (k_a1H9 - 1))
  where
      xk_a1Ha = abs (Dum.evalReal (Dum.RealC x_a1H8) k_a1H9)
Dum.evalReal :: Dum.RealT -> Integer -> Integer
Dum.evalReal (Dum.RealC tree_a1Hb) tol_a1Hc
  | tol_a1Hc <= 0 = Dum.lookupTree tree_a1Hb tol_a1Hc
Dum.evalReal (Dum.RealC tree_a1Hd) tol_a1He
  | tol_a1He > 0 = Dum.scale (Dum.lookupTree tree_a1Hd 0) tol_a1He
Dum.lookupTree :: Dum.Tree Integer -> Integer -> Integer
Dum.lookupTree tree_a1Hf n_a1Hg
  = followPath_a1Hi (getPath_a1Hh (1 - n_a1Hg) []) tree_a1Hf
  where
      getPath_a1Hh 1 p_a1Hj = p_a1Hj
      getPath_a1Hh n_a1Hk p_a1Hl
        | even n_a1Hk = getPath_a1Hh (n_a1Hk `quot` 2) (0 : p_a1Hl)
      getPath_a1Hh n_a1Oq p_a1Or
        | odd n_a1Oq = getPath_a1Hh (n_a1Oq `quot` 2) (1 : p_a1Or)
      followPath_a1Hi [] (Dum.TreeC x_a1Os _ _) = x_a1Os
      followPath_a1Hi (0 : ps_a1Ot) (Dum.TreeC x_a1Ou lc_a1Ov _)
        = followPath_a1Hi ps_a1Ot lc_a1Ov
      followPath_a1Hi (1 : ps_a1Ow) (Dum.TreeC x_a1Ox _ rc_a1Oy)
        = followPath_a1Hi ps_a1Ow rc_a1Oy
Dum.mapTree :: (a_aAD -> b_aAE) -> Dum.Tree a_aAD -> Dum.Tree b_aAE
Dum.mapTree f_a1Oz (Dum.TreeC x_a1OA lc_a1OB rc_a1OC)
  = Dum.TreeC
      (f_a1Oz x_a1OA)
      (Dum.mapTree f_a1Oz lc_a1OB)
      (Dum.mapTree f_a1Oz rc_a1OC)
Dum.int2Real :: Integer -> Dum.RealT
Dum.int2Real x_a1OD
  = Dum.RealC
      (Dum.mapTree (\ n_a1OE -> Dum.scale x_a1OD n_a1OE) Dum.numberTree)
Dum.addReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.addReal x_a1OF y_a1OG
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OH
            -> ((Dum.evalReal x_a1OF (n_a1OH - 1))
                + (Dum.evalReal y_a1OG (n_a1OH - 1))
                + 5)
               `quot` 10)
         Dum.numberTree)
Dum.subReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.subReal x_a1OI y_a1OJ
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OK
            -> ((Dum.evalReal x_a1OI (n_a1OK - 1))
                - (Dum.evalReal y_a1OJ (n_a1OK - 1))
                + 5)
               `quot` 10)
         Dum.numberTree)
Dum.mulReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.mulReal
  (xr_a1OL@(Dum.RealC x_a1OM))
  (yr_a1ON@(Dum.RealC y_a1OO))
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OP
            -> let
                 m_a1OQ
                   = if n_a1OP >= 0 then
                         (n_a1OP + 1) `quot` 2
                     else
                         (n_a1OP - 1) `quot` 2
                 x0_a1OR = Dum.evalReal xr_a1OL m_a1OQ
                 y0_a1OS = Dum.evalReal yr_a1ON m_a1OQ
                 mulAux_a1OT x_a1OU y_a1OV
                   = if y1_a1OW == 0 then
                         0
                     else
                         Dum.scale
                           (x1_a1OX * y1_a1OW)
                           (4 + (Dum.msd x_a1OU 0) + (Dum.msd y_a1OV 0) - n_a1OP)
                   where
                       y1_a1OW = (Dum.evalReal yr_a1ON (n_a1OP - (Dum.msd x_a1OU 0) - 2))
                       x1_a1OX = (Dum.evalReal xr_a1OL (n_a1OP - (Dum.msd y_a1OV 0) - 2))
               in
                 if (x0_a1OR == 0) && (y0_a1OS == 0) then
                     0
                 else
                     if x0_a1OR == 0 then
                         mulAux_a1OT y_a1OO x_a1OM
                     else
                         mulAux_a1OT x_a1OM y_a1OO)
         Dum.numberTree)
Dum.divReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.divReal x_a1OY y_a1OZ
  = Dum.mulReal x_a1OY (Dum.reciprocalReal y_a1OZ)
Dum.reciprocalReal :: Dum.RealT -> Dum.RealT
Dum.reciprocalReal xr_a1P0@(Dum.RealC x_a1P1)
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1P7 -> ((f_a1P3 (dx_a1P2 + n_a1P7)) + 5) `quot` 10)
         Dum.numberTree)
  where
      dx_a1P2 = Dum.msd x_a1P1 0
      f_a1P3 m_a1P4
        = if m_a1P4 >= 0 then
              0
          else
              if m_a1P4 == (- 1) then
                  10000 `quot` (Dum.evalReal xr_a1P0 (dx_a1P2 - 2))
              else
                  (Dum.scale
                     ((fm_a1P6)
                      * ((Dum.scale 2 (m_a1P4 + hm_a1P5 - 2))
                         - (Dum.evalReal xr_a1P0 (dx_a1P2 + m_a1P4 - 1)) * (fm_a1P6)))
                     (2 - 2 * hm_a1P5))
        where
            hm_a1P5 = (m_a1P4 - 1) `quot` 2
            fm_a1P6 = f_a1P3 hm_a1P5
Dum.sqrReal :: Dum.RealT -> Dum.RealT
Dum.sqrReal (xr_a1P8@(Dum.RealC x_a1P9))
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1Pa
            -> let
                 m_a1Pb
                   = if n_a1Pa >= 0 then
                         (n_a1Pa + 1) `quot` 2
                     else
                         (n_a1Pa - 1) `quot` 2
                 x0_a1Pc = Dum.evalReal xr_a1P8 m_a1Pb
                 x1_a1Pd = Dum.evalReal xr_a1P8 (n_a1Pa - (Dum.msd x_a1P9 0) - 2)
               in
                 if (x0_a1Pc == 0) then
                     0
                 else
                     Dum.scale
                       (x1_a1Pd * x1_a1Pd) (4 + 2 * (Dum.msd x_a1P9 0) - n_a1Pa))
         Dum.numberTree)
Dum.sqrtReal :: Dum.RealT -> Dum.RealT
Dum.sqrtReal xr_a1Pe@(Dum.RealC x_a1Pf)
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1Pr
            -> if (Dum.evalReal xr_a1Pe (2 * n_a1Pr)) == 0 then
                   0
               else
                   f_a1Pi
                     n_a1Pr (2 * hdx_a1Ph + 2) xr_a1Pe ((- 2) * hdx_a1Ph - 2 + n_a1Pr))
         Dum.numberTree)
  where
      dx_a1Pg = Dum.msd x_a1Pf 0
      hdx_a1Ph
        = if dx_a1Pg >= 0 then (dx_a1Pg + 1) `quot` 2 else dx_a1Pg `quot` 2
      f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl m_a1Pm
        = if m_a1Pm >= 0 then
              0
          else
              if m_a1Pm == (- 1) then
                  Dum.scale
                    ((round . sqrt . fromInteger)
                       (Dum.evalReal xr_a1Pl (dx_a1Pk - 10)))
                    (5 - hx_a1Pq + n_a1Pj)
              else
                  (fm_a1Po + xv_a1Pp `quot` fm_a1Po) `quot` 2
        where
            hm_a1Pn = (m_a1Pm - 1) `quot` 2
            fm_a1Po = (f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl hm_a1Pn)
            xv_a1Pp = Dum.evalReal xr_a1Pl (n_a1Pj + n_a1Pj)
            hx_a1Pq = dx_a1Pk `quot` 2

data Dum.Tree a_aAC
  = Dum.TreeC a_aAC (Dum.Tree a_aAC) (Dum.Tree a_aAC)
data Dum.RealT = Dum.RealC (Dum.Tree Integer)


["n_aAF","numberTree","x_aBL","n_aBM","x_a1H6","n_a1H7","x_a1H8","k_a1H9","xk_a1Ha","tree_a1Hb","RealC tree_a1Hb","(RealC tree_a1Hb)","tol_a1Hc","tree_a1Hd","RealC tree_a1Hd","(RealC tree_a1Hd)","tol_a1He","tree_a1Hf","n_a1Hg","1","p_a1Hj","n_a1Hk","p_a1Hl","n_a1Oq","p_a1Or","[]","x_a1Os","_","_","TreeC x_a1Os _ _","(TreeC x_a1Os _ _)","0","ps_a1Ot","0 : ps_a1Ot","(0 : ps_a1Ot)","x_a1Ou","lc_a1Ov","_","TreeC x_a1Ou lc_a1Ov _","(TreeC x_a1Ou lc_a1Ov _)","1","ps_a1Ow","1 : ps_a1Ow","(1 : ps_a1Ow)","x_a1Ox","_","rc_a1Oy","TreeC x_a1Ox _ rc_a1Oy","(TreeC x_a1Ox _ rc_a1Oy)","f_a1Oz","x_a1OA","lc_a1OB","rc_a1OC","TreeC x_a1OA lc_a1OB rc_a1OC","(TreeC x_a1OA lc_a1OB rc_a1OC)","x_a1OD","n_a1OE","x_a1OF","y_a1OG","n_a1OH","x_a1OI","y_a1OJ","n_a1OK","x_a1OM","RealC x_a1OM","(RealC x_a1OM)","xr_a1OL@(RealC x_a1OM)","(xr_a1OL@(RealC x_a1OM))","y_a1OO","RealC y_a1OO","(RealC y_a1OO)","yr_a1ON@(RealC y_a1OO)","(yr_a1ON@(RealC y_a1OO))","n_a1OP","m_a1OQ","x0_a1OR","y0_a1OS","x_a1OU","y_a1OV","y1_a1OW","x1_a1OX","x_a1OY","y_a1OZ","x_a1P1","RealC x_a1P1","(RealC x_a1P1)","xr_a1P0@(RealC x_a1P1)","n_a1P7","dx_a1P2","m_a1P4","hm_a1P5","fm_a1P6","x_a1P9","RealC x_a1P9","(RealC x_a1P9)","xr_a1P8@(RealC x_a1P9)","(xr_a1P8@(RealC x_a1P9))","n_a1Pa","m_a1Pb","x0_a1Pc","x1_a1Pd","x_a1Pf","RealC x_a1Pf","(RealC x_a1Pf)","xr_a1Pe@(RealC x_a1Pf)","n_a1Pr","dx_a1Pg","hdx_a1Ph","n_a1Pj","dx_a1Pk","xr_a1Pl","m_a1Pm","hm_a1Pn","fm_a1Po","xv_a1Pp","hx_a1Pq"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Ast
import Parser
import Env
import Print
import Eval
import BasicNumber
import System.IO

treeFrom :: Integer -> Tree Integer
treeFrom n_aAF
  = TreeC n_aAF (treeFrom (2 * n_aAF - 1)) (treeFrom (2 * n_aAF - 2))

numberTree :: Tree Integer
numberTree = treeFrom 0

scale :: Integer -> Integer -> Integer
scale x_aBL n_aBM
  | n_aBM <= 0 = (x_aBL * 10 ^ (1 - n_aBM) + 5) `quot` 10
scale x_a1H6 n_a1H7
  | n_a1H7 > 0 = (x_a1H6 `quot` 10 ^ (n_a1H7 - 1) + 5) `quot` 10

msd :: Tree Integer -> Integer -> Integer
msd x_a1H8 k_a1H9
  = if (xk_a1Ha >= 1) && (xk_a1Ha < 10) then k_a1H9 else
      if (xk_a1Ha == 10) then (k_a1H9 + 1) else
        if xk_a1Ha >= 1 then (msd x_a1H8 (k_a1H9 + 1)) else
          (msd x_a1H8 (k_a1H9 - 1))
  where xk_a1Ha = abs (evalReal (RealC x_a1H8) k_a1H9)

evalReal :: RealT -> Integer -> Integer
evalReal (RealC tree_a1Hb) tol_a1Hc
  | tol_a1Hc <= 0 = lookupTree tree_a1Hb tol_a1Hc
evalReal (RealC tree_a1Hd) tol_a1He
  | tol_a1He > 0 = scale (lookupTree tree_a1Hd 0) tol_a1He

lookupTree :: Tree Integer -> Integer -> Integer
lookupTree tree_a1Hf n_a1Hg
  = followPath_a1Hi (getPath_a1Hh (1 - n_a1Hg) []) tree_a1Hf
  where getPath_a1Hh 1 p_a1Hj = p_a1Hj
        getPath_a1Hh n_a1Hk p_a1Hl
          | even n_a1Hk = getPath_a1Hh (n_a1Hk `quot` 2) (0 : p_a1Hl)
        getPath_a1Hh n_a1Oq p_a1Or
          | odd n_a1Oq = getPath_a1Hh (n_a1Oq `quot` 2) (1 : p_a1Or)
        followPath_a1Hi [] (TreeC x_a1Os _ _) = x_a1Os
        followPath_a1Hi (0 : ps_a1Ot) (TreeC x_a1Ou lc_a1Ov _)
          = followPath_a1Hi ps_a1Ot lc_a1Ov
        followPath_a1Hi (1 : ps_a1Ow) (TreeC x_a1Ox _ rc_a1Oy)
          = followPath_a1Hi ps_a1Ow rc_a1Oy

mapTree :: (a_aAD -> b_aAE) -> Tree a_aAD -> Tree b_aAE
mapTree f_a1Oz (TreeC x_a1OA lc_a1OB rc_a1OC)
  = TreeC (f_a1Oz x_a1OA) (mapTree f_a1Oz lc_a1OB)
      (mapTree f_a1Oz rc_a1OC)

int2Real :: Integer -> RealT
int2Real x_a1OD
  = RealC (mapTree (\ n_a1OE -> scale x_a1OD n_a1OE) numberTree)

addReal :: RealT -> RealT -> RealT
addReal x_a1OF y_a1OG
  = RealC
      (mapTree
         (\ n_a1OH ->
            ((evalReal x_a1OF (n_a1OH - 1)) + (evalReal y_a1OG (n_a1OH - 1)) +
               5)
              `quot` 10)
         numberTree)

subReal :: RealT -> RealT -> RealT
subReal x_a1OI y_a1OJ
  = RealC
      (mapTree
         (\ n_a1OK ->
            ((evalReal x_a1OI (n_a1OK - 1)) - (evalReal y_a1OJ (n_a1OK - 1)) +
               5)
              `quot` 10)
         numberTree)

mulReal :: RealT -> RealT -> RealT
mulReal (xr_a1OL@(RealC x_a1OM)) (yr_a1ON@(RealC y_a1OO))
  = RealC
      (mapTree
         (\ n_a1OP ->
            let m_a1OQ
                  = if n_a1OP >= 0 then (n_a1OP + 1) `quot` 2 else
                      (n_a1OP - 1) `quot` 2
                x0_a1OR = evalReal xr_a1OL m_a1OQ
                y0_a1OS = evalReal yr_a1ON m_a1OQ
                mulAux_a1OT x_a1OU y_a1OV
                  = if y1_a1OW == 0 then 0 else
                      scale (x1_a1OX * y1_a1OW)
                        (4 + (msd x_a1OU 0) + (msd y_a1OV 0) - n_a1OP)
                  where y1_a1OW = (evalReal yr_a1ON (n_a1OP - (msd x_a1OU 0) - 2))
                        x1_a1OX = (evalReal xr_a1OL (n_a1OP - (msd y_a1OV 0) - 2))
              in
              if (x0_a1OR == 0) && (y0_a1OS == 0) then 0 else
                if x0_a1OR == 0 then mulAux_a1OT y_a1OO x_a1OM else
                  mulAux_a1OT x_a1OM y_a1OO)
         numberTree)

divReal :: RealT -> RealT -> RealT
divReal x_a1OY y_a1OZ = mulReal x_a1OY (reciprocalReal y_a1OZ)

reciprocalReal :: RealT -> RealT
reciprocalReal xr_a1P0@(RealC x_a1P1)
  = RealC
      (mapTree (\ n_a1P7 -> ((f_a1P3 (dx_a1P2 + n_a1P7)) + 5) `quot` 10)
         numberTree)
  where dx_a1P2 = msd x_a1P1 0
        f_a1P3 m_a1P4
          = if m_a1P4 >= 0 then 0 else
              if m_a1P4 == (-1) then
                10000 `quot` (evalReal xr_a1P0 (dx_a1P2 - 2)) else
                (scale
                   ((fm_a1P6) *
                      ((scale 2 (m_a1P4 + hm_a1P5 - 2)) -
                         (evalReal xr_a1P0 (dx_a1P2 + m_a1P4 - 1))
                         * (fm_a1P6)))
                   (2 - 2 * hm_a1P5))
          where hm_a1P5 = (m_a1P4 - 1) `quot` 2
                fm_a1P6 = f_a1P3 hm_a1P5

sqrReal :: RealT -> RealT
sqrReal (xr_a1P8@(RealC x_a1P9))
  = RealC
      (mapTree
         (\ n_a1Pa ->
            let m_a1Pb
                  = if n_a1Pa >= 0 then (n_a1Pa + 1) `quot` 2 else
                      (n_a1Pa - 1) `quot` 2
                x0_a1Pc = evalReal xr_a1P8 m_a1Pb
                x1_a1Pd = evalReal xr_a1P8 (n_a1Pa - (msd x_a1P9 0) - 2)
              in
              if (x0_a1Pc == 0) then 0 else
                scale (x1_a1Pd * x1_a1Pd) (4 + 2 * (msd x_a1P9 0) - n_a1Pa))
         numberTree)

sqrtReal :: RealT -> RealT
sqrtReal xr_a1Pe@(RealC x_a1Pf)
  = RealC
      (mapTree
         (\ n_a1Pr ->
            if (evalReal xr_a1Pe (2 * n_a1Pr)) == 0 then 0 else
              f_a1Pi n_a1Pr (2 * hdx_a1Ph + 2) xr_a1Pe
                ((-2) * hdx_a1Ph - 2 + n_a1Pr))
         numberTree)
  where dx_a1Pg = msd x_a1Pf 0
        hdx_a1Ph
          = if dx_a1Pg >= 0 then (dx_a1Pg + 1) `quot` 2 else dx_a1Pg `quot` 2
        f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl m_a1Pm
          = if m_a1Pm >= 0 then 0 else
              if m_a1Pm == (-1) then
                scale
                  ((round . sqrt . fromInteger) (evalReal xr_a1Pl (dx_a1Pk - 10)))
                  (5 - hx_a1Pq + n_a1Pj)
                else (fm_a1Po + xv_a1Pp `quot` fm_a1Po) `quot` 2
          where hm_a1Pn = (m_a1Pm - 1) `quot` 2
                fm_a1Po = (f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl hm_a1Pn)
                xv_a1Pp = evalReal xr_a1Pl (n_a1Pj + n_a1Pj)
                hx_a1Pq = dx_a1Pk `quot` 2

data Tree a_aAC = TreeC a_aAC (Tree a_aAC) (Tree a_aAC)

data RealT = RealC (Tree Integer)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.treeFrom :: Integer -> Dum.Tree Integer
Dum.treeFrom n_aAF
  = Dum.TreeC
      n_aAF (Dum.treeFrom (2 * n_aAF - 1)) (Dum.treeFrom (2 * n_aAF - 2))
Dum.numberTree :: Dum.Tree Integer
Dum.numberTree = Dum.treeFrom 0
Dum.scale :: Integer -> Integer -> Integer
Dum.scale x_aBL n_aBM
  | n_aBM <= 0 = (x_aBL * 10 ^ (1 - n_aBM) + 5) `quot` 10
Dum.scale x_a1H6 n_a1H7
  | n_a1H7 > 0 = (x_a1H6 `quot` 10 ^ (n_a1H7 - 1) + 5) `quot` 10
Dum.msd :: Dum.Tree Integer -> Integer -> Integer
Dum.msd x_a1H8 k_a1H9
  = if (xk_a1Ha >= 1) && (xk_a1Ha < 10) then
        k_a1H9
    else
        if (xk_a1Ha == 10) then
            (k_a1H9 + 1)
        else
            if xk_a1Ha >= 1 then
                (Dum.msd x_a1H8 (k_a1H9 + 1))
            else
                (Dum.msd x_a1H8 (k_a1H9 - 1))
  where
      xk_a1Ha = abs (Dum.evalReal (Dum.RealC x_a1H8) k_a1H9)
Dum.evalReal :: Dum.RealT -> Integer -> Integer
Dum.evalReal (Dum.RealC tree_a1Hb) tol_a1Hc
  | tol_a1Hc <= 0 = Dum.lookupTree tree_a1Hb tol_a1Hc
Dum.evalReal (Dum.RealC tree_a1Hd) tol_a1He
  | tol_a1He > 0 = Dum.scale (Dum.lookupTree tree_a1Hd 0) tol_a1He
Dum.lookupTree :: Dum.Tree Integer -> Integer -> Integer
Dum.lookupTree tree_a1Hf n_a1Hg
  = followPath_a1Hi (getPath_a1Hh (1 - n_a1Hg) []) tree_a1Hf
  where
      getPath_a1Hh 1 p_a1Hj = p_a1Hj
      getPath_a1Hh n_a1Hk p_a1Hl
        | even n_a1Hk = getPath_a1Hh (n_a1Hk `quot` 2) (0 : p_a1Hl)
      getPath_a1Hh n_a1Oq p_a1Or
        | odd n_a1Oq = getPath_a1Hh (n_a1Oq `quot` 2) (1 : p_a1Or)
      followPath_a1Hi [] (Dum.TreeC x_a1Os _ _) = x_a1Os
      followPath_a1Hi (0 : ps_a1Ot) (Dum.TreeC x_a1Ou lc_a1Ov _)
        = followPath_a1Hi ps_a1Ot lc_a1Ov
      followPath_a1Hi (1 : ps_a1Ow) (Dum.TreeC x_a1Ox _ rc_a1Oy)
        = followPath_a1Hi ps_a1Ow rc_a1Oy
Dum.mapTree :: (a_aAD -> b_aAE) -> Dum.Tree a_aAD -> Dum.Tree b_aAE
Dum.mapTree f_a1Oz (Dum.TreeC x_a1OA lc_a1OB rc_a1OC)
  = Dum.TreeC
      (f_a1Oz x_a1OA)
      (Dum.mapTree f_a1Oz lc_a1OB)
      (Dum.mapTree f_a1Oz rc_a1OC)
Dum.int2Real :: Integer -> Dum.RealT
Dum.int2Real x_a1OD
  = Dum.RealC
      (Dum.mapTree (\ n_a1OE -> Dum.scale x_a1OD n_a1OE) Dum.numberTree)
Dum.addReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.addReal x_a1OF y_a1OG
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OH
            -> ((Dum.evalReal x_a1OF (n_a1OH - 1))
                + (Dum.evalReal y_a1OG (n_a1OH - 1))
                + 5)
               `quot` 10)
         Dum.numberTree)
Dum.subReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.subReal x_a1OI y_a1OJ
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OK
            -> ((Dum.evalReal x_a1OI (n_a1OK - 1))
                - (Dum.evalReal y_a1OJ (n_a1OK - 1))
                + 5)
               `quot` 10)
         Dum.numberTree)
Dum.mulReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.mulReal
  (xr_a1OL@(Dum.RealC x_a1OM))
  (yr_a1ON@(Dum.RealC y_a1OO))
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OP
            -> let
                 m_a1OQ
                   = if n_a1OP >= 0 then
                         (n_a1OP + 1) `quot` 2
                     else
                         (n_a1OP - 1) `quot` 2
                 x0_a1OR = Dum.evalReal xr_a1OL m_a1OQ
                 y0_a1OS = Dum.evalReal yr_a1ON m_a1OQ
                 mulAux_a1OT x_a1OU y_a1OV
                   = if y1_a1OW == 0 then
                         0
                     else
                         Dum.scale
                           (x1_a1OX * y1_a1OW)
                           (4 + (Dum.msd x_a1OU 0) + (Dum.msd y_a1OV 0) - n_a1OP)
                   where
                       y1_a1OW = (Dum.evalReal yr_a1ON (n_a1OP - (Dum.msd x_a1OU 0) - 2))
                       x1_a1OX = (Dum.evalReal xr_a1OL (n_a1OP - (Dum.msd y_a1OV 0) - 2))
               in
                 if (x0_a1OR == 0) && (y0_a1OS == 0) then
                     0
                 else
                     if x0_a1OR == 0 then
                         mulAux_a1OT y_a1OO x_a1OM
                     else
                         mulAux_a1OT x_a1OM y_a1OO)
         Dum.numberTree)
Dum.divReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.divReal x_a1OY y_a1OZ
  = Dum.mulReal x_a1OY (Dum.reciprocalReal y_a1OZ)
Dum.reciprocalReal :: Dum.RealT -> Dum.RealT
Dum.reciprocalReal xr_a1P0@(Dum.RealC x_a1P1)
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1P7 -> ((f_a1P3 (dx_a1P2 + n_a1P7)) + 5) `quot` 10)
         Dum.numberTree)
  where
      dx_a1P2 = Dum.msd x_a1P1 0
      f_a1P3 m_a1P4
        = if m_a1P4 >= 0 then
              0
          else
              if m_a1P4 == (- 1) then
                  10000 `quot` (Dum.evalReal xr_a1P0 (dx_a1P2 - 2))
              else
                  (Dum.scale
                     ((fm_a1P6)
                      * ((Dum.scale 2 (m_a1P4 + hm_a1P5 - 2))
                         - (Dum.evalReal xr_a1P0 (dx_a1P2 + m_a1P4 - 1)) * (fm_a1P6)))
                     (2 - 2 * hm_a1P5))
        where
            hm_a1P5 = (m_a1P4 - 1) `quot` 2
            fm_a1P6 = f_a1P3 hm_a1P5
Dum.sqrReal :: Dum.RealT -> Dum.RealT
Dum.sqrReal (xr_a1P8@(Dum.RealC x_a1P9))
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1Pa
            -> let
                 m_a1Pb
                   = if n_a1Pa >= 0 then
                         (n_a1Pa + 1) `quot` 2
                     else
                         (n_a1Pa - 1) `quot` 2
                 x0_a1Pc = Dum.evalReal xr_a1P8 m_a1Pb
                 x1_a1Pd = Dum.evalReal xr_a1P8 (n_a1Pa - (Dum.msd x_a1P9 0) - 2)
               in
                 if (x0_a1Pc == 0) then
                     0
                 else
                     Dum.scale
                       (x1_a1Pd * x1_a1Pd) (4 + 2 * (Dum.msd x_a1P9 0) - n_a1Pa))
         Dum.numberTree)
Dum.sqrtReal :: Dum.RealT -> Dum.RealT
Dum.sqrtReal xr_a1Pe@(Dum.RealC x_a1Pf)
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1Pr
            -> if (Dum.evalReal xr_a1Pe (2 * n_a1Pr)) == 0 then
                   0
               else
                   f_a1Pi
                     n_a1Pr (2 * hdx_a1Ph + 2) xr_a1Pe ((- 2) * hdx_a1Ph - 2 + n_a1Pr))
         Dum.numberTree)
  where
      dx_a1Pg = Dum.msd x_a1Pf 0
      hdx_a1Ph
        = if dx_a1Pg >= 0 then (dx_a1Pg + 1) `quot` 2 else dx_a1Pg `quot` 2
      f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl m_a1Pm
        = if m_a1Pm >= 0 then
              0
          else
              if m_a1Pm == (- 1) then
                  Dum.scale
                    ((round . sqrt . fromInteger)
                       (Dum.evalReal xr_a1Pl (dx_a1Pk - 10)))
                    (5 - hx_a1Pq + n_a1Pj)
              else
                  (fm_a1Po + xv_a1Pp `quot` fm_a1Po) `quot` 2
        where
            hm_a1Pn = (m_a1Pm - 1) `quot` 2
            fm_a1Po = (f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl hm_a1Pn)
            xv_a1Pp = Dum.evalReal xr_a1Pl (n_a1Pj + n_a1Pj)
            hx_a1Pq = dx_a1Pk `quot` 2

data Dum.Tree a_aAC
  = Dum.TreeC a_aAC (Dum.Tree a_aAC) (Dum.Tree a_aAC)
data Dum.RealT = Dum.RealC (Dum.Tree Integer)


["n_aAF","numberTree","x_aBL","n_aBM","x_a1H6","n_a1H7","x_a1H8","k_a1H9","xk_a1Ha","tree_a1Hb","RealC tree_a1Hb","(RealC tree_a1Hb)","tol_a1Hc","tree_a1Hd","RealC tree_a1Hd","(RealC tree_a1Hd)","tol_a1He","tree_a1Hf","n_a1Hg","1","p_a1Hj","n_a1Hk","p_a1Hl","n_a1Oq","p_a1Or","[]","x_a1Os","_","_","TreeC x_a1Os _ _","(TreeC x_a1Os _ _)","0","ps_a1Ot","0 : ps_a1Ot","(0 : ps_a1Ot)","x_a1Ou","lc_a1Ov","_","TreeC x_a1Ou lc_a1Ov _","(TreeC x_a1Ou lc_a1Ov _)","1","ps_a1Ow","1 : ps_a1Ow","(1 : ps_a1Ow)","x_a1Ox","_","rc_a1Oy","TreeC x_a1Ox _ rc_a1Oy","(TreeC x_a1Ox _ rc_a1Oy)","f_a1Oz","x_a1OA","lc_a1OB","rc_a1OC","TreeC x_a1OA lc_a1OB rc_a1OC","(TreeC x_a1OA lc_a1OB rc_a1OC)","x_a1OD","n_a1OE","x_a1OF","y_a1OG","n_a1OH","x_a1OI","y_a1OJ","n_a1OK","x_a1OM","RealC x_a1OM","(RealC x_a1OM)","xr_a1OL@(RealC x_a1OM)","(xr_a1OL@(RealC x_a1OM))","y_a1OO","RealC y_a1OO","(RealC y_a1OO)","yr_a1ON@(RealC y_a1OO)","(yr_a1ON@(RealC y_a1OO))","n_a1OP","m_a1OQ","x0_a1OR","y0_a1OS","x_a1OU","y_a1OV","y1_a1OW","x1_a1OX","x_a1OY","y_a1OZ","x_a1P1","RealC x_a1P1","(RealC x_a1P1)","xr_a1P0@(RealC x_a1P1)","n_a1P7","dx_a1P2","m_a1P4","hm_a1P5","fm_a1P6","x_a1P9","RealC x_a1P9","(RealC x_a1P9)","xr_a1P8@(RealC x_a1P9)","(xr_a1P8@(RealC x_a1P9))","n_a1Pa","m_a1Pb","x0_a1Pc","x1_a1Pd","x_a1Pf","RealC x_a1Pf","(RealC x_a1Pf)","xr_a1Pe@(RealC x_a1Pf)","n_a1Pr","dx_a1Pg","hdx_a1Ph","n_a1Pj","dx_a1Pk","xr_a1Pl","m_a1Pm","hm_a1Pn","fm_a1Po","xv_a1Pp","hx_a1Pq"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import RealM
import Data.Ratio

treeFrom :: Integer -> Tree Integer
treeFrom n_aAF
  = TreeC n_aAF (treeFrom (2 * n_aAF - 1)) (treeFrom (2 * n_aAF - 2))

numberTree :: Tree Integer
numberTree = treeFrom 0

scale :: Integer -> Integer -> Integer
scale x_aBL n_aBM
  | n_aBM <= 0 = (x_aBL * 10 ^ (1 - n_aBM) + 5) `quot` 10
scale x_a1H6 n_a1H7
  | n_a1H7 > 0 = (x_a1H6 `quot` 10 ^ (n_a1H7 - 1) + 5) `quot` 10

msd :: Tree Integer -> Integer -> Integer
msd x_a1H8 k_a1H9
  = if (xk_a1Ha >= 1) && (xk_a1Ha < 10) then k_a1H9 else
      if (xk_a1Ha == 10) then (k_a1H9 + 1) else
        if xk_a1Ha >= 1 then (msd x_a1H8 (k_a1H9 + 1)) else
          (msd x_a1H8 (k_a1H9 - 1))
  where xk_a1Ha = abs (evalReal (RealC x_a1H8) k_a1H9)

evalReal :: RealT -> Integer -> Integer
evalReal (RealC tree_a1Hb) tol_a1Hc
  | tol_a1Hc <= 0 = lookupTree tree_a1Hb tol_a1Hc
evalReal (RealC tree_a1Hd) tol_a1He
  | tol_a1He > 0 = scale (lookupTree tree_a1Hd 0) tol_a1He

lookupTree :: Tree Integer -> Integer -> Integer
lookupTree tree_a1Hf n_a1Hg
  = followPath_a1Hi (getPath_a1Hh (1 - n_a1Hg) []) tree_a1Hf
  where getPath_a1Hh 1 p_a1Hj = p_a1Hj
        getPath_a1Hh n_a1Hk p_a1Hl
          | even n_a1Hk = getPath_a1Hh (n_a1Hk `quot` 2) (0 : p_a1Hl)
        getPath_a1Hh n_a1Oq p_a1Or
          | odd n_a1Oq = getPath_a1Hh (n_a1Oq `quot` 2) (1 : p_a1Or)
        followPath_a1Hi [] (TreeC x_a1Os _ _) = x_a1Os
        followPath_a1Hi (0 : ps_a1Ot) (TreeC x_a1Ou lc_a1Ov _)
          = followPath_a1Hi ps_a1Ot lc_a1Ov
        followPath_a1Hi (1 : ps_a1Ow) (TreeC x_a1Ox _ rc_a1Oy)
          = followPath_a1Hi ps_a1Ow rc_a1Oy

mapTree :: (a_aAD -> b_aAE) -> Tree a_aAD -> Tree b_aAE
mapTree f_a1Oz (TreeC x_a1OA lc_a1OB rc_a1OC)
  = TreeC (f_a1Oz x_a1OA) (mapTree f_a1Oz lc_a1OB)
      (mapTree f_a1Oz rc_a1OC)

int2Real :: Integer -> RealT
int2Real x_a1OD
  = RealC (mapTree (\ n_a1OE -> scale x_a1OD n_a1OE) numberTree)

addReal :: RealT -> RealT -> RealT
addReal x_a1OF y_a1OG
  = RealC
      (mapTree
         (\ n_a1OH ->
            ((evalReal x_a1OF (n_a1OH - 1)) + (evalReal y_a1OG (n_a1OH - 1)) +
               5)
              `quot` 10)
         numberTree)

subReal :: RealT -> RealT -> RealT
subReal x_a1OI y_a1OJ
  = RealC
      (mapTree
         (\ n_a1OK ->
            ((evalReal x_a1OI (n_a1OK - 1)) - (evalReal y_a1OJ (n_a1OK - 1)) +
               5)
              `quot` 10)
         numberTree)

mulReal :: RealT -> RealT -> RealT
mulReal (xr_a1OL@(RealC x_a1OM)) (yr_a1ON@(RealC y_a1OO))
  = RealC
      (mapTree
         (\ n_a1OP ->
            let m_a1OQ
                  = if n_a1OP >= 0 then (n_a1OP + 1) `quot` 2 else
                      (n_a1OP - 1) `quot` 2
                x0_a1OR = evalReal xr_a1OL m_a1OQ
                y0_a1OS = evalReal yr_a1ON m_a1OQ
                mulAux_a1OT x_a1OU y_a1OV
                  = if y1_a1OW == 0 then 0 else
                      scale (x1_a1OX * y1_a1OW)
                        (4 + (msd x_a1OU 0) + (msd y_a1OV 0) - n_a1OP)
                  where y1_a1OW = (evalReal yr_a1ON (n_a1OP - (msd x_a1OU 0) - 2))
                        x1_a1OX = (evalReal xr_a1OL (n_a1OP - (msd y_a1OV 0) - 2))
              in
              if (x0_a1OR == 0) && (y0_a1OS == 0) then 0 else
                if x0_a1OR == 0 then mulAux_a1OT y_a1OO x_a1OM else
                  mulAux_a1OT x_a1OM y_a1OO)
         numberTree)

divReal :: RealT -> RealT -> RealT
divReal x_a1OY y_a1OZ = mulReal x_a1OY (reciprocalReal y_a1OZ)

reciprocalReal :: RealT -> RealT
reciprocalReal xr_a1P0@(RealC x_a1P1)
  = RealC
      (mapTree (\ n_a1P7 -> ((f_a1P3 (dx_a1P2 + n_a1P7)) + 5) `quot` 10)
         numberTree)
  where dx_a1P2 = msd x_a1P1 0
        f_a1P3 m_a1P4
          = if m_a1P4 >= 0 then 0 else
              if m_a1P4 == (-1) then
                10000 `quot` (evalReal xr_a1P0 (dx_a1P2 - 2)) else
                (scale
                   ((fm_a1P6) *
                      ((scale 2 (m_a1P4 + hm_a1P5 - 2)) -
                         (evalReal xr_a1P0 (dx_a1P2 + m_a1P4 - 1))
                         * (fm_a1P6)))
                   (2 - 2 * hm_a1P5))
          where hm_a1P5 = (m_a1P4 - 1) `quot` 2
                fm_a1P6 = f_a1P3 hm_a1P5

sqrReal :: RealT -> RealT
sqrReal (xr_a1P8@(RealC x_a1P9))
  = RealC
      (mapTree
         (\ n_a1Pa ->
            let m_a1Pb
                  = if n_a1Pa >= 0 then (n_a1Pa + 1) `quot` 2 else
                      (n_a1Pa - 1) `quot` 2
                x0_a1Pc = evalReal xr_a1P8 m_a1Pb
                x1_a1Pd = evalReal xr_a1P8 (n_a1Pa - (msd x_a1P9 0) - 2)
              in
              if (x0_a1Pc == 0) then 0 else
                scale (x1_a1Pd * x1_a1Pd) (4 + 2 * (msd x_a1P9 0) - n_a1Pa))
         numberTree)

sqrtReal :: RealT -> RealT
sqrtReal xr_a1Pe@(RealC x_a1Pf)
  = RealC
      (mapTree
         (\ n_a1Pr ->
            if (evalReal xr_a1Pe (2 * n_a1Pr)) == 0 then 0 else
              f_a1Pi n_a1Pr (2 * hdx_a1Ph + 2) xr_a1Pe
                ((-2) * hdx_a1Ph - 2 + n_a1Pr))
         numberTree)
  where dx_a1Pg = msd x_a1Pf 0
        hdx_a1Ph
          = if dx_a1Pg >= 0 then (dx_a1Pg + 1) `quot` 2 else dx_a1Pg `quot` 2
        f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl m_a1Pm
          = if m_a1Pm >= 0 then 0 else
              if m_a1Pm == (-1) then
                scale
                  ((round . sqrt . fromInteger) (evalReal xr_a1Pl (dx_a1Pk - 10)))
                  (5 - hx_a1Pq + n_a1Pj)
                else (fm_a1Po + xv_a1Pp `quot` fm_a1Po) `quot` 2
          where hm_a1Pn = (m_a1Pm - 1) `quot` 2
                fm_a1Po = (f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl hm_a1Pn)
                xv_a1Pp = evalReal xr_a1Pl (n_a1Pj + n_a1Pj)
                hx_a1Pq = dx_a1Pk `quot` 2

data Tree a_aAC = TreeC a_aAC (Tree a_aAC) (Tree a_aAC)

data RealT = RealC (Tree Integer)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.treeFrom :: Integer -> Dum.Tree Integer
Dum.treeFrom n_aAF
  = Dum.TreeC
      n_aAF (Dum.treeFrom (2 * n_aAF - 1)) (Dum.treeFrom (2 * n_aAF - 2))
Dum.numberTree :: Dum.Tree Integer
Dum.numberTree = Dum.treeFrom 0
Dum.scale :: Integer -> Integer -> Integer
Dum.scale x_aBL n_aBM
  | n_aBM <= 0 = (x_aBL * 10 ^ (1 - n_aBM) + 5) `quot` 10
Dum.scale x_a1H6 n_a1H7
  | n_a1H7 > 0 = (x_a1H6 `quot` 10 ^ (n_a1H7 - 1) + 5) `quot` 10
Dum.msd :: Dum.Tree Integer -> Integer -> Integer
Dum.msd x_a1H8 k_a1H9
  = if (xk_a1Ha >= 1) && (xk_a1Ha < 10) then
        k_a1H9
    else
        if (xk_a1Ha == 10) then
            (k_a1H9 + 1)
        else
            if xk_a1Ha >= 1 then
                (Dum.msd x_a1H8 (k_a1H9 + 1))
            else
                (Dum.msd x_a1H8 (k_a1H9 - 1))
  where
      xk_a1Ha = abs (Dum.evalReal (Dum.RealC x_a1H8) k_a1H9)
Dum.evalReal :: Dum.RealT -> Integer -> Integer
Dum.evalReal (Dum.RealC tree_a1Hb) tol_a1Hc
  | tol_a1Hc <= 0 = Dum.lookupTree tree_a1Hb tol_a1Hc
Dum.evalReal (Dum.RealC tree_a1Hd) tol_a1He
  | tol_a1He > 0 = Dum.scale (Dum.lookupTree tree_a1Hd 0) tol_a1He
Dum.lookupTree :: Dum.Tree Integer -> Integer -> Integer
Dum.lookupTree tree_a1Hf n_a1Hg
  = followPath_a1Hi (getPath_a1Hh (1 - n_a1Hg) []) tree_a1Hf
  where
      getPath_a1Hh 1 p_a1Hj = p_a1Hj
      getPath_a1Hh n_a1Hk p_a1Hl
        | even n_a1Hk = getPath_a1Hh (n_a1Hk `quot` 2) (0 : p_a1Hl)
      getPath_a1Hh n_a1Oq p_a1Or
        | odd n_a1Oq = getPath_a1Hh (n_a1Oq `quot` 2) (1 : p_a1Or)
      followPath_a1Hi [] (Dum.TreeC x_a1Os _ _) = x_a1Os
      followPath_a1Hi (0 : ps_a1Ot) (Dum.TreeC x_a1Ou lc_a1Ov _)
        = followPath_a1Hi ps_a1Ot lc_a1Ov
      followPath_a1Hi (1 : ps_a1Ow) (Dum.TreeC x_a1Ox _ rc_a1Oy)
        = followPath_a1Hi ps_a1Ow rc_a1Oy
Dum.mapTree :: (a_aAD -> b_aAE) -> Dum.Tree a_aAD -> Dum.Tree b_aAE
Dum.mapTree f_a1Oz (Dum.TreeC x_a1OA lc_a1OB rc_a1OC)
  = Dum.TreeC
      (f_a1Oz x_a1OA)
      (Dum.mapTree f_a1Oz lc_a1OB)
      (Dum.mapTree f_a1Oz rc_a1OC)
Dum.int2Real :: Integer -> Dum.RealT
Dum.int2Real x_a1OD
  = Dum.RealC
      (Dum.mapTree (\ n_a1OE -> Dum.scale x_a1OD n_a1OE) Dum.numberTree)
Dum.addReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.addReal x_a1OF y_a1OG
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OH
            -> ((Dum.evalReal x_a1OF (n_a1OH - 1))
                + (Dum.evalReal y_a1OG (n_a1OH - 1))
                + 5)
               `quot` 10)
         Dum.numberTree)
Dum.subReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.subReal x_a1OI y_a1OJ
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OK
            -> ((Dum.evalReal x_a1OI (n_a1OK - 1))
                - (Dum.evalReal y_a1OJ (n_a1OK - 1))
                + 5)
               `quot` 10)
         Dum.numberTree)
Dum.mulReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.mulReal
  (xr_a1OL@(Dum.RealC x_a1OM))
  (yr_a1ON@(Dum.RealC y_a1OO))
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OP
            -> let
                 m_a1OQ
                   = if n_a1OP >= 0 then
                         (n_a1OP + 1) `quot` 2
                     else
                         (n_a1OP - 1) `quot` 2
                 x0_a1OR = Dum.evalReal xr_a1OL m_a1OQ
                 y0_a1OS = Dum.evalReal yr_a1ON m_a1OQ
                 mulAux_a1OT x_a1OU y_a1OV
                   = if y1_a1OW == 0 then
                         0
                     else
                         Dum.scale
                           (x1_a1OX * y1_a1OW)
                           (4 + (Dum.msd x_a1OU 0) + (Dum.msd y_a1OV 0) - n_a1OP)
                   where
                       y1_a1OW = (Dum.evalReal yr_a1ON (n_a1OP - (Dum.msd x_a1OU 0) - 2))
                       x1_a1OX = (Dum.evalReal xr_a1OL (n_a1OP - (Dum.msd y_a1OV 0) - 2))
               in
                 if (x0_a1OR == 0) && (y0_a1OS == 0) then
                     0
                 else
                     if x0_a1OR == 0 then
                         mulAux_a1OT y_a1OO x_a1OM
                     else
                         mulAux_a1OT x_a1OM y_a1OO)
         Dum.numberTree)
Dum.divReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.divReal x_a1OY y_a1OZ
  = Dum.mulReal x_a1OY (Dum.reciprocalReal y_a1OZ)
Dum.reciprocalReal :: Dum.RealT -> Dum.RealT
Dum.reciprocalReal xr_a1P0@(Dum.RealC x_a1P1)
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1P7 -> ((f_a1P3 (dx_a1P2 + n_a1P7)) + 5) `quot` 10)
         Dum.numberTree)
  where
      dx_a1P2 = Dum.msd x_a1P1 0
      f_a1P3 m_a1P4
        = if m_a1P4 >= 0 then
              0
          else
              if m_a1P4 == (- 1) then
                  10000 `quot` (Dum.evalReal xr_a1P0 (dx_a1P2 - 2))
              else
                  (Dum.scale
                     ((fm_a1P6)
                      * ((Dum.scale 2 (m_a1P4 + hm_a1P5 - 2))
                         - (Dum.evalReal xr_a1P0 (dx_a1P2 + m_a1P4 - 1)) * (fm_a1P6)))
                     (2 - 2 * hm_a1P5))
        where
            hm_a1P5 = (m_a1P4 - 1) `quot` 2
            fm_a1P6 = f_a1P3 hm_a1P5
Dum.sqrReal :: Dum.RealT -> Dum.RealT
Dum.sqrReal (xr_a1P8@(Dum.RealC x_a1P9))
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1Pa
            -> let
                 m_a1Pb
                   = if n_a1Pa >= 0 then
                         (n_a1Pa + 1) `quot` 2
                     else
                         (n_a1Pa - 1) `quot` 2
                 x0_a1Pc = Dum.evalReal xr_a1P8 m_a1Pb
                 x1_a1Pd = Dum.evalReal xr_a1P8 (n_a1Pa - (Dum.msd x_a1P9 0) - 2)
               in
                 if (x0_a1Pc == 0) then
                     0
                 else
                     Dum.scale
                       (x1_a1Pd * x1_a1Pd) (4 + 2 * (Dum.msd x_a1P9 0) - n_a1Pa))
         Dum.numberTree)
Dum.sqrtReal :: Dum.RealT -> Dum.RealT
Dum.sqrtReal xr_a1Pe@(Dum.RealC x_a1Pf)
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1Pr
            -> if (Dum.evalReal xr_a1Pe (2 * n_a1Pr)) == 0 then
                   0
               else
                   f_a1Pi
                     n_a1Pr (2 * hdx_a1Ph + 2) xr_a1Pe ((- 2) * hdx_a1Ph - 2 + n_a1Pr))
         Dum.numberTree)
  where
      dx_a1Pg = Dum.msd x_a1Pf 0
      hdx_a1Ph
        = if dx_a1Pg >= 0 then (dx_a1Pg + 1) `quot` 2 else dx_a1Pg `quot` 2
      f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl m_a1Pm
        = if m_a1Pm >= 0 then
              0
          else
              if m_a1Pm == (- 1) then
                  Dum.scale
                    ((round . sqrt . fromInteger)
                       (Dum.evalReal xr_a1Pl (dx_a1Pk - 10)))
                    (5 - hx_a1Pq + n_a1Pj)
              else
                  (fm_a1Po + xv_a1Pp `quot` fm_a1Po) `quot` 2
        where
            hm_a1Pn = (m_a1Pm - 1) `quot` 2
            fm_a1Po = (f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl hm_a1Pn)
            xv_a1Pp = Dum.evalReal xr_a1Pl (n_a1Pj + n_a1Pj)
            hx_a1Pq = dx_a1Pk `quot` 2

data Dum.Tree a_aAC
  = Dum.TreeC a_aAC (Dum.Tree a_aAC) (Dum.Tree a_aAC)
data Dum.RealT = Dum.RealC (Dum.Tree Integer)


["n_aAF","numberTree","x_aBL","n_aBM","x_a1H6","n_a1H7","x_a1H8","k_a1H9","xk_a1Ha","tree_a1Hb","RealC tree_a1Hb","(RealC tree_a1Hb)","tol_a1Hc","tree_a1Hd","RealC tree_a1Hd","(RealC tree_a1Hd)","tol_a1He","tree_a1Hf","n_a1Hg","1","p_a1Hj","n_a1Hk","p_a1Hl","n_a1Oq","p_a1Or","[]","x_a1Os","_","_","TreeC x_a1Os _ _","(TreeC x_a1Os _ _)","0","ps_a1Ot","0 : ps_a1Ot","(0 : ps_a1Ot)","x_a1Ou","lc_a1Ov","_","TreeC x_a1Ou lc_a1Ov _","(TreeC x_a1Ou lc_a1Ov _)","1","ps_a1Ow","1 : ps_a1Ow","(1 : ps_a1Ow)","x_a1Ox","_","rc_a1Oy","TreeC x_a1Ox _ rc_a1Oy","(TreeC x_a1Ox _ rc_a1Oy)","f_a1Oz","x_a1OA","lc_a1OB","rc_a1OC","TreeC x_a1OA lc_a1OB rc_a1OC","(TreeC x_a1OA lc_a1OB rc_a1OC)","x_a1OD","n_a1OE","x_a1OF","y_a1OG","n_a1OH","x_a1OI","y_a1OJ","n_a1OK","x_a1OM","RealC x_a1OM","(RealC x_a1OM)","xr_a1OL@(RealC x_a1OM)","(xr_a1OL@(RealC x_a1OM))","y_a1OO","RealC y_a1OO","(RealC y_a1OO)","yr_a1ON@(RealC y_a1OO)","(yr_a1ON@(RealC y_a1OO))","n_a1OP","m_a1OQ","x0_a1OR","y0_a1OS","x_a1OU","y_a1OV","y1_a1OW","x1_a1OX","x_a1OY","y_a1OZ","x_a1P1","RealC x_a1P1","(RealC x_a1P1)","xr_a1P0@(RealC x_a1P1)","n_a1P7","dx_a1P2","m_a1P4","hm_a1P5","fm_a1P6","x_a1P9","RealC x_a1P9","(RealC x_a1P9)","xr_a1P8@(RealC x_a1P9)","(xr_a1P8@(RealC x_a1P9))","n_a1Pa","m_a1Pb","x0_a1Pc","x1_a1Pd","x_a1Pf","RealC x_a1Pf","(RealC x_a1Pf)","xr_a1Pe@(RealC x_a1Pf)","n_a1Pr","dx_a1Pg","hdx_a1Ph","n_a1Pj","dx_a1Pk","xr_a1Pl","m_a1Pm","hm_a1Pn","fm_a1Po","xv_a1Pp","hx_a1Pq"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import RealM
import BasicNumber
import Data.Ratio
import Data.List (genericDrop, genericTake)

treeFrom :: Integer -> Tree Integer
treeFrom n_aAF
  = TreeC n_aAF (treeFrom (2 * n_aAF - 1)) (treeFrom (2 * n_aAF - 2))

numberTree :: Tree Integer
numberTree = treeFrom 0

scale :: Integer -> Integer -> Integer
scale x_aBL n_aBM
  | n_aBM <= 0 = (x_aBL * 10 ^ (1 - n_aBM) + 5) `quot` 10
scale x_a1H6 n_a1H7
  | n_a1H7 > 0 = (x_a1H6 `quot` 10 ^ (n_a1H7 - 1) + 5) `quot` 10

msd :: Tree Integer -> Integer -> Integer
msd x_a1H8 k_a1H9
  = if (xk_a1Ha >= 1) && (xk_a1Ha < 10) then k_a1H9 else
      if (xk_a1Ha == 10) then (k_a1H9 + 1) else
        if xk_a1Ha >= 1 then (msd x_a1H8 (k_a1H9 + 1)) else
          (msd x_a1H8 (k_a1H9 - 1))
  where xk_a1Ha = abs (evalReal (RealC x_a1H8) k_a1H9)

evalReal :: RealT -> Integer -> Integer
evalReal (RealC tree_a1Hb) tol_a1Hc
  | tol_a1Hc <= 0 = lookupTree tree_a1Hb tol_a1Hc
evalReal (RealC tree_a1Hd) tol_a1He
  | tol_a1He > 0 = scale (lookupTree tree_a1Hd 0) tol_a1He

lookupTree :: Tree Integer -> Integer -> Integer
lookupTree tree_a1Hf n_a1Hg
  = followPath_a1Hi (getPath_a1Hh (1 - n_a1Hg) []) tree_a1Hf
  where getPath_a1Hh 1 p_a1Hj = p_a1Hj
        getPath_a1Hh n_a1Hk p_a1Hl
          | even n_a1Hk = getPath_a1Hh (n_a1Hk `quot` 2) (0 : p_a1Hl)
        getPath_a1Hh n_a1Oq p_a1Or
          | odd n_a1Oq = getPath_a1Hh (n_a1Oq `quot` 2) (1 : p_a1Or)
        followPath_a1Hi [] (TreeC x_a1Os _ _) = x_a1Os
        followPath_a1Hi (0 : ps_a1Ot) (TreeC x_a1Ou lc_a1Ov _)
          = followPath_a1Hi ps_a1Ot lc_a1Ov
        followPath_a1Hi (1 : ps_a1Ow) (TreeC x_a1Ox _ rc_a1Oy)
          = followPath_a1Hi ps_a1Ow rc_a1Oy

mapTree :: (a_aAD -> b_aAE) -> Tree a_aAD -> Tree b_aAE
mapTree f_a1Oz (TreeC x_a1OA lc_a1OB rc_a1OC)
  = TreeC (f_a1Oz x_a1OA) (mapTree f_a1Oz lc_a1OB)
      (mapTree f_a1Oz rc_a1OC)

int2Real :: Integer -> RealT
int2Real x_a1OD
  = RealC (mapTree (\ n_a1OE -> scale x_a1OD n_a1OE) numberTree)

addReal :: RealT -> RealT -> RealT
addReal x_a1OF y_a1OG
  = RealC
      (mapTree
         (\ n_a1OH ->
            ((evalReal x_a1OF (n_a1OH - 1)) + (evalReal y_a1OG (n_a1OH - 1)) +
               5)
              `quot` 10)
         numberTree)

subReal :: RealT -> RealT -> RealT
subReal x_a1OI y_a1OJ
  = RealC
      (mapTree
         (\ n_a1OK ->
            ((evalReal x_a1OI (n_a1OK - 1)) - (evalReal y_a1OJ (n_a1OK - 1)) +
               5)
              `quot` 10)
         numberTree)

mulReal :: RealT -> RealT -> RealT
mulReal (xr_a1OL@(RealC x_a1OM)) (yr_a1ON@(RealC y_a1OO))
  = RealC
      (mapTree
         (\ n_a1OP ->
            let m_a1OQ
                  = if n_a1OP >= 0 then (n_a1OP + 1) `quot` 2 else
                      (n_a1OP - 1) `quot` 2
                x0_a1OR = evalReal xr_a1OL m_a1OQ
                y0_a1OS = evalReal yr_a1ON m_a1OQ
                mulAux_a1OT x_a1OU y_a1OV
                  = if y1_a1OW == 0 then 0 else
                      scale (x1_a1OX * y1_a1OW)
                        (4 + (msd x_a1OU 0) + (msd y_a1OV 0) - n_a1OP)
                  where y1_a1OW = (evalReal yr_a1ON (n_a1OP - (msd x_a1OU 0) - 2))
                        x1_a1OX = (evalReal xr_a1OL (n_a1OP - (msd y_a1OV 0) - 2))
              in
              if (x0_a1OR == 0) && (y0_a1OS == 0) then 0 else
                if x0_a1OR == 0 then mulAux_a1OT y_a1OO x_a1OM else
                  mulAux_a1OT x_a1OM y_a1OO)
         numberTree)

divReal :: RealT -> RealT -> RealT
divReal x_a1OY y_a1OZ = mulReal x_a1OY (reciprocalReal y_a1OZ)

reciprocalReal :: RealT -> RealT
reciprocalReal xr_a1P0@(RealC x_a1P1)
  = RealC
      (mapTree (\ n_a1P7 -> ((f_a1P3 (dx_a1P2 + n_a1P7)) + 5) `quot` 10)
         numberTree)
  where dx_a1P2 = msd x_a1P1 0
        f_a1P3 m_a1P4
          = if m_a1P4 >= 0 then 0 else
              if m_a1P4 == (-1) then
                10000 `quot` (evalReal xr_a1P0 (dx_a1P2 - 2)) else
                (scale
                   ((fm_a1P6) *
                      ((scale 2 (m_a1P4 + hm_a1P5 - 2)) -
                         (evalReal xr_a1P0 (dx_a1P2 + m_a1P4 - 1))
                         * (fm_a1P6)))
                   (2 - 2 * hm_a1P5))
          where hm_a1P5 = (m_a1P4 - 1) `quot` 2
                fm_a1P6 = f_a1P3 hm_a1P5

sqrReal :: RealT -> RealT
sqrReal (xr_a1P8@(RealC x_a1P9))
  = RealC
      (mapTree
         (\ n_a1Pa ->
            let m_a1Pb
                  = if n_a1Pa >= 0 then (n_a1Pa + 1) `quot` 2 else
                      (n_a1Pa - 1) `quot` 2
                x0_a1Pc = evalReal xr_a1P8 m_a1Pb
                x1_a1Pd = evalReal xr_a1P8 (n_a1Pa - (msd x_a1P9 0) - 2)
              in
              if (x0_a1Pc == 0) then 0 else
                scale (x1_a1Pd * x1_a1Pd) (4 + 2 * (msd x_a1P9 0) - n_a1Pa))
         numberTree)

sqrtReal :: RealT -> RealT
sqrtReal xr_a1Pe@(RealC x_a1Pf)
  = RealC
      (mapTree
         (\ n_a1Pr ->
            if (evalReal xr_a1Pe (2 * n_a1Pr)) == 0 then 0 else
              f_a1Pi n_a1Pr (2 * hdx_a1Ph + 2) xr_a1Pe
                ((-2) * hdx_a1Ph - 2 + n_a1Pr))
         numberTree)
  where dx_a1Pg = msd x_a1Pf 0
        hdx_a1Ph
          = if dx_a1Pg >= 0 then (dx_a1Pg + 1) `quot` 2 else dx_a1Pg `quot` 2
        f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl m_a1Pm
          = if m_a1Pm >= 0 then 0 else
              if m_a1Pm == (-1) then
                scale
                  ((round . sqrt . fromInteger) (evalReal xr_a1Pl (dx_a1Pk - 10)))
                  (5 - hx_a1Pq + n_a1Pj)
                else (fm_a1Po + xv_a1Pp `quot` fm_a1Po) `quot` 2
          where hm_a1Pn = (m_a1Pm - 1) `quot` 2
                fm_a1Po = (f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl hm_a1Pn)
                xv_a1Pp = evalReal xr_a1Pl (n_a1Pj + n_a1Pj)
                hx_a1Pq = dx_a1Pk `quot` 2

data Tree a_aAC = TreeC a_aAC (Tree a_aAC) (Tree a_aAC)

data RealT = RealC (Tree Integer)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.treeFrom :: Integer -> Dum.Tree Integer
Dum.treeFrom n_aAF
  = Dum.TreeC
      n_aAF (Dum.treeFrom (2 * n_aAF - 1)) (Dum.treeFrom (2 * n_aAF - 2))
Dum.numberTree :: Dum.Tree Integer
Dum.numberTree = Dum.treeFrom 0
Dum.scale :: Integer -> Integer -> Integer
Dum.scale x_aBL n_aBM
  | n_aBM <= 0 = (x_aBL * 10 ^ (1 - n_aBM) + 5) `quot` 10
Dum.scale x_a1H6 n_a1H7
  | n_a1H7 > 0 = (x_a1H6 `quot` 10 ^ (n_a1H7 - 1) + 5) `quot` 10
Dum.msd :: Dum.Tree Integer -> Integer -> Integer
Dum.msd x_a1H8 k_a1H9
  = if (xk_a1Ha >= 1) && (xk_a1Ha < 10) then
        k_a1H9
    else
        if (xk_a1Ha == 10) then
            (k_a1H9 + 1)
        else
            if xk_a1Ha >= 1 then
                (Dum.msd x_a1H8 (k_a1H9 + 1))
            else
                (Dum.msd x_a1H8 (k_a1H9 - 1))
  where
      xk_a1Ha = abs (Dum.evalReal (Dum.RealC x_a1H8) k_a1H9)
Dum.evalReal :: Dum.RealT -> Integer -> Integer
Dum.evalReal (Dum.RealC tree_a1Hb) tol_a1Hc
  | tol_a1Hc <= 0 = Dum.lookupTree tree_a1Hb tol_a1Hc
Dum.evalReal (Dum.RealC tree_a1Hd) tol_a1He
  | tol_a1He > 0 = Dum.scale (Dum.lookupTree tree_a1Hd 0) tol_a1He
Dum.lookupTree :: Dum.Tree Integer -> Integer -> Integer
Dum.lookupTree tree_a1Hf n_a1Hg
  = followPath_a1Hi (getPath_a1Hh (1 - n_a1Hg) []) tree_a1Hf
  where
      getPath_a1Hh 1 p_a1Hj = p_a1Hj
      getPath_a1Hh n_a1Hk p_a1Hl
        | even n_a1Hk = getPath_a1Hh (n_a1Hk `quot` 2) (0 : p_a1Hl)
      getPath_a1Hh n_a1Oq p_a1Or
        | odd n_a1Oq = getPath_a1Hh (n_a1Oq `quot` 2) (1 : p_a1Or)
      followPath_a1Hi [] (Dum.TreeC x_a1Os _ _) = x_a1Os
      followPath_a1Hi (0 : ps_a1Ot) (Dum.TreeC x_a1Ou lc_a1Ov _)
        = followPath_a1Hi ps_a1Ot lc_a1Ov
      followPath_a1Hi (1 : ps_a1Ow) (Dum.TreeC x_a1Ox _ rc_a1Oy)
        = followPath_a1Hi ps_a1Ow rc_a1Oy
Dum.mapTree :: (a_aAD -> b_aAE) -> Dum.Tree a_aAD -> Dum.Tree b_aAE
Dum.mapTree f_a1Oz (Dum.TreeC x_a1OA lc_a1OB rc_a1OC)
  = Dum.TreeC
      (f_a1Oz x_a1OA)
      (Dum.mapTree f_a1Oz lc_a1OB)
      (Dum.mapTree f_a1Oz rc_a1OC)
Dum.int2Real :: Integer -> Dum.RealT
Dum.int2Real x_a1OD
  = Dum.RealC
      (Dum.mapTree (\ n_a1OE -> Dum.scale x_a1OD n_a1OE) Dum.numberTree)
Dum.addReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.addReal x_a1OF y_a1OG
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OH
            -> ((Dum.evalReal x_a1OF (n_a1OH - 1))
                + (Dum.evalReal y_a1OG (n_a1OH - 1))
                + 5)
               `quot` 10)
         Dum.numberTree)
Dum.subReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.subReal x_a1OI y_a1OJ
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OK
            -> ((Dum.evalReal x_a1OI (n_a1OK - 1))
                - (Dum.evalReal y_a1OJ (n_a1OK - 1))
                + 5)
               `quot` 10)
         Dum.numberTree)
Dum.mulReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.mulReal
  (xr_a1OL@(Dum.RealC x_a1OM))
  (yr_a1ON@(Dum.RealC y_a1OO))
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OP
            -> let
                 m_a1OQ
                   = if n_a1OP >= 0 then
                         (n_a1OP + 1) `quot` 2
                     else
                         (n_a1OP - 1) `quot` 2
                 x0_a1OR = Dum.evalReal xr_a1OL m_a1OQ
                 y0_a1OS = Dum.evalReal yr_a1ON m_a1OQ
                 mulAux_a1OT x_a1OU y_a1OV
                   = if y1_a1OW == 0 then
                         0
                     else
                         Dum.scale
                           (x1_a1OX * y1_a1OW)
                           (4 + (Dum.msd x_a1OU 0) + (Dum.msd y_a1OV 0) - n_a1OP)
                   where
                       y1_a1OW = (Dum.evalReal yr_a1ON (n_a1OP - (Dum.msd x_a1OU 0) - 2))
                       x1_a1OX = (Dum.evalReal xr_a1OL (n_a1OP - (Dum.msd y_a1OV 0) - 2))
               in
                 if (x0_a1OR == 0) && (y0_a1OS == 0) then
                     0
                 else
                     if x0_a1OR == 0 then
                         mulAux_a1OT y_a1OO x_a1OM
                     else
                         mulAux_a1OT x_a1OM y_a1OO)
         Dum.numberTree)
Dum.divReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.divReal x_a1OY y_a1OZ
  = Dum.mulReal x_a1OY (Dum.reciprocalReal y_a1OZ)
Dum.reciprocalReal :: Dum.RealT -> Dum.RealT
Dum.reciprocalReal xr_a1P0@(Dum.RealC x_a1P1)
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1P7 -> ((f_a1P3 (dx_a1P2 + n_a1P7)) + 5) `quot` 10)
         Dum.numberTree)
  where
      dx_a1P2 = Dum.msd x_a1P1 0
      f_a1P3 m_a1P4
        = if m_a1P4 >= 0 then
              0
          else
              if m_a1P4 == (- 1) then
                  10000 `quot` (Dum.evalReal xr_a1P0 (dx_a1P2 - 2))
              else
                  (Dum.scale
                     ((fm_a1P6)
                      * ((Dum.scale 2 (m_a1P4 + hm_a1P5 - 2))
                         - (Dum.evalReal xr_a1P0 (dx_a1P2 + m_a1P4 - 1)) * (fm_a1P6)))
                     (2 - 2 * hm_a1P5))
        where
            hm_a1P5 = (m_a1P4 - 1) `quot` 2
            fm_a1P6 = f_a1P3 hm_a1P5
Dum.sqrReal :: Dum.RealT -> Dum.RealT
Dum.sqrReal (xr_a1P8@(Dum.RealC x_a1P9))
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1Pa
            -> let
                 m_a1Pb
                   = if n_a1Pa >= 0 then
                         (n_a1Pa + 1) `quot` 2
                     else
                         (n_a1Pa - 1) `quot` 2
                 x0_a1Pc = Dum.evalReal xr_a1P8 m_a1Pb
                 x1_a1Pd = Dum.evalReal xr_a1P8 (n_a1Pa - (Dum.msd x_a1P9 0) - 2)
               in
                 if (x0_a1Pc == 0) then
                     0
                 else
                     Dum.scale
                       (x1_a1Pd * x1_a1Pd) (4 + 2 * (Dum.msd x_a1P9 0) - n_a1Pa))
         Dum.numberTree)
Dum.sqrtReal :: Dum.RealT -> Dum.RealT
Dum.sqrtReal xr_a1Pe@(Dum.RealC x_a1Pf)
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1Pr
            -> if (Dum.evalReal xr_a1Pe (2 * n_a1Pr)) == 0 then
                   0
               else
                   f_a1Pi
                     n_a1Pr (2 * hdx_a1Ph + 2) xr_a1Pe ((- 2) * hdx_a1Ph - 2 + n_a1Pr))
         Dum.numberTree)
  where
      dx_a1Pg = Dum.msd x_a1Pf 0
      hdx_a1Ph
        = if dx_a1Pg >= 0 then (dx_a1Pg + 1) `quot` 2 else dx_a1Pg `quot` 2
      f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl m_a1Pm
        = if m_a1Pm >= 0 then
              0
          else
              if m_a1Pm == (- 1) then
                  Dum.scale
                    ((round . sqrt . fromInteger)
                       (Dum.evalReal xr_a1Pl (dx_a1Pk - 10)))
                    (5 - hx_a1Pq + n_a1Pj)
              else
                  (fm_a1Po + xv_a1Pp `quot` fm_a1Po) `quot` 2
        where
            hm_a1Pn = (m_a1Pm - 1) `quot` 2
            fm_a1Po = (f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl hm_a1Pn)
            xv_a1Pp = Dum.evalReal xr_a1Pl (n_a1Pj + n_a1Pj)
            hx_a1Pq = dx_a1Pk `quot` 2

data Dum.Tree a_aAC
  = Dum.TreeC a_aAC (Dum.Tree a_aAC) (Dum.Tree a_aAC)
data Dum.RealT = Dum.RealC (Dum.Tree Integer)


["n_aAF","numberTree","x_aBL","n_aBM","x_a1H6","n_a1H7","x_a1H8","k_a1H9","xk_a1Ha","tree_a1Hb","RealC tree_a1Hb","(RealC tree_a1Hb)","tol_a1Hc","tree_a1Hd","RealC tree_a1Hd","(RealC tree_a1Hd)","tol_a1He","tree_a1Hf","n_a1Hg","1","p_a1Hj","n_a1Hk","p_a1Hl","n_a1Oq","p_a1Or","[]","x_a1Os","_","_","TreeC x_a1Os _ _","(TreeC x_a1Os _ _)","0","ps_a1Ot","0 : ps_a1Ot","(0 : ps_a1Ot)","x_a1Ou","lc_a1Ov","_","TreeC x_a1Ou lc_a1Ov _","(TreeC x_a1Ou lc_a1Ov _)","1","ps_a1Ow","1 : ps_a1Ow","(1 : ps_a1Ow)","x_a1Ox","_","rc_a1Oy","TreeC x_a1Ox _ rc_a1Oy","(TreeC x_a1Ox _ rc_a1Oy)","f_a1Oz","x_a1OA","lc_a1OB","rc_a1OC","TreeC x_a1OA lc_a1OB rc_a1OC","(TreeC x_a1OA lc_a1OB rc_a1OC)","x_a1OD","n_a1OE","x_a1OF","y_a1OG","n_a1OH","x_a1OI","y_a1OJ","n_a1OK","x_a1OM","RealC x_a1OM","(RealC x_a1OM)","xr_a1OL@(RealC x_a1OM)","(xr_a1OL@(RealC x_a1OM))","y_a1OO","RealC y_a1OO","(RealC y_a1OO)","yr_a1ON@(RealC y_a1OO)","(yr_a1ON@(RealC y_a1OO))","n_a1OP","m_a1OQ","x0_a1OR","y0_a1OS","x_a1OU","y_a1OV","y1_a1OW","x1_a1OX","x_a1OY","y_a1OZ","x_a1P1","RealC x_a1P1","(RealC x_a1P1)","xr_a1P0@(RealC x_a1P1)","n_a1P7","dx_a1P2","m_a1P4","hm_a1P5","fm_a1P6","x_a1P9","RealC x_a1P9","(RealC x_a1P9)","xr_a1P8@(RealC x_a1P9)","(xr_a1P8@(RealC x_a1P9))","n_a1Pa","m_a1Pb","x0_a1Pc","x1_a1Pd","x_a1Pf","RealC x_a1Pf","(RealC x_a1Pf)","xr_a1Pe@(RealC x_a1Pf)","n_a1Pr","dx_a1Pg","hdx_a1Ph","n_a1Pj","dx_a1Pk","xr_a1Pl","m_a1Pm","hm_a1Pn","fm_a1Po","xv_a1Pp","hx_a1Pq"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BasicNumber

treeFrom :: Integer -> Tree Integer
treeFrom n_aAF
  = TreeC n_aAF (treeFrom (2 * n_aAF - 1)) (treeFrom (2 * n_aAF - 2))

numberTree :: Tree Integer
numberTree = treeFrom 0

scale :: Integer -> Integer -> Integer
scale x_aBL n_aBM
  | n_aBM <= 0 = (x_aBL * 10 ^ (1 - n_aBM) + 5) `quot` 10
scale x_a1H6 n_a1H7
  | n_a1H7 > 0 = (x_a1H6 `quot` 10 ^ (n_a1H7 - 1) + 5) `quot` 10

msd :: Tree Integer -> Integer -> Integer
msd x_a1H8 k_a1H9
  = if (xk_a1Ha >= 1) && (xk_a1Ha < 10) then k_a1H9 else
      if (xk_a1Ha == 10) then (k_a1H9 + 1) else
        if xk_a1Ha >= 1 then (msd x_a1H8 (k_a1H9 + 1)) else
          (msd x_a1H8 (k_a1H9 - 1))
  where xk_a1Ha = abs (evalReal (RealC x_a1H8) k_a1H9)

evalReal :: RealT -> Integer -> Integer
evalReal (RealC tree_a1Hb) tol_a1Hc
  | tol_a1Hc <= 0 = lookupTree tree_a1Hb tol_a1Hc
evalReal (RealC tree_a1Hd) tol_a1He
  | tol_a1He > 0 = scale (lookupTree tree_a1Hd 0) tol_a1He

lookupTree :: Tree Integer -> Integer -> Integer
lookupTree tree_a1Hf n_a1Hg
  = followPath_a1Hi (getPath_a1Hh (1 - n_a1Hg) []) tree_a1Hf
  where getPath_a1Hh 1 p_a1Hj = p_a1Hj
        getPath_a1Hh n_a1Hk p_a1Hl
          | even n_a1Hk = getPath_a1Hh (n_a1Hk `quot` 2) (0 : p_a1Hl)
        getPath_a1Hh n_a1Oq p_a1Or
          | odd n_a1Oq = getPath_a1Hh (n_a1Oq `quot` 2) (1 : p_a1Or)
        followPath_a1Hi [] (TreeC x_a1Os _ _) = x_a1Os
        followPath_a1Hi (0 : ps_a1Ot) (TreeC x_a1Ou lc_a1Ov _)
          = followPath_a1Hi ps_a1Ot lc_a1Ov
        followPath_a1Hi (1 : ps_a1Ow) (TreeC x_a1Ox _ rc_a1Oy)
          = followPath_a1Hi ps_a1Ow rc_a1Oy

mapTree :: (a_aAD -> b_aAE) -> Tree a_aAD -> Tree b_aAE
mapTree f_a1Oz (TreeC x_a1OA lc_a1OB rc_a1OC)
  = TreeC (f_a1Oz x_a1OA) (mapTree f_a1Oz lc_a1OB)
      (mapTree f_a1Oz rc_a1OC)

int2Real :: Integer -> RealT
int2Real x_a1OD
  = RealC (mapTree (\ n_a1OE -> scale x_a1OD n_a1OE) numberTree)

addReal :: RealT -> RealT -> RealT
addReal x_a1OF y_a1OG
  = RealC
      (mapTree
         (\ n_a1OH ->
            ((evalReal x_a1OF (n_a1OH - 1)) + (evalReal y_a1OG (n_a1OH - 1)) +
               5)
              `quot` 10)
         numberTree)

subReal :: RealT -> RealT -> RealT
subReal x_a1OI y_a1OJ
  = RealC
      (mapTree
         (\ n_a1OK ->
            ((evalReal x_a1OI (n_a1OK - 1)) - (evalReal y_a1OJ (n_a1OK - 1)) +
               5)
              `quot` 10)
         numberTree)

mulReal :: RealT -> RealT -> RealT
mulReal (xr_a1OL@(RealC x_a1OM)) (yr_a1ON@(RealC y_a1OO))
  = RealC
      (mapTree
         (\ n_a1OP ->
            let m_a1OQ
                  = if n_a1OP >= 0 then (n_a1OP + 1) `quot` 2 else
                      (n_a1OP - 1) `quot` 2
                x0_a1OR = evalReal xr_a1OL m_a1OQ
                y0_a1OS = evalReal yr_a1ON m_a1OQ
                mulAux_a1OT x_a1OU y_a1OV
                  = if y1_a1OW == 0 then 0 else
                      scale (x1_a1OX * y1_a1OW)
                        (4 + (msd x_a1OU 0) + (msd y_a1OV 0) - n_a1OP)
                  where y1_a1OW = (evalReal yr_a1ON (n_a1OP - (msd x_a1OU 0) - 2))
                        x1_a1OX = (evalReal xr_a1OL (n_a1OP - (msd y_a1OV 0) - 2))
              in
              if (x0_a1OR == 0) && (y0_a1OS == 0) then 0 else
                if x0_a1OR == 0 then mulAux_a1OT y_a1OO x_a1OM else
                  mulAux_a1OT x_a1OM y_a1OO)
         numberTree)

divReal :: RealT -> RealT -> RealT
divReal x_a1OY y_a1OZ = mulReal x_a1OY (reciprocalReal y_a1OZ)

reciprocalReal :: RealT -> RealT
reciprocalReal xr_a1P0@(RealC x_a1P1)
  = RealC
      (mapTree (\ n_a1P7 -> ((f_a1P3 (dx_a1P2 + n_a1P7)) + 5) `quot` 10)
         numberTree)
  where dx_a1P2 = msd x_a1P1 0
        f_a1P3 m_a1P4
          = if m_a1P4 >= 0 then 0 else
              if m_a1P4 == (-1) then
                10000 `quot` (evalReal xr_a1P0 (dx_a1P2 - 2)) else
                (scale
                   ((fm_a1P6) *
                      ((scale 2 (m_a1P4 + hm_a1P5 - 2)) -
                         (evalReal xr_a1P0 (dx_a1P2 + m_a1P4 - 1))
                         * (fm_a1P6)))
                   (2 - 2 * hm_a1P5))
          where hm_a1P5 = (m_a1P4 - 1) `quot` 2
                fm_a1P6 = f_a1P3 hm_a1P5

sqrReal :: RealT -> RealT
sqrReal (xr_a1P8@(RealC x_a1P9))
  = RealC
      (mapTree
         (\ n_a1Pa ->
            let m_a1Pb
                  = if n_a1Pa >= 0 then (n_a1Pa + 1) `quot` 2 else
                      (n_a1Pa - 1) `quot` 2
                x0_a1Pc = evalReal xr_a1P8 m_a1Pb
                x1_a1Pd = evalReal xr_a1P8 (n_a1Pa - (msd x_a1P9 0) - 2)
              in
              if (x0_a1Pc == 0) then 0 else
                scale (x1_a1Pd * x1_a1Pd) (4 + 2 * (msd x_a1P9 0) - n_a1Pa))
         numberTree)

sqrtReal :: RealT -> RealT
sqrtReal xr_a1Pe@(RealC x_a1Pf)
  = RealC
      (mapTree
         (\ n_a1Pr ->
            if (evalReal xr_a1Pe (2 * n_a1Pr)) == 0 then 0 else
              f_a1Pi n_a1Pr (2 * hdx_a1Ph + 2) xr_a1Pe
                ((-2) * hdx_a1Ph - 2 + n_a1Pr))
         numberTree)
  where dx_a1Pg = msd x_a1Pf 0
        hdx_a1Ph
          = if dx_a1Pg >= 0 then (dx_a1Pg + 1) `quot` 2 else dx_a1Pg `quot` 2
        f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl m_a1Pm
          = if m_a1Pm >= 0 then 0 else
              if m_a1Pm == (-1) then
                scale
                  ((round . sqrt . fromInteger) (evalReal xr_a1Pl (dx_a1Pk - 10)))
                  (5 - hx_a1Pq + n_a1Pj)
                else (fm_a1Po + xv_a1Pp `quot` fm_a1Po) `quot` 2
          where hm_a1Pn = (m_a1Pm - 1) `quot` 2
                fm_a1Po = (f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl hm_a1Pn)
                xv_a1Pp = evalReal xr_a1Pl (n_a1Pj + n_a1Pj)
                hx_a1Pq = dx_a1Pk `quot` 2

data Tree a_aAC = TreeC a_aAC (Tree a_aAC) (Tree a_aAC)

data RealT = RealC (Tree Integer)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.treeFrom :: Integer -> Dum.Tree Integer
Dum.treeFrom n_aAF
  = Dum.TreeC
      n_aAF (Dum.treeFrom (2 * n_aAF - 1)) (Dum.treeFrom (2 * n_aAF - 2))
Dum.numberTree :: Dum.Tree Integer
Dum.numberTree = Dum.treeFrom 0
Dum.scale :: Integer -> Integer -> Integer
Dum.scale x_aBL n_aBM
  | n_aBM <= 0 = (x_aBL * 10 ^ (1 - n_aBM) + 5) `quot` 10
Dum.scale x_a1H6 n_a1H7
  | n_a1H7 > 0 = (x_a1H6 `quot` 10 ^ (n_a1H7 - 1) + 5) `quot` 10
Dum.msd :: Dum.Tree Integer -> Integer -> Integer
Dum.msd x_a1H8 k_a1H9
  = if (xk_a1Ha >= 1) && (xk_a1Ha < 10) then
        k_a1H9
    else
        if (xk_a1Ha == 10) then
            (k_a1H9 + 1)
        else
            if xk_a1Ha >= 1 then
                (Dum.msd x_a1H8 (k_a1H9 + 1))
            else
                (Dum.msd x_a1H8 (k_a1H9 - 1))
  where
      xk_a1Ha = abs (Dum.evalReal (Dum.RealC x_a1H8) k_a1H9)
Dum.evalReal :: Dum.RealT -> Integer -> Integer
Dum.evalReal (Dum.RealC tree_a1Hb) tol_a1Hc
  | tol_a1Hc <= 0 = Dum.lookupTree tree_a1Hb tol_a1Hc
Dum.evalReal (Dum.RealC tree_a1Hd) tol_a1He
  | tol_a1He > 0 = Dum.scale (Dum.lookupTree tree_a1Hd 0) tol_a1He
Dum.lookupTree :: Dum.Tree Integer -> Integer -> Integer
Dum.lookupTree tree_a1Hf n_a1Hg
  = followPath_a1Hi (getPath_a1Hh (1 - n_a1Hg) []) tree_a1Hf
  where
      getPath_a1Hh 1 p_a1Hj = p_a1Hj
      getPath_a1Hh n_a1Hk p_a1Hl
        | even n_a1Hk = getPath_a1Hh (n_a1Hk `quot` 2) (0 : p_a1Hl)
      getPath_a1Hh n_a1Oq p_a1Or
        | odd n_a1Oq = getPath_a1Hh (n_a1Oq `quot` 2) (1 : p_a1Or)
      followPath_a1Hi [] (Dum.TreeC x_a1Os _ _) = x_a1Os
      followPath_a1Hi (0 : ps_a1Ot) (Dum.TreeC x_a1Ou lc_a1Ov _)
        = followPath_a1Hi ps_a1Ot lc_a1Ov
      followPath_a1Hi (1 : ps_a1Ow) (Dum.TreeC x_a1Ox _ rc_a1Oy)
        = followPath_a1Hi ps_a1Ow rc_a1Oy
Dum.mapTree :: (a_aAD -> b_aAE) -> Dum.Tree a_aAD -> Dum.Tree b_aAE
Dum.mapTree f_a1Oz (Dum.TreeC x_a1OA lc_a1OB rc_a1OC)
  = Dum.TreeC
      (f_a1Oz x_a1OA)
      (Dum.mapTree f_a1Oz lc_a1OB)
      (Dum.mapTree f_a1Oz rc_a1OC)
Dum.int2Real :: Integer -> Dum.RealT
Dum.int2Real x_a1OD
  = Dum.RealC
      (Dum.mapTree (\ n_a1OE -> Dum.scale x_a1OD n_a1OE) Dum.numberTree)
Dum.addReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.addReal x_a1OF y_a1OG
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OH
            -> ((Dum.evalReal x_a1OF (n_a1OH - 1))
                + (Dum.evalReal y_a1OG (n_a1OH - 1))
                + 5)
               `quot` 10)
         Dum.numberTree)
Dum.subReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.subReal x_a1OI y_a1OJ
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OK
            -> ((Dum.evalReal x_a1OI (n_a1OK - 1))
                - (Dum.evalReal y_a1OJ (n_a1OK - 1))
                + 5)
               `quot` 10)
         Dum.numberTree)
Dum.mulReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.mulReal
  (xr_a1OL@(Dum.RealC x_a1OM))
  (yr_a1ON@(Dum.RealC y_a1OO))
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1OP
            -> let
                 m_a1OQ
                   = if n_a1OP >= 0 then
                         (n_a1OP + 1) `quot` 2
                     else
                         (n_a1OP - 1) `quot` 2
                 x0_a1OR = Dum.evalReal xr_a1OL m_a1OQ
                 y0_a1OS = Dum.evalReal yr_a1ON m_a1OQ
                 mulAux_a1OT x_a1OU y_a1OV
                   = if y1_a1OW == 0 then
                         0
                     else
                         Dum.scale
                           (x1_a1OX * y1_a1OW)
                           (4 + (Dum.msd x_a1OU 0) + (Dum.msd y_a1OV 0) - n_a1OP)
                   where
                       y1_a1OW = (Dum.evalReal yr_a1ON (n_a1OP - (Dum.msd x_a1OU 0) - 2))
                       x1_a1OX = (Dum.evalReal xr_a1OL (n_a1OP - (Dum.msd y_a1OV 0) - 2))
               in
                 if (x0_a1OR == 0) && (y0_a1OS == 0) then
                     0
                 else
                     if x0_a1OR == 0 then
                         mulAux_a1OT y_a1OO x_a1OM
                     else
                         mulAux_a1OT x_a1OM y_a1OO)
         Dum.numberTree)
Dum.divReal :: Dum.RealT -> Dum.RealT -> Dum.RealT
Dum.divReal x_a1OY y_a1OZ
  = Dum.mulReal x_a1OY (Dum.reciprocalReal y_a1OZ)
Dum.reciprocalReal :: Dum.RealT -> Dum.RealT
Dum.reciprocalReal xr_a1P0@(Dum.RealC x_a1P1)
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1P7 -> ((f_a1P3 (dx_a1P2 + n_a1P7)) + 5) `quot` 10)
         Dum.numberTree)
  where
      dx_a1P2 = Dum.msd x_a1P1 0
      f_a1P3 m_a1P4
        = if m_a1P4 >= 0 then
              0
          else
              if m_a1P4 == (- 1) then
                  10000 `quot` (Dum.evalReal xr_a1P0 (dx_a1P2 - 2))
              else
                  (Dum.scale
                     ((fm_a1P6)
                      * ((Dum.scale 2 (m_a1P4 + hm_a1P5 - 2))
                         - (Dum.evalReal xr_a1P0 (dx_a1P2 + m_a1P4 - 1)) * (fm_a1P6)))
                     (2 - 2 * hm_a1P5))
        where
            hm_a1P5 = (m_a1P4 - 1) `quot` 2
            fm_a1P6 = f_a1P3 hm_a1P5
Dum.sqrReal :: Dum.RealT -> Dum.RealT
Dum.sqrReal (xr_a1P8@(Dum.RealC x_a1P9))
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1Pa
            -> let
                 m_a1Pb
                   = if n_a1Pa >= 0 then
                         (n_a1Pa + 1) `quot` 2
                     else
                         (n_a1Pa - 1) `quot` 2
                 x0_a1Pc = Dum.evalReal xr_a1P8 m_a1Pb
                 x1_a1Pd = Dum.evalReal xr_a1P8 (n_a1Pa - (Dum.msd x_a1P9 0) - 2)
               in
                 if (x0_a1Pc == 0) then
                     0
                 else
                     Dum.scale
                       (x1_a1Pd * x1_a1Pd) (4 + 2 * (Dum.msd x_a1P9 0) - n_a1Pa))
         Dum.numberTree)
Dum.sqrtReal :: Dum.RealT -> Dum.RealT
Dum.sqrtReal xr_a1Pe@(Dum.RealC x_a1Pf)
  = Dum.RealC
      (Dum.mapTree
         (\ n_a1Pr
            -> if (Dum.evalReal xr_a1Pe (2 * n_a1Pr)) == 0 then
                   0
               else
                   f_a1Pi
                     n_a1Pr (2 * hdx_a1Ph + 2) xr_a1Pe ((- 2) * hdx_a1Ph - 2 + n_a1Pr))
         Dum.numberTree)
  where
      dx_a1Pg = Dum.msd x_a1Pf 0
      hdx_a1Ph
        = if dx_a1Pg >= 0 then (dx_a1Pg + 1) `quot` 2 else dx_a1Pg `quot` 2
      f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl m_a1Pm
        = if m_a1Pm >= 0 then
              0
          else
              if m_a1Pm == (- 1) then
                  Dum.scale
                    ((round . sqrt . fromInteger)
                       (Dum.evalReal xr_a1Pl (dx_a1Pk - 10)))
                    (5 - hx_a1Pq + n_a1Pj)
              else
                  (fm_a1Po + xv_a1Pp `quot` fm_a1Po) `quot` 2
        where
            hm_a1Pn = (m_a1Pm - 1) `quot` 2
            fm_a1Po = (f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl hm_a1Pn)
            xv_a1Pp = Dum.evalReal xr_a1Pl (n_a1Pj + n_a1Pj)
            hx_a1Pq = dx_a1Pk `quot` 2

data Dum.Tree a_aAC
  = Dum.TreeC a_aAC (Dum.Tree a_aAC) (Dum.Tree a_aAC)
data Dum.RealT = Dum.RealC (Dum.Tree Integer)


["n_aAF","numberTree","x_aBL","n_aBM","x_a1H6","n_a1H7","x_a1H8","k_a1H9","xk_a1Ha","tree_a1Hb","RealC tree_a1Hb","(RealC tree_a1Hb)","tol_a1Hc","tree_a1Hd","RealC tree_a1Hd","(RealC tree_a1Hd)","tol_a1He","tree_a1Hf","n_a1Hg","1","p_a1Hj","n_a1Hk","p_a1Hl","n_a1Oq","p_a1Or","[]","x_a1Os","_","_","TreeC x_a1Os _ _","(TreeC x_a1Os _ _)","0","ps_a1Ot","0 : ps_a1Ot","(0 : ps_a1Ot)","x_a1Ou","lc_a1Ov","_","TreeC x_a1Ou lc_a1Ov _","(TreeC x_a1Ou lc_a1Ov _)","1","ps_a1Ow","1 : ps_a1Ow","(1 : ps_a1Ow)","x_a1Ox","_","rc_a1Oy","TreeC x_a1Ox _ rc_a1Oy","(TreeC x_a1Ox _ rc_a1Oy)","f_a1Oz","x_a1OA","lc_a1OB","rc_a1OC","TreeC x_a1OA lc_a1OB rc_a1OC","(TreeC x_a1OA lc_a1OB rc_a1OC)","x_a1OD","n_a1OE","x_a1OF","y_a1OG","n_a1OH","x_a1OI","y_a1OJ","n_a1OK","x_a1OM","RealC x_a1OM","(RealC x_a1OM)","xr_a1OL@(RealC x_a1OM)","(xr_a1OL@(RealC x_a1OM))","y_a1OO","RealC y_a1OO","(RealC y_a1OO)","yr_a1ON@(RealC y_a1OO)","(yr_a1ON@(RealC y_a1OO))","n_a1OP","m_a1OQ","x0_a1OR","y0_a1OS","x_a1OU","y_a1OV","y1_a1OW","x1_a1OX","x_a1OY","y_a1OZ","x_a1P1","RealC x_a1P1","(RealC x_a1P1)","xr_a1P0@(RealC x_a1P1)","n_a1P7","dx_a1P2","m_a1P4","hm_a1P5","fm_a1P6","x_a1P9","RealC x_a1P9","(RealC x_a1P9)","xr_a1P8@(RealC x_a1P9)","(xr_a1P8@(RealC x_a1P9))","n_a1Pa","m_a1Pb","x0_a1Pc","x1_a1Pd","x_a1Pf","RealC x_a1Pf","(RealC x_a1Pf)","xr_a1Pe@(RealC x_a1Pf)","n_a1Pr","dx_a1Pg","hdx_a1Ph","n_a1Pj","dx_a1Pk","xr_a1Pl","m_a1Pm","hm_a1Pn","fm_a1Po","xv_a1Pp","hx_a1Pq"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BasicNumber
import BasicNumberApprox
import Ast
import Op
import Parser
import Env
import Eval
import Data.Ratio

treeFrom :: Integer -> Tree Integer
treeFrom n_aAF
  = TreeC n_aAF (treeFrom (2 * n_aAF - 1)) (treeFrom (2 * n_aAF - 2))

numberTree :: Tree Integer
numberTree = treeFrom 0

scale :: Integer -> Integer -> Integer
scale x_aBL n_aBM
  | n_aBM <= 0 = (x_aBL * 10 ^ (1 - n_aBM) + 5) `quot` 10
scale x_a1H6 n_a1H7
  | n_a1H7 > 0 = (x_a1H6 `quot` 10 ^ (n_a1H7 - 1) + 5) `quot` 10

msd :: Tree Integer -> Integer -> Integer
msd x_a1H8 k_a1H9
  = if (xk_a1Ha >= 1) && (xk_a1Ha < 10) then k_a1H9 else
      if (xk_a1Ha == 10) then (k_a1H9 + 1) else
        if xk_a1Ha >= 1 then (msd x_a1H8 (k_a1H9 + 1)) else
          (msd x_a1H8 (k_a1H9 - 1))
  where xk_a1Ha = abs (evalReal (RealC x_a1H8) k_a1H9)

evalReal :: RealT -> Integer -> Integer
evalReal (RealC tree_a1Hb) tol_a1Hc
  | tol_a1Hc <= 0 = lookupTree tree_a1Hb tol_a1Hc
evalReal (RealC tree_a1Hd) tol_a1He
  | tol_a1He > 0 = scale (lookupTree tree_a1Hd 0) tol_a1He

lookupTree :: Tree Integer -> Integer -> Integer
lookupTree tree_a1Hf n_a1Hg
  = followPath_a1Hi (getPath_a1Hh (1 - n_a1Hg) []) tree_a1Hf
  where getPath_a1Hh 1 p_a1Hj = p_a1Hj
        getPath_a1Hh n_a1Hk p_a1Hl
          | even n_a1Hk = getPath_a1Hh (n_a1Hk `quot` 2) (0 : p_a1Hl)
        getPath_a1Hh n_a1Oq p_a1Or
          | odd n_a1Oq = getPath_a1Hh (n_a1Oq `quot` 2) (1 : p_a1Or)
        followPath_a1Hi [] (TreeC x_a1Os _ _) = x_a1Os
        followPath_a1Hi (0 : ps_a1Ot) (TreeC x_a1Ou lc_a1Ov _)
          = followPath_a1Hi ps_a1Ot lc_a1Ov
        followPath_a1Hi (1 : ps_a1Ow) (TreeC x_a1Ox _ rc_a1Oy)
          = followPath_a1Hi ps_a1Ow rc_a1Oy

mapTree :: (a_aAD -> b_aAE) -> Tree a_aAD -> Tree b_aAE
mapTree f_a1Oz (TreeC x_a1OA lc_a1OB rc_a1OC)
  = TreeC (f_a1Oz x_a1OA) (mapTree f_a1Oz lc_a1OB)
      (mapTree f_a1Oz rc_a1OC)

int2Real :: Integer -> RealT
int2Real x_a1OD
  = RealC (mapTree (\ n_a1OE -> scale x_a1OD n_a1OE) numberTree)

addReal :: RealT -> RealT -> RealT
addReal x_a1OF y_a1OG
  = RealC
      (mapTree
         (\ n_a1OH ->
            ((evalReal x_a1OF (n_a1OH - 1)) + (evalReal y_a1OG (n_a1OH - 1)) +
               5)
              `quot` 10)
         numberTree)

subReal :: RealT -> RealT -> RealT
subReal x_a1OI y_a1OJ
  = RealC
      (mapTree
         (\ n_a1OK ->
            ((evalReal x_a1OI (n_a1OK - 1)) - (evalReal y_a1OJ (n_a1OK - 1)) +
               5)
              `quot` 10)
         numberTree)

mulReal :: RealT -> RealT -> RealT
mulReal (xr_a1OL@(RealC x_a1OM)) (yr_a1ON@(RealC y_a1OO))
  = RealC
      (mapTree
         (\ n_a1OP ->
            let m_a1OQ
                  = if n_a1OP >= 0 then (n_a1OP + 1) `quot` 2 else
                      (n_a1OP - 1) `quot` 2
                x0_a1OR = evalReal xr_a1OL m_a1OQ
                y0_a1OS = evalReal yr_a1ON m_a1OQ
                mulAux_a1OT x_a1OU y_a1OV
                  = if y1_a1OW == 0 then 0 else
                      scale (x1_a1OX * y1_a1OW)
                        (4 + (msd x_a1OU 0) + (msd y_a1OV 0) - n_a1OP)
                  where y1_a1OW = (evalReal yr_a1ON (n_a1OP - (msd x_a1OU 0) - 2))
                        x1_a1OX = (evalReal xr_a1OL (n_a1OP - (msd y_a1OV 0) - 2))
              in
              if (x0_a1OR == 0) && (y0_a1OS == 0) then 0 else
                if x0_a1OR == 0 then mulAux_a1OT y_a1OO x_a1OM else
                  mulAux_a1OT x_a1OM y_a1OO)
         numberTree)

divReal :: RealT -> RealT -> RealT
divReal x_a1OY y_a1OZ = mulReal x_a1OY (reciprocalReal y_a1OZ)

reciprocalReal :: RealT -> RealT
reciprocalReal xr_a1P0@(RealC x_a1P1)
  = RealC
      (mapTree (\ n_a1P7 -> ((f_a1P3 (dx_a1P2 + n_a1P7)) + 5) `quot` 10)
         numberTree)
  where dx_a1P2 = msd x_a1P1 0
        f_a1P3 m_a1P4
          = if m_a1P4 >= 0 then 0 else
              if m_a1P4 == (-1) then
                10000 `quot` (evalReal xr_a1P0 (dx_a1P2 - 2)) else
                (scale
                   ((fm_a1P6) *
                      ((scale 2 (m_a1P4 + hm_a1P5 - 2)) -
                         (evalReal xr_a1P0 (dx_a1P2 + m_a1P4 - 1))
                         * (fm_a1P6)))
                   (2 - 2 * hm_a1P5))
          where hm_a1P5 = (m_a1P4 - 1) `quot` 2
                fm_a1P6 = f_a1P3 hm_a1P5

sqrReal :: RealT -> RealT
sqrReal (xr_a1P8@(RealC x_a1P9))
  = RealC
      (mapTree
         (\ n_a1Pa ->
            let m_a1Pb
                  = if n_a1Pa >= 0 then (n_a1Pa + 1) `quot` 2 else
                      (n_a1Pa - 1) `quot` 2
                x0_a1Pc = evalReal xr_a1P8 m_a1Pb
                x1_a1Pd = evalReal xr_a1P8 (n_a1Pa - (msd x_a1P9 0) - 2)
              in
              if (x0_a1Pc == 0) then 0 else
                scale (x1_a1Pd * x1_a1Pd) (4 + 2 * (msd x_a1P9 0) - n_a1Pa))
         numberTree)

sqrtReal :: RealT -> RealT
sqrtReal xr_a1Pe@(RealC x_a1Pf)
  = RealC
      (mapTree
         (\ n_a1Pr ->
            if (evalReal xr_a1Pe (2 * n_a1Pr)) == 0 then 0 else
              f_a1Pi n_a1Pr (2 * hdx_a1Ph + 2) xr_a1Pe
                ((-2) * hdx_a1Ph - 2 + n_a1Pr))
         numberTree)
  where dx_a1Pg = msd x_a1Pf 0
        hdx_a1Ph
          = if dx_a1Pg >= 0 then (dx_a1Pg + 1) `quot` 2 else dx_a1Pg `quot` 2
        f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl m_a1Pm
          = if m_a1Pm >= 0 then 0 else
              if m_a1Pm == (-1) then
                scale
                  ((round . sqrt . fromInteger) (evalReal xr_a1Pl (dx_a1Pk - 10)))
                  (5 - hx_a1Pq + n_a1Pj)
                else (fm_a1Po + xv_a1Pp `quot` fm_a1Po) `quot` 2
          where hm_a1Pn = (m_a1Pm - 1) `quot` 2
                fm_a1Po = (f_a1Pi n_a1Pj dx_a1Pk xr_a1Pl hm_a1Pn)
                xv_a1Pp = evalReal xr_a1Pl (n_a1Pj + n_a1Pj)
                hx_a1Pq = dx_a1Pk `quot` 2

data Tree a_aAC = TreeC a_aAC (Tree a_aAC) (Tree a_aAC)

data RealT = RealC (Tree Integer)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.opPrec1 :: String -> Int
Dum.opPrec1 "-" = 1
Dum.opPrec1 _ = 0
Dum.opPrec :: String -> Int
Dum.opPrec "==" = 5
Dum.opPrec ">=" = 5
Dum.opPrec "<=" = 5
Dum.opPrec "/=" = 5
Dum.opPrec ">" = 5
Dum.opPrec "<" = 5
Dum.opPrec "+" = 4
Dum.opPrec "-" = 4
Dum.opPrec "*" = 3
Dum.opPrec "/" = 3
Dum.opPrec "^" = 2
Dum.opPrec _ = 0
Dum.opName1 :: String -> String
Dum.opName1 "-" = "neg"
Dum.opName1 _ = ""
Dum.opName :: String -> String
Dum.opName "==" = "equ"
Dum.opName ">=" = "gte"
Dum.opName "<=" = "lte"
Dum.opName "/=" = "ne"
Dum.opName ">" = "gt"
Dum.opName "<" = "lt"
Dum.opName "+" = "add"
Dum.opName "-" = "sub"
Dum.opName "*" = "mul"
Dum.opName "/" = "div"
Dum.opName "^" = "pow"
Dum.opName _ = ""
Dum.opAssoc :: String -> String
Dum.opAssoc "==" = "non"
Dum.opAssoc ">=" = "non"
Dum.opAssoc "<=" = "non"
Dum.opAssoc "/=" = "non"
Dum.opAssoc ">" = "non"
Dum.opAssoc "<" = "non"
Dum.opAssoc "+" = "left"
Dum.opAssoc "-" = "left"
Dum.opAssoc "*" = "left"
Dum.opAssoc "/" = "left"
Dum.opAssoc "^" = "right"
Dum.opAssoc _ = "non"
Dum.toOp :: String -> String
Dum.toOp "add" = "+"
Dum.toOp "sub" = "-"
Dum.toOp "mul" = "*"
Dum.toOp "div" = "/"
Dum.toOp "pow" = "^"
Dum.toOp "equ" = "=="
Dum.toOp "lt" = "<"
Dum.toOp "gt" = ">"
Dum.toOp "lte" = "<="
Dum.toOp "gte" = ">="
Dum.toOp "ne" = "/="
Dum.toOp _ = ""
Dum.toOp1 :: String -> String
Dum.toOp1 "neg" = "-"
Dum.toOp1 _ = ""


["\"-\"","_","\"==\"","\">=\"","\"<=\"","\"/=\"","\">\"","\"<\"","\"+\"","\"-\"","\"*\"","\"/\"","\"^\"","_","\"-\"","_","\"==\"","\">=\"","\"<=\"","\"/=\"","\">\"","\"<\"","\"+\"","\"-\"","\"*\"","\"/\"","\"^\"","_","\"==\"","\">=\"","\"<=\"","\"/=\"","\">\"","\"<\"","\"+\"","\"-\"","\"*\"","\"/\"","\"^\"","_","\"add\"","\"sub\"","\"mul\"","\"div\"","\"pow\"","\"equ\"","\"lt\"","\"gt\"","\"lte\"","\"gte\"","\"ne\"","_","\"neg\"","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where

opPrec1 :: String -> Int
opPrec1 "-" = 1
opPrec1 _ = 0

opPrec :: String -> Int
opPrec "==" = 5
opPrec ">=" = 5
opPrec "<=" = 5
opPrec "/=" = 5
opPrec ">" = 5
opPrec "<" = 5
opPrec "+" = 4
opPrec "-" = 4
opPrec "*" = 3
opPrec "/" = 3
opPrec "^" = 2
opPrec _ = 0

opName1 :: String -> String
opName1 "-" = "neg"
opName1 _ = ""

opName :: String -> String
opName "==" = "equ"
opName ">=" = "gte"
opName "<=" = "lte"
opName "/=" = "ne"
opName ">" = "gt"
opName "<" = "lt"
opName "+" = "add"
opName "-" = "sub"
opName "*" = "mul"
opName "/" = "div"
opName "^" = "pow"
opName _ = ""

opAssoc :: String -> String
opAssoc "==" = "non"
opAssoc ">=" = "non"
opAssoc "<=" = "non"
opAssoc "/=" = "non"
opAssoc ">" = "non"
opAssoc "<" = "non"
opAssoc "+" = "left"
opAssoc "-" = "left"
opAssoc "*" = "left"
opAssoc "/" = "left"
opAssoc "^" = "right"
opAssoc _ = "non"

toOp :: String -> String
toOp "add" = "+"
toOp "sub" = "-"
toOp "mul" = "*"
toOp "div" = "/"
toOp "pow" = "^"
toOp "equ" = "=="
toOp "lt" = "<"
toOp "gt" = ">"
toOp "lte" = "<="
toOp "gte" = ">="
toOp "ne" = "/="
toOp _ = ""

toOp1 :: String -> String
toOp1 "neg" = "-"
toOp1 _ = ""
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.opPrec1 :: String -> Int
Dum.opPrec1 "-" = 1
Dum.opPrec1 _ = 0
Dum.opPrec :: String -> Int
Dum.opPrec "==" = 5
Dum.opPrec ">=" = 5
Dum.opPrec "<=" = 5
Dum.opPrec "/=" = 5
Dum.opPrec ">" = 5
Dum.opPrec "<" = 5
Dum.opPrec "+" = 4
Dum.opPrec "-" = 4
Dum.opPrec "*" = 3
Dum.opPrec "/" = 3
Dum.opPrec "^" = 2
Dum.opPrec _ = 0
Dum.opName1 :: String -> String
Dum.opName1 "-" = "neg"
Dum.opName1 _ = ""
Dum.opName :: String -> String
Dum.opName "==" = "equ"
Dum.opName ">=" = "gte"
Dum.opName "<=" = "lte"
Dum.opName "/=" = "ne"
Dum.opName ">" = "gt"
Dum.opName "<" = "lt"
Dum.opName "+" = "add"
Dum.opName "-" = "sub"
Dum.opName "*" = "mul"
Dum.opName "/" = "div"
Dum.opName "^" = "pow"
Dum.opName _ = ""
Dum.opAssoc :: String -> String
Dum.opAssoc "==" = "non"
Dum.opAssoc ">=" = "non"
Dum.opAssoc "<=" = "non"
Dum.opAssoc "/=" = "non"
Dum.opAssoc ">" = "non"
Dum.opAssoc "<" = "non"
Dum.opAssoc "+" = "left"
Dum.opAssoc "-" = "left"
Dum.opAssoc "*" = "left"
Dum.opAssoc "/" = "left"
Dum.opAssoc "^" = "right"
Dum.opAssoc _ = "non"
Dum.toOp :: String -> String
Dum.toOp "add" = "+"
Dum.toOp "sub" = "-"
Dum.toOp "mul" = "*"
Dum.toOp "div" = "/"
Dum.toOp "pow" = "^"
Dum.toOp "equ" = "=="
Dum.toOp "lt" = "<"
Dum.toOp "gt" = ">"
Dum.toOp "lte" = "<="
Dum.toOp "gte" = ">="
Dum.toOp "ne" = "/="
Dum.toOp _ = ""
Dum.toOp1 :: String -> String
Dum.toOp1 "neg" = "-"
Dum.toOp1 _ = ""


["\"-\"","_","\"==\"","\">=\"","\"<=\"","\"/=\"","\">\"","\"<\"","\"+\"","\"-\"","\"*\"","\"/\"","\"^\"","_","\"-\"","_","\"==\"","\">=\"","\"<=\"","\"/=\"","\">\"","\"<\"","\"+\"","\"-\"","\"*\"","\"/\"","\"^\"","_","\"==\"","\">=\"","\"<=\"","\"/=\"","\">\"","\"<\"","\"+\"","\"-\"","\"*\"","\"/\"","\"^\"","_","\"add\"","\"sub\"","\"mul\"","\"div\"","\"pow\"","\"equ\"","\"lt\"","\"gt\"","\"lte\"","\"gte\"","\"ne\"","_","\"neg\"","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import BasicNumber
import BasicNumberApprox
import Ast
import Env

opPrec1 :: String -> Int
opPrec1 "-" = 1
opPrec1 _ = 0

opPrec :: String -> Int
opPrec "==" = 5
opPrec ">=" = 5
opPrec "<=" = 5
opPrec "/=" = 5
opPrec ">" = 5
opPrec "<" = 5
opPrec "+" = 4
opPrec "-" = 4
opPrec "*" = 3
opPrec "/" = 3
opPrec "^" = 2
opPrec _ = 0

opName1 :: String -> String
opName1 "-" = "neg"
opName1 _ = ""

opName :: String -> String
opName "==" = "equ"
opName ">=" = "gte"
opName "<=" = "lte"
opName "/=" = "ne"
opName ">" = "gt"
opName "<" = "lt"
opName "+" = "add"
opName "-" = "sub"
opName "*" = "mul"
opName "/" = "div"
opName "^" = "pow"
opName _ = ""

opAssoc :: String -> String
opAssoc "==" = "non"
opAssoc ">=" = "non"
opAssoc "<=" = "non"
opAssoc "/=" = "non"
opAssoc ">" = "non"
opAssoc "<" = "non"
opAssoc "+" = "left"
opAssoc "-" = "left"
opAssoc "*" = "left"
opAssoc "/" = "left"
opAssoc "^" = "right"
opAssoc _ = "non"

toOp :: String -> String
toOp "add" = "+"
toOp "sub" = "-"
toOp "mul" = "*"
toOp "div" = "/"
toOp "pow" = "^"
toOp "equ" = "=="
toOp "lt" = "<"
toOp "gt" = ">"
toOp "lte" = "<="
toOp "gte" = ">="
toOp "ne" = "/="
toOp _ = ""

toOp1 :: String -> String
toOp1 "neg" = "-"
toOp1 _ = ""
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.opPrec1 :: String -> Int
Dum.opPrec1 "-" = 1
Dum.opPrec1 _ = 0
Dum.opPrec :: String -> Int
Dum.opPrec "==" = 5
Dum.opPrec ">=" = 5
Dum.opPrec "<=" = 5
Dum.opPrec "/=" = 5
Dum.opPrec ">" = 5
Dum.opPrec "<" = 5
Dum.opPrec "+" = 4
Dum.opPrec "-" = 4
Dum.opPrec "*" = 3
Dum.opPrec "/" = 3
Dum.opPrec "^" = 2
Dum.opPrec _ = 0
Dum.opName1 :: String -> String
Dum.opName1 "-" = "neg"
Dum.opName1 _ = ""
Dum.opName :: String -> String
Dum.opName "==" = "equ"
Dum.opName ">=" = "gte"
Dum.opName "<=" = "lte"
Dum.opName "/=" = "ne"
Dum.opName ">" = "gt"
Dum.opName "<" = "lt"
Dum.opName "+" = "add"
Dum.opName "-" = "sub"
Dum.opName "*" = "mul"
Dum.opName "/" = "div"
Dum.opName "^" = "pow"
Dum.opName _ = ""
Dum.opAssoc :: String -> String
Dum.opAssoc "==" = "non"
Dum.opAssoc ">=" = "non"
Dum.opAssoc "<=" = "non"
Dum.opAssoc "/=" = "non"
Dum.opAssoc ">" = "non"
Dum.opAssoc "<" = "non"
Dum.opAssoc "+" = "left"
Dum.opAssoc "-" = "left"
Dum.opAssoc "*" = "left"
Dum.opAssoc "/" = "left"
Dum.opAssoc "^" = "right"
Dum.opAssoc _ = "non"
Dum.toOp :: String -> String
Dum.toOp "add" = "+"
Dum.toOp "sub" = "-"
Dum.toOp "mul" = "*"
Dum.toOp "div" = "/"
Dum.toOp "pow" = "^"
Dum.toOp "equ" = "=="
Dum.toOp "lt" = "<"
Dum.toOp "gt" = ">"
Dum.toOp "lte" = "<="
Dum.toOp "gte" = ">="
Dum.toOp "ne" = "/="
Dum.toOp _ = ""
Dum.toOp1 :: String -> String
Dum.toOp1 "neg" = "-"
Dum.toOp1 _ = ""


["\"-\"","_","\"==\"","\">=\"","\"<=\"","\"/=\"","\">\"","\"<\"","\"+\"","\"-\"","\"*\"","\"/\"","\"^\"","_","\"-\"","_","\"==\"","\">=\"","\"<=\"","\"/=\"","\">\"","\"<\"","\"+\"","\"-\"","\"*\"","\"/\"","\"^\"","_","\"==\"","\">=\"","\"<=\"","\"/=\"","\">\"","\"<\"","\"+\"","\"-\"","\"*\"","\"/\"","\"^\"","_","\"add\"","\"sub\"","\"mul\"","\"div\"","\"pow\"","\"equ\"","\"lt\"","\"gt\"","\"lte\"","\"gte\"","\"ne\"","_","\"neg\"","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Ast
import BasicNumber

opPrec1 :: String -> Int
opPrec1 "-" = 1
opPrec1 _ = 0

opPrec :: String -> Int
opPrec "==" = 5
opPrec ">=" = 5
opPrec "<=" = 5
opPrec "/=" = 5
opPrec ">" = 5
opPrec "<" = 5
opPrec "+" = 4
opPrec "-" = 4
opPrec "*" = 3
opPrec "/" = 3
opPrec "^" = 2
opPrec _ = 0

opName1 :: String -> String
opName1 "-" = "neg"
opName1 _ = ""

opName :: String -> String
opName "==" = "equ"
opName ">=" = "gte"
opName "<=" = "lte"
opName "/=" = "ne"
opName ">" = "gt"
opName "<" = "lt"
opName "+" = "add"
opName "-" = "sub"
opName "*" = "mul"
opName "/" = "div"
opName "^" = "pow"
opName _ = ""

opAssoc :: String -> String
opAssoc "==" = "non"
opAssoc ">=" = "non"
opAssoc "<=" = "non"
opAssoc "/=" = "non"
opAssoc ">" = "non"
opAssoc "<" = "non"
opAssoc "+" = "left"
opAssoc "-" = "left"
opAssoc "*" = "left"
opAssoc "/" = "left"
opAssoc "^" = "right"
opAssoc _ = "non"

toOp :: String -> String
toOp "add" = "+"
toOp "sub" = "-"
toOp "mul" = "*"
toOp "div" = "/"
toOp "pow" = "^"
toOp "equ" = "=="
toOp "lt" = "<"
toOp "gt" = ">"
toOp "lte" = "<="
toOp "gte" = ">="
toOp "ne" = "/="
toOp _ = ""

toOp1 :: String -> String
toOp1 "neg" = "-"
toOp1 _ = ""
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.opPrec1 :: String -> Int
Dum.opPrec1 "-" = 1
Dum.opPrec1 _ = 0
Dum.opPrec :: String -> Int
Dum.opPrec "==" = 5
Dum.opPrec ">=" = 5
Dum.opPrec "<=" = 5
Dum.opPrec "/=" = 5
Dum.opPrec ">" = 5
Dum.opPrec "<" = 5
Dum.opPrec "+" = 4
Dum.opPrec "-" = 4
Dum.opPrec "*" = 3
Dum.opPrec "/" = 3
Dum.opPrec "^" = 2
Dum.opPrec _ = 0
Dum.opName1 :: String -> String
Dum.opName1 "-" = "neg"
Dum.opName1 _ = ""
Dum.opName :: String -> String
Dum.opName "==" = "equ"
Dum.opName ">=" = "gte"
Dum.opName "<=" = "lte"
Dum.opName "/=" = "ne"
Dum.opName ">" = "gt"
Dum.opName "<" = "lt"
Dum.opName "+" = "add"
Dum.opName "-" = "sub"
Dum.opName "*" = "mul"
Dum.opName "/" = "div"
Dum.opName "^" = "pow"
Dum.opName _ = ""
Dum.opAssoc :: String -> String
Dum.opAssoc "==" = "non"
Dum.opAssoc ">=" = "non"
Dum.opAssoc "<=" = "non"
Dum.opAssoc "/=" = "non"
Dum.opAssoc ">" = "non"
Dum.opAssoc "<" = "non"
Dum.opAssoc "+" = "left"
Dum.opAssoc "-" = "left"
Dum.opAssoc "*" = "left"
Dum.opAssoc "/" = "left"
Dum.opAssoc "^" = "right"
Dum.opAssoc _ = "non"
Dum.toOp :: String -> String
Dum.toOp "add" = "+"
Dum.toOp "sub" = "-"
Dum.toOp "mul" = "*"
Dum.toOp "div" = "/"
Dum.toOp "pow" = "^"
Dum.toOp "equ" = "=="
Dum.toOp "lt" = "<"
Dum.toOp "gt" = ">"
Dum.toOp "lte" = "<="
Dum.toOp "gte" = ">="
Dum.toOp "ne" = "/="
Dum.toOp _ = ""
Dum.toOp1 :: String -> String
Dum.toOp1 "neg" = "-"
Dum.toOp1 _ = ""


["\"-\"","_","\"==\"","\">=\"","\"<=\"","\"/=\"","\">\"","\"<\"","\"+\"","\"-\"","\"*\"","\"/\"","\"^\"","_","\"-\"","_","\"==\"","\">=\"","\"<=\"","\"/=\"","\">\"","\"<\"","\"+\"","\"-\"","\"*\"","\"/\"","\"^\"","_","\"==\"","\">=\"","\"<=\"","\"/=\"","\">\"","\"<\"","\"+\"","\"-\"","\"*\"","\"/\"","\"^\"","_","\"add\"","\"sub\"","\"mul\"","\"div\"","\"pow\"","\"equ\"","\"lt\"","\"gt\"","\"lte\"","\"gte\"","\"ne\"","_","\"neg\"","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Ast
import BasicNumber
import Lexer
import Op

opPrec1 :: String -> Int
opPrec1 "-" = 1
opPrec1 _ = 0

opPrec :: String -> Int
opPrec "==" = 5
opPrec ">=" = 5
opPrec "<=" = 5
opPrec "/=" = 5
opPrec ">" = 5
opPrec "<" = 5
opPrec "+" = 4
opPrec "-" = 4
opPrec "*" = 3
opPrec "/" = 3
opPrec "^" = 2
opPrec _ = 0

opName1 :: String -> String
opName1 "-" = "neg"
opName1 _ = ""

opName :: String -> String
opName "==" = "equ"
opName ">=" = "gte"
opName "<=" = "lte"
opName "/=" = "ne"
opName ">" = "gt"
opName "<" = "lt"
opName "+" = "add"
opName "-" = "sub"
opName "*" = "mul"
opName "/" = "div"
opName "^" = "pow"
opName _ = ""

opAssoc :: String -> String
opAssoc "==" = "non"
opAssoc ">=" = "non"
opAssoc "<=" = "non"
opAssoc "/=" = "non"
opAssoc ">" = "non"
opAssoc "<" = "non"
opAssoc "+" = "left"
opAssoc "-" = "left"
opAssoc "*" = "left"
opAssoc "/" = "left"
opAssoc "^" = "right"
opAssoc _ = "non"

toOp :: String -> String
toOp "add" = "+"
toOp "sub" = "-"
toOp "mul" = "*"
toOp "div" = "/"
toOp "pow" = "^"
toOp "equ" = "=="
toOp "lt" = "<"
toOp "gt" = ">"
toOp "lte" = "<="
toOp "gte" = ">="
toOp "ne" = "/="
toOp _ = ""

toOp1 :: String -> String
toOp1 "neg" = "-"
toOp1 _ = ""
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.minus :: (Eq x_a1mD) => [x_a1mD] -> [x_a1mD] -> [x_a1mD]
Dum.minus xs_a1mE ys_a1mF = foldl Dum.rmv xs_a1mE ys_a1mF
Dum.rmv :: (Eq x_aqT) => [x_aqT] -> x_aqT -> [x_aqT]
Dum.rmv (![]) y_a1Fw = []
Dum.rmv ((!((!x_a1Fx) : xs_a1Fy))) (!y_a1MD)
  = if x_a1Fx == y_a1MD then
        xs_a1Fy
    else
        x_a1Fx : (xs_a1Fy `Dum.rmv` y_a1MD)


["xs_a1mE","ys_a1mF","[]","![]","(![])","y_a1Fw","x_a1Fx","safebang@!x_a1Fx","(!x_a1Fx)","xs_a1Fy","(!x_a1Fx) : xs_a1Fy","((!x_a1Fx) : xs_a1Fy)","!((!x_a1Fx) : xs_a1Fy)","(!((!x_a1Fx) : xs_a1Fy))","((!((!x_a1Fx) : xs_a1Fy)))","y_a1MD","!y_a1MD","(!y_a1MD)"]
{-# LANGUAGE BangPatterns #-}
module Dum where

minus :: (Eq x_a1mD) => [x_a1mD] -> [x_a1mD] -> [x_a1mD]
minus xs_a1mE ys_a1mF = foldl rmv xs_a1mE ys_a1mF

rmv :: (Eq x_aqT) => [x_aqT] -> x_aqT -> [x_aqT]
rmv (investigate@[]) y_a1Fw = []
rmv ((investigate@((!x_a1Fx) : xs_a1Fy))) (investigate@y_a1MD)
  = if x_a1Fx == y_a1MD then xs_a1Fy else
      x_a1Fx : (xs_a1Fy `rmv` y_a1MD)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.returnM :: x_axI -> Maybe x_axI
Dum.returnM x_axJ = Just x_axJ
Dum.eachM :: Maybe x_axG -> (x_axG -> y_axH) -> Maybe y_axH
Dum.eachM ((!(Just x_axK))) (!f_axL) = Just (f_axL x_axK)
Dum.eachM Nothing (!f_axM) = Nothing
Dum.thenM :: Maybe x_axE -> (x_axE -> Maybe y_axF) -> Maybe y_axF
Dum.thenM ((!(Just x_axN))) kM_axO = kM_axO x_axN
Dum.thenM Nothing (!kM_axP) = Nothing
Dum.failM :: Maybe x_axD
Dum.failM = Nothing
Dum.orM :: Maybe x_axC -> Maybe x_axC -> Maybe x_axC
Dum.orM (Just x_axQ) yM_axR = Just x_axQ
Dum.orM Nothing (!yM_axS) = yM_axS
Dum.guardM :: Bool -> Maybe x_axB -> Maybe x_axB
Dum.guardM (!b_axT) (!xM_axU) = if b_axT then xM_axU else Dum.failM
Dum.filterM :: (x_axA -> Bool) -> Maybe x_axA -> Maybe x_axA
Dum.filterM p_axV xM_axW
  = xM_axW
    `Dum.thenM`
      (\ (!x_axX) -> p_axV x_axX `Dum.guardM` Dum.returnM x_axX)
Dum.theM :: Maybe x_axz -> x_axz
Dum.theM (!((!(Just x_axY)))) = x_axY
Dum.existsM :: Maybe x_aqu -> Bool
Dum.existsM ((!(Just x_axZ))) = True
Dum.existsM Nothing = False
Dum.useM :: x_aqt -> Maybe x_aqt -> x_aqt
Dum.useM xfail_ay0 ((!(Just (!x_ay1)))) = x_ay1
Dum.useM xfail_ay2 (!Nothing) = xfail_ay2


["x_axJ","x_axK","Just x_axK","(Just x_axK)","!(Just x_axK)","(!(Just x_axK))","((!(Just x_axK)))","f_axL","safebang@!f_axL","(!f_axL)","Nothing","f_axM","!f_axM","(!f_axM)","x_axN","Just x_axN","(Just x_axN)","!(Just x_axN)","(!(Just x_axN))","((!(Just x_axN)))","kM_axO","Nothing","kM_axP","!kM_axP","(!kM_axP)","failM","x_axQ","Just x_axQ","(Just x_axQ)","yM_axR","Nothing","yM_axS","!yM_axS","(!yM_axS)","b_axT","safebang@!b_axT","(!b_axT)","xM_axU","safebang@!xM_axU","(!xM_axU)","p_axV","xM_axW","x_axX","!x_axX","(!x_axX)","x_axY","Just x_axY","(Just x_axY)","!(Just x_axY)","(!(Just x_axY))","((!(Just x_axY)))","!((!(Just x_axY)))","(!((!(Just x_axY))))","x_axZ","Just x_axZ","(Just x_axZ)","!(Just x_axZ)","(!(Just x_axZ))","((!(Just x_axZ)))","Nothing","xfail_ay0","x_ay1","safebang@!x_ay1","(!x_ay1)","Just (!x_ay1)","(Just (!x_ay1))","!(Just (!x_ay1))","(!(Just (!x_ay1)))","((!(Just (!x_ay1))))","xfail_ay2","Nothing","!Nothing","(!Nothing)"]
{-# LANGUAGE BangPatterns #-}
module Dum where

returnM :: x_axI -> Maybe x_axI
returnM x_axJ = Just x_axJ

eachM :: Maybe x_axG -> (x_axG -> y_axH) -> Maybe y_axH
eachM ((investigate@(Just x_axK))) (!f_axL) = Just (f_axL x_axK)
eachM Nothing (investigate@f_axM) = Nothing

thenM :: Maybe x_axE -> (x_axE -> Maybe y_axF) -> Maybe y_axF
thenM ((investigate@(Just x_axN))) kM_axO = kM_axO x_axN
thenM Nothing (investigate@kM_axP) = Nothing

failM :: Maybe x_axD
failM = Nothing

orM :: Maybe x_axC -> Maybe x_axC -> Maybe x_axC
orM (Just x_axQ) yM_axR = Just x_axQ
orM Nothing (investigate@yM_axS) = yM_axS

guardM :: Bool -> Maybe x_axB -> Maybe x_axB
guardM (!b_axT) (!xM_axU) = if b_axT then xM_axU else failM

filterM :: (x_axA -> Bool) -> Maybe x_axA -> Maybe x_axA
filterM p_axV xM_axW
  = xM_axW `thenM`
      (\ (investigate@x_axX) -> p_axV x_axX `guardM` returnM x_axX)

theM :: Maybe x_axz -> x_axz
theM (investigate@((investigate@(Just x_axY)))) = x_axY

existsM :: Maybe x_aqu -> Bool
existsM ((investigate@(Just x_axZ))) = True
existsM Nothing = False

useM :: x_aqt -> Maybe x_aqt -> x_aqt
useM xfail_ay0 ((investigate@(Just (!x_ay1)))) = x_ay1
useM xfail_ay2 (investigate@Nothing) = xfail_ay2
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.emptyFM :: Dum.FM a_a1tX b_a1tY
Dum.emptyFM = Dum.MkFM []
Dum.unitFM :: a_a1tV -> b_a1tW -> Dum.FM a_a1tV b_a1tW
Dum.unitFM a_a1tZ (!b_a1u0) = Dum.MkFM [(a_a1tZ, b_a1u0)]
Dum.extendFM ::
  Dum.FM a_a1tT b_a1tU -> a_a1tT -> b_a1tU -> Dum.FM a_a1tT b_a1tU
Dum.extendFM ((!(Dum.MkFM abs_a1u1))) (!a_a1u2) b_a1u3
  = Dum.MkFM ((a_a1u2, b_a1u3) : abs_a1u1)
Dum.makeFM :: [(a_a1tR, b_a1tS)] -> Dum.FM a_a1tR b_a1tS
Dum.makeFM (!abs_a1u4) = Dum.MkFM abs_a1u4
Dum.unmakeFM :: Dum.FM a_a1tP b_a1tQ -> [(a_a1tP, b_a1tQ)]
Dum.unmakeFM (Dum.MkFM abs_a1u5) = abs_a1u5
Dum.thenFM ::
  Dum.FM a_a1tN b_a1tO
  -> Dum.FM a_a1tN b_a1tO -> Dum.FM a_a1tN b_a1tO
Dum.thenFM ((!(Dum.MkFM (!abs1_a1u6)))) (Dum.MkFM abs2_a1u7)
  = Dum.MkFM (abs2_a1u7 ++ abs1_a1u6)
Dum.plusFM ::
  (Eq a_a1tL) =>
  Dum.FM a_a1tL b_a1tM
  -> Dum.FM a_a1tL b_a1tM -> Dum.FM a_a1tL b_a1tM
Dum.plusFM f_a1u8 (!g_a1u9)
  | f_a1u8 `Dum.disjointFM` g_a1u9 = f_a1u8 `Dum.thenFM` g_a1u9
Dum.lookupFM ::
  (Eq a_a1tJ) => Dum.FM a_a1tJ b_a1tK -> a_a1tJ -> b_a1tK
Dum.lookupFM (!f_a1ua) (!a_a1ub)
  = Dum.lookupElseFM (error "lookup") f_a1ua a_a1ub
Dum.lookupElseFM ::
  (Eq a_a1tH) => b_a1tI -> Dum.FM a_a1tH b_a1tI -> a_a1tH -> b_a1tI
Dum.lookupElseFM b_a1uN ((!(Dum.MkFM abs_a1uO))) (!a_a1uP)
  = head
      ([b'_a1yJ |
          (!((!a'_a1yI), b'_a1yJ)) <- abs_a1uO, a_a1uP == a'_a1yI]
       ++ [b_a1uN])
Dum.mapFM ::
  (b_a1tE -> c_a1tF) -> Dum.FM a_a1tG b_a1tE -> Dum.FM a_a1tG c_a1tF
Dum.mapFM h_a1yK (!(Dum.MkFM abs_a1yL))
  = Dum.MkFM
      [(a_a1yM, h_a1yK b_a1yN) | ((!a_a1yM), b_a1yN) <- abs_a1yL]
Dum.domFM :: Dum.FM a_a1tC b_a1tD -> [a_a1tC]
Dum.domFM (Dum.MkFM (!abs_a1yO))
  = [a_a1yP | (!((!a_a1yP), b_a1yQ)) <- abs_a1yO]
Dum.ranFM :: Dum.FM a_a1tA b_a1tB -> [b_a1tB]
Dum.ranFM (!((!(Dum.MkFM abs_a1yR))))
  = [b_a1yT | ((!a_a1yS), b_a1yT) <- abs_a1yR]
Dum.disjointFM ::
  (Eq a_a1ty) => Dum.FM a_a1ty b_a1tz -> Dum.FM a_a1ty b_a1tz -> Bool
Dum.disjointFM (!f_a1yU) g_a1yV
  = Dum.domFM f_a1yU `Dum.disjoint` Dum.domFM g_a1yV
Dum.disjoint :: (Eq a_aqK) => [a_aqK] -> [a_aqK] -> Bool
Dum.disjoint (!xs_a1yW) (!ys_a1yX)
  = and [not (x_a1RD `elem` ys_a1yX) | (!x_a1RD) <- xs_a1yW]

data Dum.FM a_aqI b_aqJ = Dum.MkFM [(a_aqI, b_aqJ)]


["emptyFM","a_a1tZ","b_a1u0","safebang@!b_a1u0","(!b_a1u0)","abs_a1u1","MkFM abs_a1u1","(MkFM abs_a1u1)","!(MkFM abs_a1u1)","(!(MkFM abs_a1u1))","((!(MkFM abs_a1u1)))","a_a1u2","safebang@!a_a1u2","(!a_a1u2)","b_a1u3","abs_a1u4","safebang@!abs_a1u4","(!abs_a1u4)","abs_a1u5","MkFM abs_a1u5","(MkFM abs_a1u5)","abs1_a1u6","safebang@!abs1_a1u6","(!abs1_a1u6)","MkFM (!abs1_a1u6)","(MkFM (!abs1_a1u6))","!(MkFM (!abs1_a1u6))","(!(MkFM (!abs1_a1u6)))","((!(MkFM (!abs1_a1u6))))","abs2_a1u7","MkFM abs2_a1u7","(MkFM abs2_a1u7)","f_a1u8","g_a1u9","!g_a1u9","(!g_a1u9)","f_a1ua","!f_a1ua","(!f_a1ua)","a_a1ub","safebang@!a_a1ub","(!a_a1ub)","b_a1uN","abs_a1uO","MkFM abs_a1uO","(MkFM abs_a1uO)","!(MkFM abs_a1uO)","(!(MkFM abs_a1uO))","((!(MkFM abs_a1uO)))","a_a1uP","safebang@!a_a1uP","(!a_a1uP)","a'_a1yI","safebang@!a'_a1yI","(!a'_a1yI)","b'_a1yJ","((!a'_a1yI), b'_a1yJ)","!((!a'_a1yI), b'_a1yJ)","(!((!a'_a1yI), b'_a1yJ))","h_a1yK","abs_a1yL","MkFM abs_a1yL","(MkFM abs_a1yL)","!(MkFM abs_a1yL)","(!(MkFM abs_a1yL))","a_a1yM","safebang@!a_a1yM","(!a_a1yM)","b_a1yN","((!a_a1yM), b_a1yN)","abs_a1yO","safebang@!abs_a1yO","(!abs_a1yO)","MkFM (!abs_a1yO)","(MkFM (!abs_a1yO))","a_a1yP","safebang@!a_a1yP","(!a_a1yP)","b_a1yQ","((!a_a1yP), b_a1yQ)","!((!a_a1yP), b_a1yQ)","(!((!a_a1yP), b_a1yQ))","abs_a1yR","MkFM abs_a1yR","(MkFM abs_a1yR)","!(MkFM abs_a1yR)","(!(MkFM abs_a1yR))","((!(MkFM abs_a1yR)))","!((!(MkFM abs_a1yR)))","(!((!(MkFM abs_a1yR))))","a_a1yS","safebang@!a_a1yS","(!a_a1yS)","b_a1yT","((!a_a1yS), b_a1yT)","f_a1yU","!f_a1yU","(!f_a1yU)","g_a1yV","xs_a1yW","safebang@!xs_a1yW","(!xs_a1yW)","ys_a1yX","safebang@!ys_a1yX","(!ys_a1yX)","x_a1RD","!x_a1RD","(!x_a1RD)"]
{-# LANGUAGE BangPatterns #-}
module Dum where

emptyFM :: FM a_a1tX b_a1tY
emptyFM = MkFM []

unitFM :: a_a1tV -> b_a1tW -> FM a_a1tV b_a1tW
unitFM a_a1tZ (!b_a1u0) = MkFM [(a_a1tZ, b_a1u0)]

extendFM ::
         FM a_a1tT b_a1tU -> a_a1tT -> b_a1tU -> FM a_a1tT b_a1tU
extendFM ((investigate@(MkFM abs_a1u1))) (!a_a1u2) b_a1u3
  = MkFM ((a_a1u2, b_a1u3) : abs_a1u1)

makeFM :: [(a_a1tR, b_a1tS)] -> FM a_a1tR b_a1tS
makeFM (!abs_a1u4) = MkFM abs_a1u4

unmakeFM :: FM a_a1tP b_a1tQ -> [(a_a1tP, b_a1tQ)]
unmakeFM (MkFM abs_a1u5) = abs_a1u5

thenFM :: FM a_a1tN b_a1tO -> FM a_a1tN b_a1tO -> FM a_a1tN b_a1tO
thenFM ((investigate@(MkFM (!abs1_a1u6)))) (MkFM abs2_a1u7)
  = MkFM (abs2_a1u7 ++ abs1_a1u6)

plusFM ::
         (Eq a_a1tL) =>
         FM a_a1tL b_a1tM -> FM a_a1tL b_a1tM -> FM a_a1tL b_a1tM
plusFM f_a1u8 (investigate@g_a1u9)
  | f_a1u8 `disjointFM` g_a1u9 = f_a1u8 `thenFM` g_a1u9

lookupFM :: (Eq a_a1tJ) => FM a_a1tJ b_a1tK -> a_a1tJ -> b_a1tK
lookupFM (investigate@f_a1ua) (!a_a1ub)
  = lookupElseFM (error "lookup") f_a1ua a_a1ub

lookupElseFM ::
               (Eq a_a1tH) => b_a1tI -> FM a_a1tH b_a1tI -> a_a1tH -> b_a1tI
lookupElseFM b_a1uN ((investigate@(MkFM abs_a1uO))) (!a_a1uP)
  = head
      ([b'_a1yJ | (investigate@((!a'_a1yI), b'_a1yJ)) <- abs_a1uO,
        a_a1uP == a'_a1yI]
         ++ [b_a1uN])

mapFM :: (b_a1tE -> c_a1tF) -> FM a_a1tG b_a1tE -> FM a_a1tG c_a1tF
mapFM h_a1yK (investigate@(MkFM abs_a1yL))
  = MkFM [(a_a1yM, h_a1yK b_a1yN) | ((!a_a1yM), b_a1yN) <- abs_a1yL]

domFM :: FM a_a1tC b_a1tD -> [a_a1tC]
domFM (MkFM (!abs_a1yO))
  = [a_a1yP | (investigate@((!a_a1yP), b_a1yQ)) <- abs_a1yO]

ranFM :: FM a_a1tA b_a1tB -> [b_a1tB]
ranFM (investigate@((investigate@(MkFM abs_a1yR))))
  = [b_a1yT | ((!a_a1yS), b_a1yT) <- abs_a1yR]

disjointFM ::
             (Eq a_a1ty) => FM a_a1ty b_a1tz -> FM a_a1ty b_a1tz -> Bool
disjointFM (investigate@f_a1yU) g_a1yV
  = domFM f_a1yU `disjoint` domFM g_a1yV

disjoint :: (Eq a_aqK) => [a_aqK] -> [a_aqK] -> Bool
disjoint (!xs_a1yW) (!ys_a1yX)
  = and
      [not (x_a1RD `elem` ys_a1yX) | (investigate@x_a1RD) <- xs_a1yW]

data FM a_aqI b_aqJ = MkFM [(a_aqI, b_aqJ)]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.emptyFM :: Dum.FM a_a1tX b_a1tY
Dum.emptyFM = Dum.MkFM []
Dum.unitFM :: a_a1tV -> b_a1tW -> Dum.FM a_a1tV b_a1tW
Dum.unitFM a_a1tZ (!b_a1u0) = Dum.MkFM [(a_a1tZ, b_a1u0)]
Dum.extendFM ::
  Dum.FM a_a1tT b_a1tU -> a_a1tT -> b_a1tU -> Dum.FM a_a1tT b_a1tU
Dum.extendFM ((!(Dum.MkFM abs_a1u1))) (!a_a1u2) b_a1u3
  = Dum.MkFM ((a_a1u2, b_a1u3) : abs_a1u1)
Dum.makeFM :: [(a_a1tR, b_a1tS)] -> Dum.FM a_a1tR b_a1tS
Dum.makeFM (!abs_a1u4) = Dum.MkFM abs_a1u4
Dum.unmakeFM :: Dum.FM a_a1tP b_a1tQ -> [(a_a1tP, b_a1tQ)]
Dum.unmakeFM (Dum.MkFM abs_a1u5) = abs_a1u5
Dum.thenFM ::
  Dum.FM a_a1tN b_a1tO
  -> Dum.FM a_a1tN b_a1tO -> Dum.FM a_a1tN b_a1tO
Dum.thenFM ((!(Dum.MkFM (!abs1_a1u6)))) (Dum.MkFM abs2_a1u7)
  = Dum.MkFM (abs2_a1u7 ++ abs1_a1u6)
Dum.plusFM ::
  (Eq a_a1tL) =>
  Dum.FM a_a1tL b_a1tM
  -> Dum.FM a_a1tL b_a1tM -> Dum.FM a_a1tL b_a1tM
Dum.plusFM f_a1u8 (!g_a1u9)
  | f_a1u8 `Dum.disjointFM` g_a1u9 = f_a1u8 `Dum.thenFM` g_a1u9
Dum.lookupFM ::
  (Eq a_a1tJ) => Dum.FM a_a1tJ b_a1tK -> a_a1tJ -> b_a1tK
Dum.lookupFM (!f_a1ua) (!a_a1ub)
  = Dum.lookupElseFM (error "lookup") f_a1ua a_a1ub
Dum.lookupElseFM ::
  (Eq a_a1tH) => b_a1tI -> Dum.FM a_a1tH b_a1tI -> a_a1tH -> b_a1tI
Dum.lookupElseFM b_a1uN ((!(Dum.MkFM abs_a1uO))) (!a_a1uP)
  = head
      ([b'_a1yJ |
          (!((!a'_a1yI), b'_a1yJ)) <- abs_a1uO, a_a1uP == a'_a1yI]
       ++ [b_a1uN])
Dum.mapFM ::
  (b_a1tE -> c_a1tF) -> Dum.FM a_a1tG b_a1tE -> Dum.FM a_a1tG c_a1tF
Dum.mapFM h_a1yK (!(Dum.MkFM abs_a1yL))
  = Dum.MkFM
      [(a_a1yM, h_a1yK b_a1yN) | ((!a_a1yM), b_a1yN) <- abs_a1yL]
Dum.domFM :: Dum.FM a_a1tC b_a1tD -> [a_a1tC]
Dum.domFM (Dum.MkFM (!abs_a1yO))
  = [a_a1yP | (!((!a_a1yP), b_a1yQ)) <- abs_a1yO]
Dum.ranFM :: Dum.FM a_a1tA b_a1tB -> [b_a1tB]
Dum.ranFM (!((!(Dum.MkFM abs_a1yR))))
  = [b_a1yT | ((!a_a1yS), b_a1yT) <- abs_a1yR]
Dum.disjointFM ::
  (Eq a_a1ty) => Dum.FM a_a1ty b_a1tz -> Dum.FM a_a1ty b_a1tz -> Bool
Dum.disjointFM (!f_a1yU) g_a1yV
  = Dum.domFM f_a1yU `Dum.disjoint` Dum.domFM g_a1yV
Dum.disjoint :: (Eq a_aqK) => [a_aqK] -> [a_aqK] -> Bool
Dum.disjoint (!xs_a1yW) (!ys_a1yX)
  = and [not (x_a1RD `elem` ys_a1yX) | (!x_a1RD) <- xs_a1yW]

data Dum.FM a_aqI b_aqJ = Dum.MkFM [(a_aqI, b_aqJ)]


["emptyFM","a_a1tZ","b_a1u0","safebang@!b_a1u0","(!b_a1u0)","abs_a1u1","MkFM abs_a1u1","(MkFM abs_a1u1)","!(MkFM abs_a1u1)","(!(MkFM abs_a1u1))","((!(MkFM abs_a1u1)))","a_a1u2","safebang@!a_a1u2","(!a_a1u2)","b_a1u3","abs_a1u4","safebang@!abs_a1u4","(!abs_a1u4)","abs_a1u5","MkFM abs_a1u5","(MkFM abs_a1u5)","abs1_a1u6","safebang@!abs1_a1u6","(!abs1_a1u6)","MkFM (!abs1_a1u6)","(MkFM (!abs1_a1u6))","!(MkFM (!abs1_a1u6))","(!(MkFM (!abs1_a1u6)))","((!(MkFM (!abs1_a1u6))))","abs2_a1u7","MkFM abs2_a1u7","(MkFM abs2_a1u7)","f_a1u8","g_a1u9","!g_a1u9","(!g_a1u9)","f_a1ua","!f_a1ua","(!f_a1ua)","a_a1ub","safebang@!a_a1ub","(!a_a1ub)","b_a1uN","abs_a1uO","MkFM abs_a1uO","(MkFM abs_a1uO)","!(MkFM abs_a1uO)","(!(MkFM abs_a1uO))","((!(MkFM abs_a1uO)))","a_a1uP","safebang@!a_a1uP","(!a_a1uP)","a'_a1yI","safebang@!a'_a1yI","(!a'_a1yI)","b'_a1yJ","((!a'_a1yI), b'_a1yJ)","!((!a'_a1yI), b'_a1yJ)","(!((!a'_a1yI), b'_a1yJ))","h_a1yK","abs_a1yL","MkFM abs_a1yL","(MkFM abs_a1yL)","!(MkFM abs_a1yL)","(!(MkFM abs_a1yL))","a_a1yM","safebang@!a_a1yM","(!a_a1yM)","b_a1yN","((!a_a1yM), b_a1yN)","abs_a1yO","safebang@!abs_a1yO","(!abs_a1yO)","MkFM (!abs_a1yO)","(MkFM (!abs_a1yO))","a_a1yP","safebang@!a_a1yP","(!a_a1yP)","b_a1yQ","((!a_a1yP), b_a1yQ)","!((!a_a1yP), b_a1yQ)","(!((!a_a1yP), b_a1yQ))","abs_a1yR","MkFM abs_a1yR","(MkFM abs_a1yR)","!(MkFM abs_a1yR)","(!(MkFM abs_a1yR))","((!(MkFM abs_a1yR)))","!((!(MkFM abs_a1yR)))","(!((!(MkFM abs_a1yR))))","a_a1yS","safebang@!a_a1yS","(!a_a1yS)","b_a1yT","((!a_a1yS), b_a1yT)","f_a1yU","!f_a1yU","(!f_a1yU)","g_a1yV","xs_a1yW","safebang@!xs_a1yW","(!xs_a1yW)","ys_a1yX","safebang@!ys_a1yX","(!ys_a1yX)","x_a1RD","!x_a1RD","(!x_a1RD)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Parse
import Term

emptyFM :: FM a_a1tX b_a1tY
emptyFM = MkFM []

unitFM :: a_a1tV -> b_a1tW -> FM a_a1tV b_a1tW
unitFM a_a1tZ (!b_a1u0) = MkFM [(a_a1tZ, b_a1u0)]

extendFM ::
         FM a_a1tT b_a1tU -> a_a1tT -> b_a1tU -> FM a_a1tT b_a1tU
extendFM ((investigate@(MkFM abs_a1u1))) (!a_a1u2) b_a1u3
  = MkFM ((a_a1u2, b_a1u3) : abs_a1u1)

makeFM :: [(a_a1tR, b_a1tS)] -> FM a_a1tR b_a1tS
makeFM (!abs_a1u4) = MkFM abs_a1u4

unmakeFM :: FM a_a1tP b_a1tQ -> [(a_a1tP, b_a1tQ)]
unmakeFM (MkFM abs_a1u5) = abs_a1u5

thenFM :: FM a_a1tN b_a1tO -> FM a_a1tN b_a1tO -> FM a_a1tN b_a1tO
thenFM ((investigate@(MkFM (!abs1_a1u6)))) (MkFM abs2_a1u7)
  = MkFM (abs2_a1u7 ++ abs1_a1u6)

plusFM ::
         (Eq a_a1tL) =>
         FM a_a1tL b_a1tM -> FM a_a1tL b_a1tM -> FM a_a1tL b_a1tM
plusFM f_a1u8 (investigate@g_a1u9)
  | f_a1u8 `disjointFM` g_a1u9 = f_a1u8 `thenFM` g_a1u9

lookupFM :: (Eq a_a1tJ) => FM a_a1tJ b_a1tK -> a_a1tJ -> b_a1tK
lookupFM (investigate@f_a1ua) (!a_a1ub)
  = lookupElseFM (error "lookup") f_a1ua a_a1ub

lookupElseFM ::
               (Eq a_a1tH) => b_a1tI -> FM a_a1tH b_a1tI -> a_a1tH -> b_a1tI
lookupElseFM b_a1uN ((investigate@(MkFM abs_a1uO))) (!a_a1uP)
  = head
      ([b'_a1yJ | (investigate@((!a'_a1yI), b'_a1yJ)) <- abs_a1uO,
        a_a1uP == a'_a1yI]
         ++ [b_a1uN])

mapFM :: (b_a1tE -> c_a1tF) -> FM a_a1tG b_a1tE -> FM a_a1tG c_a1tF
mapFM h_a1yK (investigate@(MkFM abs_a1yL))
  = MkFM [(a_a1yM, h_a1yK b_a1yN) | ((!a_a1yM), b_a1yN) <- abs_a1yL]

domFM :: FM a_a1tC b_a1tD -> [a_a1tC]
domFM (MkFM (!abs_a1yO))
  = [a_a1yP | (investigate@((!a_a1yP), b_a1yQ)) <- abs_a1yO]

ranFM :: FM a_a1tA b_a1tB -> [b_a1tB]
ranFM (investigate@((investigate@(MkFM abs_a1yR))))
  = [b_a1yT | ((!a_a1yS), b_a1yT) <- abs_a1yR]

disjointFM ::
             (Eq a_a1ty) => FM a_a1ty b_a1tz -> FM a_a1ty b_a1tz -> Bool
disjointFM (investigate@f_a1yU) g_a1yV
  = domFM f_a1yU `disjoint` domFM g_a1yV

disjoint :: (Eq a_aqK) => [a_aqK] -> [a_aqK] -> Bool
disjoint (!xs_a1yW) (!ys_a1yX)
  = and
      [not (x_a1RD `elem` ys_a1yX) | (investigate@x_a1RD) <- xs_a1yW]

data FM a_aqI b_aqJ = MkFM [(a_aqI, b_aqJ)]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.rep :: Dum.State s_ara x_arb -> (s_ara -> (x_arb, s_ara))
Dum.rep (!(Dum.Abs f_arc)) = f_arc
Dum.returnS :: x_ar8 -> Dum.State s_ar9 x_ar8
Dum.returnS x_ard = Dum.Abs (\ (!s_are) -> (x_ard, s_are))
Dum.eachS ::
  Dum.State s_ar5 x_ar6 -> (x_ar6 -> y_ar7) -> Dum.State s_ar5 y_ar7
Dum.eachS xS_arf (!f_arg)
  = Dum.Abs
      (\ s_arh
         -> let ((!x_ari), s'_arj) = Dum.rep xS_arf s_arh
            in (f_arg x_ari, s'_arj))
Dum.thenS ::
  Dum.State s_ar2 x_ar3
  -> (x_ar3 -> Dum.State s_ar2 y_ar4) -> Dum.State s_ar2 y_ar4
Dum.thenS xS_ark (!kS_arl)
  = Dum.Abs
      (\ (!s_arm)
         -> let (x_arn, s'_aro) = Dum.rep xS_ark s_arm
            in Dum.rep (kS_arl x_arn) s'_aro)
Dum.putS :: s_ar1 -> Dum.State s_ar1 ()
Dum.putS s'_arp = Dum.Abs (\ s_arq -> ((), s'_arp))
Dum.getS :: Dum.State s_ar0 s_ar0
Dum.getS = Dum.Abs (\ (!s_arr) -> (s_arr, s_arr))
Dum.useS :: Dum.State s_aqY x_aqZ -> s_aqY -> x_aqZ
Dum.useS (!xS_ars) s_art
  = let (x_aru, (!s'_arv)) = Dum.rep xS_ars s_art in x_aru

data Dum.State s_aqW x_aqX = Dum.Abs (s_aqW -> (x_aqX, s_aqW))


["f_arc","Abs f_arc","(Abs f_arc)","!(Abs f_arc)","(!(Abs f_arc))","x_ard","s_are","safebang@!s_are","(!s_are)","xS_arf","f_arg","safebang@!f_arg","(!f_arg)","s_arh","x_ari","!x_ari","(!x_ari)","s'_arj","((!x_ari), s'_arj)","xS_ark","kS_arl","safebang@!kS_arl","(!kS_arl)","s_arm","safebang@!s_arm","(!s_arm)","x_arn","s'_aro","(x_arn, s'_aro)","s'_arp","s_arq","getS","s_arr","safebang@!s_arr","(!s_arr)","xS_ars","!xS_ars","(!xS_ars)","s_art","x_aru","s'_arv","!s'_arv","(!s'_arv)","(x_aru, (!s'_arv))"]
{-# LANGUAGE BangPatterns #-}
module Dum where

rep :: State s_ara x_arb -> (s_ara -> (x_arb, s_ara))
rep (investigate@(Abs f_arc)) = f_arc

returnS :: x_ar8 -> State s_ar9 x_ar8
returnS x_ard = Abs (\ (!s_are) -> (x_ard, s_are))

eachS :: State s_ar5 x_ar6 -> (x_ar6 -> y_ar7) -> State s_ar5 y_ar7
eachS xS_arf (!f_arg)
  = Abs
      (\ s_arh ->
         let ((investigate@x_ari), s'_arj) = rep xS_arf s_arh in
           (f_arg x_ari, s'_arj))

thenS ::
      State s_ar2 x_ar3 ->
        (x_ar3 -> State s_ar2 y_ar4) -> State s_ar2 y_ar4
thenS xS_ark (!kS_arl)
  = Abs
      (\ (!s_arm) ->
         let (x_arn, s'_aro) = rep xS_ark s_arm in
           rep (kS_arl x_arn) s'_aro)

putS :: s_ar1 -> State s_ar1 ()
putS s'_arp = Abs (\ s_arq -> ((), s'_arp))

getS :: State s_ar0 s_ar0
getS = Abs (\ (!s_arr) -> (s_arr, s_arr))

useS :: State s_aqY x_aqZ -> s_aqY -> x_aqZ
useS (investigate@xS_ars) s_art
  = let (x_aru, (investigate@s'_arv)) = rep xS_ars s_art in x_aru

data State s_aqW x_aqX = Abs (s_aqW -> (x_aqX, s_aqW))
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.rep :: Dum.State s_ara x_arb -> (s_ara -> (x_arb, s_ara))
Dum.rep (!(Dum.Abs f_arc)) = f_arc
Dum.returnS :: x_ar8 -> Dum.State s_ar9 x_ar8
Dum.returnS x_ard = Dum.Abs (\ (!s_are) -> (x_ard, s_are))
Dum.eachS ::
  Dum.State s_ar5 x_ar6 -> (x_ar6 -> y_ar7) -> Dum.State s_ar5 y_ar7
Dum.eachS xS_arf (!f_arg)
  = Dum.Abs
      (\ s_arh
         -> let ((!x_ari), s'_arj) = Dum.rep xS_arf s_arh
            in (f_arg x_ari, s'_arj))
Dum.thenS ::
  Dum.State s_ar2 x_ar3
  -> (x_ar3 -> Dum.State s_ar2 y_ar4) -> Dum.State s_ar2 y_ar4
Dum.thenS xS_ark (!kS_arl)
  = Dum.Abs
      (\ (!s_arm)
         -> let (x_arn, s'_aro) = Dum.rep xS_ark s_arm
            in Dum.rep (kS_arl x_arn) s'_aro)
Dum.putS :: s_ar1 -> Dum.State s_ar1 ()
Dum.putS s'_arp = Dum.Abs (\ s_arq -> ((), s'_arp))
Dum.getS :: Dum.State s_ar0 s_ar0
Dum.getS = Dum.Abs (\ (!s_arr) -> (s_arr, s_arr))
Dum.useS :: Dum.State s_aqY x_aqZ -> s_aqY -> x_aqZ
Dum.useS (!xS_ars) s_art
  = let (x_aru, (!s'_arv)) = Dum.rep xS_ars s_art in x_aru

data Dum.State s_aqW x_aqX = Dum.Abs (s_aqW -> (x_aqX, s_aqW))


["f_arc","Abs f_arc","(Abs f_arc)","!(Abs f_arc)","(!(Abs f_arc))","x_ard","s_are","safebang@!s_are","(!s_are)","xS_arf","f_arg","safebang@!f_arg","(!f_arg)","s_arh","x_ari","!x_ari","(!x_ari)","s'_arj","((!x_ari), s'_arj)","xS_ark","kS_arl","safebang@!kS_arl","(!kS_arl)","s_arm","safebang@!s_arm","(!s_arm)","x_arn","s'_aro","(x_arn, s'_aro)","s'_arp","s_arq","getS","s_arr","safebang@!s_arr","(!s_arr)","xS_ars","!xS_ars","(!xS_ars)","s_art","x_aru","s'_arv","!s'_arv","(!s'_arv)","(x_aru, (!s'_arv))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import MaybeM
       (Maybe, returnM, eachM, thenM, failM, guardM, theM, existsM, useM)
import StateX
       (StateX, returnSX, eachSX, thenSX, toSX, putSX, getSX, useSX)
import Type (TVarId, TConId, MonoType(TVar, TCon), freeTVarMono)
import Substitution
       (Sub, applySub, lookupSub, emptySub, extendSub, domSub, unifySub)

rep :: State s_ara x_arb -> (s_ara -> (x_arb, s_ara))
rep (investigate@(Abs f_arc)) = f_arc

returnS :: x_ar8 -> State s_ar9 x_ar8
returnS x_ard = Abs (\ (!s_are) -> (x_ard, s_are))

eachS :: State s_ar5 x_ar6 -> (x_ar6 -> y_ar7) -> State s_ar5 y_ar7
eachS xS_arf (!f_arg)
  = Abs
      (\ s_arh ->
         let ((investigate@x_ari), s'_arj) = rep xS_arf s_arh in
           (f_arg x_ari, s'_arj))

thenS ::
      State s_ar2 x_ar3 ->
        (x_ar3 -> State s_ar2 y_ar4) -> State s_ar2 y_ar4
thenS xS_ark (!kS_arl)
  = Abs
      (\ (!s_arm) ->
         let (x_arn, s'_aro) = rep xS_ark s_arm in
           rep (kS_arl x_arn) s'_aro)

putS :: s_ar1 -> State s_ar1 ()
putS s'_arp = Abs (\ s_arq -> ((), s'_arp))

getS :: State s_ar0 s_ar0
getS = Abs (\ (!s_arr) -> (s_arr, s_arr))

useS :: State s_aqY x_aqZ -> s_aqY -> x_aqZ
useS (investigate@xS_ars) s_art
  = let (x_aru, (investigate@s'_arv)) = rep xS_ars s_art in x_aru

data State s_aqW x_aqX = Abs (s_aqW -> (x_aqX, s_aqW))
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showsEmpty :: ShowS
Dum.showsEmpty r_aHZ = r_aHZ
Dum.showsConcat :: [ShowS] -> ShowS
Dum.showsConcat = foldr (.) Dum.showsEmpty
Dum.showsString :: Dum.Shows String
Dum.showsString = (++)
Dum.showsChar :: Dum.Shows Char
Dum.showsChar = (:)
Dum.showsStar :: Dum.Shows x_aHY -> Dum.Shows [x_aHY]
Dum.showsStar (!showsX_a10Q) xs_a10R
  = Dum.showsConcat (map showsX_a10Q xs_a10R)
Dum.showsStarSep :: String -> Dum.Shows x_aHX -> Dum.Shows [x_aHX]
Dum.showsStarSep (!s_a10S) showsX_a10T (![]) = Dum.showsEmpty
Dum.showsStarSep s_a10U showsX_a10V ((!(x_a10W : (!xs_a10X))))
  = showsX_a10V x_a10W
    . Dum.showsConcat
        [showString s_a10U . showsX_a10V x'_a10Y | x'_a10Y <- xs_a10X]
Dum.showsSurround ::
  String -> Dum.Shows x_aHW -> String -> Dum.Shows x_aHW
Dum.showsSurround l_a10Z showsX_a110 r_a111 (!x_a112)
  = showString l_a10Z . showsX_a110 x_a112 . showString r_a111
Dum.showsListOf :: Dum.Shows x_aHV -> Dum.Shows [x_aHV]
Dum.showsListOf (!showsX_a113)
  = Dum.showsSurround "[" (Dum.showsStarSep ", " showsX_a113) "]"
Dum.showsParen :: ShowS -> ShowS
Dum.showsParen = Dum.showsSurround "(" id ")"
Dum.showsParenIf :: Bool -> ShowS -> ShowS
Dum.showsParenIf b_a114 xS_a115
  = if b_a114 then Dum.showsParen xS_a115 else xS_a115

type Dum.Shows x_aqI = x_aqI -> ShowS


["r_aHZ","showsConcat","showsString","showsChar","showsX_a10Q","safebang@!showsX_a10Q","(!showsX_a10Q)","xs_a10R","s_a10S","safebang@!s_a10S","(!s_a10S)","showsX_a10T","[]","![]","(![])","s_a10U","showsX_a10V","x_a10W","xs_a10X","!xs_a10X","(!xs_a10X)","x_a10W : (!xs_a10X)","(x_a10W : (!xs_a10X))","!(x_a10W : (!xs_a10X))","(!(x_a10W : (!xs_a10X)))","((!(x_a10W : (!xs_a10X))))","x'_a10Y","l_a10Z","showsX_a110","r_a111","x_a112","safebang@!x_a112","(!x_a112)","showsX_a113","safebang@!showsX_a113","(!showsX_a113)","showsParen","b_a114","xS_a115"]
{-# LANGUAGE BangPatterns #-}
module Dum where

showsEmpty :: ShowS
showsEmpty r_aHZ = r_aHZ

showsConcat :: [ShowS] -> ShowS
showsConcat = foldr (.) showsEmpty

showsString :: Shows String
showsString = (++)

showsChar :: Shows Char
showsChar = (:)

showsStar :: Shows x_aHY -> Shows [x_aHY]
showsStar (!showsX_a10Q) xs_a10R
  = showsConcat (map showsX_a10Q xs_a10R)

showsStarSep :: String -> Shows x_aHX -> Shows [x_aHX]
showsStarSep (!s_a10S) showsX_a10T (investigate@[]) = showsEmpty
showsStarSep s_a10U showsX_a10V
  ((investigate@(x_a10W : (investigate@xs_a10X))))
  = showsX_a10V x_a10W .
      showsConcat
        [showString s_a10U . showsX_a10V x'_a10Y | x'_a10Y <- xs_a10X]

showsSurround :: String -> Shows x_aHW -> String -> Shows x_aHW
showsSurround l_a10Z showsX_a110 r_a111 (!x_a112)
  = showString l_a10Z . showsX_a110 x_a112 . showString r_a111

showsListOf :: Shows x_aHV -> Shows [x_aHV]
showsListOf (!showsX_a113)
  = showsSurround "[" (showsStarSep ", " showsX_a113) "]"

showsParen :: ShowS -> ShowS
showsParen = showsSurround "(" id ")"

showsParenIf :: Bool -> ShowS -> ShowS
showsParenIf b_a114 xS_a115
  = if b_a114 then showsParen xS_a115 else xS_a115

type Shows x_aqI = x_aqI -> ShowS
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.showsEmpty :: ShowS
Dum.showsEmpty r_aHZ = r_aHZ
Dum.showsConcat :: [ShowS] -> ShowS
Dum.showsConcat = foldr (.) Dum.showsEmpty
Dum.showsString :: Dum.Shows String
Dum.showsString = (++)
Dum.showsChar :: Dum.Shows Char
Dum.showsChar = (:)
Dum.showsStar :: Dum.Shows x_aHY -> Dum.Shows [x_aHY]
Dum.showsStar (!showsX_a10Q) xs_a10R
  = Dum.showsConcat (map showsX_a10Q xs_a10R)
Dum.showsStarSep :: String -> Dum.Shows x_aHX -> Dum.Shows [x_aHX]
Dum.showsStarSep (!s_a10S) showsX_a10T (![]) = Dum.showsEmpty
Dum.showsStarSep s_a10U showsX_a10V ((!(x_a10W : (!xs_a10X))))
  = showsX_a10V x_a10W
    . Dum.showsConcat
        [showString s_a10U . showsX_a10V x'_a10Y | x'_a10Y <- xs_a10X]
Dum.showsSurround ::
  String -> Dum.Shows x_aHW -> String -> Dum.Shows x_aHW
Dum.showsSurround l_a10Z showsX_a110 r_a111 (!x_a112)
  = showString l_a10Z . showsX_a110 x_a112 . showString r_a111
Dum.showsListOf :: Dum.Shows x_aHV -> Dum.Shows [x_aHV]
Dum.showsListOf (!showsX_a113)
  = Dum.showsSurround "[" (Dum.showsStarSep ", " showsX_a113) "]"
Dum.showsParen :: ShowS -> ShowS
Dum.showsParen = Dum.showsSurround "(" id ")"
Dum.showsParenIf :: Bool -> ShowS -> ShowS
Dum.showsParenIf b_a114 xS_a115
  = if b_a114 then Dum.showsParen xS_a115 else xS_a115

type Dum.Shows x_aqI = x_aqI -> ShowS


["r_aHZ","showsConcat","showsString","showsChar","showsX_a10Q","safebang@!showsX_a10Q","(!showsX_a10Q)","xs_a10R","s_a10S","safebang@!s_a10S","(!s_a10S)","showsX_a10T","[]","![]","(![])","s_a10U","showsX_a10V","x_a10W","xs_a10X","!xs_a10X","(!xs_a10X)","x_a10W : (!xs_a10X)","(x_a10W : (!xs_a10X))","!(x_a10W : (!xs_a10X))","(!(x_a10W : (!xs_a10X)))","((!(x_a10W : (!xs_a10X))))","x'_a10Y","l_a10Z","showsX_a110","r_a111","x_a112","safebang@!x_a112","(!x_a112)","showsX_a113","safebang@!showsX_a113","(!showsX_a113)","showsParen","b_a114","xS_a115"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Parse
import Type

showsEmpty :: ShowS
showsEmpty r_aHZ = r_aHZ

showsConcat :: [ShowS] -> ShowS
showsConcat = foldr (.) showsEmpty

showsString :: Shows String
showsString = (++)

showsChar :: Shows Char
showsChar = (:)

showsStar :: Shows x_aHY -> Shows [x_aHY]
showsStar (!showsX_a10Q) xs_a10R
  = showsConcat (map showsX_a10Q xs_a10R)

showsStarSep :: String -> Shows x_aHX -> Shows [x_aHX]
showsStarSep (!s_a10S) showsX_a10T (investigate@[]) = showsEmpty
showsStarSep s_a10U showsX_a10V
  ((investigate@(x_a10W : (investigate@xs_a10X))))
  = showsX_a10V x_a10W .
      showsConcat
        [showString s_a10U . showsX_a10V x'_a10Y | x'_a10Y <- xs_a10X]

showsSurround :: String -> Shows x_aHW -> String -> Shows x_aHW
showsSurround l_a10Z showsX_a110 r_a111 (!x_a112)
  = showString l_a10Z . showsX_a110 x_a112 . showString r_a111

showsListOf :: Shows x_aHV -> Shows [x_aHV]
showsListOf (!showsX_a113)
  = showsSurround "[" (showsStarSep ", " showsX_a113) "]"

showsParen :: ShowS -> ShowS
showsParen = showsSurround "(" id ")"

showsParenIf :: Bool -> ShowS -> ShowS
showsParenIf b_a114 xS_a115
  = if b_a114 then showsParen xS_a115 else xS_a115

type Shows x_aqI = x_aqI -> ShowS
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.rep (!(Dum.MkSX f_aqK)) = f_aqK
Dum.returnSX returnX_aqL (!x_aqM)
  = Dum.MkSX (\ s_aqN -> returnX_aqL (x_aqM, s_aqN))
Dum.eachSX (!eachX_aqO) xSX_aqP (!f_aqQ)
  = Dum.MkSX
      (\ s_aqR
         -> Dum.rep xSX_aqP s_aqR
            `eachX_aqO` (\ (!(x_aqS, s'_aqT)) -> (f_aqQ x_aqS, s'_aqT)))
Dum.thenSX (!thenX_aqU) xSX_aqV kSX_aqW
  = Dum.MkSX
      (\ s_aqX
         -> Dum.rep xSX_aqV s_aqX
            `thenX_aqU`
              (\ (!(x_aqY, s'_aqZ)) -> Dum.rep (kSX_aqW x_aqY) s'_aqZ))
Dum.toSX (!eachX_ar0) (!xX_ar1)
  = Dum.MkSX
      (\ s_ar2 -> xX_ar1 `eachX_ar0` (\ x_ar3 -> (x_ar3, s_ar2)))
Dum.putSX (!returnX_ar4) s'_ar5
  = Dum.MkSX (\ (!s_ar6) -> returnX_ar4 ((), s'_ar5))
Dum.getSX (!returnX_ar7)
  = Dum.MkSX (\ s_ar8 -> returnX_ar7 (s_ar8, s_ar8))
Dum.useSX (!eachX_ar9) s_ara xSX_arb
  = Dum.rep xSX_arb s_ara
    `eachX_ar9` (\ (!(x_arc, (!s'_ard))) -> x_arc)

data Dum.StateX s_aqI a_aqJ = Dum.MkSX (s_aqI -> a_aqJ)


["f_aqK","MkSX f_aqK","(MkSX f_aqK)","!(MkSX f_aqK)","(!(MkSX f_aqK))","returnX_aqL","x_aqM","safebang@!x_aqM","(!x_aqM)","s_aqN","eachX_aqO","safebang@!eachX_aqO","(!eachX_aqO)","xSX_aqP","f_aqQ","safebang@!f_aqQ","(!f_aqQ)","s_aqR","x_aqS","s'_aqT","(x_aqS, s'_aqT)","!(x_aqS, s'_aqT)","(!(x_aqS, s'_aqT))","thenX_aqU","safebang@!thenX_aqU","(!thenX_aqU)","xSX_aqV","kSX_aqW","s_aqX","x_aqY","s'_aqZ","(x_aqY, s'_aqZ)","!(x_aqY, s'_aqZ)","(!(x_aqY, s'_aqZ))","eachX_ar0","safebang@!eachX_ar0","(!eachX_ar0)","xX_ar1","safebang@!xX_ar1","(!xX_ar1)","s_ar2","x_ar3","returnX_ar4","safebang@!returnX_ar4","(!returnX_ar4)","s'_ar5","s_ar6","safebang@!s_ar6","(!s_ar6)","returnX_ar7","safebang@!returnX_ar7","(!returnX_ar7)","s_ar8","eachX_ar9","safebang@!eachX_ar9","(!eachX_ar9)","s_ara","xSX_arb","x_arc","s'_ard","safebang@!s'_ard","(!s'_ard)","(x_arc, (!s'_ard))","!(x_arc, (!s'_ard))","(!(x_arc, (!s'_ard)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
rep (investigate@(MkSX f_aqK)) = f_aqK
returnSX returnX_aqL (!x_aqM)
  = MkSX (\ s_aqN -> returnX_aqL (x_aqM, s_aqN))
eachSX (!eachX_aqO) xSX_aqP (!f_aqQ)
  = MkSX
      (\ s_aqR ->
         rep xSX_aqP s_aqR `eachX_aqO`
           (\ (investigate@(x_aqS, s'_aqT)) -> (f_aqQ x_aqS, s'_aqT)))
thenSX (!thenX_aqU) xSX_aqV kSX_aqW
  = MkSX
      (\ s_aqX ->
         rep xSX_aqV s_aqX `thenX_aqU`
           (\ (investigate@(x_aqY, s'_aqZ)) -> rep (kSX_aqW x_aqY) s'_aqZ))
toSX (!eachX_ar0) (!xX_ar1)
  = MkSX (\ s_ar2 -> xX_ar1 `eachX_ar0` (\ x_ar3 -> (x_ar3, s_ar2)))
putSX (!returnX_ar4) s'_ar5
  = MkSX (\ (!s_ar6) -> returnX_ar4 ((), s'_ar5))
getSX (!returnX_ar7) = MkSX (\ s_ar8 -> returnX_ar7 (s_ar8, s_ar8))
useSX (!eachX_ar9) s_ara xSX_arb
  = rep xSX_arb s_ara `eachX_ar9`
      (\ (investigate@(x_arc, (!s'_ard))) -> x_arc)

data StateX s_aqI a_aqJ = MkSX (s_aqI -> a_aqJ)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.rep (!(Dum.MkSX f_aqK)) = f_aqK
Dum.returnSX returnX_aqL (!x_aqM)
  = Dum.MkSX (\ s_aqN -> returnX_aqL (x_aqM, s_aqN))
Dum.eachSX (!eachX_aqO) xSX_aqP (!f_aqQ)
  = Dum.MkSX
      (\ s_aqR
         -> Dum.rep xSX_aqP s_aqR
            `eachX_aqO` (\ (!(x_aqS, s'_aqT)) -> (f_aqQ x_aqS, s'_aqT)))
Dum.thenSX (!thenX_aqU) xSX_aqV kSX_aqW
  = Dum.MkSX
      (\ s_aqX
         -> Dum.rep xSX_aqV s_aqX
            `thenX_aqU`
              (\ (!(x_aqY, s'_aqZ)) -> Dum.rep (kSX_aqW x_aqY) s'_aqZ))
Dum.toSX (!eachX_ar0) (!xX_ar1)
  = Dum.MkSX
      (\ s_ar2 -> xX_ar1 `eachX_ar0` (\ x_ar3 -> (x_ar3, s_ar2)))
Dum.putSX (!returnX_ar4) s'_ar5
  = Dum.MkSX (\ (!s_ar6) -> returnX_ar4 ((), s'_ar5))
Dum.getSX (!returnX_ar7)
  = Dum.MkSX (\ s_ar8 -> returnX_ar7 (s_ar8, s_ar8))
Dum.useSX (!eachX_ar9) s_ara xSX_arb
  = Dum.rep xSX_arb s_ara
    `eachX_ar9` (\ (!(x_arc, (!s'_ard))) -> x_arc)

data Dum.StateX s_aqI a_aqJ = Dum.MkSX (s_aqI -> a_aqJ)


["f_aqK","MkSX f_aqK","(MkSX f_aqK)","!(MkSX f_aqK)","(!(MkSX f_aqK))","returnX_aqL","x_aqM","safebang@!x_aqM","(!x_aqM)","s_aqN","eachX_aqO","safebang@!eachX_aqO","(!eachX_aqO)","xSX_aqP","f_aqQ","safebang@!f_aqQ","(!f_aqQ)","s_aqR","x_aqS","s'_aqT","(x_aqS, s'_aqT)","!(x_aqS, s'_aqT)","(!(x_aqS, s'_aqT))","thenX_aqU","safebang@!thenX_aqU","(!thenX_aqU)","xSX_aqV","kSX_aqW","s_aqX","x_aqY","s'_aqZ","(x_aqY, s'_aqZ)","!(x_aqY, s'_aqZ)","(!(x_aqY, s'_aqZ))","eachX_ar0","safebang@!eachX_ar0","(!eachX_ar0)","xX_ar1","safebang@!xX_ar1","(!xX_ar1)","s_ar2","x_ar3","returnX_ar4","safebang@!returnX_ar4","(!returnX_ar4)","s'_ar5","s_ar6","safebang@!s_ar6","(!s_ar6)","returnX_ar7","safebang@!returnX_ar7","(!returnX_ar7)","s_ar8","eachX_ar9","safebang@!eachX_ar9","(!eachX_ar9)","s_ara","xSX_arb","x_arc","s'_ard","safebang@!s'_ard","(!s'_ard)","(x_arc, (!s'_ard))","!(x_arc, (!s'_ard))","(!(x_arc, (!s'_ard)))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Digraph
rep (investigate@(MkSX f_aqK)) = f_aqK
returnSX returnX_aqL (!x_aqM)
  = MkSX (\ s_aqN -> returnX_aqL (x_aqM, s_aqN))
eachSX (!eachX_aqO) xSX_aqP (!f_aqQ)
  = MkSX
      (\ s_aqR ->
         rep xSX_aqP s_aqR `eachX_aqO`
           (\ (investigate@(x_aqS, s'_aqT)) -> (f_aqQ x_aqS, s'_aqT)))
thenSX (!thenX_aqU) xSX_aqV kSX_aqW
  = MkSX
      (\ s_aqX ->
         rep xSX_aqV s_aqX `thenX_aqU`
           (\ (investigate@(x_aqY, s'_aqZ)) -> rep (kSX_aqW x_aqY) s'_aqZ))
toSX (!eachX_ar0) (!xX_ar1)
  = MkSX (\ s_ar2 -> xX_ar1 `eachX_ar0` (\ x_ar3 -> (x_ar3, s_ar2)))
putSX (!returnX_ar4) s'_ar5
  = MkSX (\ (!s_ar6) -> returnX_ar4 ((), s'_ar5))
getSX (!returnX_ar7) = MkSX (\ s_ar8 -> returnX_ar7 (s_ar8, s_ar8))
useSX (!eachX_ar9) s_ara xSX_arb
  = rep xSX_arb s_ara `eachX_ar9`
      (\ (investigate@(x_arc, (!s'_ard))) -> x_arc)

data StateX s_aqI a_aqJ = MkSX (s_aqI -> a_aqJ)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.stronglyConnComp ::
  Eq vertex_a1mo =>
  [Dum.Edge vertex_a1mo] -> [vertex_a1mo] -> [[vertex_a1mo]]
Dum.stronglyConnComp es_a1mp (!vs_a1mq)
  = snd
      (span_tree_a1mu
         (new_range_a1mt reversed_edges_a1mr)
         ([], [])
         (snd (Dum.dfs (new_range_a1mt es_a1mp) ([], []) vs_a1mq)))
  where
      (!reversed_edges_a1mr) = map swap_a1ms es_a1mp
      swap_a1ms (x_a1mv, (!y_a1mw)) = (y_a1mw, x_a1mv)
      new_range_a1mt [] (!w_a1mx) = []
      new_range_a1mt ((!(((!x_a1my), y_a1mz) : xys_a1mA))) w_a1tF
        = if x_a1my == w_a1tF then
              (y_a1mz : (new_range_a1mt xys_a1mA w_a1tF))
          else
              (new_range_a1mt xys_a1mA w_a1tF)
      span_tree_a1mu (!r_a1tG) ((!vs_a1tH), ns_a1tI) []
        = (vs_a1tH, ns_a1tI)
      span_tree_a1mu
        r_a1tJ
        (!((!vs_a1tK), (!ns_a1tL)))
        (!((!(x_a1tM : (!xs_a1tN)))))
        | x_a1tM `elem` vs_a1tK
        = span_tree_a1mu r_a1tJ (vs_a1tK, ns_a1tL) xs_a1tN
        | True
        = span_tree_a1mu
            r_a1tJ (vs'_a1tO, (x_a1tM : ns'_a1tP) : ns_a1tL) xs_a1tN
        where
            (vs'_a1tO, ns'_a1tP)
              = Dum.dfs r_a1tJ (x_a1tM : vs_a1tK, []) (r_a1tJ x_a1tM)
Dum.dfs ::
  Eq v_aqE =>
  (v_aqE -> [v_aqE])
  -> ([v_aqE], [v_aqE]) -> [v_aqE] -> ([v_aqE], [v_aqE])
Dum.dfs (!r_a1MS) ((!vs_a1MT), (!ns_a1MU)) (![])
  = (vs_a1MT, ns_a1MU)
Dum.dfs r_a1MV ((!vs_a1MW), ns_a1MX) (x_a1MY : (!xs_a1MZ))
  | x_a1MY `elem` vs_a1MW = Dum.dfs r_a1MV (vs_a1MW, ns_a1MX) xs_a1MZ
  | True
  = Dum.dfs r_a1MV (vs'_a1N0, (x_a1MY : ns'_a1N1) ++ ns_a1MX) xs_a1MZ
  where
      ((!vs'_a1N0), ns'_a1N1)
        = Dum.dfs r_a1MV (x_a1MY : vs_a1MW, []) (r_a1MV x_a1MY)

type Dum.Edge vertex_aqD = (vertex_aqD, vertex_aqD)
type Dum.Cycle vertex_aqC = [vertex_aqC]


["es_a1mp","vs_a1mq","safebang@!vs_a1mq","(!vs_a1mq)","reversed_edges_a1mr","!reversed_edges_a1mr","(!reversed_edges_a1mr)","x_a1mv","y_a1mw","safebang@!y_a1mw","(!y_a1mw)","(x_a1mv, (!y_a1mw))","[]","w_a1mx","!w_a1mx","(!w_a1mx)","x_a1my","safebang@!x_a1my","(!x_a1my)","y_a1mz","((!x_a1my), y_a1mz)","xys_a1mA","((!x_a1my), y_a1mz) : xys_a1mA","(((!x_a1my), y_a1mz) : xys_a1mA)","!(((!x_a1my), y_a1mz) : xys_a1mA)","(!(((!x_a1my), y_a1mz) : xys_a1mA))","((!(((!x_a1my), y_a1mz) : xys_a1mA)))","w_a1tF","r_a1tG","safebang@!r_a1tG","(!r_a1tG)","vs_a1tH","safebang@!vs_a1tH","(!vs_a1tH)","ns_a1tI","((!vs_a1tH), ns_a1tI)","[]","r_a1tJ","vs_a1tK","!vs_a1tK","(!vs_a1tK)","ns_a1tL","!ns_a1tL","(!ns_a1tL)","((!vs_a1tK), (!ns_a1tL))","!((!vs_a1tK), (!ns_a1tL))","(!((!vs_a1tK), (!ns_a1tL)))","x_a1tM","xs_a1tN","!xs_a1tN","(!xs_a1tN)","x_a1tM : (!xs_a1tN)","(x_a1tM : (!xs_a1tN))","!(x_a1tM : (!xs_a1tN))","(!(x_a1tM : (!xs_a1tN)))","((!(x_a1tM : (!xs_a1tN))))","!((!(x_a1tM : (!xs_a1tN))))","(!((!(x_a1tM : (!xs_a1tN)))))","vs'_a1tO","ns'_a1tP","(vs'_a1tO, ns'_a1tP)","r_a1MS","safebang@!r_a1MS","(!r_a1MS)","vs_a1MT","safebang@!vs_a1MT","(!vs_a1MT)","ns_a1MU","safebang@!ns_a1MU","(!ns_a1MU)","((!vs_a1MT), (!ns_a1MU))","[]","![]","(![])","r_a1MV","vs_a1MW","!vs_a1MW","(!vs_a1MW)","ns_a1MX","((!vs_a1MW), ns_a1MX)","x_a1MY","xs_a1MZ","!xs_a1MZ","(!xs_a1MZ)","x_a1MY : (!xs_a1MZ)","(x_a1MY : (!xs_a1MZ))","vs'_a1N0","!vs'_a1N0","(!vs'_a1N0)","ns'_a1N1","((!vs'_a1N0), ns'_a1N1)"]
{-# LANGUAGE BangPatterns #-}
module Dum where

stronglyConnComp ::
                   Eq vertex_a1mo =>
                   [Edge vertex_a1mo] -> [vertex_a1mo] -> [[vertex_a1mo]]
stronglyConnComp es_a1mp (!vs_a1mq)
  = snd
      (span_tree_a1mu (new_range_a1mt reversed_edges_a1mr) ([], [])
         (snd (dfs (new_range_a1mt es_a1mp) ([], []) vs_a1mq)))
  where (investigate@reversed_edges_a1mr) = map swap_a1ms es_a1mp
        swap_a1ms (x_a1mv, (!y_a1mw)) = (y_a1mw, x_a1mv)
        new_range_a1mt [] (investigate@w_a1mx) = []
        new_range_a1mt ((investigate@(((!x_a1my), y_a1mz) : xys_a1mA)))
          w_a1tF
          = if x_a1my == w_a1tF then
              (y_a1mz : (new_range_a1mt xys_a1mA w_a1tF)) else
              (new_range_a1mt xys_a1mA w_a1tF)
        span_tree_a1mu (!r_a1tG) ((!vs_a1tH), ns_a1tI) []
          = (vs_a1tH, ns_a1tI)
        span_tree_a1mu r_a1tJ
          (investigate@((investigate@vs_a1tK), (investigate@ns_a1tL)))
          (investigate@((investigate@(x_a1tM : (investigate@xs_a1tN)))))
          | x_a1tM `elem` vs_a1tK =
            span_tree_a1mu r_a1tJ (vs_a1tK, ns_a1tL) xs_a1tN
          | True =
            span_tree_a1mu r_a1tJ (vs'_a1tO, (x_a1tM : ns'_a1tP) : ns_a1tL)
              xs_a1tN
          where (vs'_a1tO, ns'_a1tP)
                  = dfs r_a1tJ (x_a1tM : vs_a1tK, []) (r_a1tJ x_a1tM)

dfs ::
      Eq v_aqE =>
      (v_aqE -> [v_aqE]) ->
        ([v_aqE], [v_aqE]) -> [v_aqE] -> ([v_aqE], [v_aqE])
dfs (!r_a1MS) ((!vs_a1MT), (!ns_a1MU)) (investigate@[])
  = (vs_a1MT, ns_a1MU)
dfs r_a1MV ((investigate@vs_a1MW), ns_a1MX)
  (x_a1MY : (investigate@xs_a1MZ))
  | x_a1MY `elem` vs_a1MW = dfs r_a1MV (vs_a1MW, ns_a1MX) xs_a1MZ
  | True =
    dfs r_a1MV (vs'_a1N0, (x_a1MY : ns'_a1N1) ++ ns_a1MX) xs_a1MZ
  where ((investigate@vs'_a1N0), ns'_a1N1)
          = dfs r_a1MV (x_a1MY : vs_a1MW, []) (r_a1MV x_a1MY)

type Edge vertex_aqD = (vertex_aqD, vertex_aqD)

type Cycle vertex_aqC = [vertex_aqC]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.repTree ::
  (a_aHK -> [a_aHK])
  -> (a_aHK -> [a_aHK]) -> a_aHK -> (Dum.Tree a_aHK)
Dum.repTree f_aHL g_aHM (!a_aHN)
  = Dum.Branch a_aHN (map (Dum.repTree g_aHM f_aHL) (f_aHL a_aHN))
Dum.mapTree ::
  (a_aHI -> b_aHJ) -> (Dum.Tree a_aHI) -> (Dum.Tree b_aHJ)
Dum.mapTree (!f_aHO) (!((!(Dum.Branch a_aHP (!l_aHQ)))))
  = Dum.Branch (f_aHO a_aHP) (map (Dum.mapTree f_aHO) l_aHQ)
Dum.prune :: Int -> (Dum.Tree a_aAD) -> (Dum.Tree a_aAD)
Dum.prune 0 (!((!(Dum.Branch (!a_aHR) l_aHS))))
  = Dum.Branch a_aHR []
Dum.prune (!n_aHT) (!(Dum.Branch (!a_aHU) l_aHV))
  | n_aHT < 0 = error "Tree.prune: < 0"
  | otherwise = Dum.Branch a_aHU (map (Dum.prune (n_aHT - 1)) l_aHV)

data Dum.Tree a_aqu
  = Dum.Branch a_aqu [Dum.Tree a_aqu]
  deriving (Show)


["f_aHL","g_aHM","a_aHN","safebang@!a_aHN","(!a_aHN)","f_aHO","safebang@!f_aHO","(!f_aHO)","a_aHP","l_aHQ","!l_aHQ","(!l_aHQ)","Branch a_aHP (!l_aHQ)","(Branch a_aHP (!l_aHQ))","!(Branch a_aHP (!l_aHQ))","(!(Branch a_aHP (!l_aHQ)))","((!(Branch a_aHP (!l_aHQ))))","!((!(Branch a_aHP (!l_aHQ))))","(!((!(Branch a_aHP (!l_aHQ)))))","0","a_aHR","!a_aHR","(!a_aHR)","l_aHS","Branch (!a_aHR) l_aHS","(Branch (!a_aHR) l_aHS)","!(Branch (!a_aHR) l_aHS)","(!(Branch (!a_aHR) l_aHS))","((!(Branch (!a_aHR) l_aHS)))","!((!(Branch (!a_aHR) l_aHS)))","(!((!(Branch (!a_aHR) l_aHS))))","n_aHT","!n_aHT","(!n_aHT)","a_aHU","safebang@!a_aHU","(!a_aHU)","l_aHV","Branch (!a_aHU) l_aHV","(Branch (!a_aHU) l_aHV)","!(Branch (!a_aHU) l_aHV)","(!(Branch (!a_aHU) l_aHV))"]
{-# LANGUAGE BangPatterns #-}
module Dum where

repTree ::
        (a_aHK -> [a_aHK]) -> (a_aHK -> [a_aHK]) -> a_aHK -> (Tree a_aHK)
repTree f_aHL g_aHM (!a_aHN)
  = Branch a_aHN (map (repTree g_aHM f_aHL) (f_aHL a_aHN))

mapTree :: (a_aHI -> b_aHJ) -> (Tree a_aHI) -> (Tree b_aHJ)
mapTree (!f_aHO)
  (investigate@((investigate@(Branch a_aHP (investigate@l_aHQ)))))
  = Branch (f_aHO a_aHP) (map (mapTree f_aHO) l_aHQ)

prune :: Int -> (Tree a_aAD) -> (Tree a_aAD)
prune 0
  (investigate@((investigate@(Branch (investigate@a_aHR) l_aHS))))
  = Branch a_aHR []
prune (investigate@n_aHT) (investigate@(Branch (!a_aHU) l_aHV))
  | n_aHT < 0 = error "Tree.prune: < 0"
  | otherwise = Branch a_aHU (map (prune (n_aHT - 1)) l_aHV)

data Tree a_aqu = Branch a_aqu [Tree a_aqu]
                deriving Show
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.repTree ::
  (a_aHK -> [a_aHK])
  -> (a_aHK -> [a_aHK]) -> a_aHK -> (Dum.Tree a_aHK)
Dum.repTree f_aHL g_aHM (!a_aHN)
  = Dum.Branch a_aHN (map (Dum.repTree g_aHM f_aHL) (f_aHL a_aHN))
Dum.mapTree ::
  (a_aHI -> b_aHJ) -> (Dum.Tree a_aHI) -> (Dum.Tree b_aHJ)
Dum.mapTree (!f_aHO) (!((!(Dum.Branch a_aHP (!l_aHQ)))))
  = Dum.Branch (f_aHO a_aHP) (map (Dum.mapTree f_aHO) l_aHQ)
Dum.prune :: Int -> (Dum.Tree a_aAD) -> (Dum.Tree a_aAD)
Dum.prune 0 (!((!(Dum.Branch (!a_aHR) l_aHS))))
  = Dum.Branch a_aHR []
Dum.prune (!n_aHT) (!(Dum.Branch (!a_aHU) l_aHV))
  | n_aHT < 0 = error "Tree.prune: < 0"
  | otherwise = Dum.Branch a_aHU (map (Dum.prune (n_aHT - 1)) l_aHV)

data Dum.Tree a_aqu
  = Dum.Branch a_aqu [Dum.Tree a_aqu]
  deriving (Show)


["f_aHL","g_aHM","a_aHN","safebang@!a_aHN","(!a_aHN)","f_aHO","safebang@!f_aHO","(!f_aHO)","a_aHP","l_aHQ","!l_aHQ","(!l_aHQ)","Branch a_aHP (!l_aHQ)","(Branch a_aHP (!l_aHQ))","!(Branch a_aHP (!l_aHQ))","(!(Branch a_aHP (!l_aHQ)))","((!(Branch a_aHP (!l_aHQ))))","!((!(Branch a_aHP (!l_aHQ))))","(!((!(Branch a_aHP (!l_aHQ)))))","0","a_aHR","!a_aHR","(!a_aHR)","l_aHS","Branch (!a_aHR) l_aHS","(Branch (!a_aHR) l_aHS)","!(Branch (!a_aHR) l_aHS)","(!(Branch (!a_aHR) l_aHS))","((!(Branch (!a_aHR) l_aHS)))","!((!(Branch (!a_aHR) l_aHS)))","(!((!(Branch (!a_aHR) l_aHS))))","n_aHT","!n_aHT","(!n_aHT)","a_aHU","safebang@!a_aHU","(!a_aHU)","l_aHV","Branch (!a_aHU) l_aHV","(Branch (!a_aHU) l_aHV)","!(Branch (!a_aHU) l_aHV)","(!(Branch (!a_aHU) l_aHV))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Prog (prog)

repTree ::
        (a_aHK -> [a_aHK]) -> (a_aHK -> [a_aHK]) -> a_aHK -> (Tree a_aHK)
repTree f_aHL g_aHM (!a_aHN)
  = Branch a_aHN (map (repTree g_aHM f_aHL) (f_aHL a_aHN))

mapTree :: (a_aHI -> b_aHJ) -> (Tree a_aHI) -> (Tree b_aHJ)
mapTree (!f_aHO)
  (investigate@((investigate@(Branch a_aHP (investigate@l_aHQ)))))
  = Branch (f_aHO a_aHP) (map (mapTree f_aHO) l_aHQ)

prune :: Int -> (Tree a_aAD) -> (Tree a_aAD)
prune 0
  (investigate@((investigate@(Branch (investigate@a_aHR) l_aHS))))
  = Branch a_aHR []
prune (investigate@n_aHT) (investigate@(Branch (!a_aHU) l_aHV))
  | n_aHT < 0 = error "Tree.prune: < 0"
  | otherwise = Branch a_aHU (map (prune (n_aHT - 1)) l_aHV)

data Tree a_aqu = Branch a_aqu [Tree a_aqu]
                deriving Show
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.wins :: [Dum.Win]
Dum.wins
  = [Dum.win1, Dum.win2, Dum.win3, Dum.win4, Dum.win5, Dum.win6,
     Dum.win7, Dum.win8]
Dum.win1, Dum.win2, Dum.win3, Dum.win4, Dum.win5, Dum.win6, Dum.win7, Dum.win8 ::
  Dum.Win
Dum.win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
Dum.win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
Dum.win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
Dum.win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
Dum.win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
Dum.win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
Dum.win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
Dum.win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Dum.Win = [[Int]]


["wins","win1","win2","win3","win4","win5","win6","win7","win8"]
{-# LANGUAGE BangPatterns #-}
module Dum where

wins :: [Win]
wins = [win1, win2, win3, win4, win5, win6, win7, win8]

win1, win2, win3, win4, win5, win6, win7, win8 :: Win
win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Win = [[Int]]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.wins :: [Dum.Win]
Dum.wins
  = [Dum.win1, Dum.win2, Dum.win3, Dum.win4, Dum.win5, Dum.win6,
     Dum.win7, Dum.win8]
Dum.win1, Dum.win2, Dum.win3, Dum.win4, Dum.win5, Dum.win6, Dum.win7, Dum.win8 ::
  Dum.Win
Dum.win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
Dum.win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
Dum.win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
Dum.win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
Dum.win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
Dum.win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
Dum.win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
Dum.win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Dum.Win = [[Int]]


["wins","win1","win2","win3","win4","win5","win6","win7","win8"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Board
import Wins
import Game
import Tree

wins :: [Win]
wins = [win1, win2, win3, win4, win5, win6, win7, win8]

win1, win2, win3, win4, win5, win6, win7, win8 :: Win
win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Win = [[Int]]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.wins :: [Dum.Win]
Dum.wins
  = [Dum.win1, Dum.win2, Dum.win3, Dum.win4, Dum.win5, Dum.win6,
     Dum.win7, Dum.win8]
Dum.win1, Dum.win2, Dum.win3, Dum.win4, Dum.win5, Dum.win6, Dum.win7, Dum.win8 ::
  Dum.Win
Dum.win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
Dum.win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
Dum.win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
Dum.win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
Dum.win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
Dum.win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
Dum.win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
Dum.win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Dum.Win = [[Int]]


["wins","win1","win2","win3","win4","win5","win6","win7","win8"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Board
import Wins
import Tree

wins :: [Win]
wins = [win1, win2, win3, win4, win5, win6, win7, win8]

win1, win2, win3, win4, win5, win6, win7, win8 :: Win
win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Win = [[Int]]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.wins :: [Dum.Win]
Dum.wins
  = [Dum.win1, Dum.win2, Dum.win3, Dum.win4, Dum.win5, Dum.win6,
     Dum.win7, Dum.win8]
Dum.win1, Dum.win2, Dum.win3, Dum.win4, Dum.win5, Dum.win6, Dum.win7, Dum.win8 ::
  Dum.Win
Dum.win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
Dum.win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
Dum.win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
Dum.win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
Dum.win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
Dum.win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
Dum.win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
Dum.win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Dum.Win = [[Int]]


["wins","win1","win2","win3","win4","win5","win6","win7","win8"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Wins

wins :: [Win]
wins = [win1, win2, win3, win4, win5, win6, win7, win8]

win1, win2, win3, win4, win5, win6, win7, win8 :: Win
win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Win = [[Int]]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.wins :: [Dum.Win]
Dum.wins
  = [Dum.win1, Dum.win2, Dum.win3, Dum.win4, Dum.win5, Dum.win6,
     Dum.win7, Dum.win8]
Dum.win1, Dum.win2, Dum.win3, Dum.win4, Dum.win5, Dum.win6, Dum.win7, Dum.win8 ::
  Dum.Win
Dum.win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
Dum.win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
Dum.win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
Dum.win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
Dum.win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
Dum.win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
Dum.win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
Dum.win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Dum.Win = [[Int]]


["wins","win1","win2","win3","win4","win5","win6","win7","win8"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Lisplikefns

wins :: [Win]
wins = [win1, win2, win3, win4, win5, win6, win7, win8]

win1, win2, win3, win4, win5, win6, win7, win8 :: Win
win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Win = [[Int]]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.wins :: [Dum.Win]
Dum.wins
  = [Dum.win1, Dum.win2, Dum.win3, Dum.win4, Dum.win5, Dum.win6,
     Dum.win7, Dum.win8]
Dum.win1, Dum.win2, Dum.win3, Dum.win4, Dum.win5, Dum.win6, Dum.win7, Dum.win8 ::
  Dum.Win
Dum.win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
Dum.win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
Dum.win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
Dum.win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
Dum.win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
Dum.win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
Dum.win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
Dum.win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Dum.Win = [[Int]]


["wins","win1","win2","win3","win4","win5","win6","win7","win8"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Lisplikefns
import Rewritefns
import Rulebasetext
import Checker

wins :: [Win]
wins = [win1, win2, win3, win4, win5, win6, win7, win8]

win1, win2, win3, win4, win5, win6, win7, win8 :: Win
win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Win = [[Int]]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.rules :: [String]
Dum.rules
  = ["(equal (compile form)(reverse (codegen (optimize form) (nil) ) ) )",
     "(equal (eqp x y)(equal (fix x)(fix y) ) )",
     "(equal (greaterp x y)(lessp y x) )",
     "(equal (lesseqp x y)(not (lessp y x) ) )",
     "(equal (greatereqp x y)(not (lessp y x) ) )",
     "(equal (boolean x)(or (equal x (t) )(equal x (f) ) )",
     "(equal (iff x y)(and (implies x y)(implies y x) ) )",
     "(equal (even1 x)(if (zerop x)(t)(odd (1- x) ) ) )",
     "(equal (countps- l pred)(countps-loop l pred (zero) ) )",
     "(equal (fact- i)(fact-loop i 1) )",
     "(equal (reverse- x)(reverse-loop x (nil) ) )",
     "(equal (divides x y)(zerop (remainder y x) ) )",
     "(equal (assume-true var alist)(cons (cons var (t) )alist) )",
     "(equal (assume-false var alist)(cons (cons var (f) )alist) )",
     "(equal (tautology-checker x)(tautologyp (normalize x)(nil) ) )",
     "(equal (falsify x)(falsify1 (normalize x)(nil) ) )",
     "(equal (prime x)(and (not (zerop x))(not (equal x (add1 (zero) ) ) )(prime1 x (1- x) ) ) )",
     "(equal (and p q)(if p (if q (t) (f) ) (f) ) )",
     "(equal (or p q)(if p (t) (if q (t) (f) ) ) )",
     "(equal (not p)(if p (f) (t) ) )",
     "(equal (implies p q)(if p (if q (t) (f) ) (t) ) )",
     "(equal (fix x)(if (numberp x) x (zero) ) )",
     "(equal (if (if a b c) d e)(if a (if b d e) (if c d e) ) )",
     "(equal (zerop x)(or (equal x (zero) )(not (numberp x) ) ) )",
     "(equal (plus (plus x y) z )(plus x (plus y z) ) )",
     "(equal (equal (plus a b) (zero ) )(and (zerop a) (zerop b) ) )",
     "(equal (difference x x)(zero) )",
     "(equal (equal (plus a b) (plus a c) )(equal (fix b) (fix c) ) )",
     "(equal (equal (zero) (difference x y) )(not (lessp y x) ) )",
     "(equal (equal x (difference x y) )(and (numberp x)(or (equal x (zero) )(zerop y) ) ) )",
     "(equal (meaning (plus-tree (append x y) ) a)(plus (meaning (plus-tree x) a)(meaning (plus-tree y) a) ) )",
     "(equal (meaning (plus-tree (plus-fringe x) ) a)(fix (meaning x a) ) )",
     "(equal (append (append x y) z)(append x (append y z) ) )",
     "(equal (reverse (append a b) )(append (reverse b) (reverse a) ) )",
     "(equal (times x (plus y z) )(plus (times x y)(times x z) ) )",
     "(equal (times (times x y) z)(times x (times y z) ) )",
     "(equal (equal (times x y) (zero) )(or (zerop x)(zerop y) ) )",
     "(equal (exec (append x y)pds envrn)(exec y (exec x pds envrn)envrn) )",
     "(equal (mc-flatten x y)(append (flatten x)y) )",
     "(equal (member x (append a b) )(or (member x a)(member x b) ) )",
     "(equal (member x (reverse y) )(member x y) )",
     "(equal (length (reverse x) )(length x) )",
     "(equal (member a (intersect b c) )(and (member a b)(member a c) ) )",
     "(equal (nth (zero)i)(zero) )",
     "(equal (exp i (plus j k) )(times (exp i j)(exp i k) ) )",
     "(equal (exp i (times j k) )(exp (exp i j)k) )",
     "(equal (reverse-loop x y)(append (reverse x)y) )",
     "(equal (reverse-loop x (nil) )(reverse x) )",
     "(equal (count-list z (sort-lp x y) )(plus (count-list z x)(count-list z y) ) )",
     "(equal (equal (append a b)(append a c) )(equal b c) )",
     "(equal (plus (remainder x y)(times y (quotient x y) ) )(fix x) )",
     "(equal (power-eval (big-plus1 l i base)base)(plus (power-eval l base)i) )",
     "(equal (power-eval (big-plus x y i base)base)(plus i (plus (power-eval x base)(power-eval y base) ) ) )",
     "(equal (remainder y 1)(zero) )",
     "(equal (lessp (remainder x y)y)(not (zerop y) ) )",
     "(equal (remainder x x)(zero) )",
     "(equal (lessp (quotient i j)i)(and (not (zerop i) )(or (zerop j)(not (equal j 1) ) ) ) )",
     "(equal (lessp (remainder x y)x)(and (not (zerop y) )(not (zerop x) )(not (lessp x y) ) ) )",
     "(equal (power-eval (power-rep i base)base)(fix i) )",
     "(equal (power-eval (big-plus (power-rep i base)(power-rep j base)(zero)base)base)(plus i j) )",
     "(equal (gcd x y)(gcd y x) )",
     "(equal (nth (append a b)i)(append (nth a i)(nth b (difference i (length a) ) ) ) )",
     "(equal (difference (plus x y)x)(fix y) )",
     "(equal (difference (plus y x)x)(fix y) )",
     "(equal (difference (plus x y)(plus x z) )(difference y z) )",
     "(equal (times x (difference c w) )(difference (times c x)(times w x) ) )",
     "(equal (remainder (times x z)z)(zero) )",
     "(equal (difference (plus b (plus a c) )a)(plus b c) )",
     "(equal (difference (add1 (plus y z)z)(add1 y) )",
     "(equal (lessp (plus x y)(plus x z ) )(lessp y z) )",
     "(equal (lessp (times x z)(times y z) )(and (not (zerop z) )(lessp x y) ) )",
     "(equal (lessp y (plus x y) )(not (zerop x) ) )",
     "(equal (gcd (times x z)(times y z) )(times z (gcd x y) ) )",
     "(equal (value (normalize x)a)(value x a) )",
     "(equal (equal (flatten x)(cons y (nil) ) )(and (nlistp x)(equal x y) ) )",
     "(equal (listp (gopher x) )(listp x) )",
     "(equal (samefringe x y)(equal (flatten x)(flatten y) ) )",
     "(equal (equal (greatest-factor x y)(zero) )(and (or (zerop y)(equal y 1) )(equal x (zero) ) ) )",
     "(equal (equal (greatest-factor x y)1)(equal x 1) )",
     "(equal (numberp (greatest-factor x y) )(not (and (or (zerop y)(equal y 1) )(not (numberp x) ) ) ) )",
     "(equal (times-list (append x y) )(times (times-list x)(times-list y) ) )",
     "(equal (prime-list (append x y) )(and (prime-list x)(prime-list y) ) )",
     "(equal (equal z (times w z) )(and (numberp z)(or (equal z (zero) )(equal w 1) ) ) )",
     "(equal (greatereqpr x y)(not (lessp x y) ) )",
     "(equal (equal x (times x y) )(or (equal x (zero) )(and (numberp x)(equal y 1) ) ) )",
     "(equal (remainder (times y x)y)(zero) )",
     "(equal (equal (times a b)1)(and (not (equal a (zero) ) )(not (equal b (zero) ) )(numberp a)(numberp b)(equal (1- a)(zero) )(equal (1- b)(zero) ) ) )",
     "(equal (lessp (length (delete x l) )(length l) )(member x l) )",
     "(equal (sort2 (delete x l) )(delete x (sort2 l) ) )",
     "(equal (dsort x)(sort2 x) )",
     "(equal (length(cons x1(cons x2(cons x3(cons x4(cons x5(cons x6 x7) ) ) ) ) ) )(plus 6 (length x7) ) )",
     "(equal (difference (add1 (add1 x) )2)(fix x) )",
     "(equal (quotient (plus x (plus x y) )2)(plus x (quotient y 2) ) )",
     "(equal (sigma (zero)i)(quotient (times i (add1 i) )2) )",
     "(equal (plus x (add1 y) )(if (numberp y)(add1 (plus x y) )(add1 x) ) )",
     "(equal (equal (difference x y)(difference z y) )(if (lessp x y)(not (lessp y z) )(if (lessp z y)(not (lessp y x) )(equal (fix x)(fix z) ) ) ) )",
     "(equal (meaning (plus-tree (delete x y) )a)(if (member x y)(difference (meaning (plus-tree y)a)(meaning x a) )(meaning (plus-tree y)a) ) )",
     "(equal (times x (add1 y) )(if (numberp y)(plus x (times x y) )(fix x) ) )",
     "(equal (nth (nil)i)(if (zerop i)(nil)(zero) ) )",
     "(equal (last (append a b) )(if (listp b)(last b)(if (listp a)(cons (car (last a) )b)b) ) )",
     "(equal (equal (lessp x y)z)(if (lessp x y)(equal t z)(equal f z) ) )",
     "(equal (assignment x (append a b) )(if (assignedp x a)(assignment x a)(assignment x b) ) )",
     "(equal (car (gopher x) )(if (listp x)(car (flatten x) )(zero) ) )",
     "(equal (flatten (cdr (gopher x) ) )(if (listp x)(cdr (flatten x) )(cons (zero)(nil) ) ) )",
     "(equal (quotient (times y x)y)(if (zerop y)(zero)(fix x) ) )",
     "(equal (get j (set i val mem) )(if (eqp j i)val(get j mem) ) )"]


["rules"]
{-# LANGUAGE BangPatterns #-}
module Dum where

rules :: [String]
rules
  = ["(equal (compile form)(reverse (codegen (optimize form) (nil) ) ) )",
     "(equal (eqp x y)(equal (fix x)(fix y) ) )",
     "(equal (greaterp x y)(lessp y x) )",
     "(equal (lesseqp x y)(not (lessp y x) ) )",
     "(equal (greatereqp x y)(not (lessp y x) ) )",
     "(equal (boolean x)(or (equal x (t) )(equal x (f) ) )",
     "(equal (iff x y)(and (implies x y)(implies y x) ) )",
     "(equal (even1 x)(if (zerop x)(t)(odd (1- x) ) ) )",
     "(equal (countps- l pred)(countps-loop l pred (zero) ) )",
     "(equal (fact- i)(fact-loop i 1) )",
     "(equal (reverse- x)(reverse-loop x (nil) ) )",
     "(equal (divides x y)(zerop (remainder y x) ) )",
     "(equal (assume-true var alist)(cons (cons var (t) )alist) )",
     "(equal (assume-false var alist)(cons (cons var (f) )alist) )",
     "(equal (tautology-checker x)(tautologyp (normalize x)(nil) ) )",
     "(equal (falsify x)(falsify1 (normalize x)(nil) ) )",
     "(equal (prime x)(and (not (zerop x))(not (equal x (add1 (zero) ) ) )(prime1 x (1- x) ) ) )",
     "(equal (and p q)(if p (if q (t) (f) ) (f) ) )",
     "(equal (or p q)(if p (t) (if q (t) (f) ) ) )",
     "(equal (not p)(if p (f) (t) ) )",
     "(equal (implies p q)(if p (if q (t) (f) ) (t) ) )",
     "(equal (fix x)(if (numberp x) x (zero) ) )",
     "(equal (if (if a b c) d e)(if a (if b d e) (if c d e) ) )",
     "(equal (zerop x)(or (equal x (zero) )(not (numberp x) ) ) )",
     "(equal (plus (plus x y) z )(plus x (plus y z) ) )",
     "(equal (equal (plus a b) (zero ) )(and (zerop a) (zerop b) ) )",
     "(equal (difference x x)(zero) )",
     "(equal (equal (plus a b) (plus a c) )(equal (fix b) (fix c) ) )",
     "(equal (equal (zero) (difference x y) )(not (lessp y x) ) )",
     "(equal (equal x (difference x y) )(and (numberp x)(or (equal x (zero) )(zerop y) ) ) )",
     "(equal (meaning (plus-tree (append x y) ) a)(plus (meaning (plus-tree x) a)(meaning (plus-tree y) a) ) )",
     "(equal (meaning (plus-tree (plus-fringe x) ) a)(fix (meaning x a) ) )",
     "(equal (append (append x y) z)(append x (append y z) ) )",
     "(equal (reverse (append a b) )(append (reverse b) (reverse a) ) )",
     "(equal (times x (plus y z) )(plus (times x y)(times x z) ) )",
     "(equal (times (times x y) z)(times x (times y z) ) )",
     "(equal (equal (times x y) (zero) )(or (zerop x)(zerop y) ) )",
     "(equal (exec (append x y)pds envrn)(exec y (exec x pds envrn)envrn) )",
     "(equal (mc-flatten x y)(append (flatten x)y) )",
     "(equal (member x (append a b) )(or (member x a)(member x b) ) )",
     "(equal (member x (reverse y) )(member x y) )",
     "(equal (length (reverse x) )(length x) )",
     "(equal (member a (intersect b c) )(and (member a b)(member a c) ) )",
     "(equal (nth (zero)i)(zero) )",
     "(equal (exp i (plus j k) )(times (exp i j)(exp i k) ) )",
     "(equal (exp i (times j k) )(exp (exp i j)k) )",
     "(equal (reverse-loop x y)(append (reverse x)y) )",
     "(equal (reverse-loop x (nil) )(reverse x) )",
     "(equal (count-list z (sort-lp x y) )(plus (count-list z x)(count-list z y) ) )",
     "(equal (equal (append a b)(append a c) )(equal b c) )",
     "(equal (plus (remainder x y)(times y (quotient x y) ) )(fix x) )",
     "(equal (power-eval (big-plus1 l i base)base)(plus (power-eval l base)i) )",
     "(equal (power-eval (big-plus x y i base)base)(plus i (plus (power-eval x base)(power-eval y base) ) ) )",
     "(equal (remainder y 1)(zero) )",
     "(equal (lessp (remainder x y)y)(not (zerop y) ) )",
     "(equal (remainder x x)(zero) )",
     "(equal (lessp (quotient i j)i)(and (not (zerop i) )(or (zerop j)(not (equal j 1) ) ) ) )",
     "(equal (lessp (remainder x y)x)(and (not (zerop y) )(not (zerop x) )(not (lessp x y) ) ) )",
     "(equal (power-eval (power-rep i base)base)(fix i) )",
     "(equal (power-eval (big-plus (power-rep i base)(power-rep j base)(zero)base)base)(plus i j) )",
     "(equal (gcd x y)(gcd y x) )",
     "(equal (nth (append a b)i)(append (nth a i)(nth b (difference i (length a) ) ) ) )",
     "(equal (difference (plus x y)x)(fix y) )",
     "(equal (difference (plus y x)x)(fix y) )",
     "(equal (difference (plus x y)(plus x z) )(difference y z) )",
     "(equal (times x (difference c w) )(difference (times c x)(times w x) ) )",
     "(equal (remainder (times x z)z)(zero) )",
     "(equal (difference (plus b (plus a c) )a)(plus b c) )",
     "(equal (difference (add1 (plus y z)z)(add1 y) )",
     "(equal (lessp (plus x y)(plus x z ) )(lessp y z) )",
     "(equal (lessp (times x z)(times y z) )(and (not (zerop z) )(lessp x y) ) )",
     "(equal (lessp y (plus x y) )(not (zerop x) ) )",
     "(equal (gcd (times x z)(times y z) )(times z (gcd x y) ) )",
     "(equal (value (normalize x)a)(value x a) )",
     "(equal (equal (flatten x)(cons y (nil) ) )(and (nlistp x)(equal x y) ) )",
     "(equal (listp (gopher x) )(listp x) )",
     "(equal (samefringe x y)(equal (flatten x)(flatten y) ) )",
     "(equal (equal (greatest-factor x y)(zero) )(and (or (zerop y)(equal y 1) )(equal x (zero) ) ) )",
     "(equal (equal (greatest-factor x y)1)(equal x 1) )",
     "(equal (numberp (greatest-factor x y) )(not (and (or (zerop y)(equal y 1) )(not (numberp x) ) ) ) )",
     "(equal (times-list (append x y) )(times (times-list x)(times-list y) ) )",
     "(equal (prime-list (append x y) )(and (prime-list x)(prime-list y) ) )",
     "(equal (equal z (times w z) )(and (numberp z)(or (equal z (zero) )(equal w 1) ) ) )",
     "(equal (greatereqpr x y)(not (lessp x y) ) )",
     "(equal (equal x (times x y) )(or (equal x (zero) )(and (numberp x)(equal y 1) ) ) )",
     "(equal (remainder (times y x)y)(zero) )",
     "(equal (equal (times a b)1)(and (not (equal a (zero) ) )(not (equal b (zero) ) )(numberp a)(numberp b)(equal (1- a)(zero) )(equal (1- b)(zero) ) ) )",
     "(equal (lessp (length (delete x l) )(length l) )(member x l) )",
     "(equal (sort2 (delete x l) )(delete x (sort2 l) ) )",
     "(equal (dsort x)(sort2 x) )",
     "(equal (length(cons x1(cons x2(cons x3(cons x4(cons x5(cons x6 x7) ) ) ) ) ) )(plus 6 (length x7) ) )",
     "(equal (difference (add1 (add1 x) )2)(fix x) )",
     "(equal (quotient (plus x (plus x y) )2)(plus x (quotient y 2) ) )",
     "(equal (sigma (zero)i)(quotient (times i (add1 i) )2) )",
     "(equal (plus x (add1 y) )(if (numberp y)(add1 (plus x y) )(add1 x) ) )",
     "(equal (equal (difference x y)(difference z y) )(if (lessp x y)(not (lessp y z) )(if (lessp z y)(not (lessp y x) )(equal (fix x)(fix z) ) ) ) )",
     "(equal (meaning (plus-tree (delete x y) )a)(if (member x y)(difference (meaning (plus-tree y)a)(meaning x a) )(meaning (plus-tree y)a) ) )",
     "(equal (times x (add1 y) )(if (numberp y)(plus x (times x y) )(fix x) ) )",
     "(equal (nth (nil)i)(if (zerop i)(nil)(zero) ) )",
     "(equal (last (append a b) )(if (listp b)(last b)(if (listp a)(cons (car (last a) )b)b) ) )",
     "(equal (equal (lessp x y)z)(if (lessp x y)(equal t z)(equal f z) ) )",
     "(equal (assignment x (append a b) )(if (assignedp x a)(assignment x a)(assignment x b) ) )",
     "(equal (car (gopher x) )(if (listp x)(car (flatten x) )(zero) ) )",
     "(equal (flatten (cdr (gopher x) ) )(if (listp x)(cdr (flatten x) )(cons (zero)(nil) ) ) )",
     "(equal (quotient (times y x)y)(if (zerop y)(zero)(fix x) ) )",
     "(equal (get j (set i val mem) )(if (eqp j i)val(get j mem) ) )"]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.runalltests ::
  Integer
  -> Integer -> Integer -> Integer -> Integer -> Integer -> IO ()
Dum.runalltests
  astart_aLU
  astep_aLV
  (!alim_aLW)
  bstart_aLX
  bstep_aLY
  (!blim_aLZ)
  = do { Dum.runbench
           (+)
           (+)
           "(+)"
           astart_aLU
           astep_aLV
           alim_aLW
           astart_aLU
           astep_aLV
           alim_aLW;
         Dum.runbench
           (-)
           (-)
           "(-)"
           astart_aLU
           astep_aLV
           alim_aLW
           astart_aLU
           astep_aLV
           alim_aLW;
         Dum.runbench
           (*)
           (*)
           "(*)"
           astart_aLU
           astep_aLV
           alim_aLW
           astart_aLU
           astep_aLV
           alim_aLW;
         Dum.runbench
           div
           div
           "div"
           astart_aLU
           astep_aLV
           alim_aLW
           astart_aLU
           astep_aLV
           alim_aLW;
         Dum.runbench
           mod
           mod
           "mod"
           astart_aLU
           astep_aLV
           alim_aLW
           astart_aLU
           astep_aLV
           alim_aLW;
         Dum.runbench
           quot
           quot
           "quot"
           astart_aLU
           astep_aLV
           alim_aLW
           astart_aLU
           astep_aLV
           alim_aLW;
         Dum.runbench
           rem
           rem
           "rem"
           astart_aLU
           astep_aLV
           alim_aLW
           astart_aLU
           astep_aLV
           alim_aLW;
         Dum.runbench
           gcd
           gcd
           "gcd"
           astart_aLU
           astep_aLV
           alim_aLW
           astart_aLU
           astep_aLV
           alim_aLW;
         Dum.runbench
           lcm
           lcm
           "lcm"
           astart_aLU
           astep_aLV
           alim_aLW
           astart_aLU
           astep_aLV
           alim_aLW;
         Dum.runbench
           (==)
           (==)
           "(==)"
           astart_aLU
           astep_aLV
           alim_aLW
           astart_aLU
           astep_aLV
           alim_aLW;
         Dum.runbench
           (<)
           (<)
           "(<)"
           astart_aLU
           astep_aLV
           alim_aLW
           astart_aLU
           astep_aLV
           alim_aLW;
         Dum.runbench
           (<=)
           (<=)
           "(<=)"
           astart_aLU
           astep_aLV
           alim_aLW
           astart_aLU
           astep_aLV
           alim_aLW;
         Dum.runbench
           (>)
           (>)
           "(>)"
           astart_aLU
           astep_aLV
           alim_aLW
           astart_aLU
           astep_aLV
           alim_aLW;
         Dum.runbench
           (>=)
           (>=)
           "(>=)"
           astart_aLU
           astep_aLV
           alim_aLW
           astart_aLU
           astep_aLV
           alim_aLW }
Dum.runbench ::
  (Integer -> Integer -> a_aLS)
  -> (Int -> Int -> b_aLT)
     -> String
        -> Integer
           -> Integer -> Integer -> Integer -> Integer -> Integer -> IO ()
Dum.runbench
  jop_a1So
  iop_a1Sp
  opstr_a1Sq
  (!astart_a1Sr)
  astep_a1Ss
  (!alim_a1St)
  bstart_a1Su
  (!bstep_a1Sv)
  (!blim_a1Sw)
  = do { Dum.intbench
           iop_a1Sp
           astart_a1Sr
           astep_a1Ss
           alim_a1St
           astart_a1Sr
           astep_a1Ss
           alim_a1St;
         Dum.integerbench
           jop_a1So
           astart_a1Sr
           astep_a1Ss
           alim_a1St
           astart_a1Sr
           astep_a1Ss
           alim_a1St }
Dum.integerbench ::
  (Integer -> Integer -> a_aLR)
  -> Integer
     -> Integer -> Integer -> Integer -> Integer -> Integer -> IO ()
Dum.integerbench
  op_a1Sx
  (!astart_a1Sy)
  (!astep_a1Sz)
  alim_a1SA
  bstart_a1SB
  (!bstep_a1SC)
  blim_a1SD
  = do { Dum.seqlist
           ([a_a1SE `op_a1Sx` b_a1SF |
               a_a1SE <- [astart_a1Sy, astart_a1Sy + astep_a1Sz .. alim_a1SA],
               (!b_a1SF) <- [bstart_a1SB, astart_a1Sy
                                          + bstep_a1SC .. blim_a1SD]]);
         return () }
Dum.intbench ::
  (Int -> Int -> a_avp)
  -> Integer
     -> Integer -> Integer -> Integer -> Integer -> Integer -> IO ()
Dum.intbench
  (!op_a1SG)
  astart_a1SH
  (!astep_a1SI)
  alim_a1SJ
  (!bstart_a1SK)
  bstep_a1SL
  blim_a1SM
  = do { Dum.seqlist
           ([a_a1SN `op_a1SG` b_a1SO |
               a_a1SN <- [fromInteger astart_a1SH, fromInteger astart_a1SH
                                                   + fromInteger astep_a1SI .. fromInteger
                                                                                 alim_a1SJ],
               (!b_a1SO) <- [fromInteger bstart_a1SK, fromInteger astart_a1SH
                                                      + fromInteger bstep_a1SL .. fromInteger
                                                                                    blim_a1SM]]);
         return () }
Dum.seqlist [] = return ()
Dum.seqlist (!((!(x_a1SP : xs_a1SQ))))
  = x_a1SP `seq` Dum.seqlist xs_a1SQ


["astart_aLU","astep_aLV","alim_aLW","safebang@!alim_aLW","(!alim_aLW)","bstart_aLX","bstep_aLY","blim_aLZ","safebang@!blim_aLZ","(!blim_aLZ)","jop_a1So","iop_a1Sp","opstr_a1Sq","astart_a1Sr","safebang@!astart_a1Sr","(!astart_a1Sr)","astep_a1Ss","alim_a1St","safebang@!alim_a1St","(!alim_a1St)","bstart_a1Su","bstep_a1Sv","safebang@!bstep_a1Sv","(!bstep_a1Sv)","blim_a1Sw","safebang@!blim_a1Sw","(!blim_a1Sw)","op_a1Sx","astart_a1Sy","safebang@!astart_a1Sy","(!astart_a1Sy)","astep_a1Sz","safebang@!astep_a1Sz","(!astep_a1Sz)","alim_a1SA","bstart_a1SB","bstep_a1SC","safebang@!bstep_a1SC","(!bstep_a1SC)","blim_a1SD","a_a1SE","b_a1SF","!b_a1SF","(!b_a1SF)","op_a1SG","safebang@!op_a1SG","(!op_a1SG)","astart_a1SH","astep_a1SI","safebang@!astep_a1SI","(!astep_a1SI)","alim_a1SJ","bstart_a1SK","safebang@!bstart_a1SK","(!bstart_a1SK)","bstep_a1SL","blim_a1SM","a_a1SN","b_a1SO","!b_a1SO","(!b_a1SO)","[]","x_a1SP","xs_a1SQ","x_a1SP : xs_a1SQ","(x_a1SP : xs_a1SQ)","!(x_a1SP : xs_a1SQ)","(!(x_a1SP : xs_a1SQ))","((!(x_a1SP : xs_a1SQ)))","!((!(x_a1SP : xs_a1SQ)))","(!((!(x_a1SP : xs_a1SQ))))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.Environment

runalltests ::
            Integer ->
              Integer -> Integer -> Integer -> Integer -> Integer -> IO ()
runalltests astart_aLU astep_aLV (!alim_aLW) bstart_aLX bstep_aLY
  (!blim_aLZ)
  = do runbench (+) (+) "(+)" astart_aLU astep_aLV alim_aLW
         astart_aLU
         astep_aLV
         alim_aLW
       runbench (-) (-) "(-)" astart_aLU astep_aLV alim_aLW astart_aLU
         astep_aLV
         alim_aLW
       runbench (*) (*) "(*)" astart_aLU astep_aLV alim_aLW astart_aLU
         astep_aLV
         alim_aLW
       runbench div div "div" astart_aLU astep_aLV alim_aLW astart_aLU
         astep_aLV
         alim_aLW
       runbench mod mod "mod" astart_aLU astep_aLV alim_aLW astart_aLU
         astep_aLV
         alim_aLW
       runbench quot quot "quot" astart_aLU astep_aLV alim_aLW astart_aLU
         astep_aLV
         alim_aLW
       runbench rem rem "rem" astart_aLU astep_aLV alim_aLW astart_aLU
         astep_aLV
         alim_aLW
       runbench gcd gcd "gcd" astart_aLU astep_aLV alim_aLW astart_aLU
         astep_aLV
         alim_aLW
       runbench lcm lcm "lcm" astart_aLU astep_aLV alim_aLW astart_aLU
         astep_aLV
         alim_aLW
       runbench (==) (==) "(==)" astart_aLU astep_aLV alim_aLW astart_aLU
         astep_aLV
         alim_aLW
       runbench (<) (<) "(<)" astart_aLU astep_aLV alim_aLW astart_aLU
         astep_aLV
         alim_aLW
       runbench (<=) (<=) "(<=)" astart_aLU astep_aLV alim_aLW astart_aLU
         astep_aLV
         alim_aLW
       runbench (>) (>) "(>)" astart_aLU astep_aLV alim_aLW astart_aLU
         astep_aLV
         alim_aLW
       runbench (>=) (>=) "(>=)" astart_aLU astep_aLV alim_aLW astart_aLU
         astep_aLV
         alim_aLW

runbench ::
         (Integer -> Integer -> a_aLS) ->
           (Int -> Int -> b_aLT) ->
             String ->
               Integer ->
                 Integer -> Integer -> Integer -> Integer -> Integer -> IO ()
runbench jop_a1So iop_a1Sp opstr_a1Sq (!astart_a1Sr) astep_a1Ss
  (!alim_a1St) bstart_a1Su (!bstep_a1Sv) (!blim_a1Sw)
  = do intbench iop_a1Sp astart_a1Sr astep_a1Ss alim_a1St astart_a1Sr
         astep_a1Ss
         alim_a1St
       integerbench jop_a1So astart_a1Sr astep_a1Ss alim_a1St astart_a1Sr
         astep_a1Ss
         alim_a1St

integerbench ::
             (Integer -> Integer -> a_aLR) ->
               Integer ->
                 Integer -> Integer -> Integer -> Integer -> Integer -> IO ()
integerbench op_a1Sx (!astart_a1Sy) (!astep_a1Sz) alim_a1SA
  bstart_a1SB (!bstep_a1SC) blim_a1SD
  = do seqlist
         ([a_a1SE `op_a1Sx` b_a1SF |
           a_a1SE <- [astart_a1Sy, astart_a1Sy + astep_a1Sz .. alim_a1SA],
           (investigate@b_a1SF) <- [bstart_a1SB, astart_a1Sy + bstep_a1SC ..
                                    blim_a1SD]])
       return ()

intbench ::
         (Int -> Int -> a_avp) ->
           Integer ->
             Integer -> Integer -> Integer -> Integer -> Integer -> IO ()
intbench (!op_a1SG) astart_a1SH (!astep_a1SI) alim_a1SJ
  (!bstart_a1SK) bstep_a1SL blim_a1SM
  = do seqlist
         ([a_a1SN `op_a1SG` b_a1SO |
           a_a1SN <- [fromInteger astart_a1SH,
                      fromInteger astart_a1SH + fromInteger astep_a1SI ..
                      fromInteger alim_a1SJ],
           (investigate@b_a1SO) <- [fromInteger bstart_a1SK,
                                    fromInteger astart_a1SH + fromInteger bstep_a1SL ..
                                    fromInteger blim_a1SM]])
       return ()
seqlist [] = return ()
seqlist (investigate@((investigate@(x_a1SP : xs_a1SQ))))
  = x_a1SP `seq` seqlist xs_a1SQ
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.expand (!a_axG) (!b_axH) c_axI d_axJ e_axK (!f_axL)
  = f_axL + e_axK * 10 + d_axJ * 100 + c_axI * 1000 + b_axH * 10000
    + a_axG * 100000 ::
      Int
Dum.permutations :: [Int] -> [[Int]]
Dum.permutations [] = [[]]
Dum.permutations ((!((!j_ayY) : (!js_ayZ))))
  = [r_az5 |
       pjs_az4 <- Dum.permutations js_ayZ, r_az5 <- addj_az0 pjs_az4]
  where
      addj_az0 [] = [[j_ayY]]
      addj_az0 (!((!((!k_az1) : (!ks_az2)))))
        = (j_ayY : k_az1 : ks_az2)
          : [(k_az1 : aks_az3) | (!aks_az3) <- addj_az0 ks_az2]


["a_axG","!a_axG","(!a_axG)","b_axH","!b_axH","(!b_axH)","c_axI","d_axJ","e_axK","f_axL","!f_axL","(!f_axL)","[]","j_ayY","safebang@!j_ayY","(!j_ayY)","js_ayZ","safebang@!js_ayZ","(!js_ayZ)","(!j_ayY) : (!js_ayZ)","((!j_ayY) : (!js_ayZ))","!((!j_ayY) : (!js_ayZ))","(!((!j_ayY) : (!js_ayZ)))","((!((!j_ayY) : (!js_ayZ))))","pjs_az4","r_az5","[]","k_az1","!k_az1","(!k_az1)","ks_az2","!ks_az2","(!ks_az2)","(!k_az1) : (!ks_az2)","((!k_az1) : (!ks_az2))","!((!k_az1) : (!ks_az2))","(!((!k_az1) : (!ks_az2)))","((!((!k_az1) : (!ks_az2))))","!((!((!k_az1) : (!ks_az2))))","(!((!((!k_az1) : (!ks_az2)))))","aks_az3","!aks_az3","(!aks_az3)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
expand (investigate@a_axG) (investigate@b_axH) c_axI d_axJ e_axK
  (investigate@f_axL)
  = f_axL + e_axK * 10 + d_axJ * 100 + c_axI * 1000 + b_axH * 10000 +
      a_axG
      * 100000
      :: Int

permutations :: [Int] -> [[Int]]
permutations [] = [[]]
permutations ((investigate@((!j_ayY) : (!js_ayZ))))
  = [r_az5 | pjs_az4 <- permutations js_ayZ,
     r_az5 <- addj_az0 pjs_az4]
  where addj_az0 [] = [[j_ayY]]
        addj_az0
          (investigate@((investigate@((investigate@k_az1) :
                                        (investigate@ks_az2)))))
          = (j_ayY : k_az1 : ks_az2) :
              [(k_az1 : aks_az3) | (investigate@aks_az3) <- addj_az0 ks_az2]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.expand (!a_axG) (!b_axH) c_axI d_axJ e_axK (!f_axL)
  = f_axL + e_axK * 10 + d_axJ * 100 + c_axI * 1000 + b_axH * 10000
    + a_axG * 100000 ::
      Int
Dum.permutations :: [Int] -> [[Int]]
Dum.permutations [] = [[]]
Dum.permutations ((!((!j_ayY) : (!js_ayZ))))
  = [r_az5 |
       pjs_az4 <- Dum.permutations js_ayZ, r_az5 <- addj_az0 pjs_az4]
  where
      addj_az0 [] = [[j_ayY]]
      addj_az0 (!((!((!k_az1) : (!ks_az2)))))
        = (j_ayY : k_az1 : ks_az2)
          : [(k_az1 : aks_az3) | (!aks_az3) <- addj_az0 ks_az2]


["a_axG","!a_axG","(!a_axG)","b_axH","!b_axH","(!b_axH)","c_axI","d_axJ","e_axK","f_axL","!f_axL","(!f_axL)","[]","j_ayY","safebang@!j_ayY","(!j_ayY)","js_ayZ","safebang@!js_ayZ","(!js_ayZ)","(!j_ayY) : (!js_ayZ)","((!j_ayY) : (!js_ayZ))","!((!j_ayY) : (!js_ayZ))","(!((!j_ayY) : (!js_ayZ)))","((!((!j_ayY) : (!js_ayZ))))","pjs_az4","r_az5","[]","k_az1","!k_az1","(!k_az1)","ks_az2","!ks_az2","(!ks_az2)","(!k_az1) : (!ks_az2)","((!k_az1) : (!ks_az2))","!((!k_az1) : (!ks_az2))","(!((!k_az1) : (!ks_az2)))","((!((!k_az1) : (!ks_az2))))","!((!((!k_az1) : (!ks_az2))))","(!((!((!k_az1) : (!ks_az2)))))","aks_az3","!aks_az3","(!aks_az3)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Sort
expand (investigate@a_axG) (investigate@b_axH) c_axI d_axJ e_axK
  (investigate@f_axL)
  = f_axL + e_axK * 10 + d_axJ * 100 + c_axI * 1000 + b_axH * 10000 +
      a_axG
      * 100000
      :: Int

permutations :: [Int] -> [[Int]]
permutations [] = [[]]
permutations ((investigate@((!j_ayY) : (!js_ayZ))))
  = [r_az5 | pjs_az4 <- permutations js_ayZ,
     r_az5 <- addj_az0 pjs_az4]
  where addj_az0 [] = [[j_ayY]]
        addj_az0
          (investigate@((investigate@((investigate@k_az1) :
                                        (investigate@ks_az2)))))
          = (j_ayY : k_az1 : ks_az2) :
              [(k_az1 : aks_az3) | (investigate@aks_az3) <- addj_az0 ks_az2]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.quickSort :: Ord a_a1nB => [a_a1nB] -> [a_a1nB]
Dum.quickSort2 :: Ord a_a1nA => [a_a1nA] -> [a_a1nA]
Dum.quickerSort :: Ord a_a1nz => [a_a1nz] -> [a_a1nz]
Dum.insertSort :: Ord a_a1ny => [a_a1ny] -> [a_a1ny]
Dum.treeSort :: Ord a_a1nx => [a_a1nx] -> [a_a1nx]
Dum.treeSort2 :: Ord a_a1nw => [a_a1nw] -> [a_a1nw]
Dum.heapSort :: Ord a_a1nv => [a_a1nv] -> [a_a1nv]
Dum.mergeSort :: Ord a_arL => [a_arL] -> [a_arL]
Dum.quickSort (![]) = []
Dum.quickSort ((!(x_a1nC : (!xs_a1nD))))
  = (Dum.quickSort lo_a1uI) ++ (x_a1nC : Dum.quickSort hi_a1uJ)
  where
      lo_a1uI = [y_a1uK | (!y_a1uK) <- xs_a1nD, y_a1uK <= x_a1nC]
      (!hi_a1uJ) = [y_a1uL | y_a1uL <- xs_a1nD, y_a1uL > x_a1nC]
Dum.quickSort2 (![]) = []
Dum.quickSort2 (x_a1uM : xs_a1uN)
  = (Dum.quickSort2 lo_a1uO) ++ (x_a1uM : Dum.quickSort2 hi_a1uP)
  where
      (lo_a1uO, hi_a1uP) = partition ((>=) x_a1uM) xs_a1uN
Dum.quickerSort [] = []
Dum.quickerSort (![x_a1xC]) = [x_a1xC]
Dum.quickerSort (!((!((!x_a1xD) : (!xs_a1xE)))))
  = split_a1xF x_a1xD [] [] xs_a1xE
  where
      split_a1xF x_a1xG lo_a1xH hi_a1xI (![])
        = Dum.quickerSort lo_a1xH ++ (x_a1xG : Dum.quickerSort hi_a1xI)
      split_a1xF x_a1xJ (!lo_a1xK) hi_a1xL (!((!y_a1xM) : ys_a1xN))
        | y_a1xM <= x_a1xJ
        = split_a1xF x_a1xJ (y_a1xM : lo_a1xK) hi_a1xL ys_a1xN
        | True = split_a1xF x_a1xJ lo_a1xK (y_a1xM : hi_a1xL) ys_a1xN
Dum.insertSort [] = []
Dum.insertSort ((!x_a1xO) : xs_a1xP)
  = trins_a1xQ [] [x_a1xO] xs_a1xP
  where
      trins_a1xQ ::
        Ord a_a1xR => [a_a1xR] -> [a_a1xR] -> [a_a1xR] -> [a_a1xR]
      trins_a1xQ rev_a1xS [] (!(y_a1xT : ys_a1xU))
        = trins_a1xQ [] ((reverse rev_a1xS) ++ [y_a1xT]) ys_a1xU
      trins_a1xQ (!rev_a1Bq) (!xs_a1Br) []
        = (reverse rev_a1Bq) ++ xs_a1Br
      trins_a1xQ rev_a1Bs (x_a1Bt : xs_a1Bu) ((!y_a1Bv) : (!ys_a1Bw))
        | x_a1Bt < y_a1Bv
        = trins_a1xQ (x_a1Bt : rev_a1Bs) xs_a1Bu (y_a1Bv : ys_a1Bw)
        | True
        = trins_a1xQ
            [] (reverse rev_a1Bs ++ (y_a1Bv : x_a1Bt : xs_a1Bu)) ys_a1Bw
Dum.treeSort
  = readTree_a1By . mkTree_a1Bx
  where
      mkTree_a1Bx :: Ord a_a1Bz => [a_a1Bz] -> Dum.Tree a_a1Bz
      (!mkTree_a1Bx)
        = foldr to_tree_a1BB Dum.Tip
        where
            to_tree_a1BB ::
              Ord a_a1BC => a_a1BC -> Dum.Tree a_a1BC -> Dum.Tree a_a1BC
            to_tree_a1BB (!x_a1BD) Dum.Tip = Dum.Branch x_a1BD Dum.Tip Dum.Tip
            to_tree_a1BB (!x_a1BE) (!((!(Dum.Branch y_a1BF (!l_a1BG) r_a1BH))))
              | x_a1BE <= y_a1BF
              = Dum.Branch y_a1BF (to_tree_a1BB x_a1BE l_a1BG) r_a1BH
              | True = Dum.Branch y_a1BF l_a1BG (to_tree_a1BB x_a1BE r_a1BH)
      readTree_a1By :: Ord a_a1BA => Dum.Tree a_a1BA -> [a_a1BA]
      readTree_a1By Dum.Tip = []
      readTree_a1By (!(Dum.Branch x_a1Uj l_a1Uk r_a1Ul))
        = readTree_a1By l_a1Uk ++ (x_a1Uj : readTree_a1By r_a1Ul)
Dum.treeSort2
  = readTree_a1Un . mkTree_a1Um
  where
      mkTree_a1Um :: Ord a_a1Uo => [a_a1Uo] -> Dum.Tree2 a_a1Uo
      mkTree_a1Um
        = foldr to_tree_a1Uq Dum.Tip2
        where
            to_tree_a1Uq ::
              Ord a_a1Ur => a_a1Ur -> Dum.Tree2 a_a1Ur -> Dum.Tree2 a_a1Ur
            to_tree_a1Uq x_a1Us Dum.Tip2 = Dum.Twig2 x_a1Us
            to_tree_a1Uq (!x_a1Ut) ((!(Dum.Twig2 y_a1Uu)))
              | x_a1Ut <= y_a1Uu = Dum.Branch2 y_a1Uu (Dum.Twig2 x_a1Ut) Dum.Tip2
              | True = Dum.Branch2 y_a1Uu Dum.Tip2 (Dum.Twig2 x_a1Ut)
            to_tree_a1Uq (!x_a1Uv) (Dum.Branch2 y_a1Uw (!l_a1Ux) r_a1Uy)
              | x_a1Uv <= y_a1Uw
              = Dum.Branch2 y_a1Uw (to_tree_a1Uq x_a1Uv l_a1Ux) r_a1Uy
              | True = Dum.Branch2 y_a1Uw l_a1Ux (to_tree_a1Uq x_a1Uv r_a1Uy)
      readTree_a1Un :: Ord a_a1Up => Dum.Tree2 a_a1Up -> [a_a1Up]
      readTree_a1Un Dum.Tip2 = []
      readTree_a1Un (Dum.Twig2 (!x_a1Uz)) = [x_a1Uz]
      readTree_a1Un (!(Dum.Branch2 (!x_a1UA) (!l_a1UB) r_a1UC))
        = readTree_a1Un l_a1UB ++ (x_a1UA : readTree_a1Un r_a1UC)
Dum.heapSort xs_a1UD
  = clear_a1UG (heap_a1UE (0 :: Int) xs_a1UD)
  where
      heap_a1UE :: Ord a_a1UJ => Int -> [a_a1UJ] -> Dum.Tree a_a1UJ
      heap_a1UE k_a1UN [] = Dum.Tip
      heap_a1UE k_a1UO (!((!x_a1UP) : (!xs_a1UQ)))
        = to_heap_a1UF
            k_a1UO x_a1UP (heap_a1UE (k_a1UO + (1 :: Int)) xs_a1UQ)
      to_heap_a1UF ::
        Ord a_a1UK => Int -> a_a1UK -> Dum.Tree a_a1UK -> Dum.Tree a_a1UK
      to_heap_a1UF k_a1W3 x_a1W4 (!Dum.Tip)
        = Dum.Branch x_a1W4 Dum.Tip Dum.Tip
      to_heap_a1UF
        k_a1W5
        (!x_a1W6)
        (!((!(Dum.Branch (!y_a1W7) (!l_a1W8) r_a1W9))))
        | x_a1W6 <= y_a1W7 && odd k_a1W5
        = Dum.Branch
            x_a1W6 (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 l_a1W8) r_a1W9
        | x_a1W6 <= y_a1W7
        = Dum.Branch
            x_a1W6 l_a1W8 (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 r_a1W9)
        | odd k_a1W5
        = Dum.Branch
            y_a1W7 (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 l_a1W8) r_a1W9
        | True
        = Dum.Branch
            y_a1W7 l_a1W8 (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 r_a1W9)
      clear_a1UG :: Ord a_a1UL => Dum.Tree a_a1UL -> [a_a1UL]
      clear_a1UG Dum.Tip = []
      clear_a1UG (Dum.Branch (!x_a25N) (!l_a25O) (!r_a25P))
        = x_a25N : clear_a1UG (mix_a1UH l_a25O r_a25P)
      mix_a1UH ::
        Ord a_a1UM => Dum.Tree a_a1UM -> Dum.Tree a_a1UM -> Dum.Tree a_a1UM
      mix_a1UH (!Dum.Tip) r_a25Q = r_a25Q
      mix_a1UH (!l_a25R) (!Dum.Tip) = l_a25R
      mix_a1UH
        t1_a25S@(!(Dum.Branch (!x_a25T) l1_a25U (!r1_a25V)))
        t2_a25W@(!((!(Dum.Branch (!y_a25X) (!l2_a25Y) r2_a25Z))))
        | x_a25T <= y_a25X
        = Dum.Branch x_a25T (mix_a1UH l1_a25U r1_a25V) t2_a25W
        | True = Dum.Branch y_a25X t1_a25S (mix_a1UH l2_a25Y r2_a25Z)
      div2_a1UI :: Int -> Int
      div2_a1UI (!k_a260) = k_a260 `div` 2
Dum.mergeSort
  = merge_lists_a262 . (runsplit_a261 [])
  where
      runsplit_a261 :: Ord a_a264 => [a_a264] -> [a_a264] -> [[a_a264]]
      runsplit_a261 (![]) [] = []
      runsplit_a261 (!run_a267) [] = [run_a267]
      runsplit_a261 [] (!((!((!x_a268) : (!xs_a269)))))
        = runsplit_a261 [x_a268] xs_a269
      runsplit_a261 (![(!r_a26a)]) (!((!((!x_a26b) : (!xs_a26c)))))
        | x_a26b > r_a26a = runsplit_a261 [r_a26a, x_a26b] xs_a26c
      runsplit_a261
        (!rl_a26d@(!((!(r_a26e : rs_a26f)))))
        (!((!x_a26g) : (!xs_a26h)))
        | x_a26g <= r_a26e = runsplit_a261 (x_a26g : rl_a26d) xs_a26h
        | True = rl_a26d : (runsplit_a261 [x_a26g] xs_a26h)
      merge_lists_a262 :: Ord a_a265 => [[a_a265]] -> [a_a265]
      merge_lists_a262 [] = []
      merge_lists_a262 (!((!(x_a26i : (!xs_a26j)))))
        = merge_a263 x_a26i (merge_lists_a262 xs_a26j)
      merge_a263 :: Ord a_a266 => [a_a266] -> [a_a266] -> [a_a266]
      merge_a263 (![]) (!ys_a26k) = ys_a26k
      merge_a263 (!xs_a26l) [] = xs_a26l
      merge_a263
        (!xl_a26m@(x_a26n : xs_a26o))
        (!yl_a26p@((!y_a26q) : ys_a26r))
        | x_a26n == y_a26q = x_a26n : y_a26q : (merge_a263 xs_a26o ys_a26r)
        | x_a26n < y_a26q = x_a26n : (merge_a263 xs_a26o yl_a26p)
        | True = y_a26q : (merge_a263 xl_a26m ys_a26r)

data Dum.Tree a_arK
  = Dum.Tip | Dum.Branch a_arK (Dum.Tree a_arK) (Dum.Tree a_arK)
data Dum.Tree2 a_arJ
  = Dum.Tip2 |
    Dum.Twig2 a_arJ |
    Dum.Branch2 a_arJ (Dum.Tree2 a_arJ) (Dum.Tree2 a_arJ)


["[]","![]","(![])","x_a1nC","xs_a1nD","!xs_a1nD","(!xs_a1nD)","x_a1nC : (!xs_a1nD)","(x_a1nC : (!xs_a1nD))","!(x_a1nC : (!xs_a1nD))","(!(x_a1nC : (!xs_a1nD)))","((!(x_a1nC : (!xs_a1nD))))","lo_a1uI","y_a1uK","!y_a1uK","(!y_a1uK)","hi_a1uJ","!hi_a1uJ","(!hi_a1uJ)","y_a1uL","[]","![]","(![])","x_a1uM","xs_a1uN","x_a1uM : xs_a1uN","(x_a1uM : xs_a1uN)","lo_a1uO","hi_a1uP","(lo_a1uO, hi_a1uP)","[]","x_a1xC","[x_a1xC]","![x_a1xC]","(![x_a1xC])","x_a1xD","!x_a1xD","(!x_a1xD)","xs_a1xE","!xs_a1xE","(!xs_a1xE)","(!x_a1xD) : (!xs_a1xE)","((!x_a1xD) : (!xs_a1xE))","!((!x_a1xD) : (!xs_a1xE))","(!((!x_a1xD) : (!xs_a1xE)))","((!((!x_a1xD) : (!xs_a1xE))))","!((!((!x_a1xD) : (!xs_a1xE))))","(!((!((!x_a1xD) : (!xs_a1xE)))))","x_a1xG","lo_a1xH","hi_a1xI","[]","![]","(![])","x_a1xJ","lo_a1xK","!lo_a1xK","(!lo_a1xK)","hi_a1xL","y_a1xM","!y_a1xM","(!y_a1xM)","ys_a1xN","(!y_a1xM) : ys_a1xN","((!y_a1xM) : ys_a1xN)","!((!y_a1xM) : ys_a1xN)","(!((!y_a1xM) : ys_a1xN))","[]","x_a1xO","!x_a1xO","(!x_a1xO)","xs_a1xP","(!x_a1xO) : xs_a1xP","((!x_a1xO) : xs_a1xP)","rev_a1xS","[]","y_a1xT","ys_a1xU","y_a1xT : ys_a1xU","(y_a1xT : ys_a1xU)","!(y_a1xT : ys_a1xU)","(!(y_a1xT : ys_a1xU))","rev_a1Bq","!rev_a1Bq","(!rev_a1Bq)","xs_a1Br","!xs_a1Br","(!xs_a1Br)","[]","rev_a1Bs","x_a1Bt","xs_a1Bu","x_a1Bt : xs_a1Bu","(x_a1Bt : xs_a1Bu)","y_a1Bv","!y_a1Bv","(!y_a1Bv)","ys_a1Bw","!ys_a1Bw","(!ys_a1Bw)","(!y_a1Bv) : (!ys_a1Bw)","((!y_a1Bv) : (!ys_a1Bw))","treeSort","mkTree_a1Bx","!mkTree_a1Bx","(!mkTree_a1Bx)","x_a1BD","!x_a1BD","(!x_a1BD)","Tip","x_a1BE","!x_a1BE","(!x_a1BE)","y_a1BF","l_a1BG","!l_a1BG","(!l_a1BG)","r_a1BH","Branch y_a1BF (!l_a1BG) r_a1BH","(Branch y_a1BF (!l_a1BG) r_a1BH)","!(Branch y_a1BF (!l_a1BG) r_a1BH)","(!(Branch y_a1BF (!l_a1BG) r_a1BH))","((!(Branch y_a1BF (!l_a1BG) r_a1BH)))","!((!(Branch y_a1BF (!l_a1BG) r_a1BH)))","(!((!(Branch y_a1BF (!l_a1BG) r_a1BH))))","Tip","x_a1Uj","l_a1Uk","r_a1Ul","Branch x_a1Uj l_a1Uk r_a1Ul","(Branch x_a1Uj l_a1Uk r_a1Ul)","!(Branch x_a1Uj l_a1Uk r_a1Ul)","(!(Branch x_a1Uj l_a1Uk r_a1Ul))","treeSort2","mkTree_a1Um","x_a1Us","Tip2","x_a1Ut","!x_a1Ut","(!x_a1Ut)","y_a1Uu","Twig2 y_a1Uu","(Twig2 y_a1Uu)","!(Twig2 y_a1Uu)","(!(Twig2 y_a1Uu))","((!(Twig2 y_a1Uu)))","x_a1Uv","!x_a1Uv","(!x_a1Uv)","y_a1Uw","l_a1Ux","!l_a1Ux","(!l_a1Ux)","r_a1Uy","Branch2 y_a1Uw (!l_a1Ux) r_a1Uy","(Branch2 y_a1Uw (!l_a1Ux) r_a1Uy)","Tip2","x_a1Uz","!x_a1Uz","(!x_a1Uz)","Twig2 (!x_a1Uz)","(Twig2 (!x_a1Uz))","x_a1UA","!x_a1UA","(!x_a1UA)","l_a1UB","!l_a1UB","(!l_a1UB)","r_a1UC","Branch2 (!x_a1UA) (!l_a1UB) r_a1UC","(Branch2 (!x_a1UA) (!l_a1UB) r_a1UC)","!(Branch2 (!x_a1UA) (!l_a1UB) r_a1UC)","(!(Branch2 (!x_a1UA) (!l_a1UB) r_a1UC))","xs_a1UD","k_a1UN","[]","k_a1UO","x_a1UP","!x_a1UP","(!x_a1UP)","xs_a1UQ","!xs_a1UQ","(!xs_a1UQ)","(!x_a1UP) : (!xs_a1UQ)","((!x_a1UP) : (!xs_a1UQ))","!((!x_a1UP) : (!xs_a1UQ))","(!((!x_a1UP) : (!xs_a1UQ)))","k_a1W3","x_a1W4","Tip","!Tip","(!Tip)","k_a1W5","x_a1W6","!x_a1W6","(!x_a1W6)","y_a1W7","!y_a1W7","(!y_a1W7)","l_a1W8","!l_a1W8","(!l_a1W8)","r_a1W9","Branch (!y_a1W7) (!l_a1W8) r_a1W9","(Branch (!y_a1W7) (!l_a1W8) r_a1W9)","!(Branch (!y_a1W7) (!l_a1W8) r_a1W9)","(!(Branch (!y_a1W7) (!l_a1W8) r_a1W9))","((!(Branch (!y_a1W7) (!l_a1W8) r_a1W9)))","!((!(Branch (!y_a1W7) (!l_a1W8) r_a1W9)))","(!((!(Branch (!y_a1W7) (!l_a1W8) r_a1W9))))","Tip","x_a25N","!x_a25N","(!x_a25N)","l_a25O","!l_a25O","(!l_a25O)","r_a25P","!r_a25P","(!r_a25P)","Branch (!x_a25N) (!l_a25O) (!r_a25P)","(Branch (!x_a25N) (!l_a25O) (!r_a25P))","Tip","!Tip","(!Tip)","r_a25Q","l_a25R","!l_a25R","(!l_a25R)","Tip","!Tip","(!Tip)","x_a25T","!x_a25T","(!x_a25T)","l1_a25U","r1_a25V","!r1_a25V","(!r1_a25V)","Branch (!x_a25T) l1_a25U (!r1_a25V)","(Branch (!x_a25T) l1_a25U (!r1_a25V))","!(Branch (!x_a25T) l1_a25U (!r1_a25V))","(!(Branch (!x_a25T) l1_a25U (!r1_a25V)))","t1_a25S@(!(Branch (!x_a25T) l1_a25U (!r1_a25V)))","y_a25X","!y_a25X","(!y_a25X)","l2_a25Y","!l2_a25Y","(!l2_a25Y)","r2_a25Z","Branch (!y_a25X) (!l2_a25Y) r2_a25Z","(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)","!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)","(!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z))","((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)))","!((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)))","(!((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z))))","t2_a25W@(!((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z))))","k_a260","!k_a260","(!k_a260)","mergeSort","[]","![]","(![])","[]","run_a267","!run_a267","(!run_a267)","[]","[]","x_a268","!x_a268","(!x_a268)","xs_a269","!xs_a269","(!xs_a269)","(!x_a268) : (!xs_a269)","((!x_a268) : (!xs_a269))","!((!x_a268) : (!xs_a269))","(!((!x_a268) : (!xs_a269)))","((!((!x_a268) : (!xs_a269))))","!((!((!x_a268) : (!xs_a269))))","(!((!((!x_a268) : (!xs_a269)))))","r_a26a","!r_a26a","(!r_a26a)","[(!r_a26a)]","![(!r_a26a)]","(![(!r_a26a)])","x_a26b","!x_a26b","(!x_a26b)","xs_a26c","!xs_a26c","(!xs_a26c)","(!x_a26b) : (!xs_a26c)","((!x_a26b) : (!xs_a26c))","!((!x_a26b) : (!xs_a26c))","(!((!x_a26b) : (!xs_a26c)))","((!((!x_a26b) : (!xs_a26c))))","!((!((!x_a26b) : (!xs_a26c))))","(!((!((!x_a26b) : (!xs_a26c)))))","r_a26e","rs_a26f","r_a26e : rs_a26f","(r_a26e : rs_a26f)","!(r_a26e : rs_a26f)","(!(r_a26e : rs_a26f))","((!(r_a26e : rs_a26f)))","!((!(r_a26e : rs_a26f)))","(!((!(r_a26e : rs_a26f))))","rl_a26d@(!((!(r_a26e : rs_a26f))))","!rl_a26d@(!((!(r_a26e : rs_a26f))))","(!rl_a26d@(!((!(r_a26e : rs_a26f)))))","x_a26g","!x_a26g","(!x_a26g)","xs_a26h","!xs_a26h","(!xs_a26h)","(!x_a26g) : (!xs_a26h)","((!x_a26g) : (!xs_a26h))","!((!x_a26g) : (!xs_a26h))","(!((!x_a26g) : (!xs_a26h)))","[]","x_a26i","xs_a26j","!xs_a26j","(!xs_a26j)","x_a26i : (!xs_a26j)","(x_a26i : (!xs_a26j))","!(x_a26i : (!xs_a26j))","(!(x_a26i : (!xs_a26j)))","((!(x_a26i : (!xs_a26j))))","!((!(x_a26i : (!xs_a26j))))","(!((!(x_a26i : (!xs_a26j)))))","[]","![]","(![])","ys_a26k","!ys_a26k","(!ys_a26k)","xs_a26l","!xs_a26l","(!xs_a26l)","[]","x_a26n","xs_a26o","x_a26n : xs_a26o","(x_a26n : xs_a26o)","xl_a26m@(x_a26n : xs_a26o)","!xl_a26m@(x_a26n : xs_a26o)","(!xl_a26m@(x_a26n : xs_a26o))","y_a26q","!y_a26q","(!y_a26q)","ys_a26r","(!y_a26q) : ys_a26r","((!y_a26q) : ys_a26r)","yl_a26p@((!y_a26q) : ys_a26r)","!yl_a26p@((!y_a26q) : ys_a26r)","(!yl_a26p@((!y_a26q) : ys_a26r))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.List (partition)

quickSort :: Ord a_a1nB => [a_a1nB] -> [a_a1nB]

quickSort2 :: Ord a_a1nA => [a_a1nA] -> [a_a1nA]

quickerSort :: Ord a_a1nz => [a_a1nz] -> [a_a1nz]

insertSort :: Ord a_a1ny => [a_a1ny] -> [a_a1ny]

treeSort :: Ord a_a1nx => [a_a1nx] -> [a_a1nx]

treeSort2 :: Ord a_a1nw => [a_a1nw] -> [a_a1nw]

heapSort :: Ord a_a1nv => [a_a1nv] -> [a_a1nv]

mergeSort :: Ord a_arL => [a_arL] -> [a_arL]
quickSort (investigate@[]) = []
quickSort ((investigate@(x_a1nC : (investigate@xs_a1nD))))
  = (quickSort lo_a1uI) ++ (x_a1nC : quickSort hi_a1uJ)
  where lo_a1uI
          = [y_a1uK | (investigate@y_a1uK) <- xs_a1nD, y_a1uK <= x_a1nC]
        (investigate@hi_a1uJ)
          = [y_a1uL | y_a1uL <- xs_a1nD, y_a1uL > x_a1nC]
quickSort2 (investigate@[]) = []
quickSort2 (x_a1uM : xs_a1uN)
  = (quickSort2 lo_a1uO) ++ (x_a1uM : quickSort2 hi_a1uP)
  where (lo_a1uO, hi_a1uP) = partition ((>=) x_a1uM) xs_a1uN
quickerSort [] = []
quickerSort (investigate@[x_a1xC]) = [x_a1xC]
quickerSort
  (investigate@((investigate@((investigate@x_a1xD) :
                                (investigate@xs_a1xE)))))
  = split_a1xF x_a1xD [] [] xs_a1xE
  where split_a1xF x_a1xG lo_a1xH hi_a1xI (investigate@[])
          = quickerSort lo_a1xH ++ (x_a1xG : quickerSort hi_a1xI)
        split_a1xF x_a1xJ (investigate@lo_a1xK) hi_a1xL
          (investigate@((investigate@y_a1xM) : ys_a1xN))
          | y_a1xM <= x_a1xJ =
            split_a1xF x_a1xJ (y_a1xM : lo_a1xK) hi_a1xL ys_a1xN
          | True = split_a1xF x_a1xJ lo_a1xK (y_a1xM : hi_a1xL) ys_a1xN
insertSort [] = []
insertSort ((investigate@x_a1xO) : xs_a1xP)
  = trins_a1xQ [] [x_a1xO] xs_a1xP
  where trins_a1xQ ::
                     Ord a_a1xR => [a_a1xR] -> [a_a1xR] -> [a_a1xR] -> [a_a1xR]
        trins_a1xQ rev_a1xS [] (investigate@(y_a1xT : ys_a1xU))
          = trins_a1xQ [] ((reverse rev_a1xS) ++ [y_a1xT]) ys_a1xU
        trins_a1xQ (investigate@rev_a1Bq) (investigate@xs_a1Br) []
          = (reverse rev_a1Bq) ++ xs_a1Br
        trins_a1xQ rev_a1Bs (x_a1Bt : xs_a1Bu)
          ((investigate@y_a1Bv) : (investigate@ys_a1Bw))
          | x_a1Bt < y_a1Bv =
            trins_a1xQ (x_a1Bt : rev_a1Bs) xs_a1Bu (y_a1Bv : ys_a1Bw)
          | True =
            trins_a1xQ [] (reverse rev_a1Bs ++ (y_a1Bv : x_a1Bt : xs_a1Bu))
              ys_a1Bw
treeSort = readTree_a1By . mkTree_a1Bx
  where mkTree_a1Bx :: Ord a_a1Bz => [a_a1Bz] -> Tree a_a1Bz
        (investigate@mkTree_a1Bx) = foldr to_tree_a1BB Tip
          where to_tree_a1BB ::
                               Ord a_a1BC => a_a1BC -> Tree a_a1BC -> Tree a_a1BC
                to_tree_a1BB (investigate@x_a1BD) Tip = Branch x_a1BD Tip Tip
                to_tree_a1BB (investigate@x_a1BE)
                  (investigate@((investigate@(Branch y_a1BF (investigate@l_a1BG)
                                                r_a1BH))))
                  | x_a1BE <= y_a1BF =
                    Branch y_a1BF (to_tree_a1BB x_a1BE l_a1BG) r_a1BH
                  | True = Branch y_a1BF l_a1BG (to_tree_a1BB x_a1BE r_a1BH)
        
        readTree_a1By :: Ord a_a1BA => Tree a_a1BA -> [a_a1BA]
        readTree_a1By Tip = []
        readTree_a1By (investigate@(Branch x_a1Uj l_a1Uk r_a1Ul))
          = readTree_a1By l_a1Uk ++ (x_a1Uj : readTree_a1By r_a1Ul)
treeSort2 = readTree_a1Un . mkTree_a1Um
  where mkTree_a1Um :: Ord a_a1Uo => [a_a1Uo] -> Tree2 a_a1Uo
        mkTree_a1Um = foldr to_tree_a1Uq Tip2
          where to_tree_a1Uq ::
                               Ord a_a1Ur => a_a1Ur -> Tree2 a_a1Ur -> Tree2 a_a1Ur
                to_tree_a1Uq x_a1Us Tip2 = Twig2 x_a1Us
                to_tree_a1Uq (investigate@x_a1Ut) ((investigate@(Twig2 y_a1Uu)))
                  | x_a1Ut <= y_a1Uu = Branch2 y_a1Uu (Twig2 x_a1Ut) Tip2
                  | True = Branch2 y_a1Uu Tip2 (Twig2 x_a1Ut)
                to_tree_a1Uq (investigate@x_a1Uv)
                  (Branch2 y_a1Uw (investigate@l_a1Ux) r_a1Uy)
                  | x_a1Uv <= y_a1Uw =
                    Branch2 y_a1Uw (to_tree_a1Uq x_a1Uv l_a1Ux) r_a1Uy
                  | True = Branch2 y_a1Uw l_a1Ux (to_tree_a1Uq x_a1Uv r_a1Uy)
        
        readTree_a1Un :: Ord a_a1Up => Tree2 a_a1Up -> [a_a1Up]
        readTree_a1Un Tip2 = []
        readTree_a1Un (Twig2 (investigate@x_a1Uz)) = [x_a1Uz]
        readTree_a1Un
          (investigate@(Branch2 (investigate@x_a1UA) (investigate@l_a1UB)
                          r_a1UC))
          = readTree_a1Un l_a1UB ++ (x_a1UA : readTree_a1Un r_a1UC)
heapSort xs_a1UD = clear_a1UG (heap_a1UE (0 :: Int) xs_a1UD)
  where heap_a1UE :: Ord a_a1UJ => Int -> [a_a1UJ] -> Tree a_a1UJ
        heap_a1UE k_a1UN [] = Tip
        heap_a1UE k_a1UO
          (investigate@((investigate@x_a1UP) : (investigate@xs_a1UQ)))
          = to_heap_a1UF k_a1UO x_a1UP
              (heap_a1UE (k_a1UO + (1 :: Int)) xs_a1UQ)
        
        to_heap_a1UF ::
                       Ord a_a1UK => Int -> a_a1UK -> Tree a_a1UK -> Tree a_a1UK
        to_heap_a1UF k_a1W3 x_a1W4 (investigate@Tip)
          = Branch x_a1W4 Tip Tip
        to_heap_a1UF k_a1W5 (investigate@x_a1W6)
          (investigate@((investigate@(Branch (investigate@y_a1W7)
                                        (investigate@l_a1W8) r_a1W9))))
          | x_a1W6 <= y_a1W7 && odd k_a1W5 =
            Branch x_a1W6 (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 l_a1W8)
              r_a1W9
          | x_a1W6 <= y_a1W7 =
            Branch x_a1W6 l_a1W8
              (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 r_a1W9)
          | odd k_a1W5 =
            Branch y_a1W7 (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 l_a1W8)
              r_a1W9
          | True =
            Branch y_a1W7 l_a1W8
              (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 r_a1W9)
        
        clear_a1UG :: Ord a_a1UL => Tree a_a1UL -> [a_a1UL]
        clear_a1UG Tip = []
        clear_a1UG
          (Branch (investigate@x_a25N) (investigate@l_a25O)
             (investigate@r_a25P))
          = x_a25N : clear_a1UG (mix_a1UH l_a25O r_a25P)
        
        mix_a1UH :: Ord a_a1UM => Tree a_a1UM -> Tree a_a1UM -> Tree a_a1UM
        mix_a1UH (investigate@Tip) r_a25Q = r_a25Q
        mix_a1UH (investigate@l_a25R) (investigate@Tip) = l_a25R
        mix_a1UH
          t1_a25S@(investigate@(Branch (investigate@x_a25T) l1_a25U
                                  (investigate@r1_a25V)))
          t2_a25W@(investigate@((investigate@(Branch (investigate@y_a25X)
                                                (investigate@l2_a25Y) r2_a25Z))))
          | x_a25T <= y_a25X =
            Branch x_a25T (mix_a1UH l1_a25U r1_a25V) t2_a25W
          | True = Branch y_a25X t1_a25S (mix_a1UH l2_a25Y r2_a25Z)
        
        div2_a1UI :: Int -> Int
        div2_a1UI (investigate@k_a260) = k_a260 `div` 2
mergeSort = merge_lists_a262 . (runsplit_a261 [])
  where runsplit_a261 ::
                        Ord a_a264 => [a_a264] -> [a_a264] -> [[a_a264]]
        runsplit_a261 (investigate@[]) [] = []
        runsplit_a261 (investigate@run_a267) [] = [run_a267]
        runsplit_a261 []
          (investigate@((investigate@((investigate@x_a268) :
                                        (investigate@xs_a269)))))
          = runsplit_a261 [x_a268] xs_a269
        runsplit_a261 (investigate@[(investigate@r_a26a)])
          (investigate@((investigate@((investigate@x_a26b) :
                                        (investigate@xs_a26c)))))
          | x_a26b > r_a26a = runsplit_a261 [r_a26a, x_a26b] xs_a26c
        runsplit_a261
          (investigate@rl_a26d@(investigate@((investigate@(r_a26e :
                                                             rs_a26f)))))
          (investigate@((investigate@x_a26g) : (investigate@xs_a26h)))
          | x_a26g <= r_a26e = runsplit_a261 (x_a26g : rl_a26d) xs_a26h
          | True = rl_a26d : (runsplit_a261 [x_a26g] xs_a26h)
        
        merge_lists_a262 :: Ord a_a265 => [[a_a265]] -> [a_a265]
        merge_lists_a262 [] = []
        merge_lists_a262
          (investigate@((investigate@(x_a26i : (investigate@xs_a26j)))))
          = merge_a263 x_a26i (merge_lists_a262 xs_a26j)
        
        merge_a263 :: Ord a_a266 => [a_a266] -> [a_a266] -> [a_a266]
        merge_a263 (investigate@[]) (investigate@ys_a26k) = ys_a26k
        merge_a263 (investigate@xs_a26l) [] = xs_a26l
        merge_a263 (investigate@xl_a26m@(x_a26n : xs_a26o))
          (investigate@yl_a26p@((investigate@y_a26q) : ys_a26r))
          | x_a26n == y_a26q = x_a26n : y_a26q : (merge_a263 xs_a26o ys_a26r)
          | x_a26n < y_a26q = x_a26n : (merge_a263 xs_a26o yl_a26p)
          | True = y_a26q : (merge_a263 xl_a26m ys_a26r)

data Tree a_arK = Tip
                | Branch a_arK (Tree a_arK) (Tree a_arK)

data Tree2 a_arJ = Tip2
                 | Twig2 a_arJ
                 | Branch2 a_arJ (Tree2 a_arJ) (Tree2 a_arJ)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.quickSort :: Ord a_a1nB => [a_a1nB] -> [a_a1nB]
Dum.quickSort2 :: Ord a_a1nA => [a_a1nA] -> [a_a1nA]
Dum.quickerSort :: Ord a_a1nz => [a_a1nz] -> [a_a1nz]
Dum.insertSort :: Ord a_a1ny => [a_a1ny] -> [a_a1ny]
Dum.treeSort :: Ord a_a1nx => [a_a1nx] -> [a_a1nx]
Dum.treeSort2 :: Ord a_a1nw => [a_a1nw] -> [a_a1nw]
Dum.heapSort :: Ord a_a1nv => [a_a1nv] -> [a_a1nv]
Dum.mergeSort :: Ord a_arL => [a_arL] -> [a_arL]
Dum.quickSort (![]) = []
Dum.quickSort ((!(x_a1nC : (!xs_a1nD))))
  = (Dum.quickSort lo_a1uI) ++ (x_a1nC : Dum.quickSort hi_a1uJ)
  where
      lo_a1uI = [y_a1uK | (!y_a1uK) <- xs_a1nD, y_a1uK <= x_a1nC]
      (!hi_a1uJ) = [y_a1uL | y_a1uL <- xs_a1nD, y_a1uL > x_a1nC]
Dum.quickSort2 (![]) = []
Dum.quickSort2 (x_a1uM : xs_a1uN)
  = (Dum.quickSort2 lo_a1uO) ++ (x_a1uM : Dum.quickSort2 hi_a1uP)
  where
      (lo_a1uO, hi_a1uP) = partition ((>=) x_a1uM) xs_a1uN
Dum.quickerSort [] = []
Dum.quickerSort (![x_a1xC]) = [x_a1xC]
Dum.quickerSort (!((!((!x_a1xD) : (!xs_a1xE)))))
  = split_a1xF x_a1xD [] [] xs_a1xE
  where
      split_a1xF x_a1xG lo_a1xH hi_a1xI (![])
        = Dum.quickerSort lo_a1xH ++ (x_a1xG : Dum.quickerSort hi_a1xI)
      split_a1xF x_a1xJ (!lo_a1xK) hi_a1xL (!((!y_a1xM) : ys_a1xN))
        | y_a1xM <= x_a1xJ
        = split_a1xF x_a1xJ (y_a1xM : lo_a1xK) hi_a1xL ys_a1xN
        | True = split_a1xF x_a1xJ lo_a1xK (y_a1xM : hi_a1xL) ys_a1xN
Dum.insertSort [] = []
Dum.insertSort ((!x_a1xO) : xs_a1xP)
  = trins_a1xQ [] [x_a1xO] xs_a1xP
  where
      trins_a1xQ ::
        Ord a_a1xR => [a_a1xR] -> [a_a1xR] -> [a_a1xR] -> [a_a1xR]
      trins_a1xQ rev_a1xS [] (!(y_a1xT : ys_a1xU))
        = trins_a1xQ [] ((reverse rev_a1xS) ++ [y_a1xT]) ys_a1xU
      trins_a1xQ (!rev_a1Bq) (!xs_a1Br) []
        = (reverse rev_a1Bq) ++ xs_a1Br
      trins_a1xQ rev_a1Bs (x_a1Bt : xs_a1Bu) ((!y_a1Bv) : (!ys_a1Bw))
        | x_a1Bt < y_a1Bv
        = trins_a1xQ (x_a1Bt : rev_a1Bs) xs_a1Bu (y_a1Bv : ys_a1Bw)
        | True
        = trins_a1xQ
            [] (reverse rev_a1Bs ++ (y_a1Bv : x_a1Bt : xs_a1Bu)) ys_a1Bw
Dum.treeSort
  = readTree_a1By . mkTree_a1Bx
  where
      mkTree_a1Bx :: Ord a_a1Bz => [a_a1Bz] -> Dum.Tree a_a1Bz
      (!mkTree_a1Bx)
        = foldr to_tree_a1BB Dum.Tip
        where
            to_tree_a1BB ::
              Ord a_a1BC => a_a1BC -> Dum.Tree a_a1BC -> Dum.Tree a_a1BC
            to_tree_a1BB (!x_a1BD) Dum.Tip = Dum.Branch x_a1BD Dum.Tip Dum.Tip
            to_tree_a1BB (!x_a1BE) (!((!(Dum.Branch y_a1BF (!l_a1BG) r_a1BH))))
              | x_a1BE <= y_a1BF
              = Dum.Branch y_a1BF (to_tree_a1BB x_a1BE l_a1BG) r_a1BH
              | True = Dum.Branch y_a1BF l_a1BG (to_tree_a1BB x_a1BE r_a1BH)
      readTree_a1By :: Ord a_a1BA => Dum.Tree a_a1BA -> [a_a1BA]
      readTree_a1By Dum.Tip = []
      readTree_a1By (!(Dum.Branch x_a1Uj l_a1Uk r_a1Ul))
        = readTree_a1By l_a1Uk ++ (x_a1Uj : readTree_a1By r_a1Ul)
Dum.treeSort2
  = readTree_a1Un . mkTree_a1Um
  where
      mkTree_a1Um :: Ord a_a1Uo => [a_a1Uo] -> Dum.Tree2 a_a1Uo
      mkTree_a1Um
        = foldr to_tree_a1Uq Dum.Tip2
        where
            to_tree_a1Uq ::
              Ord a_a1Ur => a_a1Ur -> Dum.Tree2 a_a1Ur -> Dum.Tree2 a_a1Ur
            to_tree_a1Uq x_a1Us Dum.Tip2 = Dum.Twig2 x_a1Us
            to_tree_a1Uq (!x_a1Ut) ((!(Dum.Twig2 y_a1Uu)))
              | x_a1Ut <= y_a1Uu = Dum.Branch2 y_a1Uu (Dum.Twig2 x_a1Ut) Dum.Tip2
              | True = Dum.Branch2 y_a1Uu Dum.Tip2 (Dum.Twig2 x_a1Ut)
            to_tree_a1Uq (!x_a1Uv) (Dum.Branch2 y_a1Uw (!l_a1Ux) r_a1Uy)
              | x_a1Uv <= y_a1Uw
              = Dum.Branch2 y_a1Uw (to_tree_a1Uq x_a1Uv l_a1Ux) r_a1Uy
              | True = Dum.Branch2 y_a1Uw l_a1Ux (to_tree_a1Uq x_a1Uv r_a1Uy)
      readTree_a1Un :: Ord a_a1Up => Dum.Tree2 a_a1Up -> [a_a1Up]
      readTree_a1Un Dum.Tip2 = []
      readTree_a1Un (Dum.Twig2 (!x_a1Uz)) = [x_a1Uz]
      readTree_a1Un (!(Dum.Branch2 (!x_a1UA) (!l_a1UB) r_a1UC))
        = readTree_a1Un l_a1UB ++ (x_a1UA : readTree_a1Un r_a1UC)
Dum.heapSort xs_a1UD
  = clear_a1UG (heap_a1UE (0 :: Int) xs_a1UD)
  where
      heap_a1UE :: Ord a_a1UJ => Int -> [a_a1UJ] -> Dum.Tree a_a1UJ
      heap_a1UE k_a1UN [] = Dum.Tip
      heap_a1UE k_a1UO (!((!x_a1UP) : (!xs_a1UQ)))
        = to_heap_a1UF
            k_a1UO x_a1UP (heap_a1UE (k_a1UO + (1 :: Int)) xs_a1UQ)
      to_heap_a1UF ::
        Ord a_a1UK => Int -> a_a1UK -> Dum.Tree a_a1UK -> Dum.Tree a_a1UK
      to_heap_a1UF k_a1W3 x_a1W4 (!Dum.Tip)
        = Dum.Branch x_a1W4 Dum.Tip Dum.Tip
      to_heap_a1UF
        k_a1W5
        (!x_a1W6)
        (!((!(Dum.Branch (!y_a1W7) (!l_a1W8) r_a1W9))))
        | x_a1W6 <= y_a1W7 && odd k_a1W5
        = Dum.Branch
            x_a1W6 (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 l_a1W8) r_a1W9
        | x_a1W6 <= y_a1W7
        = Dum.Branch
            x_a1W6 l_a1W8 (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 r_a1W9)
        | odd k_a1W5
        = Dum.Branch
            y_a1W7 (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 l_a1W8) r_a1W9
        | True
        = Dum.Branch
            y_a1W7 l_a1W8 (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 r_a1W9)
      clear_a1UG :: Ord a_a1UL => Dum.Tree a_a1UL -> [a_a1UL]
      clear_a1UG Dum.Tip = []
      clear_a1UG (Dum.Branch (!x_a25N) (!l_a25O) (!r_a25P))
        = x_a25N : clear_a1UG (mix_a1UH l_a25O r_a25P)
      mix_a1UH ::
        Ord a_a1UM => Dum.Tree a_a1UM -> Dum.Tree a_a1UM -> Dum.Tree a_a1UM
      mix_a1UH (!Dum.Tip) r_a25Q = r_a25Q
      mix_a1UH (!l_a25R) (!Dum.Tip) = l_a25R
      mix_a1UH
        t1_a25S@(!(Dum.Branch (!x_a25T) l1_a25U (!r1_a25V)))
        t2_a25W@(!((!(Dum.Branch (!y_a25X) (!l2_a25Y) r2_a25Z))))
        | x_a25T <= y_a25X
        = Dum.Branch x_a25T (mix_a1UH l1_a25U r1_a25V) t2_a25W
        | True = Dum.Branch y_a25X t1_a25S (mix_a1UH l2_a25Y r2_a25Z)
      div2_a1UI :: Int -> Int
      div2_a1UI (!k_a260) = k_a260 `div` 2
Dum.mergeSort
  = merge_lists_a262 . (runsplit_a261 [])
  where
      runsplit_a261 :: Ord a_a264 => [a_a264] -> [a_a264] -> [[a_a264]]
      runsplit_a261 (![]) [] = []
      runsplit_a261 (!run_a267) [] = [run_a267]
      runsplit_a261 [] (!((!((!x_a268) : (!xs_a269)))))
        = runsplit_a261 [x_a268] xs_a269
      runsplit_a261 (![(!r_a26a)]) (!((!((!x_a26b) : (!xs_a26c)))))
        | x_a26b > r_a26a = runsplit_a261 [r_a26a, x_a26b] xs_a26c
      runsplit_a261
        (!rl_a26d@(!((!(r_a26e : rs_a26f)))))
        (!((!x_a26g) : (!xs_a26h)))
        | x_a26g <= r_a26e = runsplit_a261 (x_a26g : rl_a26d) xs_a26h
        | True = rl_a26d : (runsplit_a261 [x_a26g] xs_a26h)
      merge_lists_a262 :: Ord a_a265 => [[a_a265]] -> [a_a265]
      merge_lists_a262 [] = []
      merge_lists_a262 (!((!(x_a26i : (!xs_a26j)))))
        = merge_a263 x_a26i (merge_lists_a262 xs_a26j)
      merge_a263 :: Ord a_a266 => [a_a266] -> [a_a266] -> [a_a266]
      merge_a263 (![]) (!ys_a26k) = ys_a26k
      merge_a263 (!xs_a26l) [] = xs_a26l
      merge_a263
        (!xl_a26m@(x_a26n : xs_a26o))
        (!yl_a26p@((!y_a26q) : ys_a26r))
        | x_a26n == y_a26q = x_a26n : y_a26q : (merge_a263 xs_a26o ys_a26r)
        | x_a26n < y_a26q = x_a26n : (merge_a263 xs_a26o yl_a26p)
        | True = y_a26q : (merge_a263 xl_a26m ys_a26r)

data Dum.Tree a_arK
  = Dum.Tip | Dum.Branch a_arK (Dum.Tree a_arK) (Dum.Tree a_arK)
data Dum.Tree2 a_arJ
  = Dum.Tip2 |
    Dum.Twig2 a_arJ |
    Dum.Branch2 a_arJ (Dum.Tree2 a_arJ) (Dum.Tree2 a_arJ)


["[]","![]","(![])","x_a1nC","xs_a1nD","!xs_a1nD","(!xs_a1nD)","x_a1nC : (!xs_a1nD)","(x_a1nC : (!xs_a1nD))","!(x_a1nC : (!xs_a1nD))","(!(x_a1nC : (!xs_a1nD)))","((!(x_a1nC : (!xs_a1nD))))","lo_a1uI","y_a1uK","!y_a1uK","(!y_a1uK)","hi_a1uJ","!hi_a1uJ","(!hi_a1uJ)","y_a1uL","[]","![]","(![])","x_a1uM","xs_a1uN","x_a1uM : xs_a1uN","(x_a1uM : xs_a1uN)","lo_a1uO","hi_a1uP","(lo_a1uO, hi_a1uP)","[]","x_a1xC","[x_a1xC]","![x_a1xC]","(![x_a1xC])","x_a1xD","!x_a1xD","(!x_a1xD)","xs_a1xE","!xs_a1xE","(!xs_a1xE)","(!x_a1xD) : (!xs_a1xE)","((!x_a1xD) : (!xs_a1xE))","!((!x_a1xD) : (!xs_a1xE))","(!((!x_a1xD) : (!xs_a1xE)))","((!((!x_a1xD) : (!xs_a1xE))))","!((!((!x_a1xD) : (!xs_a1xE))))","(!((!((!x_a1xD) : (!xs_a1xE)))))","x_a1xG","lo_a1xH","hi_a1xI","[]","![]","(![])","x_a1xJ","lo_a1xK","!lo_a1xK","(!lo_a1xK)","hi_a1xL","y_a1xM","!y_a1xM","(!y_a1xM)","ys_a1xN","(!y_a1xM) : ys_a1xN","((!y_a1xM) : ys_a1xN)","!((!y_a1xM) : ys_a1xN)","(!((!y_a1xM) : ys_a1xN))","[]","x_a1xO","!x_a1xO","(!x_a1xO)","xs_a1xP","(!x_a1xO) : xs_a1xP","((!x_a1xO) : xs_a1xP)","rev_a1xS","[]","y_a1xT","ys_a1xU","y_a1xT : ys_a1xU","(y_a1xT : ys_a1xU)","!(y_a1xT : ys_a1xU)","(!(y_a1xT : ys_a1xU))","rev_a1Bq","!rev_a1Bq","(!rev_a1Bq)","xs_a1Br","!xs_a1Br","(!xs_a1Br)","[]","rev_a1Bs","x_a1Bt","xs_a1Bu","x_a1Bt : xs_a1Bu","(x_a1Bt : xs_a1Bu)","y_a1Bv","!y_a1Bv","(!y_a1Bv)","ys_a1Bw","!ys_a1Bw","(!ys_a1Bw)","(!y_a1Bv) : (!ys_a1Bw)","((!y_a1Bv) : (!ys_a1Bw))","treeSort","mkTree_a1Bx","!mkTree_a1Bx","(!mkTree_a1Bx)","x_a1BD","!x_a1BD","(!x_a1BD)","Tip","x_a1BE","!x_a1BE","(!x_a1BE)","y_a1BF","l_a1BG","!l_a1BG","(!l_a1BG)","r_a1BH","Branch y_a1BF (!l_a1BG) r_a1BH","(Branch y_a1BF (!l_a1BG) r_a1BH)","!(Branch y_a1BF (!l_a1BG) r_a1BH)","(!(Branch y_a1BF (!l_a1BG) r_a1BH))","((!(Branch y_a1BF (!l_a1BG) r_a1BH)))","!((!(Branch y_a1BF (!l_a1BG) r_a1BH)))","(!((!(Branch y_a1BF (!l_a1BG) r_a1BH))))","Tip","x_a1Uj","l_a1Uk","r_a1Ul","Branch x_a1Uj l_a1Uk r_a1Ul","(Branch x_a1Uj l_a1Uk r_a1Ul)","!(Branch x_a1Uj l_a1Uk r_a1Ul)","(!(Branch x_a1Uj l_a1Uk r_a1Ul))","treeSort2","mkTree_a1Um","x_a1Us","Tip2","x_a1Ut","!x_a1Ut","(!x_a1Ut)","y_a1Uu","Twig2 y_a1Uu","(Twig2 y_a1Uu)","!(Twig2 y_a1Uu)","(!(Twig2 y_a1Uu))","((!(Twig2 y_a1Uu)))","x_a1Uv","!x_a1Uv","(!x_a1Uv)","y_a1Uw","l_a1Ux","!l_a1Ux","(!l_a1Ux)","r_a1Uy","Branch2 y_a1Uw (!l_a1Ux) r_a1Uy","(Branch2 y_a1Uw (!l_a1Ux) r_a1Uy)","Tip2","x_a1Uz","!x_a1Uz","(!x_a1Uz)","Twig2 (!x_a1Uz)","(Twig2 (!x_a1Uz))","x_a1UA","!x_a1UA","(!x_a1UA)","l_a1UB","!l_a1UB","(!l_a1UB)","r_a1UC","Branch2 (!x_a1UA) (!l_a1UB) r_a1UC","(Branch2 (!x_a1UA) (!l_a1UB) r_a1UC)","!(Branch2 (!x_a1UA) (!l_a1UB) r_a1UC)","(!(Branch2 (!x_a1UA) (!l_a1UB) r_a1UC))","xs_a1UD","k_a1UN","[]","k_a1UO","x_a1UP","!x_a1UP","(!x_a1UP)","xs_a1UQ","!xs_a1UQ","(!xs_a1UQ)","(!x_a1UP) : (!xs_a1UQ)","((!x_a1UP) : (!xs_a1UQ))","!((!x_a1UP) : (!xs_a1UQ))","(!((!x_a1UP) : (!xs_a1UQ)))","k_a1W3","x_a1W4","Tip","!Tip","(!Tip)","k_a1W5","x_a1W6","!x_a1W6","(!x_a1W6)","y_a1W7","!y_a1W7","(!y_a1W7)","l_a1W8","!l_a1W8","(!l_a1W8)","r_a1W9","Branch (!y_a1W7) (!l_a1W8) r_a1W9","(Branch (!y_a1W7) (!l_a1W8) r_a1W9)","!(Branch (!y_a1W7) (!l_a1W8) r_a1W9)","(!(Branch (!y_a1W7) (!l_a1W8) r_a1W9))","((!(Branch (!y_a1W7) (!l_a1W8) r_a1W9)))","!((!(Branch (!y_a1W7) (!l_a1W8) r_a1W9)))","(!((!(Branch (!y_a1W7) (!l_a1W8) r_a1W9))))","Tip","x_a25N","!x_a25N","(!x_a25N)","l_a25O","!l_a25O","(!l_a25O)","r_a25P","!r_a25P","(!r_a25P)","Branch (!x_a25N) (!l_a25O) (!r_a25P)","(Branch (!x_a25N) (!l_a25O) (!r_a25P))","Tip","!Tip","(!Tip)","r_a25Q","l_a25R","!l_a25R","(!l_a25R)","Tip","!Tip","(!Tip)","x_a25T","!x_a25T","(!x_a25T)","l1_a25U","r1_a25V","!r1_a25V","(!r1_a25V)","Branch (!x_a25T) l1_a25U (!r1_a25V)","(Branch (!x_a25T) l1_a25U (!r1_a25V))","!(Branch (!x_a25T) l1_a25U (!r1_a25V))","(!(Branch (!x_a25T) l1_a25U (!r1_a25V)))","t1_a25S@(!(Branch (!x_a25T) l1_a25U (!r1_a25V)))","y_a25X","!y_a25X","(!y_a25X)","l2_a25Y","!l2_a25Y","(!l2_a25Y)","r2_a25Z","Branch (!y_a25X) (!l2_a25Y) r2_a25Z","(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)","!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)","(!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z))","((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)))","!((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)))","(!((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z))))","t2_a25W@(!((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z))))","k_a260","!k_a260","(!k_a260)","mergeSort","[]","![]","(![])","[]","run_a267","!run_a267","(!run_a267)","[]","[]","x_a268","!x_a268","(!x_a268)","xs_a269","!xs_a269","(!xs_a269)","(!x_a268) : (!xs_a269)","((!x_a268) : (!xs_a269))","!((!x_a268) : (!xs_a269))","(!((!x_a268) : (!xs_a269)))","((!((!x_a268) : (!xs_a269))))","!((!((!x_a268) : (!xs_a269))))","(!((!((!x_a268) : (!xs_a269)))))","r_a26a","!r_a26a","(!r_a26a)","[(!r_a26a)]","![(!r_a26a)]","(![(!r_a26a)])","x_a26b","!x_a26b","(!x_a26b)","xs_a26c","!xs_a26c","(!xs_a26c)","(!x_a26b) : (!xs_a26c)","((!x_a26b) : (!xs_a26c))","!((!x_a26b) : (!xs_a26c))","(!((!x_a26b) : (!xs_a26c)))","((!((!x_a26b) : (!xs_a26c))))","!((!((!x_a26b) : (!xs_a26c))))","(!((!((!x_a26b) : (!xs_a26c)))))","r_a26e","rs_a26f","r_a26e : rs_a26f","(r_a26e : rs_a26f)","!(r_a26e : rs_a26f)","(!(r_a26e : rs_a26f))","((!(r_a26e : rs_a26f)))","!((!(r_a26e : rs_a26f)))","(!((!(r_a26e : rs_a26f))))","rl_a26d@(!((!(r_a26e : rs_a26f))))","!rl_a26d@(!((!(r_a26e : rs_a26f))))","(!rl_a26d@(!((!(r_a26e : rs_a26f)))))","x_a26g","!x_a26g","(!x_a26g)","xs_a26h","!xs_a26h","(!xs_a26h)","(!x_a26g) : (!xs_a26h)","((!x_a26g) : (!xs_a26h))","!((!x_a26g) : (!xs_a26h))","(!((!x_a26g) : (!xs_a26h)))","[]","x_a26i","xs_a26j","!xs_a26j","(!xs_a26j)","x_a26i : (!xs_a26j)","(x_a26i : (!xs_a26j))","!(x_a26i : (!xs_a26j))","(!(x_a26i : (!xs_a26j)))","((!(x_a26i : (!xs_a26j))))","!((!(x_a26i : (!xs_a26j))))","(!((!(x_a26i : (!xs_a26j)))))","[]","![]","(![])","ys_a26k","!ys_a26k","(!ys_a26k)","xs_a26l","!xs_a26l","(!xs_a26l)","[]","x_a26n","xs_a26o","x_a26n : xs_a26o","(x_a26n : xs_a26o)","xl_a26m@(x_a26n : xs_a26o)","!xl_a26m@(x_a26n : xs_a26o)","(!xl_a26m@(x_a26n : xs_a26o))","y_a26q","!y_a26q","(!y_a26q)","ys_a26r","(!y_a26q) : ys_a26r","((!y_a26q) : ys_a26r)","yl_a26p@((!y_a26q) : ys_a26r)","!yl_a26p@((!y_a26q) : ys_a26r)","(!yl_a26p@((!y_a26q) : ys_a26r))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Result
import Table
import Knowledge

quickSort :: Ord a_a1nB => [a_a1nB] -> [a_a1nB]

quickSort2 :: Ord a_a1nA => [a_a1nA] -> [a_a1nA]

quickerSort :: Ord a_a1nz => [a_a1nz] -> [a_a1nz]

insertSort :: Ord a_a1ny => [a_a1ny] -> [a_a1ny]

treeSort :: Ord a_a1nx => [a_a1nx] -> [a_a1nx]

treeSort2 :: Ord a_a1nw => [a_a1nw] -> [a_a1nw]

heapSort :: Ord a_a1nv => [a_a1nv] -> [a_a1nv]

mergeSort :: Ord a_arL => [a_arL] -> [a_arL]
quickSort (investigate@[]) = []
quickSort ((investigate@(x_a1nC : (investigate@xs_a1nD))))
  = (quickSort lo_a1uI) ++ (x_a1nC : quickSort hi_a1uJ)
  where lo_a1uI
          = [y_a1uK | (investigate@y_a1uK) <- xs_a1nD, y_a1uK <= x_a1nC]
        (investigate@hi_a1uJ)
          = [y_a1uL | y_a1uL <- xs_a1nD, y_a1uL > x_a1nC]
quickSort2 (investigate@[]) = []
quickSort2 (x_a1uM : xs_a1uN)
  = (quickSort2 lo_a1uO) ++ (x_a1uM : quickSort2 hi_a1uP)
  where (lo_a1uO, hi_a1uP) = partition ((>=) x_a1uM) xs_a1uN
quickerSort [] = []
quickerSort (investigate@[x_a1xC]) = [x_a1xC]
quickerSort
  (investigate@((investigate@((investigate@x_a1xD) :
                                (investigate@xs_a1xE)))))
  = split_a1xF x_a1xD [] [] xs_a1xE
  where split_a1xF x_a1xG lo_a1xH hi_a1xI (investigate@[])
          = quickerSort lo_a1xH ++ (x_a1xG : quickerSort hi_a1xI)
        split_a1xF x_a1xJ (investigate@lo_a1xK) hi_a1xL
          (investigate@((investigate@y_a1xM) : ys_a1xN))
          | y_a1xM <= x_a1xJ =
            split_a1xF x_a1xJ (y_a1xM : lo_a1xK) hi_a1xL ys_a1xN
          | True = split_a1xF x_a1xJ lo_a1xK (y_a1xM : hi_a1xL) ys_a1xN
insertSort [] = []
insertSort ((investigate@x_a1xO) : xs_a1xP)
  = trins_a1xQ [] [x_a1xO] xs_a1xP
  where trins_a1xQ ::
                     Ord a_a1xR => [a_a1xR] -> [a_a1xR] -> [a_a1xR] -> [a_a1xR]
        trins_a1xQ rev_a1xS [] (investigate@(y_a1xT : ys_a1xU))
          = trins_a1xQ [] ((reverse rev_a1xS) ++ [y_a1xT]) ys_a1xU
        trins_a1xQ (investigate@rev_a1Bq) (investigate@xs_a1Br) []
          = (reverse rev_a1Bq) ++ xs_a1Br
        trins_a1xQ rev_a1Bs (x_a1Bt : xs_a1Bu)
          ((investigate@y_a1Bv) : (investigate@ys_a1Bw))
          | x_a1Bt < y_a1Bv =
            trins_a1xQ (x_a1Bt : rev_a1Bs) xs_a1Bu (y_a1Bv : ys_a1Bw)
          | True =
            trins_a1xQ [] (reverse rev_a1Bs ++ (y_a1Bv : x_a1Bt : xs_a1Bu))
              ys_a1Bw
treeSort = readTree_a1By . mkTree_a1Bx
  where mkTree_a1Bx :: Ord a_a1Bz => [a_a1Bz] -> Tree a_a1Bz
        (investigate@mkTree_a1Bx) = foldr to_tree_a1BB Tip
          where to_tree_a1BB ::
                               Ord a_a1BC => a_a1BC -> Tree a_a1BC -> Tree a_a1BC
                to_tree_a1BB (investigate@x_a1BD) Tip = Branch x_a1BD Tip Tip
                to_tree_a1BB (investigate@x_a1BE)
                  (investigate@((investigate@(Branch y_a1BF (investigate@l_a1BG)
                                                r_a1BH))))
                  | x_a1BE <= y_a1BF =
                    Branch y_a1BF (to_tree_a1BB x_a1BE l_a1BG) r_a1BH
                  | True = Branch y_a1BF l_a1BG (to_tree_a1BB x_a1BE r_a1BH)
        
        readTree_a1By :: Ord a_a1BA => Tree a_a1BA -> [a_a1BA]
        readTree_a1By Tip = []
        readTree_a1By (investigate@(Branch x_a1Uj l_a1Uk r_a1Ul))
          = readTree_a1By l_a1Uk ++ (x_a1Uj : readTree_a1By r_a1Ul)
treeSort2 = readTree_a1Un . mkTree_a1Um
  where mkTree_a1Um :: Ord a_a1Uo => [a_a1Uo] -> Tree2 a_a1Uo
        mkTree_a1Um = foldr to_tree_a1Uq Tip2
          where to_tree_a1Uq ::
                               Ord a_a1Ur => a_a1Ur -> Tree2 a_a1Ur -> Tree2 a_a1Ur
                to_tree_a1Uq x_a1Us Tip2 = Twig2 x_a1Us
                to_tree_a1Uq (investigate@x_a1Ut) ((investigate@(Twig2 y_a1Uu)))
                  | x_a1Ut <= y_a1Uu = Branch2 y_a1Uu (Twig2 x_a1Ut) Tip2
                  | True = Branch2 y_a1Uu Tip2 (Twig2 x_a1Ut)
                to_tree_a1Uq (investigate@x_a1Uv)
                  (Branch2 y_a1Uw (investigate@l_a1Ux) r_a1Uy)
                  | x_a1Uv <= y_a1Uw =
                    Branch2 y_a1Uw (to_tree_a1Uq x_a1Uv l_a1Ux) r_a1Uy
                  | True = Branch2 y_a1Uw l_a1Ux (to_tree_a1Uq x_a1Uv r_a1Uy)
        
        readTree_a1Un :: Ord a_a1Up => Tree2 a_a1Up -> [a_a1Up]
        readTree_a1Un Tip2 = []
        readTree_a1Un (Twig2 (investigate@x_a1Uz)) = [x_a1Uz]
        readTree_a1Un
          (investigate@(Branch2 (investigate@x_a1UA) (investigate@l_a1UB)
                          r_a1UC))
          = readTree_a1Un l_a1UB ++ (x_a1UA : readTree_a1Un r_a1UC)
heapSort xs_a1UD = clear_a1UG (heap_a1UE (0 :: Int) xs_a1UD)
  where heap_a1UE :: Ord a_a1UJ => Int -> [a_a1UJ] -> Tree a_a1UJ
        heap_a1UE k_a1UN [] = Tip
        heap_a1UE k_a1UO
          (investigate@((investigate@x_a1UP) : (investigate@xs_a1UQ)))
          = to_heap_a1UF k_a1UO x_a1UP
              (heap_a1UE (k_a1UO + (1 :: Int)) xs_a1UQ)
        
        to_heap_a1UF ::
                       Ord a_a1UK => Int -> a_a1UK -> Tree a_a1UK -> Tree a_a1UK
        to_heap_a1UF k_a1W3 x_a1W4 (investigate@Tip)
          = Branch x_a1W4 Tip Tip
        to_heap_a1UF k_a1W5 (investigate@x_a1W6)
          (investigate@((investigate@(Branch (investigate@y_a1W7)
                                        (investigate@l_a1W8) r_a1W9))))
          | x_a1W6 <= y_a1W7 && odd k_a1W5 =
            Branch x_a1W6 (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 l_a1W8)
              r_a1W9
          | x_a1W6 <= y_a1W7 =
            Branch x_a1W6 l_a1W8
              (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 r_a1W9)
          | odd k_a1W5 =
            Branch y_a1W7 (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 l_a1W8)
              r_a1W9
          | True =
            Branch y_a1W7 l_a1W8
              (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 r_a1W9)
        
        clear_a1UG :: Ord a_a1UL => Tree a_a1UL -> [a_a1UL]
        clear_a1UG Tip = []
        clear_a1UG
          (Branch (investigate@x_a25N) (investigate@l_a25O)
             (investigate@r_a25P))
          = x_a25N : clear_a1UG (mix_a1UH l_a25O r_a25P)
        
        mix_a1UH :: Ord a_a1UM => Tree a_a1UM -> Tree a_a1UM -> Tree a_a1UM
        mix_a1UH (investigate@Tip) r_a25Q = r_a25Q
        mix_a1UH (investigate@l_a25R) (investigate@Tip) = l_a25R
        mix_a1UH
          t1_a25S@(investigate@(Branch (investigate@x_a25T) l1_a25U
                                  (investigate@r1_a25V)))
          t2_a25W@(investigate@((investigate@(Branch (investigate@y_a25X)
                                                (investigate@l2_a25Y) r2_a25Z))))
          | x_a25T <= y_a25X =
            Branch x_a25T (mix_a1UH l1_a25U r1_a25V) t2_a25W
          | True = Branch y_a25X t1_a25S (mix_a1UH l2_a25Y r2_a25Z)
        
        div2_a1UI :: Int -> Int
        div2_a1UI (investigate@k_a260) = k_a260 `div` 2
mergeSort = merge_lists_a262 . (runsplit_a261 [])
  where runsplit_a261 ::
                        Ord a_a264 => [a_a264] -> [a_a264] -> [[a_a264]]
        runsplit_a261 (investigate@[]) [] = []
        runsplit_a261 (investigate@run_a267) [] = [run_a267]
        runsplit_a261 []
          (investigate@((investigate@((investigate@x_a268) :
                                        (investigate@xs_a269)))))
          = runsplit_a261 [x_a268] xs_a269
        runsplit_a261 (investigate@[(investigate@r_a26a)])
          (investigate@((investigate@((investigate@x_a26b) :
                                        (investigate@xs_a26c)))))
          | x_a26b > r_a26a = runsplit_a261 [r_a26a, x_a26b] xs_a26c
        runsplit_a261
          (investigate@rl_a26d@(investigate@((investigate@(r_a26e :
                                                             rs_a26f)))))
          (investigate@((investigate@x_a26g) : (investigate@xs_a26h)))
          | x_a26g <= r_a26e = runsplit_a261 (x_a26g : rl_a26d) xs_a26h
          | True = rl_a26d : (runsplit_a261 [x_a26g] xs_a26h)
        
        merge_lists_a262 :: Ord a_a265 => [[a_a265]] -> [a_a265]
        merge_lists_a262 [] = []
        merge_lists_a262
          (investigate@((investigate@(x_a26i : (investigate@xs_a26j)))))
          = merge_a263 x_a26i (merge_lists_a262 xs_a26j)
        
        merge_a263 :: Ord a_a266 => [a_a266] -> [a_a266] -> [a_a266]
        merge_a263 (investigate@[]) (investigate@ys_a26k) = ys_a26k
        merge_a263 (investigate@xs_a26l) [] = xs_a26l
        merge_a263 (investigate@xl_a26m@(x_a26n : xs_a26o))
          (investigate@yl_a26p@((investigate@y_a26q) : ys_a26r))
          | x_a26n == y_a26q = x_a26n : y_a26q : (merge_a263 xs_a26o ys_a26r)
          | x_a26n < y_a26q = x_a26n : (merge_a263 xs_a26o yl_a26p)
          | True = y_a26q : (merge_a263 xl_a26m ys_a26r)

data Tree a_arK = Tip
                | Branch a_arK (Tree a_arK) (Tree a_arK)

data Tree2 a_arJ = Tip2
                 | Twig2 a_arJ
                 | Branch2 a_arJ (Tree2 a_arJ) (Tree2 a_arJ)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.quickSort :: Ord a_a1nB => [a_a1nB] -> [a_a1nB]
Dum.quickSort2 :: Ord a_a1nA => [a_a1nA] -> [a_a1nA]
Dum.quickerSort :: Ord a_a1nz => [a_a1nz] -> [a_a1nz]
Dum.insertSort :: Ord a_a1ny => [a_a1ny] -> [a_a1ny]
Dum.treeSort :: Ord a_a1nx => [a_a1nx] -> [a_a1nx]
Dum.treeSort2 :: Ord a_a1nw => [a_a1nw] -> [a_a1nw]
Dum.heapSort :: Ord a_a1nv => [a_a1nv] -> [a_a1nv]
Dum.mergeSort :: Ord a_arL => [a_arL] -> [a_arL]
Dum.quickSort (![]) = []
Dum.quickSort ((!(x_a1nC : (!xs_a1nD))))
  = (Dum.quickSort lo_a1uI) ++ (x_a1nC : Dum.quickSort hi_a1uJ)
  where
      lo_a1uI = [y_a1uK | (!y_a1uK) <- xs_a1nD, y_a1uK <= x_a1nC]
      (!hi_a1uJ) = [y_a1uL | y_a1uL <- xs_a1nD, y_a1uL > x_a1nC]
Dum.quickSort2 (![]) = []
Dum.quickSort2 (x_a1uM : xs_a1uN)
  = (Dum.quickSort2 lo_a1uO) ++ (x_a1uM : Dum.quickSort2 hi_a1uP)
  where
      (lo_a1uO, hi_a1uP) = partition ((>=) x_a1uM) xs_a1uN
Dum.quickerSort [] = []
Dum.quickerSort (![x_a1xC]) = [x_a1xC]
Dum.quickerSort (!((!((!x_a1xD) : (!xs_a1xE)))))
  = split_a1xF x_a1xD [] [] xs_a1xE
  where
      split_a1xF x_a1xG lo_a1xH hi_a1xI (![])
        = Dum.quickerSort lo_a1xH ++ (x_a1xG : Dum.quickerSort hi_a1xI)
      split_a1xF x_a1xJ (!lo_a1xK) hi_a1xL (!((!y_a1xM) : ys_a1xN))
        | y_a1xM <= x_a1xJ
        = split_a1xF x_a1xJ (y_a1xM : lo_a1xK) hi_a1xL ys_a1xN
        | True = split_a1xF x_a1xJ lo_a1xK (y_a1xM : hi_a1xL) ys_a1xN
Dum.insertSort [] = []
Dum.insertSort ((!x_a1xO) : xs_a1xP)
  = trins_a1xQ [] [x_a1xO] xs_a1xP
  where
      trins_a1xQ ::
        Ord a_a1xR => [a_a1xR] -> [a_a1xR] -> [a_a1xR] -> [a_a1xR]
      trins_a1xQ rev_a1xS [] (!(y_a1xT : ys_a1xU))
        = trins_a1xQ [] ((reverse rev_a1xS) ++ [y_a1xT]) ys_a1xU
      trins_a1xQ (!rev_a1Bq) (!xs_a1Br) []
        = (reverse rev_a1Bq) ++ xs_a1Br
      trins_a1xQ rev_a1Bs (x_a1Bt : xs_a1Bu) ((!y_a1Bv) : (!ys_a1Bw))
        | x_a1Bt < y_a1Bv
        = trins_a1xQ (x_a1Bt : rev_a1Bs) xs_a1Bu (y_a1Bv : ys_a1Bw)
        | True
        = trins_a1xQ
            [] (reverse rev_a1Bs ++ (y_a1Bv : x_a1Bt : xs_a1Bu)) ys_a1Bw
Dum.treeSort
  = readTree_a1By . mkTree_a1Bx
  where
      mkTree_a1Bx :: Ord a_a1Bz => [a_a1Bz] -> Dum.Tree a_a1Bz
      (!mkTree_a1Bx)
        = foldr to_tree_a1BB Dum.Tip
        where
            to_tree_a1BB ::
              Ord a_a1BC => a_a1BC -> Dum.Tree a_a1BC -> Dum.Tree a_a1BC
            to_tree_a1BB (!x_a1BD) Dum.Tip = Dum.Branch x_a1BD Dum.Tip Dum.Tip
            to_tree_a1BB (!x_a1BE) (!((!(Dum.Branch y_a1BF (!l_a1BG) r_a1BH))))
              | x_a1BE <= y_a1BF
              = Dum.Branch y_a1BF (to_tree_a1BB x_a1BE l_a1BG) r_a1BH
              | True = Dum.Branch y_a1BF l_a1BG (to_tree_a1BB x_a1BE r_a1BH)
      readTree_a1By :: Ord a_a1BA => Dum.Tree a_a1BA -> [a_a1BA]
      readTree_a1By Dum.Tip = []
      readTree_a1By (!(Dum.Branch x_a1Uj l_a1Uk r_a1Ul))
        = readTree_a1By l_a1Uk ++ (x_a1Uj : readTree_a1By r_a1Ul)
Dum.treeSort2
  = readTree_a1Un . mkTree_a1Um
  where
      mkTree_a1Um :: Ord a_a1Uo => [a_a1Uo] -> Dum.Tree2 a_a1Uo
      mkTree_a1Um
        = foldr to_tree_a1Uq Dum.Tip2
        where
            to_tree_a1Uq ::
              Ord a_a1Ur => a_a1Ur -> Dum.Tree2 a_a1Ur -> Dum.Tree2 a_a1Ur
            to_tree_a1Uq x_a1Us Dum.Tip2 = Dum.Twig2 x_a1Us
            to_tree_a1Uq (!x_a1Ut) ((!(Dum.Twig2 y_a1Uu)))
              | x_a1Ut <= y_a1Uu = Dum.Branch2 y_a1Uu (Dum.Twig2 x_a1Ut) Dum.Tip2
              | True = Dum.Branch2 y_a1Uu Dum.Tip2 (Dum.Twig2 x_a1Ut)
            to_tree_a1Uq (!x_a1Uv) (Dum.Branch2 y_a1Uw (!l_a1Ux) r_a1Uy)
              | x_a1Uv <= y_a1Uw
              = Dum.Branch2 y_a1Uw (to_tree_a1Uq x_a1Uv l_a1Ux) r_a1Uy
              | True = Dum.Branch2 y_a1Uw l_a1Ux (to_tree_a1Uq x_a1Uv r_a1Uy)
      readTree_a1Un :: Ord a_a1Up => Dum.Tree2 a_a1Up -> [a_a1Up]
      readTree_a1Un Dum.Tip2 = []
      readTree_a1Un (Dum.Twig2 (!x_a1Uz)) = [x_a1Uz]
      readTree_a1Un (!(Dum.Branch2 (!x_a1UA) (!l_a1UB) r_a1UC))
        = readTree_a1Un l_a1UB ++ (x_a1UA : readTree_a1Un r_a1UC)
Dum.heapSort xs_a1UD
  = clear_a1UG (heap_a1UE (0 :: Int) xs_a1UD)
  where
      heap_a1UE :: Ord a_a1UJ => Int -> [a_a1UJ] -> Dum.Tree a_a1UJ
      heap_a1UE k_a1UN [] = Dum.Tip
      heap_a1UE k_a1UO (!((!x_a1UP) : (!xs_a1UQ)))
        = to_heap_a1UF
            k_a1UO x_a1UP (heap_a1UE (k_a1UO + (1 :: Int)) xs_a1UQ)
      to_heap_a1UF ::
        Ord a_a1UK => Int -> a_a1UK -> Dum.Tree a_a1UK -> Dum.Tree a_a1UK
      to_heap_a1UF k_a1W3 x_a1W4 (!Dum.Tip)
        = Dum.Branch x_a1W4 Dum.Tip Dum.Tip
      to_heap_a1UF
        k_a1W5
        (!x_a1W6)
        (!((!(Dum.Branch (!y_a1W7) (!l_a1W8) r_a1W9))))
        | x_a1W6 <= y_a1W7 && odd k_a1W5
        = Dum.Branch
            x_a1W6 (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 l_a1W8) r_a1W9
        | x_a1W6 <= y_a1W7
        = Dum.Branch
            x_a1W6 l_a1W8 (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 r_a1W9)
        | odd k_a1W5
        = Dum.Branch
            y_a1W7 (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 l_a1W8) r_a1W9
        | True
        = Dum.Branch
            y_a1W7 l_a1W8 (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 r_a1W9)
      clear_a1UG :: Ord a_a1UL => Dum.Tree a_a1UL -> [a_a1UL]
      clear_a1UG Dum.Tip = []
      clear_a1UG (Dum.Branch (!x_a25N) (!l_a25O) (!r_a25P))
        = x_a25N : clear_a1UG (mix_a1UH l_a25O r_a25P)
      mix_a1UH ::
        Ord a_a1UM => Dum.Tree a_a1UM -> Dum.Tree a_a1UM -> Dum.Tree a_a1UM
      mix_a1UH (!Dum.Tip) r_a25Q = r_a25Q
      mix_a1UH (!l_a25R) (!Dum.Tip) = l_a25R
      mix_a1UH
        t1_a25S@(!(Dum.Branch (!x_a25T) l1_a25U (!r1_a25V)))
        t2_a25W@(!((!(Dum.Branch (!y_a25X) (!l2_a25Y) r2_a25Z))))
        | x_a25T <= y_a25X
        = Dum.Branch x_a25T (mix_a1UH l1_a25U r1_a25V) t2_a25W
        | True = Dum.Branch y_a25X t1_a25S (mix_a1UH l2_a25Y r2_a25Z)
      div2_a1UI :: Int -> Int
      div2_a1UI (!k_a260) = k_a260 `div` 2
Dum.mergeSort
  = merge_lists_a262 . (runsplit_a261 [])
  where
      runsplit_a261 :: Ord a_a264 => [a_a264] -> [a_a264] -> [[a_a264]]
      runsplit_a261 (![]) [] = []
      runsplit_a261 (!run_a267) [] = [run_a267]
      runsplit_a261 [] (!((!((!x_a268) : (!xs_a269)))))
        = runsplit_a261 [x_a268] xs_a269
      runsplit_a261 (![(!r_a26a)]) (!((!((!x_a26b) : (!xs_a26c)))))
        | x_a26b > r_a26a = runsplit_a261 [r_a26a, x_a26b] xs_a26c
      runsplit_a261
        (!rl_a26d@(!((!(r_a26e : rs_a26f)))))
        (!((!x_a26g) : (!xs_a26h)))
        | x_a26g <= r_a26e = runsplit_a261 (x_a26g : rl_a26d) xs_a26h
        | True = rl_a26d : (runsplit_a261 [x_a26g] xs_a26h)
      merge_lists_a262 :: Ord a_a265 => [[a_a265]] -> [a_a265]
      merge_lists_a262 [] = []
      merge_lists_a262 (!((!(x_a26i : (!xs_a26j)))))
        = merge_a263 x_a26i (merge_lists_a262 xs_a26j)
      merge_a263 :: Ord a_a266 => [a_a266] -> [a_a266] -> [a_a266]
      merge_a263 (![]) (!ys_a26k) = ys_a26k
      merge_a263 (!xs_a26l) [] = xs_a26l
      merge_a263
        (!xl_a26m@(x_a26n : xs_a26o))
        (!yl_a26p@((!y_a26q) : ys_a26r))
        | x_a26n == y_a26q = x_a26n : y_a26q : (merge_a263 xs_a26o ys_a26r)
        | x_a26n < y_a26q = x_a26n : (merge_a263 xs_a26o yl_a26p)
        | True = y_a26q : (merge_a263 xl_a26m ys_a26r)

data Dum.Tree a_arK
  = Dum.Tip | Dum.Branch a_arK (Dum.Tree a_arK) (Dum.Tree a_arK)
data Dum.Tree2 a_arJ
  = Dum.Tip2 |
    Dum.Twig2 a_arJ |
    Dum.Branch2 a_arJ (Dum.Tree2 a_arJ) (Dum.Tree2 a_arJ)


["[]","![]","(![])","x_a1nC","xs_a1nD","!xs_a1nD","(!xs_a1nD)","x_a1nC : (!xs_a1nD)","(x_a1nC : (!xs_a1nD))","!(x_a1nC : (!xs_a1nD))","(!(x_a1nC : (!xs_a1nD)))","((!(x_a1nC : (!xs_a1nD))))","lo_a1uI","y_a1uK","!y_a1uK","(!y_a1uK)","hi_a1uJ","!hi_a1uJ","(!hi_a1uJ)","y_a1uL","[]","![]","(![])","x_a1uM","xs_a1uN","x_a1uM : xs_a1uN","(x_a1uM : xs_a1uN)","lo_a1uO","hi_a1uP","(lo_a1uO, hi_a1uP)","[]","x_a1xC","[x_a1xC]","![x_a1xC]","(![x_a1xC])","x_a1xD","!x_a1xD","(!x_a1xD)","xs_a1xE","!xs_a1xE","(!xs_a1xE)","(!x_a1xD) : (!xs_a1xE)","((!x_a1xD) : (!xs_a1xE))","!((!x_a1xD) : (!xs_a1xE))","(!((!x_a1xD) : (!xs_a1xE)))","((!((!x_a1xD) : (!xs_a1xE))))","!((!((!x_a1xD) : (!xs_a1xE))))","(!((!((!x_a1xD) : (!xs_a1xE)))))","x_a1xG","lo_a1xH","hi_a1xI","[]","![]","(![])","x_a1xJ","lo_a1xK","!lo_a1xK","(!lo_a1xK)","hi_a1xL","y_a1xM","!y_a1xM","(!y_a1xM)","ys_a1xN","(!y_a1xM) : ys_a1xN","((!y_a1xM) : ys_a1xN)","!((!y_a1xM) : ys_a1xN)","(!((!y_a1xM) : ys_a1xN))","[]","x_a1xO","!x_a1xO","(!x_a1xO)","xs_a1xP","(!x_a1xO) : xs_a1xP","((!x_a1xO) : xs_a1xP)","rev_a1xS","[]","y_a1xT","ys_a1xU","y_a1xT : ys_a1xU","(y_a1xT : ys_a1xU)","!(y_a1xT : ys_a1xU)","(!(y_a1xT : ys_a1xU))","rev_a1Bq","!rev_a1Bq","(!rev_a1Bq)","xs_a1Br","!xs_a1Br","(!xs_a1Br)","[]","rev_a1Bs","x_a1Bt","xs_a1Bu","x_a1Bt : xs_a1Bu","(x_a1Bt : xs_a1Bu)","y_a1Bv","!y_a1Bv","(!y_a1Bv)","ys_a1Bw","!ys_a1Bw","(!ys_a1Bw)","(!y_a1Bv) : (!ys_a1Bw)","((!y_a1Bv) : (!ys_a1Bw))","treeSort","mkTree_a1Bx","!mkTree_a1Bx","(!mkTree_a1Bx)","x_a1BD","!x_a1BD","(!x_a1BD)","Tip","x_a1BE","!x_a1BE","(!x_a1BE)","y_a1BF","l_a1BG","!l_a1BG","(!l_a1BG)","r_a1BH","Branch y_a1BF (!l_a1BG) r_a1BH","(Branch y_a1BF (!l_a1BG) r_a1BH)","!(Branch y_a1BF (!l_a1BG) r_a1BH)","(!(Branch y_a1BF (!l_a1BG) r_a1BH))","((!(Branch y_a1BF (!l_a1BG) r_a1BH)))","!((!(Branch y_a1BF (!l_a1BG) r_a1BH)))","(!((!(Branch y_a1BF (!l_a1BG) r_a1BH))))","Tip","x_a1Uj","l_a1Uk","r_a1Ul","Branch x_a1Uj l_a1Uk r_a1Ul","(Branch x_a1Uj l_a1Uk r_a1Ul)","!(Branch x_a1Uj l_a1Uk r_a1Ul)","(!(Branch x_a1Uj l_a1Uk r_a1Ul))","treeSort2","mkTree_a1Um","x_a1Us","Tip2","x_a1Ut","!x_a1Ut","(!x_a1Ut)","y_a1Uu","Twig2 y_a1Uu","(Twig2 y_a1Uu)","!(Twig2 y_a1Uu)","(!(Twig2 y_a1Uu))","((!(Twig2 y_a1Uu)))","x_a1Uv","!x_a1Uv","(!x_a1Uv)","y_a1Uw","l_a1Ux","!l_a1Ux","(!l_a1Ux)","r_a1Uy","Branch2 y_a1Uw (!l_a1Ux) r_a1Uy","(Branch2 y_a1Uw (!l_a1Ux) r_a1Uy)","Tip2","x_a1Uz","!x_a1Uz","(!x_a1Uz)","Twig2 (!x_a1Uz)","(Twig2 (!x_a1Uz))","x_a1UA","!x_a1UA","(!x_a1UA)","l_a1UB","!l_a1UB","(!l_a1UB)","r_a1UC","Branch2 (!x_a1UA) (!l_a1UB) r_a1UC","(Branch2 (!x_a1UA) (!l_a1UB) r_a1UC)","!(Branch2 (!x_a1UA) (!l_a1UB) r_a1UC)","(!(Branch2 (!x_a1UA) (!l_a1UB) r_a1UC))","xs_a1UD","k_a1UN","[]","k_a1UO","x_a1UP","!x_a1UP","(!x_a1UP)","xs_a1UQ","!xs_a1UQ","(!xs_a1UQ)","(!x_a1UP) : (!xs_a1UQ)","((!x_a1UP) : (!xs_a1UQ))","!((!x_a1UP) : (!xs_a1UQ))","(!((!x_a1UP) : (!xs_a1UQ)))","k_a1W3","x_a1W4","Tip","!Tip","(!Tip)","k_a1W5","x_a1W6","!x_a1W6","(!x_a1W6)","y_a1W7","!y_a1W7","(!y_a1W7)","l_a1W8","!l_a1W8","(!l_a1W8)","r_a1W9","Branch (!y_a1W7) (!l_a1W8) r_a1W9","(Branch (!y_a1W7) (!l_a1W8) r_a1W9)","!(Branch (!y_a1W7) (!l_a1W8) r_a1W9)","(!(Branch (!y_a1W7) (!l_a1W8) r_a1W9))","((!(Branch (!y_a1W7) (!l_a1W8) r_a1W9)))","!((!(Branch (!y_a1W7) (!l_a1W8) r_a1W9)))","(!((!(Branch (!y_a1W7) (!l_a1W8) r_a1W9))))","Tip","x_a25N","!x_a25N","(!x_a25N)","l_a25O","!l_a25O","(!l_a25O)","r_a25P","!r_a25P","(!r_a25P)","Branch (!x_a25N) (!l_a25O) (!r_a25P)","(Branch (!x_a25N) (!l_a25O) (!r_a25P))","Tip","!Tip","(!Tip)","r_a25Q","l_a25R","!l_a25R","(!l_a25R)","Tip","!Tip","(!Tip)","x_a25T","!x_a25T","(!x_a25T)","l1_a25U","r1_a25V","!r1_a25V","(!r1_a25V)","Branch (!x_a25T) l1_a25U (!r1_a25V)","(Branch (!x_a25T) l1_a25U (!r1_a25V))","!(Branch (!x_a25T) l1_a25U (!r1_a25V))","(!(Branch (!x_a25T) l1_a25U (!r1_a25V)))","t1_a25S@(!(Branch (!x_a25T) l1_a25U (!r1_a25V)))","y_a25X","!y_a25X","(!y_a25X)","l2_a25Y","!l2_a25Y","(!l2_a25Y)","r2_a25Z","Branch (!y_a25X) (!l2_a25Y) r2_a25Z","(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)","!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)","(!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z))","((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)))","!((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)))","(!((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z))))","t2_a25W@(!((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z))))","k_a260","!k_a260","(!k_a260)","mergeSort","[]","![]","(![])","[]","run_a267","!run_a267","(!run_a267)","[]","[]","x_a268","!x_a268","(!x_a268)","xs_a269","!xs_a269","(!xs_a269)","(!x_a268) : (!xs_a269)","((!x_a268) : (!xs_a269))","!((!x_a268) : (!xs_a269))","(!((!x_a268) : (!xs_a269)))","((!((!x_a268) : (!xs_a269))))","!((!((!x_a268) : (!xs_a269))))","(!((!((!x_a268) : (!xs_a269)))))","r_a26a","!r_a26a","(!r_a26a)","[(!r_a26a)]","![(!r_a26a)]","(![(!r_a26a)])","x_a26b","!x_a26b","(!x_a26b)","xs_a26c","!xs_a26c","(!xs_a26c)","(!x_a26b) : (!xs_a26c)","((!x_a26b) : (!xs_a26c))","!((!x_a26b) : (!xs_a26c))","(!((!x_a26b) : (!xs_a26c)))","((!((!x_a26b) : (!xs_a26c))))","!((!((!x_a26b) : (!xs_a26c))))","(!((!((!x_a26b) : (!xs_a26c)))))","r_a26e","rs_a26f","r_a26e : rs_a26f","(r_a26e : rs_a26f)","!(r_a26e : rs_a26f)","(!(r_a26e : rs_a26f))","((!(r_a26e : rs_a26f)))","!((!(r_a26e : rs_a26f)))","(!((!(r_a26e : rs_a26f))))","rl_a26d@(!((!(r_a26e : rs_a26f))))","!rl_a26d@(!((!(r_a26e : rs_a26f))))","(!rl_a26d@(!((!(r_a26e : rs_a26f)))))","x_a26g","!x_a26g","(!x_a26g)","xs_a26h","!xs_a26h","(!xs_a26h)","(!x_a26g) : (!xs_a26h)","((!x_a26g) : (!xs_a26h))","!((!x_a26g) : (!xs_a26h))","(!((!x_a26g) : (!xs_a26h)))","[]","x_a26i","xs_a26j","!xs_a26j","(!xs_a26j)","x_a26i : (!xs_a26j)","(x_a26i : (!xs_a26j))","!(x_a26i : (!xs_a26j))","(!(x_a26i : (!xs_a26j)))","((!(x_a26i : (!xs_a26j))))","!((!(x_a26i : (!xs_a26j))))","(!((!(x_a26i : (!xs_a26j)))))","[]","![]","(![])","ys_a26k","!ys_a26k","(!ys_a26k)","xs_a26l","!xs_a26l","(!xs_a26l)","[]","x_a26n","xs_a26o","x_a26n : xs_a26o","(x_a26n : xs_a26o)","xl_a26m@(x_a26n : xs_a26o)","!xl_a26m@(x_a26n : xs_a26o)","(!xl_a26m@(x_a26n : xs_a26o))","y_a26q","!y_a26q","(!y_a26q)","ys_a26r","(!y_a26q) : ys_a26r","((!y_a26q) : ys_a26r)","yl_a26p@((!y_a26q) : ys_a26r)","!yl_a26p@((!y_a26q) : ys_a26r)","(!yl_a26p@((!y_a26q) : ys_a26r))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Result
import Table
import Data.List (nub)

quickSort :: Ord a_a1nB => [a_a1nB] -> [a_a1nB]

quickSort2 :: Ord a_a1nA => [a_a1nA] -> [a_a1nA]

quickerSort :: Ord a_a1nz => [a_a1nz] -> [a_a1nz]

insertSort :: Ord a_a1ny => [a_a1ny] -> [a_a1ny]

treeSort :: Ord a_a1nx => [a_a1nx] -> [a_a1nx]

treeSort2 :: Ord a_a1nw => [a_a1nw] -> [a_a1nw]

heapSort :: Ord a_a1nv => [a_a1nv] -> [a_a1nv]

mergeSort :: Ord a_arL => [a_arL] -> [a_arL]
quickSort (investigate@[]) = []
quickSort ((investigate@(x_a1nC : (investigate@xs_a1nD))))
  = (quickSort lo_a1uI) ++ (x_a1nC : quickSort hi_a1uJ)
  where lo_a1uI
          = [y_a1uK | (investigate@y_a1uK) <- xs_a1nD, y_a1uK <= x_a1nC]
        (investigate@hi_a1uJ)
          = [y_a1uL | y_a1uL <- xs_a1nD, y_a1uL > x_a1nC]
quickSort2 (investigate@[]) = []
quickSort2 (x_a1uM : xs_a1uN)
  = (quickSort2 lo_a1uO) ++ (x_a1uM : quickSort2 hi_a1uP)
  where (lo_a1uO, hi_a1uP) = partition ((>=) x_a1uM) xs_a1uN
quickerSort [] = []
quickerSort (investigate@[x_a1xC]) = [x_a1xC]
quickerSort
  (investigate@((investigate@((investigate@x_a1xD) :
                                (investigate@xs_a1xE)))))
  = split_a1xF x_a1xD [] [] xs_a1xE
  where split_a1xF x_a1xG lo_a1xH hi_a1xI (investigate@[])
          = quickerSort lo_a1xH ++ (x_a1xG : quickerSort hi_a1xI)
        split_a1xF x_a1xJ (investigate@lo_a1xK) hi_a1xL
          (investigate@((investigate@y_a1xM) : ys_a1xN))
          | y_a1xM <= x_a1xJ =
            split_a1xF x_a1xJ (y_a1xM : lo_a1xK) hi_a1xL ys_a1xN
          | True = split_a1xF x_a1xJ lo_a1xK (y_a1xM : hi_a1xL) ys_a1xN
insertSort [] = []
insertSort ((investigate@x_a1xO) : xs_a1xP)
  = trins_a1xQ [] [x_a1xO] xs_a1xP
  where trins_a1xQ ::
                     Ord a_a1xR => [a_a1xR] -> [a_a1xR] -> [a_a1xR] -> [a_a1xR]
        trins_a1xQ rev_a1xS [] (investigate@(y_a1xT : ys_a1xU))
          = trins_a1xQ [] ((reverse rev_a1xS) ++ [y_a1xT]) ys_a1xU
        trins_a1xQ (investigate@rev_a1Bq) (investigate@xs_a1Br) []
          = (reverse rev_a1Bq) ++ xs_a1Br
        trins_a1xQ rev_a1Bs (x_a1Bt : xs_a1Bu)
          ((investigate@y_a1Bv) : (investigate@ys_a1Bw))
          | x_a1Bt < y_a1Bv =
            trins_a1xQ (x_a1Bt : rev_a1Bs) xs_a1Bu (y_a1Bv : ys_a1Bw)
          | True =
            trins_a1xQ [] (reverse rev_a1Bs ++ (y_a1Bv : x_a1Bt : xs_a1Bu))
              ys_a1Bw
treeSort = readTree_a1By . mkTree_a1Bx
  where mkTree_a1Bx :: Ord a_a1Bz => [a_a1Bz] -> Tree a_a1Bz
        (investigate@mkTree_a1Bx) = foldr to_tree_a1BB Tip
          where to_tree_a1BB ::
                               Ord a_a1BC => a_a1BC -> Tree a_a1BC -> Tree a_a1BC
                to_tree_a1BB (investigate@x_a1BD) Tip = Branch x_a1BD Tip Tip
                to_tree_a1BB (investigate@x_a1BE)
                  (investigate@((investigate@(Branch y_a1BF (investigate@l_a1BG)
                                                r_a1BH))))
                  | x_a1BE <= y_a1BF =
                    Branch y_a1BF (to_tree_a1BB x_a1BE l_a1BG) r_a1BH
                  | True = Branch y_a1BF l_a1BG (to_tree_a1BB x_a1BE r_a1BH)
        
        readTree_a1By :: Ord a_a1BA => Tree a_a1BA -> [a_a1BA]
        readTree_a1By Tip = []
        readTree_a1By (investigate@(Branch x_a1Uj l_a1Uk r_a1Ul))
          = readTree_a1By l_a1Uk ++ (x_a1Uj : readTree_a1By r_a1Ul)
treeSort2 = readTree_a1Un . mkTree_a1Um
  where mkTree_a1Um :: Ord a_a1Uo => [a_a1Uo] -> Tree2 a_a1Uo
        mkTree_a1Um = foldr to_tree_a1Uq Tip2
          where to_tree_a1Uq ::
                               Ord a_a1Ur => a_a1Ur -> Tree2 a_a1Ur -> Tree2 a_a1Ur
                to_tree_a1Uq x_a1Us Tip2 = Twig2 x_a1Us
                to_tree_a1Uq (investigate@x_a1Ut) ((investigate@(Twig2 y_a1Uu)))
                  | x_a1Ut <= y_a1Uu = Branch2 y_a1Uu (Twig2 x_a1Ut) Tip2
                  | True = Branch2 y_a1Uu Tip2 (Twig2 x_a1Ut)
                to_tree_a1Uq (investigate@x_a1Uv)
                  (Branch2 y_a1Uw (investigate@l_a1Ux) r_a1Uy)
                  | x_a1Uv <= y_a1Uw =
                    Branch2 y_a1Uw (to_tree_a1Uq x_a1Uv l_a1Ux) r_a1Uy
                  | True = Branch2 y_a1Uw l_a1Ux (to_tree_a1Uq x_a1Uv r_a1Uy)
        
        readTree_a1Un :: Ord a_a1Up => Tree2 a_a1Up -> [a_a1Up]
        readTree_a1Un Tip2 = []
        readTree_a1Un (Twig2 (investigate@x_a1Uz)) = [x_a1Uz]
        readTree_a1Un
          (investigate@(Branch2 (investigate@x_a1UA) (investigate@l_a1UB)
                          r_a1UC))
          = readTree_a1Un l_a1UB ++ (x_a1UA : readTree_a1Un r_a1UC)
heapSort xs_a1UD = clear_a1UG (heap_a1UE (0 :: Int) xs_a1UD)
  where heap_a1UE :: Ord a_a1UJ => Int -> [a_a1UJ] -> Tree a_a1UJ
        heap_a1UE k_a1UN [] = Tip
        heap_a1UE k_a1UO
          (investigate@((investigate@x_a1UP) : (investigate@xs_a1UQ)))
          = to_heap_a1UF k_a1UO x_a1UP
              (heap_a1UE (k_a1UO + (1 :: Int)) xs_a1UQ)
        
        to_heap_a1UF ::
                       Ord a_a1UK => Int -> a_a1UK -> Tree a_a1UK -> Tree a_a1UK
        to_heap_a1UF k_a1W3 x_a1W4 (investigate@Tip)
          = Branch x_a1W4 Tip Tip
        to_heap_a1UF k_a1W5 (investigate@x_a1W6)
          (investigate@((investigate@(Branch (investigate@y_a1W7)
                                        (investigate@l_a1W8) r_a1W9))))
          | x_a1W6 <= y_a1W7 && odd k_a1W5 =
            Branch x_a1W6 (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 l_a1W8)
              r_a1W9
          | x_a1W6 <= y_a1W7 =
            Branch x_a1W6 l_a1W8
              (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 r_a1W9)
          | odd k_a1W5 =
            Branch y_a1W7 (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 l_a1W8)
              r_a1W9
          | True =
            Branch y_a1W7 l_a1W8
              (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 r_a1W9)
        
        clear_a1UG :: Ord a_a1UL => Tree a_a1UL -> [a_a1UL]
        clear_a1UG Tip = []
        clear_a1UG
          (Branch (investigate@x_a25N) (investigate@l_a25O)
             (investigate@r_a25P))
          = x_a25N : clear_a1UG (mix_a1UH l_a25O r_a25P)
        
        mix_a1UH :: Ord a_a1UM => Tree a_a1UM -> Tree a_a1UM -> Tree a_a1UM
        mix_a1UH (investigate@Tip) r_a25Q = r_a25Q
        mix_a1UH (investigate@l_a25R) (investigate@Tip) = l_a25R
        mix_a1UH
          t1_a25S@(investigate@(Branch (investigate@x_a25T) l1_a25U
                                  (investigate@r1_a25V)))
          t2_a25W@(investigate@((investigate@(Branch (investigate@y_a25X)
                                                (investigate@l2_a25Y) r2_a25Z))))
          | x_a25T <= y_a25X =
            Branch x_a25T (mix_a1UH l1_a25U r1_a25V) t2_a25W
          | True = Branch y_a25X t1_a25S (mix_a1UH l2_a25Y r2_a25Z)
        
        div2_a1UI :: Int -> Int
        div2_a1UI (investigate@k_a260) = k_a260 `div` 2
mergeSort = merge_lists_a262 . (runsplit_a261 [])
  where runsplit_a261 ::
                        Ord a_a264 => [a_a264] -> [a_a264] -> [[a_a264]]
        runsplit_a261 (investigate@[]) [] = []
        runsplit_a261 (investigate@run_a267) [] = [run_a267]
        runsplit_a261 []
          (investigate@((investigate@((investigate@x_a268) :
                                        (investigate@xs_a269)))))
          = runsplit_a261 [x_a268] xs_a269
        runsplit_a261 (investigate@[(investigate@r_a26a)])
          (investigate@((investigate@((investigate@x_a26b) :
                                        (investigate@xs_a26c)))))
          | x_a26b > r_a26a = runsplit_a261 [r_a26a, x_a26b] xs_a26c
        runsplit_a261
          (investigate@rl_a26d@(investigate@((investigate@(r_a26e :
                                                             rs_a26f)))))
          (investigate@((investigate@x_a26g) : (investigate@xs_a26h)))
          | x_a26g <= r_a26e = runsplit_a261 (x_a26g : rl_a26d) xs_a26h
          | True = rl_a26d : (runsplit_a261 [x_a26g] xs_a26h)
        
        merge_lists_a262 :: Ord a_a265 => [[a_a265]] -> [a_a265]
        merge_lists_a262 [] = []
        merge_lists_a262
          (investigate@((investigate@(x_a26i : (investigate@xs_a26j)))))
          = merge_a263 x_a26i (merge_lists_a262 xs_a26j)
        
        merge_a263 :: Ord a_a266 => [a_a266] -> [a_a266] -> [a_a266]
        merge_a263 (investigate@[]) (investigate@ys_a26k) = ys_a26k
        merge_a263 (investigate@xs_a26l) [] = xs_a26l
        merge_a263 (investigate@xl_a26m@(x_a26n : xs_a26o))
          (investigate@yl_a26p@((investigate@y_a26q) : ys_a26r))
          | x_a26n == y_a26q = x_a26n : y_a26q : (merge_a263 xs_a26o ys_a26r)
          | x_a26n < y_a26q = x_a26n : (merge_a263 xs_a26o yl_a26p)
          | True = y_a26q : (merge_a263 xl_a26m ys_a26r)

data Tree a_arK = Tip
                | Branch a_arK (Tree a_arK) (Tree a_arK)

data Tree2 a_arJ = Tip2
                 | Twig2 a_arJ
                 | Branch2 a_arJ (Tree2 a_arJ) (Tree2 a_arJ)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.quickSort :: Ord a_a1nB => [a_a1nB] -> [a_a1nB]
Dum.quickSort2 :: Ord a_a1nA => [a_a1nA] -> [a_a1nA]
Dum.quickerSort :: Ord a_a1nz => [a_a1nz] -> [a_a1nz]
Dum.insertSort :: Ord a_a1ny => [a_a1ny] -> [a_a1ny]
Dum.treeSort :: Ord a_a1nx => [a_a1nx] -> [a_a1nx]
Dum.treeSort2 :: Ord a_a1nw => [a_a1nw] -> [a_a1nw]
Dum.heapSort :: Ord a_a1nv => [a_a1nv] -> [a_a1nv]
Dum.mergeSort :: Ord a_arL => [a_arL] -> [a_arL]
Dum.quickSort (![]) = []
Dum.quickSort ((!(x_a1nC : (!xs_a1nD))))
  = (Dum.quickSort lo_a1uI) ++ (x_a1nC : Dum.quickSort hi_a1uJ)
  where
      lo_a1uI = [y_a1uK | (!y_a1uK) <- xs_a1nD, y_a1uK <= x_a1nC]
      (!hi_a1uJ) = [y_a1uL | y_a1uL <- xs_a1nD, y_a1uL > x_a1nC]
Dum.quickSort2 (![]) = []
Dum.quickSort2 (x_a1uM : xs_a1uN)
  = (Dum.quickSort2 lo_a1uO) ++ (x_a1uM : Dum.quickSort2 hi_a1uP)
  where
      (lo_a1uO, hi_a1uP) = partition ((>=) x_a1uM) xs_a1uN
Dum.quickerSort [] = []
Dum.quickerSort (![x_a1xC]) = [x_a1xC]
Dum.quickerSort (!((!((!x_a1xD) : (!xs_a1xE)))))
  = split_a1xF x_a1xD [] [] xs_a1xE
  where
      split_a1xF x_a1xG lo_a1xH hi_a1xI (![])
        = Dum.quickerSort lo_a1xH ++ (x_a1xG : Dum.quickerSort hi_a1xI)
      split_a1xF x_a1xJ (!lo_a1xK) hi_a1xL (!((!y_a1xM) : ys_a1xN))
        | y_a1xM <= x_a1xJ
        = split_a1xF x_a1xJ (y_a1xM : lo_a1xK) hi_a1xL ys_a1xN
        | True = split_a1xF x_a1xJ lo_a1xK (y_a1xM : hi_a1xL) ys_a1xN
Dum.insertSort [] = []
Dum.insertSort ((!x_a1xO) : xs_a1xP)
  = trins_a1xQ [] [x_a1xO] xs_a1xP
  where
      trins_a1xQ ::
        Ord a_a1xR => [a_a1xR] -> [a_a1xR] -> [a_a1xR] -> [a_a1xR]
      trins_a1xQ rev_a1xS [] (!(y_a1xT : ys_a1xU))
        = trins_a1xQ [] ((reverse rev_a1xS) ++ [y_a1xT]) ys_a1xU
      trins_a1xQ (!rev_a1Bq) (!xs_a1Br) []
        = (reverse rev_a1Bq) ++ xs_a1Br
      trins_a1xQ rev_a1Bs (x_a1Bt : xs_a1Bu) ((!y_a1Bv) : (!ys_a1Bw))
        | x_a1Bt < y_a1Bv
        = trins_a1xQ (x_a1Bt : rev_a1Bs) xs_a1Bu (y_a1Bv : ys_a1Bw)
        | True
        = trins_a1xQ
            [] (reverse rev_a1Bs ++ (y_a1Bv : x_a1Bt : xs_a1Bu)) ys_a1Bw
Dum.treeSort
  = readTree_a1By . mkTree_a1Bx
  where
      mkTree_a1Bx :: Ord a_a1Bz => [a_a1Bz] -> Dum.Tree a_a1Bz
      (!mkTree_a1Bx)
        = foldr to_tree_a1BB Dum.Tip
        where
            to_tree_a1BB ::
              Ord a_a1BC => a_a1BC -> Dum.Tree a_a1BC -> Dum.Tree a_a1BC
            to_tree_a1BB (!x_a1BD) Dum.Tip = Dum.Branch x_a1BD Dum.Tip Dum.Tip
            to_tree_a1BB (!x_a1BE) (!((!(Dum.Branch y_a1BF (!l_a1BG) r_a1BH))))
              | x_a1BE <= y_a1BF
              = Dum.Branch y_a1BF (to_tree_a1BB x_a1BE l_a1BG) r_a1BH
              | True = Dum.Branch y_a1BF l_a1BG (to_tree_a1BB x_a1BE r_a1BH)
      readTree_a1By :: Ord a_a1BA => Dum.Tree a_a1BA -> [a_a1BA]
      readTree_a1By Dum.Tip = []
      readTree_a1By (!(Dum.Branch x_a1Uj l_a1Uk r_a1Ul))
        = readTree_a1By l_a1Uk ++ (x_a1Uj : readTree_a1By r_a1Ul)
Dum.treeSort2
  = readTree_a1Un . mkTree_a1Um
  where
      mkTree_a1Um :: Ord a_a1Uo => [a_a1Uo] -> Dum.Tree2 a_a1Uo
      mkTree_a1Um
        = foldr to_tree_a1Uq Dum.Tip2
        where
            to_tree_a1Uq ::
              Ord a_a1Ur => a_a1Ur -> Dum.Tree2 a_a1Ur -> Dum.Tree2 a_a1Ur
            to_tree_a1Uq x_a1Us Dum.Tip2 = Dum.Twig2 x_a1Us
            to_tree_a1Uq (!x_a1Ut) ((!(Dum.Twig2 y_a1Uu)))
              | x_a1Ut <= y_a1Uu = Dum.Branch2 y_a1Uu (Dum.Twig2 x_a1Ut) Dum.Tip2
              | True = Dum.Branch2 y_a1Uu Dum.Tip2 (Dum.Twig2 x_a1Ut)
            to_tree_a1Uq (!x_a1Uv) (Dum.Branch2 y_a1Uw (!l_a1Ux) r_a1Uy)
              | x_a1Uv <= y_a1Uw
              = Dum.Branch2 y_a1Uw (to_tree_a1Uq x_a1Uv l_a1Ux) r_a1Uy
              | True = Dum.Branch2 y_a1Uw l_a1Ux (to_tree_a1Uq x_a1Uv r_a1Uy)
      readTree_a1Un :: Ord a_a1Up => Dum.Tree2 a_a1Up -> [a_a1Up]
      readTree_a1Un Dum.Tip2 = []
      readTree_a1Un (Dum.Twig2 (!x_a1Uz)) = [x_a1Uz]
      readTree_a1Un (!(Dum.Branch2 (!x_a1UA) (!l_a1UB) r_a1UC))
        = readTree_a1Un l_a1UB ++ (x_a1UA : readTree_a1Un r_a1UC)
Dum.heapSort xs_a1UD
  = clear_a1UG (heap_a1UE (0 :: Int) xs_a1UD)
  where
      heap_a1UE :: Ord a_a1UJ => Int -> [a_a1UJ] -> Dum.Tree a_a1UJ
      heap_a1UE k_a1UN [] = Dum.Tip
      heap_a1UE k_a1UO (!((!x_a1UP) : (!xs_a1UQ)))
        = to_heap_a1UF
            k_a1UO x_a1UP (heap_a1UE (k_a1UO + (1 :: Int)) xs_a1UQ)
      to_heap_a1UF ::
        Ord a_a1UK => Int -> a_a1UK -> Dum.Tree a_a1UK -> Dum.Tree a_a1UK
      to_heap_a1UF k_a1W3 x_a1W4 (!Dum.Tip)
        = Dum.Branch x_a1W4 Dum.Tip Dum.Tip
      to_heap_a1UF
        k_a1W5
        (!x_a1W6)
        (!((!(Dum.Branch (!y_a1W7) (!l_a1W8) r_a1W9))))
        | x_a1W6 <= y_a1W7 && odd k_a1W5
        = Dum.Branch
            x_a1W6 (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 l_a1W8) r_a1W9
        | x_a1W6 <= y_a1W7
        = Dum.Branch
            x_a1W6 l_a1W8 (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 r_a1W9)
        | odd k_a1W5
        = Dum.Branch
            y_a1W7 (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 l_a1W8) r_a1W9
        | True
        = Dum.Branch
            y_a1W7 l_a1W8 (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 r_a1W9)
      clear_a1UG :: Ord a_a1UL => Dum.Tree a_a1UL -> [a_a1UL]
      clear_a1UG Dum.Tip = []
      clear_a1UG (Dum.Branch (!x_a25N) (!l_a25O) (!r_a25P))
        = x_a25N : clear_a1UG (mix_a1UH l_a25O r_a25P)
      mix_a1UH ::
        Ord a_a1UM => Dum.Tree a_a1UM -> Dum.Tree a_a1UM -> Dum.Tree a_a1UM
      mix_a1UH (!Dum.Tip) r_a25Q = r_a25Q
      mix_a1UH (!l_a25R) (!Dum.Tip) = l_a25R
      mix_a1UH
        t1_a25S@(!(Dum.Branch (!x_a25T) l1_a25U (!r1_a25V)))
        t2_a25W@(!((!(Dum.Branch (!y_a25X) (!l2_a25Y) r2_a25Z))))
        | x_a25T <= y_a25X
        = Dum.Branch x_a25T (mix_a1UH l1_a25U r1_a25V) t2_a25W
        | True = Dum.Branch y_a25X t1_a25S (mix_a1UH l2_a25Y r2_a25Z)
      div2_a1UI :: Int -> Int
      div2_a1UI (!k_a260) = k_a260 `div` 2
Dum.mergeSort
  = merge_lists_a262 . (runsplit_a261 [])
  where
      runsplit_a261 :: Ord a_a264 => [a_a264] -> [a_a264] -> [[a_a264]]
      runsplit_a261 (![]) [] = []
      runsplit_a261 (!run_a267) [] = [run_a267]
      runsplit_a261 [] (!((!((!x_a268) : (!xs_a269)))))
        = runsplit_a261 [x_a268] xs_a269
      runsplit_a261 (![(!r_a26a)]) (!((!((!x_a26b) : (!xs_a26c)))))
        | x_a26b > r_a26a = runsplit_a261 [r_a26a, x_a26b] xs_a26c
      runsplit_a261
        (!rl_a26d@(!((!(r_a26e : rs_a26f)))))
        (!((!x_a26g) : (!xs_a26h)))
        | x_a26g <= r_a26e = runsplit_a261 (x_a26g : rl_a26d) xs_a26h
        | True = rl_a26d : (runsplit_a261 [x_a26g] xs_a26h)
      merge_lists_a262 :: Ord a_a265 => [[a_a265]] -> [a_a265]
      merge_lists_a262 [] = []
      merge_lists_a262 (!((!(x_a26i : (!xs_a26j)))))
        = merge_a263 x_a26i (merge_lists_a262 xs_a26j)
      merge_a263 :: Ord a_a266 => [a_a266] -> [a_a266] -> [a_a266]
      merge_a263 (![]) (!ys_a26k) = ys_a26k
      merge_a263 (!xs_a26l) [] = xs_a26l
      merge_a263
        (!xl_a26m@(x_a26n : xs_a26o))
        (!yl_a26p@((!y_a26q) : ys_a26r))
        | x_a26n == y_a26q = x_a26n : y_a26q : (merge_a263 xs_a26o ys_a26r)
        | x_a26n < y_a26q = x_a26n : (merge_a263 xs_a26o yl_a26p)
        | True = y_a26q : (merge_a263 xl_a26m ys_a26r)

data Dum.Tree a_arK
  = Dum.Tip | Dum.Branch a_arK (Dum.Tree a_arK) (Dum.Tree a_arK)
data Dum.Tree2 a_arJ
  = Dum.Tip2 |
    Dum.Twig2 a_arJ |
    Dum.Branch2 a_arJ (Dum.Tree2 a_arJ) (Dum.Tree2 a_arJ)


["[]","![]","(![])","x_a1nC","xs_a1nD","!xs_a1nD","(!xs_a1nD)","x_a1nC : (!xs_a1nD)","(x_a1nC : (!xs_a1nD))","!(x_a1nC : (!xs_a1nD))","(!(x_a1nC : (!xs_a1nD)))","((!(x_a1nC : (!xs_a1nD))))","lo_a1uI","y_a1uK","!y_a1uK","(!y_a1uK)","hi_a1uJ","!hi_a1uJ","(!hi_a1uJ)","y_a1uL","[]","![]","(![])","x_a1uM","xs_a1uN","x_a1uM : xs_a1uN","(x_a1uM : xs_a1uN)","lo_a1uO","hi_a1uP","(lo_a1uO, hi_a1uP)","[]","x_a1xC","[x_a1xC]","![x_a1xC]","(![x_a1xC])","x_a1xD","!x_a1xD","(!x_a1xD)","xs_a1xE","!xs_a1xE","(!xs_a1xE)","(!x_a1xD) : (!xs_a1xE)","((!x_a1xD) : (!xs_a1xE))","!((!x_a1xD) : (!xs_a1xE))","(!((!x_a1xD) : (!xs_a1xE)))","((!((!x_a1xD) : (!xs_a1xE))))","!((!((!x_a1xD) : (!xs_a1xE))))","(!((!((!x_a1xD) : (!xs_a1xE)))))","x_a1xG","lo_a1xH","hi_a1xI","[]","![]","(![])","x_a1xJ","lo_a1xK","!lo_a1xK","(!lo_a1xK)","hi_a1xL","y_a1xM","!y_a1xM","(!y_a1xM)","ys_a1xN","(!y_a1xM) : ys_a1xN","((!y_a1xM) : ys_a1xN)","!((!y_a1xM) : ys_a1xN)","(!((!y_a1xM) : ys_a1xN))","[]","x_a1xO","!x_a1xO","(!x_a1xO)","xs_a1xP","(!x_a1xO) : xs_a1xP","((!x_a1xO) : xs_a1xP)","rev_a1xS","[]","y_a1xT","ys_a1xU","y_a1xT : ys_a1xU","(y_a1xT : ys_a1xU)","!(y_a1xT : ys_a1xU)","(!(y_a1xT : ys_a1xU))","rev_a1Bq","!rev_a1Bq","(!rev_a1Bq)","xs_a1Br","!xs_a1Br","(!xs_a1Br)","[]","rev_a1Bs","x_a1Bt","xs_a1Bu","x_a1Bt : xs_a1Bu","(x_a1Bt : xs_a1Bu)","y_a1Bv","!y_a1Bv","(!y_a1Bv)","ys_a1Bw","!ys_a1Bw","(!ys_a1Bw)","(!y_a1Bv) : (!ys_a1Bw)","((!y_a1Bv) : (!ys_a1Bw))","treeSort","mkTree_a1Bx","!mkTree_a1Bx","(!mkTree_a1Bx)","x_a1BD","!x_a1BD","(!x_a1BD)","Tip","x_a1BE","!x_a1BE","(!x_a1BE)","y_a1BF","l_a1BG","!l_a1BG","(!l_a1BG)","r_a1BH","Branch y_a1BF (!l_a1BG) r_a1BH","(Branch y_a1BF (!l_a1BG) r_a1BH)","!(Branch y_a1BF (!l_a1BG) r_a1BH)","(!(Branch y_a1BF (!l_a1BG) r_a1BH))","((!(Branch y_a1BF (!l_a1BG) r_a1BH)))","!((!(Branch y_a1BF (!l_a1BG) r_a1BH)))","(!((!(Branch y_a1BF (!l_a1BG) r_a1BH))))","Tip","x_a1Uj","l_a1Uk","r_a1Ul","Branch x_a1Uj l_a1Uk r_a1Ul","(Branch x_a1Uj l_a1Uk r_a1Ul)","!(Branch x_a1Uj l_a1Uk r_a1Ul)","(!(Branch x_a1Uj l_a1Uk r_a1Ul))","treeSort2","mkTree_a1Um","x_a1Us","Tip2","x_a1Ut","!x_a1Ut","(!x_a1Ut)","y_a1Uu","Twig2 y_a1Uu","(Twig2 y_a1Uu)","!(Twig2 y_a1Uu)","(!(Twig2 y_a1Uu))","((!(Twig2 y_a1Uu)))","x_a1Uv","!x_a1Uv","(!x_a1Uv)","y_a1Uw","l_a1Ux","!l_a1Ux","(!l_a1Ux)","r_a1Uy","Branch2 y_a1Uw (!l_a1Ux) r_a1Uy","(Branch2 y_a1Uw (!l_a1Ux) r_a1Uy)","Tip2","x_a1Uz","!x_a1Uz","(!x_a1Uz)","Twig2 (!x_a1Uz)","(Twig2 (!x_a1Uz))","x_a1UA","!x_a1UA","(!x_a1UA)","l_a1UB","!l_a1UB","(!l_a1UB)","r_a1UC","Branch2 (!x_a1UA) (!l_a1UB) r_a1UC","(Branch2 (!x_a1UA) (!l_a1UB) r_a1UC)","!(Branch2 (!x_a1UA) (!l_a1UB) r_a1UC)","(!(Branch2 (!x_a1UA) (!l_a1UB) r_a1UC))","xs_a1UD","k_a1UN","[]","k_a1UO","x_a1UP","!x_a1UP","(!x_a1UP)","xs_a1UQ","!xs_a1UQ","(!xs_a1UQ)","(!x_a1UP) : (!xs_a1UQ)","((!x_a1UP) : (!xs_a1UQ))","!((!x_a1UP) : (!xs_a1UQ))","(!((!x_a1UP) : (!xs_a1UQ)))","k_a1W3","x_a1W4","Tip","!Tip","(!Tip)","k_a1W5","x_a1W6","!x_a1W6","(!x_a1W6)","y_a1W7","!y_a1W7","(!y_a1W7)","l_a1W8","!l_a1W8","(!l_a1W8)","r_a1W9","Branch (!y_a1W7) (!l_a1W8) r_a1W9","(Branch (!y_a1W7) (!l_a1W8) r_a1W9)","!(Branch (!y_a1W7) (!l_a1W8) r_a1W9)","(!(Branch (!y_a1W7) (!l_a1W8) r_a1W9))","((!(Branch (!y_a1W7) (!l_a1W8) r_a1W9)))","!((!(Branch (!y_a1W7) (!l_a1W8) r_a1W9)))","(!((!(Branch (!y_a1W7) (!l_a1W8) r_a1W9))))","Tip","x_a25N","!x_a25N","(!x_a25N)","l_a25O","!l_a25O","(!l_a25O)","r_a25P","!r_a25P","(!r_a25P)","Branch (!x_a25N) (!l_a25O) (!r_a25P)","(Branch (!x_a25N) (!l_a25O) (!r_a25P))","Tip","!Tip","(!Tip)","r_a25Q","l_a25R","!l_a25R","(!l_a25R)","Tip","!Tip","(!Tip)","x_a25T","!x_a25T","(!x_a25T)","l1_a25U","r1_a25V","!r1_a25V","(!r1_a25V)","Branch (!x_a25T) l1_a25U (!r1_a25V)","(Branch (!x_a25T) l1_a25U (!r1_a25V))","!(Branch (!x_a25T) l1_a25U (!r1_a25V))","(!(Branch (!x_a25T) l1_a25U (!r1_a25V)))","t1_a25S@(!(Branch (!x_a25T) l1_a25U (!r1_a25V)))","y_a25X","!y_a25X","(!y_a25X)","l2_a25Y","!l2_a25Y","(!l2_a25Y)","r2_a25Z","Branch (!y_a25X) (!l2_a25Y) r2_a25Z","(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)","!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)","(!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z))","((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)))","!((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z)))","(!((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z))))","t2_a25W@(!((!(Branch (!y_a25X) (!l2_a25Y) r2_a25Z))))","k_a260","!k_a260","(!k_a260)","mergeSort","[]","![]","(![])","[]","run_a267","!run_a267","(!run_a267)","[]","[]","x_a268","!x_a268","(!x_a268)","xs_a269","!xs_a269","(!xs_a269)","(!x_a268) : (!xs_a269)","((!x_a268) : (!xs_a269))","!((!x_a268) : (!xs_a269))","(!((!x_a268) : (!xs_a269)))","((!((!x_a268) : (!xs_a269))))","!((!((!x_a268) : (!xs_a269))))","(!((!((!x_a268) : (!xs_a269)))))","r_a26a","!r_a26a","(!r_a26a)","[(!r_a26a)]","![(!r_a26a)]","(![(!r_a26a)])","x_a26b","!x_a26b","(!x_a26b)","xs_a26c","!xs_a26c","(!xs_a26c)","(!x_a26b) : (!xs_a26c)","((!x_a26b) : (!xs_a26c))","!((!x_a26b) : (!xs_a26c))","(!((!x_a26b) : (!xs_a26c)))","((!((!x_a26b) : (!xs_a26c))))","!((!((!x_a26b) : (!xs_a26c))))","(!((!((!x_a26b) : (!xs_a26c)))))","r_a26e","rs_a26f","r_a26e : rs_a26f","(r_a26e : rs_a26f)","!(r_a26e : rs_a26f)","(!(r_a26e : rs_a26f))","((!(r_a26e : rs_a26f)))","!((!(r_a26e : rs_a26f)))","(!((!(r_a26e : rs_a26f))))","rl_a26d@(!((!(r_a26e : rs_a26f))))","!rl_a26d@(!((!(r_a26e : rs_a26f))))","(!rl_a26d@(!((!(r_a26e : rs_a26f)))))","x_a26g","!x_a26g","(!x_a26g)","xs_a26h","!xs_a26h","(!xs_a26h)","(!x_a26g) : (!xs_a26h)","((!x_a26g) : (!xs_a26h))","!((!x_a26g) : (!xs_a26h))","(!((!x_a26g) : (!xs_a26h)))","[]","x_a26i","xs_a26j","!xs_a26j","(!xs_a26j)","x_a26i : (!xs_a26j)","(x_a26i : (!xs_a26j))","!(x_a26i : (!xs_a26j))","(!(x_a26i : (!xs_a26j)))","((!(x_a26i : (!xs_a26j))))","!((!(x_a26i : (!xs_a26j))))","(!((!(x_a26i : (!xs_a26j)))))","[]","![]","(![])","ys_a26k","!ys_a26k","(!ys_a26k)","xs_a26l","!xs_a26l","(!xs_a26l)","[]","x_a26n","xs_a26o","x_a26n : xs_a26o","(x_a26n : xs_a26o)","xl_a26m@(x_a26n : xs_a26o)","!xl_a26m@(x_a26n : xs_a26o)","(!xl_a26m@(x_a26n : xs_a26o))","y_a26q","!y_a26q","(!y_a26q)","ys_a26r","(!y_a26q) : ys_a26r","((!y_a26q) : ys_a26r)","yl_a26p@((!y_a26q) : ys_a26r)","!yl_a26p@((!y_a26q) : ys_a26r)","(!yl_a26p@((!y_a26q) : ys_a26r))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Result
import Table
import Knowledge
import Match
import Search
import System.IO
import System.Environment

quickSort :: Ord a_a1nB => [a_a1nB] -> [a_a1nB]

quickSort2 :: Ord a_a1nA => [a_a1nA] -> [a_a1nA]

quickerSort :: Ord a_a1nz => [a_a1nz] -> [a_a1nz]

insertSort :: Ord a_a1ny => [a_a1ny] -> [a_a1ny]

treeSort :: Ord a_a1nx => [a_a1nx] -> [a_a1nx]

treeSort2 :: Ord a_a1nw => [a_a1nw] -> [a_a1nw]

heapSort :: Ord a_a1nv => [a_a1nv] -> [a_a1nv]

mergeSort :: Ord a_arL => [a_arL] -> [a_arL]
quickSort (investigate@[]) = []
quickSort ((investigate@(x_a1nC : (investigate@xs_a1nD))))
  = (quickSort lo_a1uI) ++ (x_a1nC : quickSort hi_a1uJ)
  where lo_a1uI
          = [y_a1uK | (investigate@y_a1uK) <- xs_a1nD, y_a1uK <= x_a1nC]
        (investigate@hi_a1uJ)
          = [y_a1uL | y_a1uL <- xs_a1nD, y_a1uL > x_a1nC]
quickSort2 (investigate@[]) = []
quickSort2 (x_a1uM : xs_a1uN)
  = (quickSort2 lo_a1uO) ++ (x_a1uM : quickSort2 hi_a1uP)
  where (lo_a1uO, hi_a1uP) = partition ((>=) x_a1uM) xs_a1uN
quickerSort [] = []
quickerSort (investigate@[x_a1xC]) = [x_a1xC]
quickerSort
  (investigate@((investigate@((investigate@x_a1xD) :
                                (investigate@xs_a1xE)))))
  = split_a1xF x_a1xD [] [] xs_a1xE
  where split_a1xF x_a1xG lo_a1xH hi_a1xI (investigate@[])
          = quickerSort lo_a1xH ++ (x_a1xG : quickerSort hi_a1xI)
        split_a1xF x_a1xJ (investigate@lo_a1xK) hi_a1xL
          (investigate@((investigate@y_a1xM) : ys_a1xN))
          | y_a1xM <= x_a1xJ =
            split_a1xF x_a1xJ (y_a1xM : lo_a1xK) hi_a1xL ys_a1xN
          | True = split_a1xF x_a1xJ lo_a1xK (y_a1xM : hi_a1xL) ys_a1xN
insertSort [] = []
insertSort ((investigate@x_a1xO) : xs_a1xP)
  = trins_a1xQ [] [x_a1xO] xs_a1xP
  where trins_a1xQ ::
                     Ord a_a1xR => [a_a1xR] -> [a_a1xR] -> [a_a1xR] -> [a_a1xR]
        trins_a1xQ rev_a1xS [] (investigate@(y_a1xT : ys_a1xU))
          = trins_a1xQ [] ((reverse rev_a1xS) ++ [y_a1xT]) ys_a1xU
        trins_a1xQ (investigate@rev_a1Bq) (investigate@xs_a1Br) []
          = (reverse rev_a1Bq) ++ xs_a1Br
        trins_a1xQ rev_a1Bs (x_a1Bt : xs_a1Bu)
          ((investigate@y_a1Bv) : (investigate@ys_a1Bw))
          | x_a1Bt < y_a1Bv =
            trins_a1xQ (x_a1Bt : rev_a1Bs) xs_a1Bu (y_a1Bv : ys_a1Bw)
          | True =
            trins_a1xQ [] (reverse rev_a1Bs ++ (y_a1Bv : x_a1Bt : xs_a1Bu))
              ys_a1Bw
treeSort = readTree_a1By . mkTree_a1Bx
  where mkTree_a1Bx :: Ord a_a1Bz => [a_a1Bz] -> Tree a_a1Bz
        (investigate@mkTree_a1Bx) = foldr to_tree_a1BB Tip
          where to_tree_a1BB ::
                               Ord a_a1BC => a_a1BC -> Tree a_a1BC -> Tree a_a1BC
                to_tree_a1BB (investigate@x_a1BD) Tip = Branch x_a1BD Tip Tip
                to_tree_a1BB (investigate@x_a1BE)
                  (investigate@((investigate@(Branch y_a1BF (investigate@l_a1BG)
                                                r_a1BH))))
                  | x_a1BE <= y_a1BF =
                    Branch y_a1BF (to_tree_a1BB x_a1BE l_a1BG) r_a1BH
                  | True = Branch y_a1BF l_a1BG (to_tree_a1BB x_a1BE r_a1BH)
        
        readTree_a1By :: Ord a_a1BA => Tree a_a1BA -> [a_a1BA]
        readTree_a1By Tip = []
        readTree_a1By (investigate@(Branch x_a1Uj l_a1Uk r_a1Ul))
          = readTree_a1By l_a1Uk ++ (x_a1Uj : readTree_a1By r_a1Ul)
treeSort2 = readTree_a1Un . mkTree_a1Um
  where mkTree_a1Um :: Ord a_a1Uo => [a_a1Uo] -> Tree2 a_a1Uo
        mkTree_a1Um = foldr to_tree_a1Uq Tip2
          where to_tree_a1Uq ::
                               Ord a_a1Ur => a_a1Ur -> Tree2 a_a1Ur -> Tree2 a_a1Ur
                to_tree_a1Uq x_a1Us Tip2 = Twig2 x_a1Us
                to_tree_a1Uq (investigate@x_a1Ut) ((investigate@(Twig2 y_a1Uu)))
                  | x_a1Ut <= y_a1Uu = Branch2 y_a1Uu (Twig2 x_a1Ut) Tip2
                  | True = Branch2 y_a1Uu Tip2 (Twig2 x_a1Ut)
                to_tree_a1Uq (investigate@x_a1Uv)
                  (Branch2 y_a1Uw (investigate@l_a1Ux) r_a1Uy)
                  | x_a1Uv <= y_a1Uw =
                    Branch2 y_a1Uw (to_tree_a1Uq x_a1Uv l_a1Ux) r_a1Uy
                  | True = Branch2 y_a1Uw l_a1Ux (to_tree_a1Uq x_a1Uv r_a1Uy)
        
        readTree_a1Un :: Ord a_a1Up => Tree2 a_a1Up -> [a_a1Up]
        readTree_a1Un Tip2 = []
        readTree_a1Un (Twig2 (investigate@x_a1Uz)) = [x_a1Uz]
        readTree_a1Un
          (investigate@(Branch2 (investigate@x_a1UA) (investigate@l_a1UB)
                          r_a1UC))
          = readTree_a1Un l_a1UB ++ (x_a1UA : readTree_a1Un r_a1UC)
heapSort xs_a1UD = clear_a1UG (heap_a1UE (0 :: Int) xs_a1UD)
  where heap_a1UE :: Ord a_a1UJ => Int -> [a_a1UJ] -> Tree a_a1UJ
        heap_a1UE k_a1UN [] = Tip
        heap_a1UE k_a1UO
          (investigate@((investigate@x_a1UP) : (investigate@xs_a1UQ)))
          = to_heap_a1UF k_a1UO x_a1UP
              (heap_a1UE (k_a1UO + (1 :: Int)) xs_a1UQ)
        
        to_heap_a1UF ::
                       Ord a_a1UK => Int -> a_a1UK -> Tree a_a1UK -> Tree a_a1UK
        to_heap_a1UF k_a1W3 x_a1W4 (investigate@Tip)
          = Branch x_a1W4 Tip Tip
        to_heap_a1UF k_a1W5 (investigate@x_a1W6)
          (investigate@((investigate@(Branch (investigate@y_a1W7)
                                        (investigate@l_a1W8) r_a1W9))))
          | x_a1W6 <= y_a1W7 && odd k_a1W5 =
            Branch x_a1W6 (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 l_a1W8)
              r_a1W9
          | x_a1W6 <= y_a1W7 =
            Branch x_a1W6 l_a1W8
              (to_heap_a1UF (div2_a1UI k_a1W5) y_a1W7 r_a1W9)
          | odd k_a1W5 =
            Branch y_a1W7 (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 l_a1W8)
              r_a1W9
          | True =
            Branch y_a1W7 l_a1W8
              (to_heap_a1UF (div2_a1UI k_a1W5) x_a1W6 r_a1W9)
        
        clear_a1UG :: Ord a_a1UL => Tree a_a1UL -> [a_a1UL]
        clear_a1UG Tip = []
        clear_a1UG
          (Branch (investigate@x_a25N) (investigate@l_a25O)
             (investigate@r_a25P))
          = x_a25N : clear_a1UG (mix_a1UH l_a25O r_a25P)
        
        mix_a1UH :: Ord a_a1UM => Tree a_a1UM -> Tree a_a1UM -> Tree a_a1UM
        mix_a1UH (investigate@Tip) r_a25Q = r_a25Q
        mix_a1UH (investigate@l_a25R) (investigate@Tip) = l_a25R
        mix_a1UH
          t1_a25S@(investigate@(Branch (investigate@x_a25T) l1_a25U
                                  (investigate@r1_a25V)))
          t2_a25W@(investigate@((investigate@(Branch (investigate@y_a25X)
                                                (investigate@l2_a25Y) r2_a25Z))))
          | x_a25T <= y_a25X =
            Branch x_a25T (mix_a1UH l1_a25U r1_a25V) t2_a25W
          | True = Branch y_a25X t1_a25S (mix_a1UH l2_a25Y r2_a25Z)
        
        div2_a1UI :: Int -> Int
        div2_a1UI (investigate@k_a260) = k_a260 `div` 2
mergeSort = merge_lists_a262 . (runsplit_a261 [])
  where runsplit_a261 ::
                        Ord a_a264 => [a_a264] -> [a_a264] -> [[a_a264]]
        runsplit_a261 (investigate@[]) [] = []
        runsplit_a261 (investigate@run_a267) [] = [run_a267]
        runsplit_a261 []
          (investigate@((investigate@((investigate@x_a268) :
                                        (investigate@xs_a269)))))
          = runsplit_a261 [x_a268] xs_a269
        runsplit_a261 (investigate@[(investigate@r_a26a)])
          (investigate@((investigate@((investigate@x_a26b) :
                                        (investigate@xs_a26c)))))
          | x_a26b > r_a26a = runsplit_a261 [r_a26a, x_a26b] xs_a26c
        runsplit_a261
          (investigate@rl_a26d@(investigate@((investigate@(r_a26e :
                                                             rs_a26f)))))
          (investigate@((investigate@x_a26g) : (investigate@xs_a26h)))
          | x_a26g <= r_a26e = runsplit_a261 (x_a26g : rl_a26d) xs_a26h
          | True = rl_a26d : (runsplit_a261 [x_a26g] xs_a26h)
        
        merge_lists_a262 :: Ord a_a265 => [[a_a265]] -> [a_a265]
        merge_lists_a262 [] = []
        merge_lists_a262
          (investigate@((investigate@(x_a26i : (investigate@xs_a26j)))))
          = merge_a263 x_a26i (merge_lists_a262 xs_a26j)
        
        merge_a263 :: Ord a_a266 => [a_a266] -> [a_a266] -> [a_a266]
        merge_a263 (investigate@[]) (investigate@ys_a26k) = ys_a26k
        merge_a263 (investigate@xs_a26l) [] = xs_a26l
        merge_a263 (investigate@xl_a26m@(x_a26n : xs_a26o))
          (investigate@yl_a26p@((investigate@y_a26q) : ys_a26r))
          | x_a26n == y_a26q = x_a26n : y_a26q : (merge_a263 xs_a26o ys_a26r)
          | x_a26n < y_a26q = x_a26n : (merge_a263 xs_a26o yl_a26p)
          | True = y_a26q : (merge_a263 xl_a26m ys_a26r)

data Tree a_arK = Tip
                | Branch a_arK (Tree a_arK) (Tree a_arK)

data Tree2 a_arJ = Tip2
                 | Twig2 a_arJ
                 | Branch2 a_arJ (Tree2 a_arJ) (Tree2 a_arJ)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.success (!a_aqv) = Dum.Answer a_aqv
Dum.succeeds (Dum.Answer a_aqw) = True
Dum.succeeds (!_) = False
Dum.answer ((!(Dum.Answer a_axB))) = a_axB
Dum.failure (!r_axC) = Dum.Reason r_axC
Dum.fails = not . Dum.succeeds
Dum.reason (Dum.Reason r_a1tm) = r_a1tm
Dum.answers ((!(Dum.Answer a_a1tn))) = [a_a1tn]
Dum.answers _ = []

data Dum.Result a_aqt r_aqu = Dum.Answer a_aqt | Dum.Reason r_aqu


["a_aqv","safebang@!a_aqv","(!a_aqv)","a_aqw","Answer a_aqw","(Answer a_aqw)","_","!_","(!_)","a_axB","Answer a_axB","(Answer a_axB)","!(Answer a_axB)","(!(Answer a_axB))","((!(Answer a_axB)))","r_axC","safebang@!r_axC","(!r_axC)","fails","r_a1tm","Reason r_a1tm","(Reason r_a1tm)","a_a1tn","Answer a_a1tn","(Answer a_a1tn)","!(Answer a_a1tn)","(!(Answer a_a1tn))","((!(Answer a_a1tn)))","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
success (!a_aqv) = Answer a_aqv
succeeds (Answer a_aqw) = True
succeeds (investigate@_) = False
answer ((investigate@(Answer a_axB))) = a_axB
failure (!r_axC) = Reason r_axC
fails = not . succeeds
reason (Reason r_a1tm) = r_a1tm
answers ((investigate@(Answer a_a1tn))) = [a_a1tn]
answers _ = []

data Result a_aqt r_aqu = Answer a_aqt
                        | Reason r_aqu
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.success (!a_aqv) = Dum.Answer a_aqv
Dum.succeeds (Dum.Answer a_aqw) = True
Dum.succeeds (!_) = False
Dum.answer ((!(Dum.Answer a_axB))) = a_axB
Dum.failure (!r_axC) = Dum.Reason r_axC
Dum.fails = not . Dum.succeeds
Dum.reason (Dum.Reason r_a1tm) = r_a1tm
Dum.answers ((!(Dum.Answer a_a1tn))) = [a_a1tn]
Dum.answers _ = []

data Dum.Result a_aqt r_aqu = Dum.Answer a_aqt | Dum.Reason r_aqu


["a_aqv","safebang@!a_aqv","(!a_aqv)","a_aqw","Answer a_aqw","(Answer a_aqw)","_","!_","(!_)","a_axB","Answer a_axB","(Answer a_axB)","!(Answer a_axB)","(!(Answer a_axB))","((!(Answer a_axB)))","r_axC","safebang@!r_axC","(!r_axC)","fails","r_a1tm","Reason r_a1tm","(Reason r_a1tm)","a_a1tn","Answer a_a1tn","(Answer a_a1tn)","!(Answer a_a1tn)","(!(Answer a_a1tn))","((!(Answer a_a1tn)))","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Result
success (!a_aqv) = Answer a_aqv
succeeds (Answer a_aqw) = True
succeeds (investigate@_) = False
answer ((investigate@(Answer a_axB))) = a_axB
failure (!r_axC) = Reason r_axC
fails = not . succeeds
reason (Reason r_a1tm) = r_a1tm
answers ((investigate@(Answer a_a1tn))) = [a_a1tn]
answers _ = []

data Result a_aqt r_aqu = Answer a_aqt
                        | Reason r_aqu
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.success (!a_aqv) = Dum.Answer a_aqv
Dum.succeeds (Dum.Answer a_aqw) = True
Dum.succeeds (!_) = False
Dum.answer ((!(Dum.Answer a_axB))) = a_axB
Dum.failure (!r_axC) = Dum.Reason r_axC
Dum.fails = not . Dum.succeeds
Dum.reason (Dum.Reason r_a1tm) = r_a1tm
Dum.answers ((!(Dum.Answer a_a1tn))) = [a_a1tn]
Dum.answers _ = []

data Dum.Result a_aqt r_aqu = Dum.Answer a_aqt | Dum.Reason r_aqu


["a_aqv","safebang@!a_aqv","(!a_aqv)","a_aqw","Answer a_aqw","(Answer a_aqw)","_","!_","(!_)","a_axB","Answer a_axB","(Answer a_axB)","!(Answer a_axB)","(!(Answer a_axB))","((!(Answer a_axB)))","r_axC","safebang@!r_axC","(!r_axC)","fails","r_a1tm","Reason r_a1tm","(Reason r_a1tm)","a_a1tn","Answer a_a1tn","(Answer a_a1tn)","!(Answer a_a1tn)","(!(Answer a_a1tn))","((!(Answer a_a1tn)))","_"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Result
import Table
import Knowledge
import Match
success (!a_aqv) = Answer a_aqv
succeeds (Answer a_aqw) = True
succeeds (investigate@_) = False
answer ((investigate@(Answer a_axB))) = a_axB
failure (!r_axC) = Reason r_axC
fails = not . succeeds
reason (Reason r_a1tm) = r_a1tm
answers ((investigate@(Answer a_a1tn))) = [a_a1tn]
answers _ = []

data Result a_aqt r_aqu = Answer a_aqt
                        | Reason r_aqu
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.polling = 5 :: Int
Dum.interval = 3 :: Int
Dum.threshold = 100 :: Int


["polling","interval","threshold"]
{-# LANGUAGE BangPatterns #-}
module Dum where
polling = 5 :: Int
interval = 3 :: Int
threshold = 100 :: Int
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.polling = 5 :: Int
Dum.interval = 3 :: Int
Dum.threshold = 100 :: Int


["polling","interval","threshold"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Key
polling = 5 :: Int
interval = 3 :: Int
threshold = 100 :: Int
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.polling = 5 :: Int
Dum.interval = 3 :: Int
Dum.threshold = 100 :: Int


["polling","interval","threshold"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Auxil
import Key
polling = 5 :: Int
interval = 3 :: Int
threshold = 100 :: Int
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.polling = 5 :: Int
Dum.interval = 3 :: Int
Dum.threshold = 100 :: Int


["polling","interval","threshold"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import QSort
import Data.List ((\\))
import System.Environment
import Control.Monad
polling = 5 :: Int
interval = 3 :: Int
threshold = 100 :: Int
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.sortLe :: (a_a1ma -> a_a1ma -> Bool) -> [a_a1ma] -> [a_a1ma]
Dum.sortLe (!le_a1tf) l_a1tg = Dum.qsort le_a1tf l_a1tg []
Dum.sort :: (Ord a_aqq) => [a_aqq] -> [a_aqq]
Dum.sort (!l_a1th) = Dum.qsort (<=) l_a1th []
Dum.qsort le_a1ti (![]) r_a1tj = r_a1tj
Dum.qsort le_a1tk [(!x_a1tl)] (!r_a1tm) = x_a1tl : r_a1tm
Dum.qsort (!le_a1tn) (!((!((!x_a1to) : xs_a1tp)))) r_a1tq
  = Dum.qpart le_a1tn x_a1to xs_a1tp [] [] r_a1tq
Dum.qpart (!le_a1tr) (!x_a1ts) [] rlt_a1tt (!rge_a1tu) (!r_a1tv)
  = Dum.rqsort
      le_a1tr rlt_a1tt (x_a1ts : Dum.rqsort le_a1tr rge_a1tu r_a1tv)
Dum.qpart
  le_a1tw
  (!x_a1tx)
  (!(y_a1ty : ys_a1tz))
  rlt_a1tA
  rge_a1tB
  (!r_a1tC)
  = if le_a1tw x_a1tx y_a1ty then
        Dum.qpart
          le_a1tw x_a1tx ys_a1tz rlt_a1tA (y_a1ty : rge_a1tB) r_a1tC
    else
        Dum.qpart
          le_a1tw x_a1tx ys_a1tz (y_a1ty : rlt_a1tA) rge_a1tB r_a1tC
Dum.rqsort le_a1tD [] r_a1tE = r_a1tE
Dum.rqsort le_a1tF [x_a1tG] r_a1tH = x_a1tG : r_a1tH
Dum.rqsort le_a1tI (x_a1tJ : xs_a1tK) r_a1tL
  = Dum.rqpart le_a1tI x_a1tJ xs_a1tK [] [] r_a1tL
Dum.rqpart le_a1tM x_a1tN [] (!rle_a1tO) rgt_a1tP (!r_a1tQ)
  = Dum.qsort
      le_a1tM rle_a1tO (x_a1tN : Dum.qsort le_a1tM rgt_a1tP r_a1tQ)
Dum.rqpart
  (!le_a1tR)
  x_a1tS
  (!(y_a1tT : ys_a1tU))
  rle_a1tV
  rgt_a1tW
  r_a1tX
  = if le_a1tR y_a1tT x_a1tS then
        Dum.rqpart
          le_a1tR x_a1tS ys_a1tU (y_a1tT : rle_a1tV) rgt_a1tW r_a1tX
    else
        Dum.rqpart
          le_a1tR x_a1tS ys_a1tU rle_a1tV (y_a1tT : rgt_a1tW) r_a1tX


["le_a1tf","safebang@!le_a1tf","(!le_a1tf)","l_a1tg","l_a1th","safebang@!l_a1th","(!l_a1th)","le_a1ti","[]","![]","(![])","r_a1tj","le_a1tk","x_a1tl","safebang@!x_a1tl","(!x_a1tl)","[(!x_a1tl)]","r_a1tm","!r_a1tm","(!r_a1tm)","le_a1tn","!le_a1tn","(!le_a1tn)","x_a1to","!x_a1to","(!x_a1to)","xs_a1tp","(!x_a1to) : xs_a1tp","((!x_a1to) : xs_a1tp)","!((!x_a1to) : xs_a1tp)","(!((!x_a1to) : xs_a1tp))","((!((!x_a1to) : xs_a1tp)))","!((!((!x_a1to) : xs_a1tp)))","(!((!((!x_a1to) : xs_a1tp))))","r_a1tq","le_a1tr","safebang@!le_a1tr","(!le_a1tr)","x_a1ts","safebang@!x_a1ts","(!x_a1ts)","[]","rlt_a1tt","rge_a1tu","!rge_a1tu","(!rge_a1tu)","r_a1tv","safebang@!r_a1tv","(!r_a1tv)","le_a1tw","x_a1tx","!x_a1tx","(!x_a1tx)","y_a1ty","ys_a1tz","y_a1ty : ys_a1tz","(y_a1ty : ys_a1tz)","!(y_a1ty : ys_a1tz)","(!(y_a1ty : ys_a1tz))","rlt_a1tA","rge_a1tB","r_a1tC","!r_a1tC","(!r_a1tC)","le_a1tD","[]","r_a1tE","le_a1tF","x_a1tG","[x_a1tG]","r_a1tH","le_a1tI","x_a1tJ","xs_a1tK","x_a1tJ : xs_a1tK","(x_a1tJ : xs_a1tK)","r_a1tL","le_a1tM","x_a1tN","[]","rle_a1tO","!rle_a1tO","(!rle_a1tO)","rgt_a1tP","r_a1tQ","safebang@!r_a1tQ","(!r_a1tQ)","le_a1tR","!le_a1tR","(!le_a1tR)","x_a1tS","y_a1tT","ys_a1tU","y_a1tT : ys_a1tU","(y_a1tT : ys_a1tU)","!(y_a1tT : ys_a1tU)","(!(y_a1tT : ys_a1tU))","rle_a1tV","rgt_a1tW","r_a1tX"]
{-# LANGUAGE BangPatterns #-}
module Dum where

sortLe :: (a_a1ma -> a_a1ma -> Bool) -> [a_a1ma] -> [a_a1ma]
sortLe (!le_a1tf) l_a1tg = qsort le_a1tf l_a1tg []

sort :: (Ord a_aqq) => [a_aqq] -> [a_aqq]
sort (!l_a1th) = qsort (<=) l_a1th []
qsort le_a1ti (investigate@[]) r_a1tj = r_a1tj
qsort le_a1tk [(!x_a1tl)] (investigate@r_a1tm) = x_a1tl : r_a1tm
qsort (investigate@le_a1tn)
  (investigate@((investigate@((investigate@x_a1to) : xs_a1tp))))
  r_a1tq = qpart le_a1tn x_a1to xs_a1tp [] [] r_a1tq
qpart (!le_a1tr) (!x_a1ts) [] rlt_a1tt (investigate@rge_a1tu)
  (!r_a1tv)
  = rqsort le_a1tr rlt_a1tt (x_a1ts : rqsort le_a1tr rge_a1tu r_a1tv)
qpart le_a1tw (investigate@x_a1tx) (investigate@(y_a1ty : ys_a1tz))
  rlt_a1tA rge_a1tB (investigate@r_a1tC)
  = if le_a1tw x_a1tx y_a1ty then
      qpart le_a1tw x_a1tx ys_a1tz rlt_a1tA (y_a1ty : rge_a1tB) r_a1tC
      else
      qpart le_a1tw x_a1tx ys_a1tz (y_a1ty : rlt_a1tA) rge_a1tB r_a1tC
rqsort le_a1tD [] r_a1tE = r_a1tE
rqsort le_a1tF [x_a1tG] r_a1tH = x_a1tG : r_a1tH
rqsort le_a1tI (x_a1tJ : xs_a1tK) r_a1tL
  = rqpart le_a1tI x_a1tJ xs_a1tK [] [] r_a1tL
rqpart le_a1tM x_a1tN [] (investigate@rle_a1tO) rgt_a1tP (!r_a1tQ)
  = qsort le_a1tM rle_a1tO (x_a1tN : qsort le_a1tM rgt_a1tP r_a1tQ)
rqpart (investigate@le_a1tR) x_a1tS
  (investigate@(y_a1tT : ys_a1tU)) rle_a1tV rgt_a1tW r_a1tX
  = if le_a1tR y_a1tT x_a1tS then
      rqpart le_a1tR x_a1tS ys_a1tU (y_a1tT : rle_a1tV) rgt_a1tW r_a1tX
      else
      rqpart le_a1tR x_a1tS ys_a1tU rle_a1tV (y_a1tT : rgt_a1tW) r_a1tX
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 5 Dum.:+:
infixl 7 Dum..*

default (Integer, Rational, Double)

Dum.tree = 0 Dum.:+: Dum.forest
Dum.forest = Dum.compose Dum.list Dum.tree
Dum.list = 1 Dum.:+: Dum.list
Dum.ts = 1 Dum.:+: Dum.ts ^ 2
Dum.extract :: Int -> Dum.Ps a_a1Uj -> [a_a1Uj]
Dum.extract 0 ps_a1Uk = []
Dum.extract n_a1Ul Dum.Pz = []
Dum.extract n_a1Um (x_a1Un Dum.:+: ps_a1Uo)
  = x_a1Un : Dum.extract (n_a1Um - 1) ps_a1Uo
Dum.deriv :: Num a_a1Ui => Dum.Ps a_a1Ui -> Dum.Ps a_a1Ui
Dum.integral :: Fractional a_a1Uh => Dum.Ps a_a1Uh -> Dum.Ps a_a1Uh
Dum.compose ::
  (Eq a_a1Ug, Num a_a1Ug) =>
  Dum.Ps a_a1Ug -> Dum.Ps a_a1Ug -> Dum.Ps a_a1Ug
Dum.revert ::
  (Eq a_a1Uf, Fractional a_a1Uf) => Dum.Ps a_a1Uf -> Dum.Ps a_a1Uf
Dum.toList :: Num a_a1Ue => Dum.Ps a_a1Ue -> [a_a1Ue]
Dum.takePs :: Num a_a1N9 => Int -> Dum.Ps a_a1N9 -> [a_a1N9]
(Dum..*) :: Num a_a1N8 => a_a1N8 -> Dum.Ps a_a1N8 -> Dum.Ps a_a1N8
Dum.x :: Num a_a1N7 => Dum.Ps a_a1N7
Dum.expx, Dum.sinx, Dum.cosx :: Fractional a_a1N6 => Dum.Ps a_a1N6
c_a1Up Dum..* Dum.Pz = Dum.Pz
c_a1Uq Dum..* (f_a1Ur Dum.:+: fs_a1Us)
  = c_a1Uq * f_a1Ur Dum.:+: c_a1Uq Dum..* fs_a1Us
Dum.x = 0 Dum.:+: 1 Dum.:+: Dum.Pz
Dum.toList Dum.Pz = []
Dum.toList (f_a1Ut Dum.:+: fs_a1Uu) = f_a1Ut : (Dum.toList fs_a1Uu)
Dum.takePs n_a1Uv fs_a1Uw = take n_a1Uv (Dum.toList fs_a1Uw)
Dum.compose Dum.Pz _ = Dum.Pz
Dum.compose (f_a1Yn Dum.:+: _) Dum.Pz = f_a1Yn Dum.:+: Dum.Pz
Dum.compose (f_a1Yo Dum.:+: fs_a1Yp) (0 Dum.:+: gs_a1Yq)
  = f_a1Yo
    Dum.:+: gs_a1Yq * (Dum.compose fs_a1Yp (0 Dum.:+: gs_a1Yq))
Dum.compose (f_a1Yr Dum.:+: fs_a1Ys) gs_a1Yt
  = (f_a1Yr Dum.:+: Dum.Pz) + gs_a1Yt * (Dum.compose fs_a1Ys gs_a1Yt)
Dum.revert (0 Dum.:+: fs_a1Yu)
  = rs_a1Yv
  where
      rs_a1Yv = 0 Dum.:+: 1 / (Dum.compose fs_a1Yu rs_a1Yv)
Dum.revert ((f0_a1Yw Dum.:+: f1_a1Yx) Dum.:+: Dum.Pz)
  = (- 1) / f1_a1Yx Dum.:+: 1 / f1_a1Yx Dum.:+: Dum.Pz
Dum.deriv Dum.Pz = Dum.Pz
Dum.deriv (_ Dum.:+: fs_a1Yy)
  = deriv1_a1Yz fs_a1Yy 1
  where
      deriv1_a1Yz Dum.Pz _ = Dum.Pz
      deriv1_a1Yz (f_a1YA Dum.:+: fs_a1YB) n_a1YC
        = n_a1YC * f_a1YA Dum.:+: (deriv1_a1Yz fs_a1YB (n_a1YC + 1))
Dum.integral fs_a1YD
  = 0 Dum.:+: (int1_a1YE fs_a1YD 1)
  where
      int1_a1YE Dum.Pz _ = Dum.Pz
      int1_a1YE (f_a1YF Dum.:+: fs_a1YG) n_a1YH
        = f_a1YF / n_a1YH Dum.:+: (int1_a1YE fs_a1YG (n_a1YH + 1))
Dum.expx = 1 + (Dum.integral Dum.expx)
Dum.sinx = Dum.integral Dum.cosx
Dum.cosx = 1 - (Dum.integral Dum.sinx)

data Dum.Ps a_a1N5 = Dum.Pz | a_a1N5 Dum.:+: Dum.Ps a_a1N5

instance (Eq a_a1YI, Fractional a_a1YI) =>
         Floating (Dum.Ps a_a1YI) where
  sqrt Dum.Pz = Dum.Pz
  sqrt ((0 Dum.:+: 0) Dum.:+: fs_a1YJ) = 0 Dum.:+: (sqrt fs_a1YJ)
  sqrt (1 Dum.:+: fs_a1YK)
    = qs_a1YL
    where
        qs_a1YL
          = 1
            + Dum.integral
                ((Dum.deriv (1 Dum.:+: fs_a1YK)) / (2 Dum..* qs_a1YL))
instance (Eq a_a1YM, Fractional a_a1YM) =>
         Fractional (Dum.Ps a_a1YM) where
  recip fs_a1YN = 1 / fs_a1YN
  Dum.Pz / Dum.Pz = error "power series 0/0"
  Dum.Pz / (0 Dum.:+: gs_a1Zn) = Dum.Pz / gs_a1Zn
  Dum.Pz / _ = Dum.Pz
  (0 Dum.:+: fs_a1Zo) / (0 Dum.:+: gs_a1Zp) = fs_a1Zo / gs_a1Zp
  (f_a1Zq Dum.:+: fs_a1Zr) / (g_a1Zs Dum.:+: gs_a1Zt)
    = let q_a1Zu = f_a1Zq / g_a1Zs
      in
        q_a1Zu
        Dum.:+:
          (fs_a1Zr - q_a1Zu Dum..* gs_a1Zt) / (g_a1Zs Dum.:+: gs_a1Zt)
instance Num a_a1Zv => Num (Dum.Ps a_a1Zv) where
  negate Dum.Pz = Dum.Pz
  negate (f_a1Zw Dum.:+: fs_a1Zx) = (- f_a1Zw) Dum.:+: (- fs_a1Zx)
  Dum.Pz + gs_a1Zy = gs_a1Zy
  fs_a1Zz + Dum.Pz = fs_a1Zz
  (f_a1ZA Dum.:+: fs_a1ZB) + (g_a1ZC Dum.:+: gs_a1ZD)
    = f_a1ZA + g_a1ZC Dum.:+: fs_a1ZB + gs_a1ZD
  Dum.Pz * _ = Dum.Pz
  _ * Dum.Pz = Dum.Pz
  (f_a1ZE Dum.:+: fs_a1ZF) * (g_a1ZG Dum.:+: gs_a1ZH)
    = f_a1ZE * g_a1ZG
      Dum.:+:
        f_a1ZE Dum..* gs_a1ZH + g_a1ZG Dum..* fs_a1ZF
        + Dum.x * fs_a1ZF * gs_a1ZH
  fromInteger 0 = Dum.Pz
  fromInteger c_a1ZI = fromInteger c_a1ZI Dum.:+: Dum.Pz
instance (Show a_a1ZJ, Num a_a1ZJ) => Show (Dum.Ps a_a1ZJ) where
  showsPrec p_a1ZK Dum.Pz = showsPrec p_a1ZK [0]
  showsPrec p_a1ZL fs_a1ZM = showsPrec p_a1ZL (Dum.toList fs_a1ZM)
instance (Eq a_a1ZN, Num a_a1ZN) => Eq (Dum.Ps a_a1ZN) where
  Dum.Pz == Dum.Pz = True
  Dum.Pz == (f_a1ZO Dum.:+: fs_a1ZP)
    = f_a1ZO == 0 && Dum.Pz == fs_a1ZP
  fs_a1ZQ == Dum.Pz = Dum.Pz == fs_a1ZQ
  (f_a1ZR Dum.:+: fs_a1ZS) == (g_a1ZT Dum.:+: gs_a1ZU)
    = f_a1ZR == g_a1ZT && fs_a1ZS == gs_a1ZU


["tree","forest","list","ts","0","ps_a1Uk","n_a1Ul","Pz","n_a1Um","x_a1Un","ps_a1Uo","x_a1Un :+: ps_a1Uo","(x_a1Un :+: ps_a1Uo)","c_a1Up","Pz","c_a1Uq","f_a1Ur","fs_a1Us","f_a1Ur :+: fs_a1Us","(f_a1Ur :+: fs_a1Us)","x","Pz","f_a1Ut","fs_a1Uu","f_a1Ut :+: fs_a1Uu","(f_a1Ut :+: fs_a1Uu)","n_a1Uv","fs_a1Uw","Pz","_","f_a1Yn","_","f_a1Yn :+: _","(f_a1Yn :+: _)","Pz","f_a1Yo","fs_a1Yp","f_a1Yo :+: fs_a1Yp","(f_a1Yo :+: fs_a1Yp)","0","gs_a1Yq","0 :+: gs_a1Yq","(0 :+: gs_a1Yq)","f_a1Yr","fs_a1Ys","f_a1Yr :+: fs_a1Ys","(f_a1Yr :+: fs_a1Ys)","gs_a1Yt","0","fs_a1Yu","0 :+: fs_a1Yu","(0 :+: fs_a1Yu)","rs_a1Yv","f0_a1Yw","f1_a1Yx","f0_a1Yw :+: f1_a1Yx","(f0_a1Yw :+: f1_a1Yx)","Pz","(f0_a1Yw :+: f1_a1Yx) :+: Pz","((f0_a1Yw :+: f1_a1Yx) :+: Pz)","Pz","_","fs_a1Yy","_ :+: fs_a1Yy","(_ :+: fs_a1Yy)","Pz","_","f_a1YA","fs_a1YB","f_a1YA :+: fs_a1YB","(f_a1YA :+: fs_a1YB)","n_a1YC","fs_a1YD","Pz","_","f_a1YF","fs_a1YG","f_a1YF :+: fs_a1YG","(f_a1YF :+: fs_a1YG)","n_a1YH","expx","sinx","cosx","Pz","0","0","0 :+: 0","(0 :+: 0)","fs_a1YJ","(0 :+: 0) :+: fs_a1YJ","((0 :+: 0) :+: fs_a1YJ)","1","fs_a1YK","1 :+: fs_a1YK","(1 :+: fs_a1YK)","qs_a1YL","fs_a1YN","Pz","Pz","Pz","0","gs_a1Zn","0 :+: gs_a1Zn","(0 :+: gs_a1Zn)","Pz","_","0","fs_a1Zo","0 :+: fs_a1Zo","(0 :+: fs_a1Zo)","0","gs_a1Zp","0 :+: gs_a1Zp","(0 :+: gs_a1Zp)","f_a1Zq","fs_a1Zr","f_a1Zq :+: fs_a1Zr","(f_a1Zq :+: fs_a1Zr)","g_a1Zs","gs_a1Zt","g_a1Zs :+: gs_a1Zt","(g_a1Zs :+: gs_a1Zt)","q_a1Zu","Pz","f_a1Zw","fs_a1Zx","f_a1Zw :+: fs_a1Zx","(f_a1Zw :+: fs_a1Zx)","Pz","gs_a1Zy","fs_a1Zz","Pz","f_a1ZA","fs_a1ZB","f_a1ZA :+: fs_a1ZB","(f_a1ZA :+: fs_a1ZB)","g_a1ZC","gs_a1ZD","g_a1ZC :+: gs_a1ZD","(g_a1ZC :+: gs_a1ZD)","Pz","_","_","Pz","f_a1ZE","fs_a1ZF","f_a1ZE :+: fs_a1ZF","(f_a1ZE :+: fs_a1ZF)","g_a1ZG","gs_a1ZH","g_a1ZG :+: gs_a1ZH","(g_a1ZG :+: gs_a1ZH)","0","c_a1ZI","p_a1ZK","Pz","p_a1ZL","fs_a1ZM","Pz","Pz","Pz","f_a1ZO","fs_a1ZP","f_a1ZO :+: fs_a1ZP","(f_a1ZO :+: fs_a1ZP)","fs_a1ZQ","Pz","f_a1ZR","fs_a1ZS","f_a1ZR :+: fs_a1ZS","(f_a1ZR :+: fs_a1ZS)","g_a1ZT","gs_a1ZU","g_a1ZT :+: gs_a1ZU","(g_a1ZT :+: gs_a1ZU)"]
{-# LANGUAGE BangPatterns #-}
{-# OPTIONS_GHC -fno-warn-missing-methods #-}
module Dum where
import System.IO
import Data.Ratio
import System.Environment (getArgs)

infixr 5 :+:

infixl 7 .*

default (Integer, Rational, Double)
tree = 0 :+: forest
forest = compose list tree
list = 1 :+: list
ts = 1 :+: ts ^ 2

extract :: Int -> Ps a_a1Uj -> [a_a1Uj]
extract 0 ps_a1Uk = []
extract n_a1Ul Pz = []
extract n_a1Um (x_a1Un :+: ps_a1Uo)
  = x_a1Un : extract (n_a1Um - 1) ps_a1Uo

deriv :: Num a_a1Ui => Ps a_a1Ui -> Ps a_a1Ui

integral :: Fractional a_a1Uh => Ps a_a1Uh -> Ps a_a1Uh

compose ::
          (Eq a_a1Ug, Num a_a1Ug) => Ps a_a1Ug -> Ps a_a1Ug -> Ps a_a1Ug

revert :: (Eq a_a1Uf, Fractional a_a1Uf) => Ps a_a1Uf -> Ps a_a1Uf

toList :: Num a_a1Ue => Ps a_a1Ue -> [a_a1Ue]

takePs :: Num a_a1N9 => Int -> Ps a_a1N9 -> [a_a1N9]

(.*) :: Num a_a1N8 => a_a1N8 -> Ps a_a1N8 -> Ps a_a1N8

x :: Num a_a1N7 => Ps a_a1N7

expx, sinx, cosx :: Fractional a_a1N6 => Ps a_a1N6
c_a1Up .* Pz = Pz
c_a1Uq .* (f_a1Ur :+: fs_a1Us)
  = c_a1Uq * f_a1Ur :+: c_a1Uq .* fs_a1Us
x = 0 :+: 1 :+: Pz
toList Pz = []
toList (f_a1Ut :+: fs_a1Uu) = f_a1Ut : (toList fs_a1Uu)
takePs n_a1Uv fs_a1Uw = take n_a1Uv (toList fs_a1Uw)
compose Pz _ = Pz
compose (f_a1Yn :+: _) Pz = f_a1Yn :+: Pz
compose (f_a1Yo :+: fs_a1Yp) (0 :+: gs_a1Yq)
  = f_a1Yo :+: gs_a1Yq * (compose fs_a1Yp (0 :+: gs_a1Yq))
compose (f_a1Yr :+: fs_a1Ys) gs_a1Yt
  = (f_a1Yr :+: Pz) + gs_a1Yt * (compose fs_a1Ys gs_a1Yt)
revert (0 :+: fs_a1Yu) = rs_a1Yv
  where rs_a1Yv = 0 :+: 1 / (compose fs_a1Yu rs_a1Yv)
revert ((f0_a1Yw :+: f1_a1Yx) :+: Pz)
  = (-1) / f1_a1Yx :+: 1 / f1_a1Yx :+: Pz
deriv Pz = Pz
deriv (_ :+: fs_a1Yy) = deriv1_a1Yz fs_a1Yy 1
  where deriv1_a1Yz Pz _ = Pz
        deriv1_a1Yz (f_a1YA :+: fs_a1YB) n_a1YC
          = n_a1YC * f_a1YA :+: (deriv1_a1Yz fs_a1YB (n_a1YC + 1))
integral fs_a1YD = 0 :+: (int1_a1YE fs_a1YD 1)
  where int1_a1YE Pz _ = Pz
        int1_a1YE (f_a1YF :+: fs_a1YG) n_a1YH
          = f_a1YF / n_a1YH :+: (int1_a1YE fs_a1YG (n_a1YH + 1))
expx = 1 + (integral expx)
sinx = integral cosx
cosx = 1 - (integral sinx)

data Ps a_a1N5 = Pz
               | a_a1N5 :+: Ps a_a1N5

instance (Eq a_a1YI, Fractional a_a1YI) => Floating (Ps a_a1YI)
         where
        sqrt Pz = Pz
        sqrt ((0 :+: 0) :+: fs_a1YJ) = 0 :+: (sqrt fs_a1YJ)
        sqrt (1 :+: fs_a1YK) = qs_a1YL
          where qs_a1YL
                  = 1 + integral ((deriv (1 :+: fs_a1YK)) / (2 .* qs_a1YL))

instance (Eq a_a1YM, Fractional a_a1YM) => Fractional (Ps a_a1YM)
         where
        recip fs_a1YN = 1 / fs_a1YN
        Pz / Pz = error "power series 0/0"
        Pz / (0 :+: gs_a1Zn) = Pz / gs_a1Zn
        Pz / _ = Pz
        (0 :+: fs_a1Zo) / (0 :+: gs_a1Zp) = fs_a1Zo / gs_a1Zp
        (f_a1Zq :+: fs_a1Zr) / (g_a1Zs :+: gs_a1Zt)
          = let q_a1Zu = f_a1Zq / g_a1Zs in
              q_a1Zu :+: (fs_a1Zr - q_a1Zu .* gs_a1Zt) / (g_a1Zs :+: gs_a1Zt)

instance Num a_a1Zv => Num (Ps a_a1Zv) where
        negate Pz = Pz
        negate (f_a1Zw :+: fs_a1Zx) = (-f_a1Zw) :+: (-fs_a1Zx)
        Pz + gs_a1Zy = gs_a1Zy
        fs_a1Zz + Pz = fs_a1Zz
        (f_a1ZA :+: fs_a1ZB) + (g_a1ZC :+: gs_a1ZD)
          = f_a1ZA + g_a1ZC :+: fs_a1ZB + gs_a1ZD
        Pz * _ = Pz
        _ * Pz = Pz
        (f_a1ZE :+: fs_a1ZF) * (g_a1ZG :+: gs_a1ZH)
          = f_a1ZE * g_a1ZG :+: f_a1ZE .* gs_a1ZH + g_a1ZG .* fs_a1ZF + x *
              fs_a1ZF
              * gs_a1ZH
        fromInteger 0 = Pz
        fromInteger c_a1ZI = fromInteger c_a1ZI :+: Pz

instance (Show a_a1ZJ, Num a_a1ZJ) => Show (Ps a_a1ZJ) where
        showsPrec p_a1ZK Pz = showsPrec p_a1ZK [0]
        showsPrec p_a1ZL fs_a1ZM = showsPrec p_a1ZL (toList fs_a1ZM)

instance (Eq a_a1ZN, Num a_a1ZN) => Eq (Ps a_a1ZN) where
        Pz == Pz = True
        Pz == (f_a1ZO :+: fs_a1ZP) = f_a1ZO == 0 && Pz == fs_a1ZP
        fs_a1ZQ == Pz = Pz == fs_a1ZQ
        (f_a1ZR :+: fs_a1ZS) == (g_a1ZT :+: gs_a1ZU)
          = f_a1ZR == g_a1ZT && fs_a1ZS == gs_a1ZU
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.go wordsize_aAE
  = let
      limit_aAF = 2000
      verbose_aAG = True
      width_aAH = 10
      xs_aAI = [(2 + 3 * i_aAJ, 11 + 2 * i_aAJ) | i_aAJ <- [1 .. ]]
    in
      "Binary multiplier circuit simulation\n"
      ++
        (if verbose_aAG then Dum.traceMult width_aAH else Dum.runMult)
          wordsize_aAE limit_aAF xs_aAI
Dum.traceMult :: Int -> Int -> Int -> [(Int, Int)] -> String
Dum.traceMult width_aBW wordsize_aBX limit_aBY xs_aBZ
  = Dum.format
      limit_aBY
      [Dum.fmtInt 5 [0 .. ], Dum.fmtStr ". ", Dum.fmtB start_aC6,
       Dum.fmtW width_aBW as_aC0, Dum.fmtW width_aBW bs_aC1,
       Dum.fmtStr "  ==> ", Dum.fmtB ready_aC2, Dum.fmtW width_aBW ra_aC3,
       Dum.fmtW width_aBW rb_aC4, Dum.fmtW width_aBW prod_aC5,
       Dum.fmtStr "\n"]
  where
      (as_aC0, bs_aC1, ready_aC2, ra_aC3, rb_aC4, prod_aC5)
        = Dum.multsys wordsize_aBX xs_aBZ
      start_aC6 = ready_aC2
Dum.runMult :: Int -> Int -> [(Int, Int)] -> String
Dum.runMult wordsize_aC7 limit_aC8 xs_aC9
  = show dummy_aCg ++ "\n"
  where
      (as_aCa, bs_aCb, ready_aCc, ra_aCd, rb_aCe, prod_aCf)
        = Dum.multsys wordsize_aC7 xs_aC9
      dummy_aCg = (sum (take limit_aC8 ready_aCc)) :: Int
Dum.multsys ::
  Int -> [(Int, Int)] -> (Dum.W, Dum.W, Dum.B, Dum.W, Dum.W, Dum.W)
Dum.multsys wordsize_a18V xs_a18W
  = (as_a192, bs_a193, ready_a18X, ra_a18Y, rb_a18Z, prod_a190)
  where
      (ready_a18X, ra_a18Y, rb_a18Z, prod_a190)
        = Dum.multiplier wordsize_a18V start_a191 as_a192 bs_a193
      start_a191 = ready_a18X
      as_a192 = f_a194 (map fst xs_a18W)
      bs_a193 = f_a194 (map snd xs_a18W)
      f_a194 :: [Int] -> Dum.W
      f_a194 as_a19i
        = Dum.ntrans
            wordsize_a18V
            (map (Dum.ibits wordsize_a18V) (g_a195 start_a191 as_a19i))
      g_a195 :: Dum.B -> [Int] -> [Int]
      g_a195 [] xs_a19j = []
      g_a195 st_a19k [] = []
      g_a195 (0 : sts_a19l) xs_a19m = 0 : g_a195 sts_a19l xs_a19m
      g_a195 (1 : sts_a19n) (x_a19o : xs_a19p)
        = x_a19o : g_a195 sts_a19n xs_a19p
Dum.multiplier ::
  Int -> Dum.B -> Dum.W -> Dum.W -> (Dum.B, Dum.W, Dum.W, Dum.W)
Dum.multiplier k_a19q start_a19r a_a19s b_a19t
  = (ready_a19A, regA_a19x, regB_a19y, regP_a19u)
  where
      regP_a19u
        = Dum.wlat
            (2 * k_a19q)
            (Dum.wmux1
               (2 * k_a19q) start_a19r sum_a19w (Dum.rept (2 * k_a19q) Dum.zerO))
      (ovfl_a19v, sum_a19w)
        = Dum.add
            (2 * k_a19q)
            regP_a19u
            (Dum.wmux1
               (2 * k_a19q) lsbB_a19z (Dum.rept (2 * k_a19q) Dum.zerO) regA_a19x)
            Dum.zerO
      regA_a19x
        = Dum.wlat
            (2 * k_a19q)
            (Dum.wmux1
               (2 * k_a19q)
               start_a19r
               (Dum.shl (2 * k_a19q) regA_a19x)
               (Dum.rept k_a19q Dum.zerO ++ a_a19s))
      regB_a19y
        = Dum.wlat
            k_a19q
            (Dum.wmux1 k_a19q start_a19r (Dum.shr k_a19q regB_a19y) b_a19t)
      lsbB_a19z = head (drop (k_a19q - 1) regB_a19y)
      ready_a19A
        = Dum.or2
            (Dum.regIs0 (2 * k_a19q) regA_a19x) (Dum.regIs0 k_a19q regB_a19y)
Dum.regIs0 :: Int -> Dum.W -> Dum.B
Dum.regIs0 k_a19B xs_a19C = Dum.wideAnd (map Dum.inv xs_a19C)
Dum.shl :: Int -> Dum.W -> Dum.W
Dum.shl k_a19D xs_a19E = drop 1 xs_a19E ++ [Dum.zerO]
Dum.shr :: Int -> Dum.W -> Dum.W
Dum.shr k_a19F xs_a19G = [Dum.zerO] ++ take (k_a19F - 1) xs_a19G
Dum.add :: Int -> Dum.W -> Dum.W -> Dum.B -> (Dum.B, Dum.W)
Dum.add 0 xs_a19H ys_a19I cin_a19J = (cin_a19J, [])
Dum.add k_a19K (x_a19L : xs_a19M) (y_a19N : ys_a19O) cin_a19P
  | k_a19K < 0 = error "Main.add < 0"
  | otherwise = (cout_a19Q, s_a19R : ss_a19T)
  where
      (cout_a19Q, s_a19R) = Dum.fulladd x_a19L y_a19N c_a19S
      (c_a19S, ss_a19T) = Dum.add (k_a19K - 1) xs_a19M ys_a19O cin_a19P
Dum.halfadd :: Dum.B -> Dum.B -> (Dum.B, Dum.B)
Dum.halfadd x_a26b y_a26c
  = (Dum.and2 x_a26b y_a26c, Dum.xor x_a26b y_a26c)
Dum.fulladd :: Dum.B -> Dum.B -> Dum.B -> (Dum.B, Dum.B)
Dum.fulladd a_a26d b_a26e c_a26f
  = (Dum.or2 w_a26g y_a26i, z_a26j)
  where
      (w_a26g, x_a26h) = Dum.halfadd a_a26d b_a26e
      (y_a26i, z_a26j) = Dum.halfadd x_a26h c_a26f
Dum.bmux1 :: Dum.B -> Dum.B -> Dum.B -> Dum.B
Dum.bmux1 c_a26k a_a26l b_a26m
  = Dum.or2
      (Dum.and2 (Dum.inv c_a26k) a_a26l) (Dum.and2 c_a26k b_a26m)
Dum.wmux1 :: Int -> Dum.B -> Dum.W -> Dum.W -> Dum.W
Dum.wmux1 k_a26n a_a26o = Dum.word21 k_a26n (Dum.bmux1 a_a26o)
Dum.bdemux1 :: Dum.B -> Dum.B -> (Dum.B, Dum.B)
Dum.bdemux1 c_a26p a_a26q
  = (Dum.and2 (Dum.inv c_a26p) a_a26q, Dum.and2 c_a26p a_a26q)
Dum.bdemux :: Int -> [Dum.B] -> Dum.B -> [Dum.B]
Dum.bdemux 0 [] x_a26r = [x_a26r]
Dum.bdemux n_a26s as_a26t x_a26u
  | n_a26s < 0 = error "bdemux; n < 0"
  | otherwise
  = let n'_a26x = n_a26s - 1
    in
      Dum.bdemux n'_a26x (tail as_a26t) p_a26v
      ++ Dum.bdemux n'_a26x (tail as_a26t) q_a26w
  where
      (p_a26v, q_a26w) = Dum.bdemux1 (head as_a26t) x_a26u
Dum.breg :: Dum.B -> Dum.B -> Dum.B
Dum.breg sto_a26y a_a26z
  = x_a26A
  where
      x_a26A = Dum.latch (Dum.bmux1 sto_a26y x_a26A a_a26z)
Dum.wreg :: Int -> Dum.B -> [Dum.B] -> [Dum.B]
Dum.wreg 0 sto_a26B [] = []
Dum.wreg n_a26C sto_a26D (x_a26E : xs_a26F)
  = Dum.breg sto_a26D x_a26E : Dum.wreg (n_a26C - 1) sto_a26D xs_a26F
Dum.wlat :: Int -> [Dum.B] -> [Dum.B]
Dum.wlat 0 xs_a26G = []
Dum.wlat k_a26H (x_a26I : xs_a26J)
  | k_a26H < 0 = error "wlat"
  | otherwise = Dum.latch x_a26I : Dum.wlat (k_a26H - 1) xs_a26J
Dum.latch :: Dum.B -> Dum.B
Dum.latch a_a26K = 0 : a_a26K
Dum.zerO, Dum.one :: Dum.B
Dum.zerO = 0 : Dum.zerO
Dum.one = 1 : Dum.one
Dum.inv
  = Dum.lift11 Dum.forceBit f_a26L
  where
      f_a26L :: Dum.Bit -> Dum.Bit
      f_a26L 0 = 1
      f_a26L 1 = 0
Dum.and2
  = Dum.lift21 Dum.forceBit f_a26M
  where
      f_a26M :: Dum.Bit -> Dum.Bit -> Dum.Bit
      f_a26M 0 0 = 0
      f_a26M 0 1 = 0
      f_a26M 1 0 = 0
      f_a26M 1 1 = 1
Dum.nand2
  = Dum.lift21 Dum.forceBit f_a26N
  where
      f_a26N :: Dum.Bit -> Dum.Bit -> Dum.Bit
      f_a26N 0 0 = 1
      f_a26N 0 1 = 1
      f_a26N 1 0 = 1
      f_a26N 1 1 = 0
Dum.or2
  = Dum.lift21 Dum.forceBit f_a26O
  where
      f_a26O :: Dum.Bit -> Dum.Bit -> Dum.Bit
      f_a26O 0 0 = 0
      f_a26O 0 1 = 1
      f_a26O 1 0 = 1
      f_a26O 1 1 = 1
Dum.nor2
  = Dum.lift21 Dum.forceBit f_a26P
  where
      f_a26P :: Dum.Bit -> Dum.Bit -> Dum.Bit
      f_a26P 0 0 = 1
      f_a26P 0 1 = 0
      f_a26P 1 0 = 0
      f_a26P 1 1 = 0
Dum.or3
  = Dum.lift31 Dum.forceBit f_a26Q
  where
      f_a26Q :: Dum.Bit -> Dum.Bit -> Dum.Bit -> Dum.Bit
      f_a26Q 0 0 0 = 0
      f_a26Q 0 0 1 = 1
      f_a26Q 0 1 0 = 1
      f_a26Q 0 1 1 = 1
      f_a26Q 1 0 0 = 1
      f_a26Q 1 0 1 = 1
      f_a26Q 1 1 0 = 1
      f_a26Q 1 1 1 = 1
Dum.xor
  = Dum.lift21 Dum.forceBit f_a26R
  where
      f_a26R :: Dum.Bit -> Dum.Bit -> Dum.Bit
      f_a26R 0 0 = 0
      f_a26R 0 1 = 1
      f_a26R 1 0 = 1
      f_a26R 1 1 = 0
Dum.wideGate f_a26S [x_a26T] = x_a26T
Dum.wideGate f_a26U xs_a26V
  = f_a26U
      (Dum.wideGate f_a26U (take i_a26W xs_a26V))
      (Dum.wideGate f_a26U (drop i_a26W xs_a26V))
  where
      i_a26W = length xs_a26V `div` 2
Dum.wideAnd xs_a2gy = Dum.wideGate Dum.and2 xs_a2gy
Dum.wideNand xs_a2gz = Dum.wideGate Dum.nand2 xs_a2gz
Dum.wideOr xs_a2gA = Dum.wideGate Dum.or2 xs_a2gA
Dum.wideNor xs_a2gB = Dum.wideGate Dum.nor2 xs_a2gB
Dum.forceBit :: Dum.Bit -> Bool
Dum.forceBit x_a2gC = (x_a2gC == 0)
Dum.headstrict :: (a_aAD -> Bool) -> [a_aAD] -> [a_aAD]
Dum.headstrict force_a2gD [] = []
Dum.headstrict force_a2gE xs_a2gF
  = if force_a2gE (head xs_a2gF) then xs_a2gF else xs_a2gF
Dum.pairstrict ::
  (a_aAB -> Bool)
  -> (b_aAC -> Bool) -> ([a_aAB], [b_aAC]) -> ([a_aAB], [b_aAC])
Dum.pairstrict force1_a2gG force2_a2gH p_a2gI
  = if force1_a2gG (head x_a2gJ) then
        if force2_a2gH (head y_a2gK) then p_a2gI else p_a2gI
    else
        if force2_a2gH (head y_a2gK) then p_a2gI else p_a2gI
  where
      (x_a2gJ, y_a2gK) = p_a2gI
Dum.lift11 force_a2gL f_a2gM [] = []
Dum.lift11 force_a2gN f_a2gO (x_a2gP : xs_a2gQ)
  = Dum.headstrict
      force_a2gN (f_a2gO x_a2gP : Dum.lift11 force_a2gN f_a2gO xs_a2gQ)
Dum.lift21 force_a2gR f_a2gS (y_a2gT : ys_a2gU) (z_a2gV : zs_a2gW)
  = (f_a2gS y_a2gT z_a2gV
     : Dum.lift21 force_a2gR f_a2gS ys_a2gU zs_a2gW)
Dum.lift31 force_a2gX f_a2gY [] ys_a2gZ zs_a2h0 = []
Dum.lift31 force_a2h1 f_a2h2 xs_a2h3 [] zs_a2h4 = []
Dum.lift31 force_a2h5 f_a2h6 xs_a2h7 ys_a2h8 [] = []
Dum.lift31
  force_a2h9
  f_a2ha
  (x_a2hb : xs_a2hc)
  (y_a2hd : ys_a2he)
  (z_a2hf : zs_a2hg)
  = Dum.headstrict
      force_a2h9
      (f_a2ha x_a2hb y_a2hd z_a2hf
       : Dum.lift31 force_a2h9 f_a2ha xs_a2hc ys_a2he zs_a2hg)
Dum.lift41 force_a2hh f_a2hi [] xs_a2hj ys_a2hk zs_a2hl = []
Dum.lift41 force_a2hm f_a2hn ws_a2ho [] ys_a2hp zs_a2hq = []
Dum.lift41 force_a2hr f_a2hs ws_a2ht xs_a2hu [] zs_a2hv = []
Dum.lift41 force_a2hw f_a2hx ws_a2hy xs_a2hz ys_a2hA [] = []
Dum.lift41
  force_a2hB
  f_a2hC
  (w_a2hD : ws_a2hE)
  (x_a2hF : xs_a2hG)
  (y_a2hH : ys_a2hI)
  (z_a2hJ : zs_a2hK)
  = Dum.headstrict
      force_a2hB
      (f_a2hC w_a2hD x_a2hF y_a2hH z_a2hJ
       : Dum.lift41 force_a2hB f_a2hC ws_a2hE xs_a2hG ys_a2hI zs_a2hK)
Dum.lift22 force1_a2hL force2_a2hM f_a2hN [] ys_a2hO = ([], [])
Dum.lift22 force1_a2hP force2_a2hQ f_a2hR xs_a2hS [] = ([], [])
Dum.lift22
  force1_a2hT
  force2_a2hU
  f_a2hV
  (x_a2hW : xs_a2hX)
  (y_a2hY : ys_a2hZ)
  = Dum.pairstrict
      force1_a2hT force2_a2hU (a_a2i0 : as_a2i2, b_a2i1 : bs_a2i3)
  where
      (a_a2i0, b_a2i1) = f_a2hV x_a2hW y_a2hY
      (as_a2i2, bs_a2i3)
        = Dum.lift22 force1_a2hT force2_a2hU f_a2hV xs_a2hX ys_a2hZ
Dum.word11 :: Int -> (a_aAz -> b_aAA) -> [a_aAz] -> [b_aAA]
Dum.word11 0 f_a2i4 as_a2i5 = []
Dum.word11 k_a2i6 f_a2i7 as_a2i8
  = f_a2i7 (head as_a2i8)
    : Dum.word11 (k_a2i6 - 1) f_a2i7 (tail as_a2i8)
Dum.word21 ::
  Int -> (a_aAw -> b_aAx -> c_aAy) -> [a_aAw] -> [b_aAx] -> [c_aAy]
Dum.word21 0 f_a2i9 as_a2ia bs_a2ib = []
Dum.word21 k_a2ic f_a2id as_a2ie bs_a2if
  = f_a2id (head as_a2ie) (head bs_a2if)
    : Dum.word21 (k_a2ic - 1) f_a2id (tail as_a2ie) (tail bs_a2if)
Dum.word31 ::
  Int
  -> (a_aAs -> b_aAt -> c_aAu -> d_aAv)
     -> [a_aAs] -> [b_aAt] -> [c_aAu] -> [d_aAv]
Dum.word31 0 f_a2ig as_a2ih bs_a2ii cs_a2ij = []
Dum.word31 k_a2ik f_a2il as_a2im bs_a2in cs_a2io
  = f_a2il (head as_a2im) (head bs_a2in) (head cs_a2io)
    : Dum.word31
        (k_a2ik - 1) f_a2il (tail as_a2im) (tail bs_a2in) (tail cs_a2io)
Dum.word12 ::
  Int -> (a_aAp -> (b_aAq, c_aAr)) -> [a_aAp] -> ([b_aAq], [c_aAr])
Dum.word12 0 f_a2ip as_a2iq = ([], [])
Dum.word12 k_a2ir f_a2is as_a2it
  = (b_a2iu : bs_a2iw, c_a2iv : cs_a2ix)
  where
      (b_a2iu, c_a2iv) = f_a2is (head as_a2it)
      (bs_a2iw, cs_a2ix) = Dum.word12 (k_a2ir - 1) f_a2is (tail as_a2it)
Dum.word22 ::
  Int
  -> (a_aAl -> b_aAm -> (c_aAn, d_aAo))
     -> [a_aAl] -> [b_aAm] -> ([c_aAn], [d_aAo])
Dum.word22 0 f_a2iy as_a2iz bs_a2iA = ([], [])
Dum.word22 k_a2iB f_a2iC as_a2iD bs_a2iE
  = (c_a2iF : cs_a2iH, d_a2iG : ds_a2iI)
  where
      (c_a2iF, d_a2iG) = f_a2iC (head as_a2iD) (head bs_a2iE)
      (cs_a2iH, ds_a2iI)
        = Dum.word22 (k_a2iB - 1) f_a2iC (tail as_a2iD) (tail bs_a2iE)
Dum.shoInt :: Int -> String
Dum.shoInt n_a2iJ = show n_a2iJ
Dum.trans :: [[a_aAk]] -> [[a_aAk]]
Dum.trans xs_a2iK
  = if or (map null xs_a2iK) then
        []
    else
        map head xs_a2iK : Dum.trans (map tail xs_a2iK)
Dum.ntrans 0 xs_a2iL = []
Dum.ntrans i_a2iM xs_a2iN
  = map head xs_a2iN : Dum.ntrans (i_a2iM - 1) (map tail xs_a2iN)
Dum.dec :: Int -> Int -> String
Dum.dec k_a2iO n_a2iP
  = if i_a2iR < k_a2iO then
        (Dum.rept (k_a2iO - i_a2iR) ' ') ++ xs_a2iQ
    else
        xs_a2iQ
  where
      xs_a2iQ = show n_a2iP
      i_a2iR = length xs_a2iQ
Dum.ibits :: Int -> Int -> [Int]
Dum.ibits n_a2iS i_a2iT
  = reverse (f_ibits_a2iU n_a2iS i_a2iT)
  where
      f_ibits_a2iU 0 i_a2iV = []
      f_ibits_a2iU n_a2iW i_a2iX
        = i_a2iX `mod` 2 : f_ibits_a2iU (n_a2iW - 1) (i_a2iX `div` 2)
Dum.bitsi :: [Int] -> Int
Dum.bitsi
  = f_bitsi_a2iY 0
  where
      f_bitsi_a2iY i_a2iZ [] = i_a2iZ
      f_bitsi_a2iY i_a2j0 (b_a2j1 : bs_a2j2)
        = f_bitsi_a2iY (2 * i_a2j0 + b_a2j1) bs_a2j2
Dum.intrep :: [Dum.B] -> [Int]
Dum.intrep bs_a2j3 = map Dum.bitsi (Dum.trans bs_a2j3)
Dum.bitrep :: Int -> [Int] -> [Dum.B]
Dum.bitrep n_a2j4 = Dum.ntrans n_a2j4 . map (Dum.ibits n_a2j4)
Dum.rept :: Int -> a_aAj -> [a_aAj]
Dum.rept 0 x_a2j5 = []
Dum.rept i_a2j6 x_a2j7 = x_a2j7 : Dum.rept (i_a2j6 - 1) x_a2j7
Dum.mksepline c_a2j8 = "\n" ++ Dum.rept 79 c_a2j8 ++ "\n"
Dum.sepline = Dum.mksepline '-'
Dum.bigsepline = Dum.mksepline '='
Dum.format :: Int -> [[[a_aAi]]] -> [a_aAi]
Dum.format limit_a2j9
  = concat . take limit_a2j9 . map concat . Dum.trans
Dum.fmtW i_a2ja xs_a2jb = Dum.fmtDec i_a2ja (Dum.intrep xs_a2jb)
Dum.fmtDec :: Int -> [Int] -> [String]
Dum.fmtDec w_a2jc = map (Dum.dec w_a2jc)
Dum.fmtB :: Dum.B -> [String]
Dum.fmtB = map (Dum.dec 1)
Dum.fmtInt :: Int -> [Int] -> [String]
Dum.fmtInt i_a2jd = map (Dum.dec i_a2jd)
Dum.fmtFld ::
  (Int -> Dum.Bit -> String) -> Int -> [Dum.B] -> [String]
Dum.fmtFld f_a2je i_a2jf xs_a2jg
  = map (f_a2je i_a2jf) (Dum.intrep xs_a2jg)
Dum.fmtList :: (a_aAh -> String) -> [[a_aAh]] -> [String]
Dum.fmtList f_a2jh xs_a2ji
  = map (g_a2jj . concat . map f_a2jh) xs_a2ji
  where
      g_a2jj cs_a2jk = cs_a2jk ++ "  "
Dum.fmtStr :: String -> [String]
Dum.fmtStr s_a2jl = s_a2jl : Dum.fmtStr s_a2jl
Dum.when :: Dum.B -> Dum.W -> [Int]
Dum.when (0 : xs_a2jm) w_a2jn = Dum.when xs_a2jm (map tail w_a2jn)
Dum.when (1 : xs_a2jo) w_a2jp = map head w_a2jp

type Dum.Bit = Int
type Dum.B = [Dum.Bit]
type Dum.W = [Dum.B]


["wordsize_aAE","limit_aAF","verbose_aAG","width_aAH","xs_aAI","i_aAJ","width_aBW","wordsize_aBX","limit_aBY","xs_aBZ","as_aC0","bs_aC1","ready_aC2","ra_aC3","rb_aC4","prod_aC5","(as_aC0, bs_aC1, ready_aC2, ra_aC3, rb_aC4, prod_aC5)","start_aC6","wordsize_aC7","limit_aC8","xs_aC9","as_aCa","bs_aCb","ready_aCc","ra_aCd","rb_aCe","prod_aCf","(as_aCa, bs_aCb, ready_aCc, ra_aCd, rb_aCe, prod_aCf)","dummy_aCg","wordsize_a18V","xs_a18W","ready_a18X","ra_a18Y","rb_a18Z","prod_a190","(ready_a18X, ra_a18Y, rb_a18Z, prod_a190)","start_a191","as_a192","bs_a193","as_a19i","[]","xs_a19j","st_a19k","[]","0","sts_a19l","0 : sts_a19l","(0 : sts_a19l)","xs_a19m","1","sts_a19n","1 : sts_a19n","(1 : sts_a19n)","x_a19o","xs_a19p","x_a19o : xs_a19p","(x_a19o : xs_a19p)","k_a19q","start_a19r","a_a19s","b_a19t","regP_a19u","ovfl_a19v","sum_a19w","(ovfl_a19v, sum_a19w)","regA_a19x","regB_a19y","lsbB_a19z","ready_a19A","k_a19B","xs_a19C","k_a19D","xs_a19E","k_a19F","xs_a19G","0","xs_a19H","ys_a19I","cin_a19J","k_a19K","x_a19L","xs_a19M","x_a19L : xs_a19M","(x_a19L : xs_a19M)","y_a19N","ys_a19O","y_a19N : ys_a19O","(y_a19N : ys_a19O)","cin_a19P","cout_a19Q","s_a19R","(cout_a19Q, s_a19R)","c_a19S","ss_a19T","(c_a19S, ss_a19T)","x_a26b","y_a26c","a_a26d","b_a26e","c_a26f","w_a26g","x_a26h","(w_a26g, x_a26h)","y_a26i","z_a26j","(y_a26i, z_a26j)","c_a26k","a_a26l","b_a26m","k_a26n","a_a26o","c_a26p","a_a26q","0","[]","x_a26r","n_a26s","as_a26t","x_a26u","n'_a26x","p_a26v","q_a26w","(p_a26v, q_a26w)","sto_a26y","a_a26z","x_a26A","0","sto_a26B","[]","n_a26C","sto_a26D","x_a26E","xs_a26F","x_a26E : xs_a26F","(x_a26E : xs_a26F)","0","xs_a26G","k_a26H","x_a26I","xs_a26J","x_a26I : xs_a26J","(x_a26I : xs_a26J)","a_a26K","zerO","one","inv","0","1","and2","0","0","0","1","1","0","1","1","nand2","0","0","0","1","1","0","1","1","or2","0","0","0","1","1","0","1","1","nor2","0","0","0","1","1","0","1","1","or3","0","0","0","0","0","1","0","1","0","0","1","1","1","0","0","1","0","1","1","1","0","1","1","1","xor","0","0","0","1","1","0","1","1","f_a26S","x_a26T","[x_a26T]","f_a26U","xs_a26V","i_a26W","xs_a2gy","xs_a2gz","xs_a2gA","xs_a2gB","x_a2gC","force_a2gD","[]","force_a2gE","xs_a2gF","force1_a2gG","force2_a2gH","p_a2gI","x_a2gJ","y_a2gK","(x_a2gJ, y_a2gK)","force_a2gL","f_a2gM","[]","force_a2gN","f_a2gO","x_a2gP","xs_a2gQ","x_a2gP : xs_a2gQ","(x_a2gP : xs_a2gQ)","force_a2gR","f_a2gS","y_a2gT","ys_a2gU","y_a2gT : ys_a2gU","(y_a2gT : ys_a2gU)","z_a2gV","zs_a2gW","z_a2gV : zs_a2gW","(z_a2gV : zs_a2gW)","force_a2gX","f_a2gY","[]","ys_a2gZ","zs_a2h0","force_a2h1","f_a2h2","xs_a2h3","[]","zs_a2h4","force_a2h5","f_a2h6","xs_a2h7","ys_a2h8","[]","force_a2h9","f_a2ha","x_a2hb","xs_a2hc","x_a2hb : xs_a2hc","(x_a2hb : xs_a2hc)","y_a2hd","ys_a2he","y_a2hd : ys_a2he","(y_a2hd : ys_a2he)","z_a2hf","zs_a2hg","z_a2hf : zs_a2hg","(z_a2hf : zs_a2hg)","force_a2hh","f_a2hi","[]","xs_a2hj","ys_a2hk","zs_a2hl","force_a2hm","f_a2hn","ws_a2ho","[]","ys_a2hp","zs_a2hq","force_a2hr","f_a2hs","ws_a2ht","xs_a2hu","[]","zs_a2hv","force_a2hw","f_a2hx","ws_a2hy","xs_a2hz","ys_a2hA","[]","force_a2hB","f_a2hC","w_a2hD","ws_a2hE","w_a2hD : ws_a2hE","(w_a2hD : ws_a2hE)","x_a2hF","xs_a2hG","x_a2hF : xs_a2hG","(x_a2hF : xs_a2hG)","y_a2hH","ys_a2hI","y_a2hH : ys_a2hI","(y_a2hH : ys_a2hI)","z_a2hJ","zs_a2hK","z_a2hJ : zs_a2hK","(z_a2hJ : zs_a2hK)","force1_a2hL","force2_a2hM","f_a2hN","[]","ys_a2hO","force1_a2hP","force2_a2hQ","f_a2hR","xs_a2hS","[]","force1_a2hT","force2_a2hU","f_a2hV","x_a2hW","xs_a2hX","x_a2hW : xs_a2hX","(x_a2hW : xs_a2hX)","y_a2hY","ys_a2hZ","y_a2hY : ys_a2hZ","(y_a2hY : ys_a2hZ)","a_a2i0","b_a2i1","(a_a2i0, b_a2i1)","as_a2i2","bs_a2i3","(as_a2i2, bs_a2i3)","0","f_a2i4","as_a2i5","k_a2i6","f_a2i7","as_a2i8","0","f_a2i9","as_a2ia","bs_a2ib","k_a2ic","f_a2id","as_a2ie","bs_a2if","0","f_a2ig","as_a2ih","bs_a2ii","cs_a2ij","k_a2ik","f_a2il","as_a2im","bs_a2in","cs_a2io","0","f_a2ip","as_a2iq","k_a2ir","f_a2is","as_a2it","b_a2iu","c_a2iv","(b_a2iu, c_a2iv)","bs_a2iw","cs_a2ix","(bs_a2iw, cs_a2ix)","0","f_a2iy","as_a2iz","bs_a2iA","k_a2iB","f_a2iC","as_a2iD","bs_a2iE","c_a2iF","d_a2iG","(c_a2iF, d_a2iG)","cs_a2iH","ds_a2iI","(cs_a2iH, ds_a2iI)","n_a2iJ","xs_a2iK","0","xs_a2iL","i_a2iM","xs_a2iN","k_a2iO","n_a2iP","xs_a2iQ","i_a2iR","n_a2iS","i_a2iT","0","i_a2iV","n_a2iW","i_a2iX","bitsi","i_a2iZ","[]","i_a2j0","b_a2j1","bs_a2j2","b_a2j1 : bs_a2j2","(b_a2j1 : bs_a2j2)","bs_a2j3","n_a2j4","0","x_a2j5","i_a2j6","x_a2j7","c_a2j8","sepline","bigsepline","limit_a2j9","i_a2ja","xs_a2jb","w_a2jc","fmtB","i_a2jd","f_a2je","i_a2jf","xs_a2jg","f_a2jh","xs_a2ji","cs_a2jk","s_a2jl","0","xs_a2jm","0 : xs_a2jm","(0 : xs_a2jm)","w_a2jn","1","xs_a2jo","1 : xs_a2jo","(1 : xs_a2jo)","w_a2jp"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.Environment
go wordsize_aAE
  = let limit_aAF = 2000
        verbose_aAG = True
        width_aAH = 10
        xs_aAI = [(2 + 3 * i_aAJ, 11 + 2 * i_aAJ) | i_aAJ <- [1 ..]]
      in
      "Binary multiplier circuit simulation\n" ++
        (if verbose_aAG then traceMult width_aAH else runMult) wordsize_aAE
          limit_aAF
          xs_aAI

traceMult :: Int -> Int -> Int -> [(Int, Int)] -> String
traceMult width_aBW wordsize_aBX limit_aBY xs_aBZ
  = format limit_aBY
      [fmtInt 5 [0 ..], fmtStr ". ", fmtB start_aC6,
       fmtW width_aBW as_aC0, fmtW width_aBW bs_aC1, fmtStr "  ==> ",
       fmtB ready_aC2, fmtW width_aBW ra_aC3, fmtW width_aBW rb_aC4,
       fmtW width_aBW prod_aC5, fmtStr "\n"]
  where (as_aC0, bs_aC1, ready_aC2, ra_aC3, rb_aC4, prod_aC5)
          = multsys wordsize_aBX xs_aBZ
        start_aC6 = ready_aC2

runMult :: Int -> Int -> [(Int, Int)] -> String
runMult wordsize_aC7 limit_aC8 xs_aC9 = show dummy_aCg ++ "\n"
  where (as_aCa, bs_aCb, ready_aCc, ra_aCd, rb_aCe, prod_aCf)
          = multsys wordsize_aC7 xs_aC9
        dummy_aCg = (sum (take limit_aC8 ready_aCc)) :: Int

multsys :: Int -> [(Int, Int)] -> (W, W, B, W, W, W)
multsys wordsize_a18V xs_a18W
  = (as_a192, bs_a193, ready_a18X, ra_a18Y, rb_a18Z, prod_a190)
  where (ready_a18X, ra_a18Y, rb_a18Z, prod_a190)
          = multiplier wordsize_a18V start_a191 as_a192 bs_a193
        start_a191 = ready_a18X
        as_a192 = f_a194 (map fst xs_a18W)
        bs_a193 = f_a194 (map snd xs_a18W)
        
        f_a194 :: [Int] -> W
        f_a194 as_a19i
          = ntrans wordsize_a18V
              (map (ibits wordsize_a18V) (g_a195 start_a191 as_a19i))
        
        g_a195 :: B -> [Int] -> [Int]
        g_a195 [] xs_a19j = []
        g_a195 st_a19k [] = []
        g_a195 (0 : sts_a19l) xs_a19m = 0 : g_a195 sts_a19l xs_a19m
        g_a195 (1 : sts_a19n) (x_a19o : xs_a19p)
          = x_a19o : g_a195 sts_a19n xs_a19p

multiplier :: Int -> B -> W -> W -> (B, W, W, W)
multiplier k_a19q start_a19r a_a19s b_a19t
  = (ready_a19A, regA_a19x, regB_a19y, regP_a19u)
  where regP_a19u
          = wlat (2 * k_a19q)
              (wmux1 (2 * k_a19q) start_a19r sum_a19w (rept (2 * k_a19q) zerO))
        (ovfl_a19v, sum_a19w)
          = add (2 * k_a19q) regP_a19u
              (wmux1 (2 * k_a19q) lsbB_a19z (rept (2 * k_a19q) zerO) regA_a19x)
              zerO
        regA_a19x
          = wlat (2 * k_a19q)
              (wmux1 (2 * k_a19q) start_a19r (shl (2 * k_a19q) regA_a19x)
                 (rept k_a19q zerO ++ a_a19s))
        regB_a19y
          = wlat k_a19q
              (wmux1 k_a19q start_a19r (shr k_a19q regB_a19y) b_a19t)
        lsbB_a19z = head (drop (k_a19q - 1) regB_a19y)
        ready_a19A
          = or2 (regIs0 (2 * k_a19q) regA_a19x) (regIs0 k_a19q regB_a19y)

regIs0 :: Int -> W -> B
regIs0 k_a19B xs_a19C = wideAnd (map inv xs_a19C)

shl :: Int -> W -> W
shl k_a19D xs_a19E = drop 1 xs_a19E ++ [zerO]

shr :: Int -> W -> W
shr k_a19F xs_a19G = [zerO] ++ take (k_a19F - 1) xs_a19G

add :: Int -> W -> W -> B -> (B, W)
add 0 xs_a19H ys_a19I cin_a19J = (cin_a19J, [])
add k_a19K (x_a19L : xs_a19M) (y_a19N : ys_a19O) cin_a19P
  | k_a19K < 0 = error "Main.add < 0"
  | otherwise = (cout_a19Q, s_a19R : ss_a19T)
  where (cout_a19Q, s_a19R) = fulladd x_a19L y_a19N c_a19S
        (c_a19S, ss_a19T) = add (k_a19K - 1) xs_a19M ys_a19O cin_a19P

halfadd :: B -> B -> (B, B)
halfadd x_a26b y_a26c = (and2 x_a26b y_a26c, xor x_a26b y_a26c)

fulladd :: B -> B -> B -> (B, B)
fulladd a_a26d b_a26e c_a26f = (or2 w_a26g y_a26i, z_a26j)
  where (w_a26g, x_a26h) = halfadd a_a26d b_a26e
        (y_a26i, z_a26j) = halfadd x_a26h c_a26f

bmux1 :: B -> B -> B -> B
bmux1 c_a26k a_a26l b_a26m
  = or2 (and2 (inv c_a26k) a_a26l) (and2 c_a26k b_a26m)

wmux1 :: Int -> B -> W -> W -> W
wmux1 k_a26n a_a26o = word21 k_a26n (bmux1 a_a26o)

bdemux1 :: B -> B -> (B, B)
bdemux1 c_a26p a_a26q
  = (and2 (inv c_a26p) a_a26q, and2 c_a26p a_a26q)

bdemux :: Int -> [B] -> B -> [B]
bdemux 0 [] x_a26r = [x_a26r]
bdemux n_a26s as_a26t x_a26u
  | n_a26s < 0 = error "bdemux; n < 0"
  | otherwise =
    let n'_a26x = n_a26s - 1 in
      bdemux n'_a26x (tail as_a26t) p_a26v ++
        bdemux n'_a26x (tail as_a26t) q_a26w
  where (p_a26v, q_a26w) = bdemux1 (head as_a26t) x_a26u

breg :: B -> B -> B
breg sto_a26y a_a26z = x_a26A
  where x_a26A = latch (bmux1 sto_a26y x_a26A a_a26z)

wreg :: Int -> B -> [B] -> [B]
wreg 0 sto_a26B [] = []
wreg n_a26C sto_a26D (x_a26E : xs_a26F)
  = breg sto_a26D x_a26E : wreg (n_a26C - 1) sto_a26D xs_a26F

wlat :: Int -> [B] -> [B]
wlat 0 xs_a26G = []
wlat k_a26H (x_a26I : xs_a26J)
  | k_a26H < 0 = error "wlat"
  | otherwise = latch x_a26I : wlat (k_a26H - 1) xs_a26J

latch :: B -> B
latch a_a26K = 0 : a_a26K

zerO, one :: B
zerO = 0 : zerO
one = 1 : one
inv = lift11 forceBit f_a26L
  where f_a26L :: Bit -> Bit
        f_a26L 0 = 1
        f_a26L 1 = 0
and2 = lift21 forceBit f_a26M
  where f_a26M :: Bit -> Bit -> Bit
        f_a26M 0 0 = 0
        f_a26M 0 1 = 0
        f_a26M 1 0 = 0
        f_a26M 1 1 = 1
nand2 = lift21 forceBit f_a26N
  where f_a26N :: Bit -> Bit -> Bit
        f_a26N 0 0 = 1
        f_a26N 0 1 = 1
        f_a26N 1 0 = 1
        f_a26N 1 1 = 0
or2 = lift21 forceBit f_a26O
  where f_a26O :: Bit -> Bit -> Bit
        f_a26O 0 0 = 0
        f_a26O 0 1 = 1
        f_a26O 1 0 = 1
        f_a26O 1 1 = 1
nor2 = lift21 forceBit f_a26P
  where f_a26P :: Bit -> Bit -> Bit
        f_a26P 0 0 = 1
        f_a26P 0 1 = 0
        f_a26P 1 0 = 0
        f_a26P 1 1 = 0
or3 = lift31 forceBit f_a26Q
  where f_a26Q :: Bit -> Bit -> Bit -> Bit
        f_a26Q 0 0 0 = 0
        f_a26Q 0 0 1 = 1
        f_a26Q 0 1 0 = 1
        f_a26Q 0 1 1 = 1
        f_a26Q 1 0 0 = 1
        f_a26Q 1 0 1 = 1
        f_a26Q 1 1 0 = 1
        f_a26Q 1 1 1 = 1
xor = lift21 forceBit f_a26R
  where f_a26R :: Bit -> Bit -> Bit
        f_a26R 0 0 = 0
        f_a26R 0 1 = 1
        f_a26R 1 0 = 1
        f_a26R 1 1 = 0
wideGate f_a26S [x_a26T] = x_a26T
wideGate f_a26U xs_a26V
  = f_a26U (wideGate f_a26U (take i_a26W xs_a26V))
      (wideGate f_a26U (drop i_a26W xs_a26V))
  where i_a26W = length xs_a26V `div` 2
wideAnd xs_a2gy = wideGate and2 xs_a2gy
wideNand xs_a2gz = wideGate nand2 xs_a2gz
wideOr xs_a2gA = wideGate or2 xs_a2gA
wideNor xs_a2gB = wideGate nor2 xs_a2gB

forceBit :: Bit -> Bool
forceBit x_a2gC = (x_a2gC == 0)

headstrict :: (a_aAD -> Bool) -> [a_aAD] -> [a_aAD]
headstrict force_a2gD [] = []
headstrict force_a2gE xs_a2gF
  = if force_a2gE (head xs_a2gF) then xs_a2gF else xs_a2gF

pairstrict ::
           (a_aAB -> Bool) ->
             (b_aAC -> Bool) -> ([a_aAB], [b_aAC]) -> ([a_aAB], [b_aAC])
pairstrict force1_a2gG force2_a2gH p_a2gI
  = if force1_a2gG (head x_a2gJ) then
      if force2_a2gH (head y_a2gK) then p_a2gI else p_a2gI else
      if force2_a2gH (head y_a2gK) then p_a2gI else p_a2gI
  where (x_a2gJ, y_a2gK) = p_a2gI
lift11 force_a2gL f_a2gM [] = []
lift11 force_a2gN f_a2gO (x_a2gP : xs_a2gQ)
  = headstrict force_a2gN
      (f_a2gO x_a2gP : lift11 force_a2gN f_a2gO xs_a2gQ)
lift21 force_a2gR f_a2gS (y_a2gT : ys_a2gU) (z_a2gV : zs_a2gW)
  = (f_a2gS y_a2gT z_a2gV : lift21 force_a2gR f_a2gS ys_a2gU zs_a2gW)
lift31 force_a2gX f_a2gY [] ys_a2gZ zs_a2h0 = []
lift31 force_a2h1 f_a2h2 xs_a2h3 [] zs_a2h4 = []
lift31 force_a2h5 f_a2h6 xs_a2h7 ys_a2h8 [] = []
lift31 force_a2h9 f_a2ha (x_a2hb : xs_a2hc) (y_a2hd : ys_a2he)
  (z_a2hf : zs_a2hg)
  = headstrict force_a2h9
      (f_a2ha x_a2hb y_a2hd z_a2hf :
         lift31 force_a2h9 f_a2ha xs_a2hc ys_a2he zs_a2hg)
lift41 force_a2hh f_a2hi [] xs_a2hj ys_a2hk zs_a2hl = []
lift41 force_a2hm f_a2hn ws_a2ho [] ys_a2hp zs_a2hq = []
lift41 force_a2hr f_a2hs ws_a2ht xs_a2hu [] zs_a2hv = []
lift41 force_a2hw f_a2hx ws_a2hy xs_a2hz ys_a2hA [] = []
lift41 force_a2hB f_a2hC (w_a2hD : ws_a2hE) (x_a2hF : xs_a2hG)
  (y_a2hH : ys_a2hI) (z_a2hJ : zs_a2hK)
  = headstrict force_a2hB
      (f_a2hC w_a2hD x_a2hF y_a2hH z_a2hJ :
         lift41 force_a2hB f_a2hC ws_a2hE xs_a2hG ys_a2hI zs_a2hK)
lift22 force1_a2hL force2_a2hM f_a2hN [] ys_a2hO = ([], [])
lift22 force1_a2hP force2_a2hQ f_a2hR xs_a2hS [] = ([], [])
lift22 force1_a2hT force2_a2hU f_a2hV (x_a2hW : xs_a2hX)
  (y_a2hY : ys_a2hZ)
  = pairstrict force1_a2hT force2_a2hU
      (a_a2i0 : as_a2i2, b_a2i1 : bs_a2i3)
  where (a_a2i0, b_a2i1) = f_a2hV x_a2hW y_a2hY
        (as_a2i2, bs_a2i3)
          = lift22 force1_a2hT force2_a2hU f_a2hV xs_a2hX ys_a2hZ

word11 :: Int -> (a_aAz -> b_aAA) -> [a_aAz] -> [b_aAA]
word11 0 f_a2i4 as_a2i5 = []
word11 k_a2i6 f_a2i7 as_a2i8
  = f_a2i7 (head as_a2i8) : word11 (k_a2i6 - 1) f_a2i7 (tail as_a2i8)

word21 ::
       Int -> (a_aAw -> b_aAx -> c_aAy) -> [a_aAw] -> [b_aAx] -> [c_aAy]
word21 0 f_a2i9 as_a2ia bs_a2ib = []
word21 k_a2ic f_a2id as_a2ie bs_a2if
  = f_a2id (head as_a2ie) (head bs_a2if) :
      word21 (k_a2ic - 1) f_a2id (tail as_a2ie) (tail bs_a2if)

word31 ::
       Int ->
         (a_aAs -> b_aAt -> c_aAu -> d_aAv) ->
           [a_aAs] -> [b_aAt] -> [c_aAu] -> [d_aAv]
word31 0 f_a2ig as_a2ih bs_a2ii cs_a2ij = []
word31 k_a2ik f_a2il as_a2im bs_a2in cs_a2io
  = f_a2il (head as_a2im) (head bs_a2in) (head cs_a2io) :
      word31 (k_a2ik - 1) f_a2il (tail as_a2im) (tail bs_a2in)
        (tail cs_a2io)

word12 ::
       Int -> (a_aAp -> (b_aAq, c_aAr)) -> [a_aAp] -> ([b_aAq], [c_aAr])
word12 0 f_a2ip as_a2iq = ([], [])
word12 k_a2ir f_a2is as_a2it = (b_a2iu : bs_a2iw, c_a2iv : cs_a2ix)
  where (b_a2iu, c_a2iv) = f_a2is (head as_a2it)
        (bs_a2iw, cs_a2ix) = word12 (k_a2ir - 1) f_a2is (tail as_a2it)

word22 ::
       Int ->
         (a_aAl -> b_aAm -> (c_aAn, d_aAo)) ->
           [a_aAl] -> [b_aAm] -> ([c_aAn], [d_aAo])
word22 0 f_a2iy as_a2iz bs_a2iA = ([], [])
word22 k_a2iB f_a2iC as_a2iD bs_a2iE
  = (c_a2iF : cs_a2iH, d_a2iG : ds_a2iI)
  where (c_a2iF, d_a2iG) = f_a2iC (head as_a2iD) (head bs_a2iE)
        (cs_a2iH, ds_a2iI)
          = word22 (k_a2iB - 1) f_a2iC (tail as_a2iD) (tail bs_a2iE)

shoInt :: Int -> String
shoInt n_a2iJ = show n_a2iJ

trans :: [[a_aAk]] -> [[a_aAk]]
trans xs_a2iK
  = if or (map null xs_a2iK) then [] else
      map head xs_a2iK : trans (map tail xs_a2iK)
ntrans 0 xs_a2iL = []
ntrans i_a2iM xs_a2iN
  = map head xs_a2iN : ntrans (i_a2iM - 1) (map tail xs_a2iN)

dec :: Int -> Int -> String
dec k_a2iO n_a2iP
  = if i_a2iR < k_a2iO then (rept (k_a2iO - i_a2iR) ' ') ++ xs_a2iQ
      else xs_a2iQ
  where xs_a2iQ = show n_a2iP
        i_a2iR = length xs_a2iQ

ibits :: Int -> Int -> [Int]
ibits n_a2iS i_a2iT = reverse (f_ibits_a2iU n_a2iS i_a2iT)
  where f_ibits_a2iU 0 i_a2iV = []
        f_ibits_a2iU n_a2iW i_a2iX
          = i_a2iX `mod` 2 : f_ibits_a2iU (n_a2iW - 1) (i_a2iX `div` 2)

bitsi :: [Int] -> Int
bitsi = f_bitsi_a2iY 0
  where f_bitsi_a2iY i_a2iZ [] = i_a2iZ
        f_bitsi_a2iY i_a2j0 (b_a2j1 : bs_a2j2)
          = f_bitsi_a2iY (2 * i_a2j0 + b_a2j1) bs_a2j2

intrep :: [B] -> [Int]
intrep bs_a2j3 = map bitsi (trans bs_a2j3)

bitrep :: Int -> [Int] -> [B]
bitrep n_a2j4 = ntrans n_a2j4 . map (ibits n_a2j4)

rept :: Int -> a_aAj -> [a_aAj]
rept 0 x_a2j5 = []
rept i_a2j6 x_a2j7 = x_a2j7 : rept (i_a2j6 - 1) x_a2j7
mksepline c_a2j8 = "\n" ++ rept 79 c_a2j8 ++ "\n"
sepline = mksepline '-'
bigsepline = mksepline '='

format :: Int -> [[[a_aAi]]] -> [a_aAi]
format limit_a2j9 = concat . take limit_a2j9 . map concat . trans
fmtW i_a2ja xs_a2jb = fmtDec i_a2ja (intrep xs_a2jb)

fmtDec :: Int -> [Int] -> [String]
fmtDec w_a2jc = map (dec w_a2jc)

fmtB :: B -> [String]
fmtB = map (dec 1)

fmtInt :: Int -> [Int] -> [String]
fmtInt i_a2jd = map (dec i_a2jd)

fmtFld :: (Int -> Bit -> String) -> Int -> [B] -> [String]
fmtFld f_a2je i_a2jf xs_a2jg = map (f_a2je i_a2jf) (intrep xs_a2jg)

fmtList :: (a_aAh -> String) -> [[a_aAh]] -> [String]
fmtList f_a2jh xs_a2ji = map (g_a2jj . concat . map f_a2jh) xs_a2ji
  where g_a2jj cs_a2jk = cs_a2jk ++ "  "

fmtStr :: String -> [String]
fmtStr s_a2jl = s_a2jl : fmtStr s_a2jl

when :: B -> W -> [Int]
when (0 : xs_a2jm) w_a2jn = when xs_a2jm (map tail w_a2jn)
when (1 : xs_a2jo) w_a2jp = map head w_a2jp

type Bit = Int

type B = [Bit]

type W = [B]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.retURN :: a_aAk -> Dum.SM s_aAl a_aAk
Dum.retURN (!x_aAm) = \ (!s_aAn) -> (s_aAn, x_aAm)
Dum.bind ::
  Dum.SM s_aAh a_aAi
  -> (a_aAi -> Dum.SM s_aAh b_aAj) -> Dum.SM s_aAh b_aAj
Dum.bind m_aAo f_aAp
  = \ (!s_aAq)
      -> let (s'_aAr, a_aAs) = m_aAo s_aAq in f_aAp a_aAs s'_aAr
Dum.join :: Dum.SM s_aAf (Dum.SM s_aAf a_aAg) -> Dum.SM s_aAf a_aAg
Dum.join m_aAt
  = \ s_aAu -> let (!(s'_aAv, ma_aAw)) = m_aAt s_aAu in ma_aAw s'_aAv
Dum.mmap ::
  (a_aAc -> b_aAd) -> (Dum.SM s_aAe a_aAc -> Dum.SM s_aAe b_aAd)
Dum.mmap f_aAx (!m_aAy)
  = \ s_aAz
      -> let (s'_aAA, (!a_aAB)) = m_aAy s_aAz in (s'_aAA, f_aAx a_aAB)
Dum.mmapl ::
  (a_aA9 -> Dum.SM s_aAa b_aAb) -> ([a_aA9] -> Dum.SM s_aAa [b_aAb])
Dum.mmapl f_aAC (![]) = Dum.retURN []
Dum.mmapl f_aAD ((!(a_aAE : (!as_aAF))))
  = f_aAD a_aAE
    `Dum.bind`
      \ (!b_aAG)
        -> Dum.mmapl f_aAD as_aAF
           `Dum.bind` \ bs_aAH -> Dum.retURN (b_aAG : bs_aAH)
Dum.mmapr ::
  (a_aA6 -> Dum.SM s_aA7 b_aA8) -> ([a_aA6] -> Dum.SM s_aA7 [b_aA8])
Dum.mmapr f_aAI (![]) = Dum.retURN []
Dum.mmapr (!f_aAJ) ((!x_aAK) : (!xs_aAL))
  = Dum.mmapr f_aAJ xs_aAL
    `Dum.bind`
      \ (!ys_aAM)
        -> f_aAJ x_aAK `Dum.bind` \ (!y_aAN) -> Dum.retURN (y_aAN : ys_aAM)
Dum.mfoldl ::
  (a_aA3 -> b_aA4 -> Dum.SM s_aA5 a_aA3)
  -> a_aA3 -> [b_aA4] -> Dum.SM s_aA5 a_aA3
Dum.mfoldl (!f_aAO) a_aAP [] = Dum.retURN a_aAP
Dum.mfoldl (!f_aAQ) (!a_aAR) ((!((!x_aAS) : xs_aAT)))
  = f_aAQ a_aAR x_aAS
    `Dum.bind` \ fax_aAU -> Dum.mfoldl f_aAQ fax_aAU xs_aAT
Dum.mfoldr ::
  (a_aA0 -> b_aA1 -> Dum.SM s_aA2 b_aA1)
  -> b_aA1 -> [a_aA0] -> Dum.SM s_aA2 b_aA1
Dum.mfoldr f_aAV a_aAW (![]) = Dum.retURN a_aAW
Dum.mfoldr f_aAX a_aAY (!((!(x_aAZ : (!xs_aB0)))))
  = Dum.mfoldr f_aAX a_aAY xs_aB0
    `Dum.bind` \ (!y_aB1) -> f_aAX x_aAZ y_aB1
Dum.mif ::
  Dum.SM s_azY Bool
  -> Dum.SM s_azY a_azZ -> Dum.SM s_azY a_azZ -> Dum.SM s_azY a_azZ
Dum.mif c_aB2 t_aB3 f_aB4
  = c_aB2 `Dum.bind` \ cond_aB5 -> if cond_aB5 then t_aB3 else f_aB4
Dum.startingWith :: Dum.SM s_azW a_azX -> s_azW -> a_azX
Dum.startingWith (!m_aB6) (!v_aB7)
  = answer_aB9
  where
      ((!final_aB8), answer_aB9) = m_aB6 v_aB7
Dum.fetch :: Dum.SM s_azV s_azV
Dum.fetch = \ s_aBa -> (s_aBa, s_aBa)
Dum.fetchWith :: (s_azT -> a_azU) -> Dum.SM s_azT a_azU
Dum.fetchWith (!f_aBb) = \ s_aBc -> (s_aBc, f_aBb s_aBc)
Dum.update :: (s_azS -> s_azS) -> Dum.SM s_azS s_azS
Dum.update (!f_aBd) = \ s_aBe -> (f_aBd s_aBe, s_aBe)
Dum.set :: s_azR -> Dum.SM s_azR s_azR
Dum.set s'_aBf = \ s_aBg -> (s'_aBf, s_aBg)
Dum.incr :: Dum.SM Int Int
Dum.incr = Dum.update (1 +)

type Dum.SM s_asL a_asM = s_asL -> (s_asL, a_asM)


["x_aAm","safebang@!x_aAm","(!x_aAm)","s_aAn","!s_aAn","(!s_aAn)","m_aAo","f_aAp","s_aAq","safebang@!s_aAq","(!s_aAq)","s'_aAr","a_aAs","(s'_aAr, a_aAs)","m_aAt","s_aAu","s'_aAv","ma_aAw","(s'_aAv, ma_aAw)","!(s'_aAv, ma_aAw)","(!(s'_aAv, ma_aAw))","f_aAx","m_aAy","safebang@!m_aAy","(!m_aAy)","s_aAz","s'_aAA","a_aAB","!a_aAB","(!a_aAB)","(s'_aAA, (!a_aAB))","f_aAC","[]","![]","(![])","f_aAD","a_aAE","as_aAF","safebang@!as_aAF","(!as_aAF)","a_aAE : (!as_aAF)","(a_aAE : (!as_aAF))","!(a_aAE : (!as_aAF))","(!(a_aAE : (!as_aAF)))","((!(a_aAE : (!as_aAF))))","b_aAG","!b_aAG","(!b_aAG)","bs_aAH","f_aAI","[]","![]","(![])","f_aAJ","!f_aAJ","(!f_aAJ)","x_aAK","!x_aAK","(!x_aAK)","xs_aAL","!xs_aAL","(!xs_aAL)","(!x_aAK) : (!xs_aAL)","((!x_aAK) : (!xs_aAL))","ys_aAM","!ys_aAM","(!ys_aAM)","y_aAN","!y_aAN","(!y_aAN)","f_aAO","safebang@!f_aAO","(!f_aAO)","a_aAP","[]","f_aAQ","!f_aAQ","(!f_aAQ)","a_aAR","!a_aAR","(!a_aAR)","x_aAS","!x_aAS","(!x_aAS)","xs_aAT","(!x_aAS) : xs_aAT","((!x_aAS) : xs_aAT)","!((!x_aAS) : xs_aAT)","(!((!x_aAS) : xs_aAT))","((!((!x_aAS) : xs_aAT)))","fax_aAU","f_aAV","a_aAW","[]","![]","(![])","f_aAX","a_aAY","x_aAZ","xs_aB0","!xs_aB0","(!xs_aB0)","x_aAZ : (!xs_aB0)","(x_aAZ : (!xs_aB0))","!(x_aAZ : (!xs_aB0))","(!(x_aAZ : (!xs_aB0)))","((!(x_aAZ : (!xs_aB0))))","!((!(x_aAZ : (!xs_aB0))))","(!((!(x_aAZ : (!xs_aB0)))))","y_aB1","!y_aB1","(!y_aB1)","c_aB2","t_aB3","f_aB4","cond_aB5","m_aB6","safebang@!m_aB6","(!m_aB6)","v_aB7","safebang@!v_aB7","(!v_aB7)","final_aB8","!final_aB8","(!final_aB8)","answer_aB9","((!final_aB8), answer_aB9)","fetch","s_aBa","f_aBb","safebang@!f_aBb","(!f_aBb)","s_aBc","f_aBd","safebang@!f_aBd","(!f_aBd)","s_aBe","s'_aBf","s_aBg","incr"]
{-# LANGUAGE BangPatterns #-}
module Dum where

retURN :: a_aAk -> SM s_aAl a_aAk
retURN (!x_aAm) = \ (investigate@s_aAn) -> (s_aAn, x_aAm)

bind ::
     SM s_aAh a_aAi -> (a_aAi -> SM s_aAh b_aAj) -> SM s_aAh b_aAj
bind m_aAo f_aAp
  = \ (!s_aAq) ->
      let (s'_aAr, a_aAs) = m_aAo s_aAq in f_aAp a_aAs s'_aAr

join :: SM s_aAf (SM s_aAf a_aAg) -> SM s_aAf a_aAg
join m_aAt
  = \ s_aAu ->
      let (investigate@(s'_aAv, ma_aAw)) = m_aAt s_aAu in ma_aAw s'_aAv

mmap :: (a_aAc -> b_aAd) -> (SM s_aAe a_aAc -> SM s_aAe b_aAd)
mmap f_aAx (!m_aAy)
  = \ s_aAz ->
      let (s'_aAA, (investigate@a_aAB)) = m_aAy s_aAz in
        (s'_aAA, f_aAx a_aAB)

mmapl :: (a_aA9 -> SM s_aAa b_aAb) -> ([a_aA9] -> SM s_aAa [b_aAb])
mmapl f_aAC (investigate@[]) = retURN []
mmapl f_aAD ((investigate@(a_aAE : (!as_aAF))))
  = f_aAD a_aAE `bind`
      \ (investigate@b_aAG) ->
        mmapl f_aAD as_aAF `bind` \ bs_aAH -> retURN (b_aAG : bs_aAH)

mmapr :: (a_aA6 -> SM s_aA7 b_aA8) -> ([a_aA6] -> SM s_aA7 [b_aA8])
mmapr f_aAI (investigate@[]) = retURN []
mmapr (investigate@f_aAJ)
  ((investigate@x_aAK) : (investigate@xs_aAL))
  = mmapr f_aAJ xs_aAL `bind`
      \ (investigate@ys_aAM) ->
        f_aAJ x_aAK `bind` \ (investigate@y_aAN) -> retURN (y_aAN : ys_aAM)

mfoldl ::
       (a_aA3 -> b_aA4 -> SM s_aA5 a_aA3) ->
         a_aA3 -> [b_aA4] -> SM s_aA5 a_aA3
mfoldl (!f_aAO) a_aAP [] = retURN a_aAP
mfoldl (investigate@f_aAQ) (investigate@a_aAR)
  ((investigate@((investigate@x_aAS) : xs_aAT)))
  = f_aAQ a_aAR x_aAS `bind` \ fax_aAU -> mfoldl f_aAQ fax_aAU xs_aAT

mfoldr ::
       (a_aA0 -> b_aA1 -> SM s_aA2 b_aA1) ->
         b_aA1 -> [a_aA0] -> SM s_aA2 b_aA1
mfoldr f_aAV a_aAW (investigate@[]) = retURN a_aAW
mfoldr f_aAX a_aAY
  (investigate@((investigate@(x_aAZ : (investigate@xs_aB0)))))
  = mfoldr f_aAX a_aAY xs_aB0 `bind`
      \ (investigate@y_aB1) -> f_aAX x_aAZ y_aB1

mif ::
    SM s_azY Bool -> SM s_azY a_azZ -> SM s_azY a_azZ -> SM s_azY a_azZ
mif c_aB2 t_aB3 f_aB4
  = c_aB2 `bind` \ cond_aB5 -> if cond_aB5 then t_aB3 else f_aB4

startingWith :: SM s_azW a_azX -> s_azW -> a_azX
startingWith (!m_aB6) (!v_aB7) = answer_aB9
  where ((investigate@final_aB8), answer_aB9) = m_aB6 v_aB7

fetch :: SM s_azV s_azV
fetch = \ s_aBa -> (s_aBa, s_aBa)

fetchWith :: (s_azT -> a_azU) -> SM s_azT a_azU
fetchWith (!f_aBb) = \ s_aBc -> (s_aBc, f_aBb s_aBc)

update :: (s_azS -> s_azS) -> SM s_azS s_azS
update (!f_aBd) = \ s_aBe -> (f_aBd s_aBe, s_aBe)

set :: s_azR -> SM s_azR s_azR
set s'_aBf = \ s_aBg -> (s'_aBf, s_aBg)

incr :: SM Int Int
incr = update (1 +)

type SM s_asL a_asM = s_asL -> (s_asL, a_asM)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.trim :: String -> String
Dum.trim
  = foldr cons_a1v0 "" . dropWhile (`elem` punct_a1v1)
  where
      cons_a1v0 (!x_a1v2) (!xs_a1v3)
        | x_a1v2 `elem` punct_a1v1 && null xs_a1v3 = []
        | otherwise = x_a1v2 : xs_a1v3
      (!punct_a1v1) = [' ', '.', '!', '?', ',']
Dum.session :: Dum.State -> Dum.Words -> [Dum.Words] -> String
Dum.session rs_a1RB (!prev_a1RC) (![]) = []
Dum.session (!rs_a1RD) (!prev_a1RE) (!((!(l_a1RF : ls_a1RG))))
  = response_a1RH
    ++
      "\n\
      \\n"
      ++ Dum.session rs'_a1RI l_a1RF ls_a1RG
  where
      (!(response_a1RH, (!rs'_a1RI)))
        | prev_a1RE == l_a1RF = Dum.repeated rs_a1RD
        | otherwise = Dum.answer rs_a1RD l_a1RF
Dum.answer :: Dum.State -> Dum.Words -> (String, Dum.State)
Dum.answer st_a1RJ (!l_a1RK)
  = (response_a1RL, Dum.newKeyTab kt_a1RM st_a1RJ)
  where
      (!((!response_a1RL), (!kt_a1RM))) = ans_a1RO (Dum.keyTabOf st_a1RJ)
      cons_a1RN e_a1RP (!(r_a1RQ, (!es_a1RR)))
        = (r_a1RQ, e_a1RP : es_a1RR)
      ans_a1RO ((!e_a1RS) : (!es_a1RT))
        | null rs_a1RU = e_a1RS `cons_a1RN` ans_a1RO es_a1RT
        | otherwise
        = (Dum.makeResponse a_a1RW (head rs_a1RU), 
           (key_a1RV, as_a1RX) : es_a1RT)
        where
            rs_a1RU = Dum.replies key_a1RV l_a1RK
            (!(key_a1RV, (!(a_a1RW : as_a1RX)))) = e_a1RS
Dum.replies :: Dum.Words -> Dum.Words -> [String]
Dum.replies (!key_a1RY) l_a1RZ
  = (map (Dum.conjug l_a1RZ . drop (length key_a1RY))
     . filter (Dum.prefix key_a1RY . map Dum.ucase) . Dum.tails)
      l_a1RZ
Dum.prefix :: Eq a_asc => [a_asc] -> [a_asc] -> Bool
Dum.prefix [] (!xs_a1S0) = True
Dum.prefix (!(x_a1S1 : xs_a1S2)) [] = False
Dum.prefix ((!((!x_a1S3) : xs_a1S4))) (!((!(y_a1S5 : ys_a1S6))))
  = x_a1S3 == y_a1S5 && (xs_a1S4 `Dum.prefix` ys_a1S6)
Dum.tails :: [a_asb] -> [[a_asb]]
Dum.tails (![]) = []
Dum.tails (!xs_a1S7) = xs_a1S7 : Dum.tails (tail xs_a1S7)
Dum.ucase :: String -> String
Dum.ucase = map toUpper
Dum.conjug :: Dum.Words -> Dum.Words -> String
Dum.conjug (!d_a1WG)
  = unwords . trailingI_a1WJ . map conj_a1WI . maybe_a1WH d_a1WG
  where
      maybe_a1WH d_a1WK xs_a1WL
        = if null xs_a1WL then d_a1WK else xs_a1WL
      conj_a1WI w_a1WM
        = head
            ([m_a1WP |
                (!((!w'_a1WO), (!m_a1WP))) <- Dum.conjugates, uw_a1WN == w'_a1WO]
             ++ [w_a1WM])
        where
            (!uw_a1WN) = Dum.ucase w_a1WM
      (!trailingI_a1WJ)
        = foldr cons_a1WQ []
        where
            cons_a1WQ (!x_a1WR) xs_a1WS
              | x_a1WR == "I" && null xs_a1WS = ["me"]
              | otherwise = x_a1WR : xs_a1WS
Dum.conjugates :: [(Dum.Word, Dum.Word)]
Dum.conjugates
  = prepare_a20d
      (oneways_a20b
       ++
         concat
           [[(x_a20g, y_a20h), (y_a20h, x_a20g)] |
              (x_a20g, y_a20h) <- bothways_a20c])
  where
      oneways_a20b = [("me", "you")]
      bothways_a20c
        = [("are", "am"), ("we're", "was"), ("you", "I"), ("your", "my"),
           ("I've", "you've"), ("I'm", "you're")]
      (!prepare_a20d)
        = map (\ (!(w_a20e, r_a20f)) -> (Dum.ucase w_a20e, r_a20f))
Dum.repeated :: Dum.State -> (String, Dum.State)
Dum.repeated (!((!kt_a20i), ((!r_a20j) : (!rp_a20k))))
  = (r_a20j, (kt_a20i, rp_a20k))
Dum.newKeyTab :: Dum.KeyTable -> Dum.State -> Dum.State
Dum.newKeyTab kt'_a20l ((!kt_a20m), rp_a20n) = (kt'_a20l, rp_a20n)
Dum.keyTabOf :: Dum.State -> Dum.KeyTable
Dum.keyTabOf ((!kt_a20o), rp_a20p) = kt_a20o
Dum.makeResponse :: String -> String -> String
Dum.makeResponse ((!('?' : (!cs_a20q)))) (!us_a20r)
  = cs_a20q ++ " " ++ us_a20r ++ "?"
Dum.makeResponse ('.' : (!cs_a20s)) us_a20t
  = cs_a20s ++ " " ++ us_a20t ++ "."
Dum.makeResponse (!cs_a20u) us_a20v = cs_a20u
Dum.initial :: Dum.State
Dum.initial
  = ([(words k_a20w, cycle rs_a20x) |
        (k_a20w, rs_a20x) <- Dum.respMsgs], 
     cycle Dum.repeatMsgs)
Dum.repeatMsgs
  = ["Why did you repeat yourself?",
     "Do you expect a different answer by repeating yourself?",
     "Come, come, elucidate your thoughts.",
     "Please don't repeat yourself!"]
Dum.respMsgs
  = [("CAN YOU", canYou_a20y), ("CAN I", canI_a20z),
     ("YOU ARE", youAre_a20A), ("YOU'RE", youAre_a20A),
     ("I DON'T", iDont_a20B), ("I FEEL", iFeel_a20C),
     ("WHY DON'T YOU", whyDont_a20D), ("WHY CAN'T I", whyCant_a20E),
     ("ARE YOU", areYou_a20F), ("I CAN'T", iCant_a20G),
     ("I AM", iAm_a20H), ("I'M", iAm_a20H), ("YOU", you_a20I),
     ("YES", yes_a20J), ("NO", no_a20K), ("COMPUTER", computer_a20L),
     ("COMPUTERS", computer_a20L), ("I WANT", iWant_a20M),
     ("WHAT", question_a20N), ("HOW", question_a20N),
     ("WHO", question_a20N), ("WHERE", question_a20N),
     ("WHEN", question_a20N), ("WHY", question_a20N),
     ("NAME", name_a20O), ("BECAUSE", because_a20P),
     ("CAUSE", because_a20P), ("SORRY", sorry_a20Q),
     ("DREAM", dream_a20R), ("DREAMS", dream_a20R), ("HI", hello_a20S),
     ("HELLO", hello_a20S), ("MAYBE", maybe_a20T), ("YOUR", your_a20U),
     ("ALWAYS", always_a20V), ("THINK", think_a20W),
     ("ALIKE", alike_a20X), ("FRIEND", friend_a20Y),
     ("FRIENDS", friend_a20Y), ("", nokeyMsgs_a20Z)]
  where
      canYou_a20y
        = ["?Don't you believe that I can",
           "?Perhaps you would like to be able to",
           "?You want me to be able to"]
      (!canI_a20z)
        = ["?Perhaps you don't want to", "?Do you want to be able to"]
      (!youAre_a20A)
        = ["?What makes you think I am",
           "?Does it please you to believe I am",
           "?Perhaps you would like to be", "?Do you sometimes wish you were"]
      iDont_a20B
        = ["?Don't you really", "?Why don't you",
           "?Do you wish to be able to", "Does that trouble you?"]
      iFeel_a20C
        = ["Tell me more about such feelings.", "?Do you often feel",
           "?Do you enjoy feeling"]
      (!whyDont_a20D)
        = ["?Do you really believe I don't",
           ".Perhaps in good time I will", "?Do you want me to"]
      (!whyCant_a20E)
        = ["?Do you think you should be able to", "?Why can't you"]
      areYou_a20F
        = ["?Why are you interested in whether or not I am",
           "?Would you prefer if I were not",
           "?Perhaps in your fantasies I am"]
      (!iCant_a20G)
        = ["?How do you know you can't", "Have you tried?",
           "?Perhaps you can now"]
      iAm_a20H
        = ["?Did you come to me because you are",
           "?How long have you been", "?Do you believe it is normal to be",
           "?Do you enjoy being"]
      (!you_a20I)
        = ["We were discussing you --not me.", "?Oh,",
           "You're not really talking about me, are you?"]
      yes_a20J
        = ["You seem quite positive.", "Are you Sure?", "I see.",
           "I understand."]
      (!no_a20K)
        = ["Are you saying no just to be negative?",
           "You are being a bit negative.", "Why not?", "Are you sure?",
           "Why no?"]
      computer_a20L
        = ["Do computers worry you?",
           "Are you talking about me in particular?",
           "Are you frightened by machines?", "Why do you mention computers?",
           "What do you think machines have to do with your problems?",
           "Don't you think computers can help people?",
           "What is it about machines that worries you?"]
      (!iWant_a20M)
        = ["?Why do you want", "?What would it mean to you if you got",
           "?Suppose you got", "?What if you never got",
           ".I sometimes also want"]
      (!question_a20N)
        = ["Why do you ask?", "Does that question interest you?",
           "What answer would please you the most?", "What do you think?",
           "Are such questions on your mind often?",
           "What is it that you really want to know?",
           "Have you asked anyone else?",
           "Have you asked such questions before?",
           "What else comes to mind when you ask that?"]
      (!name_a20O)
        = ["Names don't interest me.",
           "I don't care about names --please go on."]
      because_a20P
        = ["Is that the real reason?",
           "Don't any other reasons come to mind?",
           "Does that reason explain anything else?",
           "What other reasons might there be?"]
      sorry_a20Q
        = ["Please don't apologise!", "Apologies are not necessary.",
           "What feelings do you have when you apologise?",
           "Don't be so defensive!"]
      dream_a20R
        = ["What does that dream suggest to you?", "Do you dream often?",
           "What persons appear in your dreams?",
           "Are you disturbed by your dreams?"]
      hello_a20S = ["How do you...please state your problem."]
      maybe_a20T
        = ["You don't seem quite certain.", "Why the uncertain tone?",
           "Can't you be more positive?", "You aren't sure?",
           "Don't you know?"]
      your_a20U
        = ["?Why are you concerned about my", "?What about your own"]
      always_a20V
        = ["Can you think of a specific example?", "When?",
           "What are you thinking of?", "Really, always?"]
      (!think_a20W)
        = ["Do you really think so?", "?But you are not sure you",
           "?Do you doubt you"]
      (!alike_a20X)
        = ["In what way?", "What resemblence do you see?",
           "What does the similarity suggest to you?",
           "What other connections do you see?",
           "Cound there really be some connection?", "How?"]
      (!friend_a20Y)
        = ["Why do you bring up the topic of friends?",
           "Do your friends worry you?", "Do your friends pick on you?",
           "Are you sure you have any friends?",
           "Do you impose on your friends?",
           "Perhaps your love for friends worries you."]
      nokeyMsgs_a20Z
        = ["I'm not sure I understand you fully.",
           "What does that suggest to you?", "I see.",
           "Can you elaborate on that?",
           "Say, do you have any psychological problems?"]

type Dum.Word = String
type Dum.Words = [Dum.Word]
type Dum.Replies = [String]
type Dum.Key = Dum.Words
type Dum.KeyTable = [(Dum.Key, Dum.Replies)]
type Dum.State = (Dum.KeyTable, Dum.Replies)


["trim","x_a1v2","!x_a1v2","(!x_a1v2)","xs_a1v3","!xs_a1v3","(!xs_a1v3)","punct_a1v1","!punct_a1v1","(!punct_a1v1)","rs_a1RB","prev_a1RC","safebang@!prev_a1RC","(!prev_a1RC)","[]","![]","(![])","rs_a1RD","!rs_a1RD","(!rs_a1RD)","prev_a1RE","!prev_a1RE","(!prev_a1RE)","l_a1RF","ls_a1RG","l_a1RF : ls_a1RG","(l_a1RF : ls_a1RG)","!(l_a1RF : ls_a1RG)","(!(l_a1RF : ls_a1RG))","((!(l_a1RF : ls_a1RG)))","!((!(l_a1RF : ls_a1RG)))","(!((!(l_a1RF : ls_a1RG))))","response_a1RH","rs'_a1RI","!rs'_a1RI","(!rs'_a1RI)","(response_a1RH, (!rs'_a1RI))","!(response_a1RH, (!rs'_a1RI))","(!(response_a1RH, (!rs'_a1RI)))","st_a1RJ","l_a1RK","safebang@!l_a1RK","(!l_a1RK)","response_a1RL","!response_a1RL","(!response_a1RL)","kt_a1RM","!kt_a1RM","(!kt_a1RM)","((!response_a1RL), (!kt_a1RM))","!((!response_a1RL), (!kt_a1RM))","(!((!response_a1RL), (!kt_a1RM)))","e_a1RP","r_a1RQ","es_a1RR","safebang@!es_a1RR","(!es_a1RR)","(r_a1RQ, (!es_a1RR))","!(r_a1RQ, (!es_a1RR))","(!(r_a1RQ, (!es_a1RR)))","e_a1RS","!e_a1RS","(!e_a1RS)","es_a1RT","safebang@!es_a1RT","(!es_a1RT)","(!e_a1RS) : (!es_a1RT)","((!e_a1RS) : (!es_a1RT))","rs_a1RU","key_a1RV","a_a1RW","as_a1RX","a_a1RW : as_a1RX","(a_a1RW : as_a1RX)","!(a_a1RW : as_a1RX)","(!(a_a1RW : as_a1RX))","(key_a1RV, (!(a_a1RW : as_a1RX)))","!(key_a1RV, (!(a_a1RW : as_a1RX)))","(!(key_a1RV, (!(a_a1RW : as_a1RX))))","key_a1RY","safebang@!key_a1RY","(!key_a1RY)","l_a1RZ","[]","xs_a1S0","safebang@!xs_a1S0","(!xs_a1S0)","x_a1S1","xs_a1S2","x_a1S1 : xs_a1S2","(x_a1S1 : xs_a1S2)","!(x_a1S1 : xs_a1S2)","(!(x_a1S1 : xs_a1S2))","[]","x_a1S3","!x_a1S3","(!x_a1S3)","xs_a1S4","(!x_a1S3) : xs_a1S4","((!x_a1S3) : xs_a1S4)","!((!x_a1S3) : xs_a1S4)","(!((!x_a1S3) : xs_a1S4))","((!((!x_a1S3) : xs_a1S4)))","y_a1S5","ys_a1S6","y_a1S5 : ys_a1S6","(y_a1S5 : ys_a1S6)","!(y_a1S5 : ys_a1S6)","(!(y_a1S5 : ys_a1S6))","((!(y_a1S5 : ys_a1S6)))","!((!(y_a1S5 : ys_a1S6)))","(!((!(y_a1S5 : ys_a1S6))))","[]","![]","(![])","xs_a1S7","!xs_a1S7","(!xs_a1S7)","ucase","d_a1WG","safebang@!d_a1WG","(!d_a1WG)","d_a1WK","xs_a1WL","w_a1WM","w'_a1WO","safebang@!w'_a1WO","(!w'_a1WO)","m_a1WP","safebang@!m_a1WP","(!m_a1WP)","((!w'_a1WO), (!m_a1WP))","!((!w'_a1WO), (!m_a1WP))","(!((!w'_a1WO), (!m_a1WP)))","uw_a1WN","!uw_a1WN","(!uw_a1WN)","trailingI_a1WJ","!trailingI_a1WJ","(!trailingI_a1WJ)","x_a1WR","!x_a1WR","(!x_a1WR)","xs_a1WS","conjugates","x_a20g","y_a20h","(x_a20g, y_a20h)","oneways_a20b","bothways_a20c","prepare_a20d","!prepare_a20d","(!prepare_a20d)","w_a20e","r_a20f","(w_a20e, r_a20f)","!(w_a20e, r_a20f)","(!(w_a20e, r_a20f))","kt_a20i","safebang@!kt_a20i","(!kt_a20i)","r_a20j","safebang@!r_a20j","(!r_a20j)","rp_a20k","safebang@!rp_a20k","(!rp_a20k)","(!r_a20j) : (!rp_a20k)","((!r_a20j) : (!rp_a20k))","((!kt_a20i), ((!r_a20j) : (!rp_a20k)))","!((!kt_a20i), ((!r_a20j) : (!rp_a20k)))","(!((!kt_a20i), ((!r_a20j) : (!rp_a20k))))","kt'_a20l","kt_a20m","safebang@!kt_a20m","(!kt_a20m)","rp_a20n","((!kt_a20m), rp_a20n)","kt_a20o","safebang@!kt_a20o","(!kt_a20o)","rp_a20p","((!kt_a20o), rp_a20p)","'?'","cs_a20q","!cs_a20q","(!cs_a20q)","'?' : (!cs_a20q)","('?' : (!cs_a20q))","!('?' : (!cs_a20q))","(!('?' : (!cs_a20q)))","((!('?' : (!cs_a20q))))","us_a20r","investigate@!us_a20r","(!us_a20r)","'.'","cs_a20s","!cs_a20s","(!cs_a20s)","'.' : (!cs_a20s)","('.' : (!cs_a20s))","us_a20t","cs_a20u","!cs_a20u","(!cs_a20u)","us_a20v","initial","k_a20w","rs_a20x","(k_a20w, rs_a20x)","repeatMsgs","respMsgs","canYou_a20y","canI_a20z","!canI_a20z","(!canI_a20z)","youAre_a20A","!youAre_a20A","(!youAre_a20A)","iDont_a20B","iFeel_a20C","whyDont_a20D","!whyDont_a20D","(!whyDont_a20D)","whyCant_a20E","!whyCant_a20E","(!whyCant_a20E)","areYou_a20F","iCant_a20G","!iCant_a20G","(!iCant_a20G)","iAm_a20H","you_a20I","!you_a20I","(!you_a20I)","yes_a20J","no_a20K","!no_a20K","(!no_a20K)","computer_a20L","iWant_a20M","!iWant_a20M","(!iWant_a20M)","question_a20N","!question_a20N","(!question_a20N)","name_a20O","!name_a20O","(!name_a20O)","because_a20P","sorry_a20Q","dream_a20R","hello_a20S","maybe_a20T","your_a20U","always_a20V","think_a20W","!think_a20W","(!think_a20W)","alike_a20X","!alike_a20X","(!alike_a20X)","friend_a20Y","!friend_a20Y","(!friend_a20Y)","nokeyMsgs_a20Z"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Char
import Prelude hiding (Word)

trim :: String -> String
trim = foldr cons_a1v0 "" . dropWhile (`elem` punct_a1v1)
  where cons_a1v0 (investigate@x_a1v2) (investigate@xs_a1v3)
          | x_a1v2 `elem` punct_a1v1 && null xs_a1v3 = []
          | otherwise = x_a1v2 : xs_a1v3
        (investigate@punct_a1v1) = [' ', '.', '!', '?', ',']

session :: State -> Words -> [Words] -> String
session rs_a1RB (!prev_a1RC) (investigate@[]) = []
session (investigate@rs_a1RD) (investigate@prev_a1RE)
  (investigate@((investigate@(l_a1RF : ls_a1RG))))
  = response_a1RH ++ "\n\n" ++ session rs'_a1RI l_a1RF ls_a1RG
  where (investigate@(response_a1RH, (investigate@rs'_a1RI)))
          | prev_a1RE == l_a1RF = repeated rs_a1RD
          | otherwise = answer rs_a1RD l_a1RF

answer :: State -> Words -> (String, State)
answer st_a1RJ (!l_a1RK)
  = (response_a1RL, newKeyTab kt_a1RM st_a1RJ)
  where (investigate@((investigate@response_a1RL),
                      (investigate@kt_a1RM)))
          = ans_a1RO (keyTabOf st_a1RJ)
        cons_a1RN e_a1RP (investigate@(r_a1RQ, (!es_a1RR)))
          = (r_a1RQ, e_a1RP : es_a1RR)
        ans_a1RO ((investigate@e_a1RS) : (!es_a1RT))
          | null rs_a1RU = e_a1RS `cons_a1RN` ans_a1RO es_a1RT
          | otherwise =
            (makeResponse a_a1RW (head rs_a1RU), (key_a1RV, as_a1RX) : es_a1RT)
          where rs_a1RU = replies key_a1RV l_a1RK
                (investigate@(key_a1RV, (investigate@(a_a1RW : as_a1RX)))) = e_a1RS

replies :: Words -> Words -> [String]
replies (!key_a1RY) l_a1RZ
  = (map (conjug l_a1RZ . drop (length key_a1RY)) .
       filter (prefix key_a1RY . map ucase)
       . tails)
      l_a1RZ

prefix :: Eq a_asc => [a_asc] -> [a_asc] -> Bool
prefix [] (!xs_a1S0) = True
prefix (investigate@(x_a1S1 : xs_a1S2)) [] = False
prefix ((investigate@((investigate@x_a1S3) : xs_a1S4)))
  (investigate@((investigate@(y_a1S5 : ys_a1S6))))
  = x_a1S3 == y_a1S5 && (xs_a1S4 `prefix` ys_a1S6)

tails :: [a_asb] -> [[a_asb]]
tails (investigate@[]) = []
tails (investigate@xs_a1S7) = xs_a1S7 : tails (tail xs_a1S7)

ucase :: String -> String
ucase = map toUpper

conjug :: Words -> Words -> String
conjug (!d_a1WG)
  = unwords . trailingI_a1WJ . map conj_a1WI . maybe_a1WH d_a1WG
  where maybe_a1WH d_a1WK xs_a1WL
          = if null xs_a1WL then d_a1WK else xs_a1WL
        conj_a1WI w_a1WM
          = head
              ([m_a1WP | (investigate@((!w'_a1WO), (!m_a1WP))) <- conjugates,
                uw_a1WN == w'_a1WO]
                 ++ [w_a1WM])
          where (investigate@uw_a1WN) = ucase w_a1WM
        (investigate@trailingI_a1WJ) = foldr cons_a1WQ []
          where cons_a1WQ (investigate@x_a1WR) xs_a1WS
                  | x_a1WR == "I" && null xs_a1WS = ["me"]
                  | otherwise = x_a1WR : xs_a1WS

conjugates :: [(Word, Word)]
conjugates
  = prepare_a20d
      (oneways_a20b ++
         concat
           [[(x_a20g, y_a20h), (y_a20h, x_a20g)] |
            (x_a20g, y_a20h) <- bothways_a20c])
  where oneways_a20b = [("me", "you")]
        bothways_a20c
          = [("are", "am"), ("we're", "was"), ("you", "I"), ("your", "my"),
             ("I've", "you've"), ("I'm", "you're")]
        (investigate@prepare_a20d)
          = map (\ (investigate@(w_a20e, r_a20f)) -> (ucase w_a20e, r_a20f))

repeated :: State -> (String, State)
repeated (investigate@((!kt_a20i), ((!r_a20j) : (!rp_a20k))))
  = (r_a20j, (kt_a20i, rp_a20k))

newKeyTab :: KeyTable -> State -> State
newKeyTab kt'_a20l ((!kt_a20m), rp_a20n) = (kt'_a20l, rp_a20n)

keyTabOf :: State -> KeyTable
keyTabOf ((!kt_a20o), rp_a20p) = kt_a20o

makeResponse :: String -> String -> String
makeResponse ((investigate@('?' : (investigate@cs_a20q))))
  (investigate@us_a20r) = cs_a20q ++ " " ++ us_a20r ++ "?"
makeResponse ('.' : (investigate@cs_a20s)) us_a20t
  = cs_a20s ++ " " ++ us_a20t ++ "."
makeResponse (investigate@cs_a20u) us_a20v = cs_a20u

initial :: State
initial
  = ([(words k_a20w, cycle rs_a20x) | (k_a20w, rs_a20x) <- respMsgs],
     cycle repeatMsgs)
repeatMsgs
  = ["Why did you repeat yourself?",
     "Do you expect a different answer by repeating yourself?",
     "Come, come, elucidate your thoughts.",
     "Please don't repeat yourself!"]
respMsgs
  = [("CAN YOU", canYou_a20y), ("CAN I", canI_a20z),
     ("YOU ARE", youAre_a20A), ("YOU'RE", youAre_a20A),
     ("I DON'T", iDont_a20B), ("I FEEL", iFeel_a20C),
     ("WHY DON'T YOU", whyDont_a20D), ("WHY CAN'T I", whyCant_a20E),
     ("ARE YOU", areYou_a20F), ("I CAN'T", iCant_a20G),
     ("I AM", iAm_a20H), ("I'M", iAm_a20H), ("YOU", you_a20I),
     ("YES", yes_a20J), ("NO", no_a20K), ("COMPUTER", computer_a20L),
     ("COMPUTERS", computer_a20L), ("I WANT", iWant_a20M),
     ("WHAT", question_a20N), ("HOW", question_a20N),
     ("WHO", question_a20N), ("WHERE", question_a20N),
     ("WHEN", question_a20N), ("WHY", question_a20N),
     ("NAME", name_a20O), ("BECAUSE", because_a20P),
     ("CAUSE", because_a20P), ("SORRY", sorry_a20Q),
     ("DREAM", dream_a20R), ("DREAMS", dream_a20R), ("HI", hello_a20S),
     ("HELLO", hello_a20S), ("MAYBE", maybe_a20T), ("YOUR", your_a20U),
     ("ALWAYS", always_a20V), ("THINK", think_a20W),
     ("ALIKE", alike_a20X), ("FRIEND", friend_a20Y),
     ("FRIENDS", friend_a20Y), ("", nokeyMsgs_a20Z)]
  where canYou_a20y
          = ["?Don't you believe that I can",
             "?Perhaps you would like to be able to",
             "?You want me to be able to"]
        (investigate@canI_a20z)
          = ["?Perhaps you don't want to", "?Do you want to be able to"]
        (investigate@youAre_a20A)
          = ["?What makes you think I am",
             "?Does it please you to believe I am",
             "?Perhaps you would like to be", "?Do you sometimes wish you were"]
        iDont_a20B
          = ["?Don't you really", "?Why don't you",
             "?Do you wish to be able to", "Does that trouble you?"]
        iFeel_a20C
          = ["Tell me more about such feelings.", "?Do you often feel",
             "?Do you enjoy feeling"]
        (investigate@whyDont_a20D)
          = ["?Do you really believe I don't",
             ".Perhaps in good time I will", "?Do you want me to"]
        (investigate@whyCant_a20E)
          = ["?Do you think you should be able to", "?Why can't you"]
        areYou_a20F
          = ["?Why are you interested in whether or not I am",
             "?Would you prefer if I were not",
             "?Perhaps in your fantasies I am"]
        (investigate@iCant_a20G)
          = ["?How do you know you can't", "Have you tried?",
             "?Perhaps you can now"]
        iAm_a20H
          = ["?Did you come to me because you are",
             "?How long have you been", "?Do you believe it is normal to be",
             "?Do you enjoy being"]
        (investigate@you_a20I)
          = ["We were discussing you --not me.", "?Oh,",
             "You're not really talking about me, are you?"]
        yes_a20J
          = ["You seem quite positive.", "Are you Sure?", "I see.",
             "I understand."]
        (investigate@no_a20K)
          = ["Are you saying no just to be negative?",
             "You are being a bit negative.", "Why not?", "Are you sure?",
             "Why no?"]
        computer_a20L
          = ["Do computers worry you?",
             "Are you talking about me in particular?",
             "Are you frightened by machines?", "Why do you mention computers?",
             "What do you think machines have to do with your problems?",
             "Don't you think computers can help people?",
             "What is it about machines that worries you?"]
        (investigate@iWant_a20M)
          = ["?Why do you want", "?What would it mean to you if you got",
             "?Suppose you got", "?What if you never got",
             ".I sometimes also want"]
        (investigate@question_a20N)
          = ["Why do you ask?", "Does that question interest you?",
             "What answer would please you the most?", "What do you think?",
             "Are such questions on your mind often?",
             "What is it that you really want to know?",
             "Have you asked anyone else?",
             "Have you asked such questions before?",
             "What else comes to mind when you ask that?"]
        (investigate@name_a20O)
          = ["Names don't interest me.",
             "I don't care about names --please go on."]
        because_a20P
          = ["Is that the real reason?",
             "Don't any other reasons come to mind?",
             "Does that reason explain anything else?",
             "What other reasons might there be?"]
        sorry_a20Q
          = ["Please don't apologise!", "Apologies are not necessary.",
             "What feelings do you have when you apologise?",
             "Don't be so defensive!"]
        dream_a20R
          = ["What does that dream suggest to you?", "Do you dream often?",
             "What persons appear in your dreams?",
             "Are you disturbed by your dreams?"]
        hello_a20S = ["How do you...please state your problem."]
        maybe_a20T
          = ["You don't seem quite certain.", "Why the uncertain tone?",
             "Can't you be more positive?", "You aren't sure?",
             "Don't you know?"]
        your_a20U
          = ["?Why are you concerned about my", "?What about your own"]
        always_a20V
          = ["Can you think of a specific example?", "When?",
             "What are you thinking of?", "Really, always?"]
        (investigate@think_a20W)
          = ["Do you really think so?", "?But you are not sure you",
             "?Do you doubt you"]
        (investigate@alike_a20X)
          = ["In what way?", "What resemblence do you see?",
             "What does the similarity suggest to you?",
             "What other connections do you see?",
             "Cound there really be some connection?", "How?"]
        (investigate@friend_a20Y)
          = ["Why do you bring up the topic of friends?",
             "Do your friends worry you?", "Do your friends pick on you?",
             "Are you sure you have any friends?",
             "Do you impose on your friends?",
             "Perhaps your love for friends worries you."]
        nokeyMsgs_a20Z
          = ["I'm not sure I understand you fully.",
             "What does that suggest to you?", "I see.",
             "Can you elaborate on that?",
             "Say, do you have any psychological problems?"]

type Word = String

type Words = [Word]

type Replies = [String]

type Key = Words

type KeyTable = [(Key, Replies)]

type State = (KeyTable, Replies)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.res n_aGQ
  = concat (map Dum.clauses xs_aGR)
  where
      xs_aGR
        = take n_aGQ (repeat "(a = a = a) = (a = a = a) = (a = a = a)")
      {-# NOINLINE xs_aGR #-}
Dum.clause (!p_a13n)
  = clause'_a13o p_a13n ([], [])
  where
      clause'_a13o ((!(Dum.Dis (!p_a13p) (!q_a13q)))) x_a13r
        = clause'_a13o p_a13p (clause'_a13o q_a13q x_a13r)
      clause'_a13o (!(Dum.Sym s_a13s)) (!(c_a13t, (!a_a13u)))
        = (Dum.insert s_a13s c_a13t, a_a13u)
      clause'_a13o (!((!(Dum.Not (Dum.Sym s_a13v))))) (c_a13w, (!a_a13x))
        = (c_a13w, Dum.insert s_a13v a_a13x)
Dum.clauses
  = concat
    . map Dum.disp
      . Dum.unicl
        . Dum.split . Dum.disin . Dum.negin . Dum.elim . Dum.parse
Dum.conjunct (!(Dum.Con (!p_a13y) (!q_a13z))) = True
Dum.conjunct (!p_a13A) = False
Dum.disin (!((!(Dum.Dis (!p_a13B) ((!(Dum.Con q_a13C r_a13D)))))))
  = Dum.Con
      (Dum.disin (Dum.Dis p_a13B q_a13C))
      (Dum.disin (Dum.Dis p_a13B r_a13D))
Dum.disin (Dum.Dis (!(Dum.Con (!p_a13E) q_a13F)) (!r_a13G))
  = Dum.Con
      (Dum.disin (Dum.Dis p_a13E r_a13G))
      (Dum.disin (Dum.Dis q_a13F r_a13G))
Dum.disin (!((!(Dum.Dis (!p_a13H) (!q_a13I)))))
  = if Dum.conjunct dp_a13J || Dum.conjunct dq_a13K then
        Dum.disin (Dum.Dis dp_a13J dq_a13K)
    else
        (Dum.Dis dp_a13J dq_a13K)
  where
      dp_a13J = Dum.disin p_a13H
      (!dq_a13K) = Dum.disin q_a13I
Dum.disin (Dum.Con (!p_a1Zr) q_a1Zs)
  = Dum.Con (Dum.disin p_a1Zr) (Dum.disin q_a1Zs)
Dum.disin (!p_a1Zt) = p_a1Zt
Dum.disp (l_a1Zu, (!r_a1Zv))
  = Dum.interleave l_a1Zu Dum.spaces
    ++ "<=" ++ Dum.interleave Dum.spaces r_a1Zv ++ "\n"
Dum.elim (Dum.Sym (!s_a1Zw)) = Dum.Sym s_a1Zw
Dum.elim (!(Dum.Not (!p_a1Zx))) = Dum.Not (Dum.elim p_a1Zx)
Dum.elim ((!(Dum.Dis p_a1Zy (!q_a1Zz))))
  = Dum.Dis (Dum.elim p_a1Zy) (Dum.elim q_a1Zz)
Dum.elim (!((!(Dum.Con (!p_a1ZA) q_a1ZB))))
  = Dum.Con (Dum.elim p_a1ZA) (Dum.elim q_a1ZB)
Dum.elim ((!(Dum.Imp p_a1ZC (!q_a1ZD))))
  = Dum.Dis (Dum.Not (Dum.elim p_a1ZC)) (Dum.elim q_a1ZD)
Dum.elim (Dum.Eqv (!f_a1ZE) (!f'_a1ZF))
  = Dum.Con
      (Dum.elim (Dum.Imp f_a1ZE f'_a1ZF))
      (Dum.elim (Dum.Imp f'_a1ZF f_a1ZE))
Dum.insert x_a1ZG [] = [x_a1ZG]
Dum.insert x_a1ZH p_a1ZI@(y_a1ZJ : ys_a1ZK)
  = if x_a1ZH < y_a1ZJ then
        x_a1ZH : p_a1ZI
    else
        if x_a1ZH > y_a1ZJ then
            y_a1ZJ : Dum.insert x_a1ZH ys_a1ZK
        else
            p_a1ZI
Dum.interleave ((!((!x_a1ZL) : xs_a1ZM))) ys_a1ZN
  = x_a1ZL : Dum.interleave ys_a1ZN xs_a1ZM
Dum.interleave [] (!_) = []
Dum.negin (!(Dum.Not ((!(Dum.Not p_a1ZO))))) = Dum.negin p_a1ZO
Dum.negin ((!(Dum.Not (!(Dum.Con p_a1ZP (!q_a1ZQ))))))
  = Dum.Dis (Dum.negin (Dum.Not p_a1ZP)) (Dum.negin (Dum.Not q_a1ZQ))
Dum.negin (Dum.Not ((!(Dum.Dis p_a1ZR q_a1ZS))))
  = Dum.Con (Dum.negin (Dum.Not p_a1ZR)) (Dum.negin (Dum.Not q_a1ZS))
Dum.negin (!((!(Dum.Dis (!p_a1ZT) (!q_a1ZU)))))
  = Dum.Dis (Dum.negin p_a1ZT) (Dum.negin q_a1ZU)
Dum.negin (!(Dum.Con (!p_a1ZV) q_a1ZW))
  = Dum.Con (Dum.negin p_a1ZV) (Dum.negin q_a1ZW)
Dum.negin (!p_a1ZX) = p_a1ZX
Dum.opri '(' = 0
Dum.opri (!'=') = 1
Dum.opri '>' = 2
Dum.opri (!'|') = 3
Dum.opri '&' = 4
Dum.opri '~' = 5
Dum.parse t_a1ZY
  = f_a1ZZ
  where
      [Dum.Ast f_a1ZZ] = Dum.parse' t_a1ZY []
Dum.parse' [] (!s_a200) = Dum.redstar s_a200
Dum.parse' (!(' ' : (!t_a201))) (!s_a202)
  = Dum.parse' t_a201 s_a202
Dum.parse' ((!((!'(') : t_a203))) (!s_a204)
  = Dum.parse' t_a203 (Dum.Lex '(' : s_a204)
Dum.parse' (!((!((!')') : t_a205)))) (!s_a206)
  = Dum.parse' t_a205 (x_a207 : s'_a208)
  where
      ((!(x_a207 : (!((!(Dum.Lex (!'('))) : (!s'_a208))))))
        = Dum.redstar s_a206
Dum.parse' ((!c_a209) : t_a20a) (!s_a20b)
  = if inRange ('a', 'z') c_a209 then
        Dum.parse' t_a20a (Dum.Ast (Dum.Sym c_a209) : s_a20b)
    else
        if Dum.spri s_a20b > Dum.opri c_a209 then
            Dum.parse' (c_a209 : t_a20a) (Dum.red s_a20b)
        else
            Dum.parse' t_a20a (Dum.Lex c_a209 : s_a20b)
Dum.red
  ((!(Dum.Ast p_a29g : (!(Dum.Lex (!'=') : (Dum.Ast q_a29h : (!s_a29i)))))))
  = Dum.Ast (Dum.Eqv q_a29h p_a29g) : s_a29i
Dum.red
  (!((!(Dum.Ast (!p_a29j) : (Dum.Lex '>' : (!((!(Dum.Ast (!q_a29k))) : (!s_a29l))))))))
  = Dum.Ast (Dum.Imp q_a29k p_a29j) : s_a29l
Dum.red
  ((!(Dum.Ast p_a29m : (!(Dum.Lex (!'|') : (!(Dum.Ast q_a29n : s_a29o)))))))
  = Dum.Ast (Dum.Dis q_a29n p_a29m) : s_a29o
Dum.red
  ((!(Dum.Ast p_a29p : (Dum.Lex (!'&') : (!((!(Dum.Ast q_a29q)) : s_a29r))))))
  = Dum.Ast (Dum.Con q_a29q p_a29p) : s_a29r
Dum.red (!((!(Dum.Ast (!p_a29s) : (Dum.Lex '~' : (!s_a29t))))))
  = Dum.Ast (Dum.Not p_a29s) : s_a29t
Dum.redstar = Dum.while ((/=) 0 . Dum.spri) Dum.red
Dum.spaces = repeat ' '
Dum.split (!p_a29u)
  = split'_a29v p_a29u []
  where
      split'_a29v ((!(Dum.Con p_a29w (!q_a29x)))) (!a_a29y)
        = split'_a29v p_a29w (split'_a29v q_a29x a_a29y)
      split'_a29v p_a29z (!a_a29A) = p_a29z : a_a29A
Dum.spri
  ((!(Dum.Ast x_a29B : ((!(Dum.Lex (!c_a29C))) : (!s_a29D)))))
  = Dum.opri c_a29C
Dum.spri (!s_a29E) = 0
Dum.tautclause (!(c_a29F, (!a_a29G)))
  = [x_a29H | x_a29H <- c_a29F, x_a29H `elem` a_a29G] /= []
Dum.unicl a_a29I
  = foldr unicl'_a29J [] a_a29I
  where
      unicl'_a29J p_a29K x_a29L
        = if Dum.tautclause cp_a29M then
              x_a29L
          else
              Dum.insert cp_a29M x_a29L
        where
            cp_a29M = Dum.clause p_a29K
Dum.while (!p_a29N) (!f_a29O) (!x_a29P)
  = if p_a29N x_a29P then
        Dum.while p_a29N f_a29O (f_a29O x_a29P)
    else
        x_a29P

data Dum.Formula
  = Dum.Sym Char |
    Dum.Not Dum.Formula |
    Dum.Dis Dum.Formula Dum.Formula |
    Dum.Con Dum.Formula Dum.Formula |
    Dum.Imp Dum.Formula Dum.Formula |
    Dum.Eqv Dum.Formula Dum.Formula
data Dum.StackFrame = Dum.Ast Dum.Formula | Dum.Lex Char


["n_aGQ","xs_aGR","p_a13n","safebang@!p_a13n","(!p_a13n)","p_a13p","safebang@!p_a13p","(!p_a13p)","q_a13q","safebang@!q_a13q","(!q_a13q)","Dis (!p_a13p) (!q_a13q)","(Dis (!p_a13p) (!q_a13q))","!(Dis (!p_a13p) (!q_a13q))","(!(Dis (!p_a13p) (!q_a13q)))","((!(Dis (!p_a13p) (!q_a13q))))","x_a13r","s_a13s","Sym s_a13s","(Sym s_a13s)","!(Sym s_a13s)","(!(Sym s_a13s))","c_a13t","a_a13u","safebang@!a_a13u","(!a_a13u)","(c_a13t, (!a_a13u))","!(c_a13t, (!a_a13u))","(!(c_a13t, (!a_a13u)))","s_a13v","Sym s_a13v","(Sym s_a13v)","Not (Sym s_a13v)","(Not (Sym s_a13v))","!(Not (Sym s_a13v))","(!(Not (Sym s_a13v)))","((!(Not (Sym s_a13v))))","!((!(Not (Sym s_a13v))))","(!((!(Not (Sym s_a13v)))))","c_a13w","a_a13x","safebang@!a_a13x","(!a_a13x)","(c_a13w, (!a_a13x))","clauses","p_a13y","safebang@!p_a13y","(!p_a13y)","q_a13z","safebang@!q_a13z","(!q_a13z)","Con (!p_a13y) (!q_a13z)","(Con (!p_a13y) (!q_a13z))","!(Con (!p_a13y) (!q_a13z))","(!(Con (!p_a13y) (!q_a13z)))","p_a13A","!p_a13A","(!p_a13A)","p_a13B","safebang@!p_a13B","(!p_a13B)","q_a13C","r_a13D","Con q_a13C r_a13D","(Con q_a13C r_a13D)","!(Con q_a13C r_a13D)","(!(Con q_a13C r_a13D))","((!(Con q_a13C r_a13D)))","Dis (!p_a13B) ((!(Con q_a13C r_a13D)))","(Dis (!p_a13B) ((!(Con q_a13C r_a13D))))","!(Dis (!p_a13B) ((!(Con q_a13C r_a13D))))","(!(Dis (!p_a13B) ((!(Con q_a13C r_a13D)))))","((!(Dis (!p_a13B) ((!(Con q_a13C r_a13D))))))","!((!(Dis (!p_a13B) ((!(Con q_a13C r_a13D))))))","(!((!(Dis (!p_a13B) ((!(Con q_a13C r_a13D)))))))","p_a13E","safebang@!p_a13E","(!p_a13E)","q_a13F","Con (!p_a13E) q_a13F","(Con (!p_a13E) q_a13F)","!(Con (!p_a13E) q_a13F)","(!(Con (!p_a13E) q_a13F))","r_a13G","investigate@!r_a13G","(!r_a13G)","Dis (!(Con (!p_a13E) q_a13F)) (!r_a13G)","(Dis (!(Con (!p_a13E) q_a13F)) (!r_a13G))","p_a13H","safebang@!p_a13H","(!p_a13H)","q_a13I","safebang@!q_a13I","(!q_a13I)","Dis (!p_a13H) (!q_a13I)","(Dis (!p_a13H) (!q_a13I))","!(Dis (!p_a13H) (!q_a13I))","(!(Dis (!p_a13H) (!q_a13I)))","((!(Dis (!p_a13H) (!q_a13I))))","!((!(Dis (!p_a13H) (!q_a13I))))","(!((!(Dis (!p_a13H) (!q_a13I)))))","dp_a13J","dq_a13K","!dq_a13K","(!dq_a13K)","p_a1Zr","safebang@!p_a1Zr","(!p_a1Zr)","q_a1Zs","Con (!p_a1Zr) q_a1Zs","(Con (!p_a1Zr) q_a1Zs)","p_a1Zt","!p_a1Zt","(!p_a1Zt)","l_a1Zu","r_a1Zv","safebang@!r_a1Zv","(!r_a1Zv)","(l_a1Zu, (!r_a1Zv))","s_a1Zw","safebang@!s_a1Zw","(!s_a1Zw)","Sym (!s_a1Zw)","(Sym (!s_a1Zw))","p_a1Zx","safebang@!p_a1Zx","(!p_a1Zx)","Not (!p_a1Zx)","(Not (!p_a1Zx))","!(Not (!p_a1Zx))","(!(Not (!p_a1Zx)))","p_a1Zy","q_a1Zz","safebang@!q_a1Zz","(!q_a1Zz)","Dis p_a1Zy (!q_a1Zz)","(Dis p_a1Zy (!q_a1Zz))","!(Dis p_a1Zy (!q_a1Zz))","(!(Dis p_a1Zy (!q_a1Zz)))","((!(Dis p_a1Zy (!q_a1Zz))))","p_a1ZA","safebang@!p_a1ZA","(!p_a1ZA)","q_a1ZB","Con (!p_a1ZA) q_a1ZB","(Con (!p_a1ZA) q_a1ZB)","!(Con (!p_a1ZA) q_a1ZB)","(!(Con (!p_a1ZA) q_a1ZB))","((!(Con (!p_a1ZA) q_a1ZB)))","!((!(Con (!p_a1ZA) q_a1ZB)))","(!((!(Con (!p_a1ZA) q_a1ZB))))","p_a1ZC","q_a1ZD","safebang@!q_a1ZD","(!q_a1ZD)","Imp p_a1ZC (!q_a1ZD)","(Imp p_a1ZC (!q_a1ZD))","!(Imp p_a1ZC (!q_a1ZD))","(!(Imp p_a1ZC (!q_a1ZD)))","((!(Imp p_a1ZC (!q_a1ZD))))","f_a1ZE","safebang@!f_a1ZE","(!f_a1ZE)","f'_a1ZF","safebang@!f'_a1ZF","(!f'_a1ZF)","Eqv (!f_a1ZE) (!f'_a1ZF)","(Eqv (!f_a1ZE) (!f'_a1ZF))","x_a1ZG","[]","x_a1ZH","y_a1ZJ","ys_a1ZK","y_a1ZJ : ys_a1ZK","(y_a1ZJ : ys_a1ZK)","p_a1ZI@(y_a1ZJ : ys_a1ZK)","x_a1ZL","safebang@!x_a1ZL","(!x_a1ZL)","xs_a1ZM","(!x_a1ZL) : xs_a1ZM","((!x_a1ZL) : xs_a1ZM)","!((!x_a1ZL) : xs_a1ZM)","(!((!x_a1ZL) : xs_a1ZM))","((!((!x_a1ZL) : xs_a1ZM)))","ys_a1ZN","[]","_","!_","(!_)","p_a1ZO","Not p_a1ZO","(Not p_a1ZO)","!(Not p_a1ZO)","(!(Not p_a1ZO))","((!(Not p_a1ZO)))","Not ((!(Not p_a1ZO)))","(Not ((!(Not p_a1ZO))))","!(Not ((!(Not p_a1ZO))))","(!(Not ((!(Not p_a1ZO)))))","p_a1ZP","q_a1ZQ","safebang@!q_a1ZQ","(!q_a1ZQ)","Con p_a1ZP (!q_a1ZQ)","(Con p_a1ZP (!q_a1ZQ))","!(Con p_a1ZP (!q_a1ZQ))","(!(Con p_a1ZP (!q_a1ZQ)))","Not (!(Con p_a1ZP (!q_a1ZQ)))","(Not (!(Con p_a1ZP (!q_a1ZQ))))","!(Not (!(Con p_a1ZP (!q_a1ZQ))))","(!(Not (!(Con p_a1ZP (!q_a1ZQ)))))","((!(Not (!(Con p_a1ZP (!q_a1ZQ))))))","p_a1ZR","q_a1ZS","Dis p_a1ZR q_a1ZS","(Dis p_a1ZR q_a1ZS)","!(Dis p_a1ZR q_a1ZS)","(!(Dis p_a1ZR q_a1ZS))","((!(Dis p_a1ZR q_a1ZS)))","Not ((!(Dis p_a1ZR q_a1ZS)))","(Not ((!(Dis p_a1ZR q_a1ZS))))","p_a1ZT","safebang@!p_a1ZT","(!p_a1ZT)","q_a1ZU","safebang@!q_a1ZU","(!q_a1ZU)","Dis (!p_a1ZT) (!q_a1ZU)","(Dis (!p_a1ZT) (!q_a1ZU))","!(Dis (!p_a1ZT) (!q_a1ZU))","(!(Dis (!p_a1ZT) (!q_a1ZU)))","((!(Dis (!p_a1ZT) (!q_a1ZU))))","!((!(Dis (!p_a1ZT) (!q_a1ZU))))","(!((!(Dis (!p_a1ZT) (!q_a1ZU)))))","p_a1ZV","safebang@!p_a1ZV","(!p_a1ZV)","q_a1ZW","Con (!p_a1ZV) q_a1ZW","(Con (!p_a1ZV) q_a1ZW)","!(Con (!p_a1ZV) q_a1ZW)","(!(Con (!p_a1ZV) q_a1ZW))","p_a1ZX","!p_a1ZX","(!p_a1ZX)","'('","'='","!'='","(!'=')","'>'","'|'","!'|'","(!'|')","'&'","'~'","t_a1ZY","f_a1ZZ","Ast f_a1ZZ","[Ast f_a1ZZ]","[]","s_a200","safebang@!s_a200","(!s_a200)","' '","t_a201","!t_a201","(!t_a201)","' ' : (!t_a201)","(' ' : (!t_a201))","!(' ' : (!t_a201))","(!(' ' : (!t_a201)))","s_a202","!s_a202","(!s_a202)","'('","!'('","(!'(')","t_a203","(!'(') : t_a203","((!'(') : t_a203)","!((!'(') : t_a203)","(!((!'(') : t_a203))","((!((!'(') : t_a203)))","s_a204","!s_a204","(!s_a204)","')'","!')'","(!')')","t_a205","(!')') : t_a205","((!')') : t_a205)","!((!')') : t_a205)","(!((!')') : t_a205))","((!((!')') : t_a205)))","!((!((!')') : t_a205)))","(!((!((!')') : t_a205))))","s_a206","!s_a206","(!s_a206)","x_a207","'('","!'('","(!'(')","Lex (!'(')","(Lex (!'('))","!(Lex (!'('))","(!(Lex (!'(')))","s'_a208","!s'_a208","(!s'_a208)","(!(Lex (!'('))) : (!s'_a208)","((!(Lex (!'('))) : (!s'_a208))","!((!(Lex (!'('))) : (!s'_a208))","(!((!(Lex (!'('))) : (!s'_a208)))","x_a207 : (!((!(Lex (!'('))) : (!s'_a208)))","(x_a207 : (!((!(Lex (!'('))) : (!s'_a208))))","!(x_a207 : (!((!(Lex (!'('))) : (!s'_a208))))","(!(x_a207 : (!((!(Lex (!'('))) : (!s'_a208)))))","((!(x_a207 : (!((!(Lex (!'('))) : (!s'_a208))))))","c_a209","!c_a209","(!c_a209)","t_a20a","(!c_a209) : t_a20a","((!c_a209) : t_a20a)","s_a20b","!s_a20b","(!s_a20b)","p_a29g","Ast p_a29g","'='","!'='","(!'=')","Lex (!'=')","q_a29h","Ast q_a29h","s_a29i","investigate@!s_a29i","(!s_a29i)","Ast q_a29h : (!s_a29i)","(Ast q_a29h : (!s_a29i))","Lex (!'=') : (Ast q_a29h : (!s_a29i))","(Lex (!'=') : (Ast q_a29h : (!s_a29i)))","!(Lex (!'=') : (Ast q_a29h : (!s_a29i)))","(!(Lex (!'=') : (Ast q_a29h : (!s_a29i))))","Ast p_a29g : (!(Lex (!'=') : (Ast q_a29h : (!s_a29i))))","(Ast p_a29g : (!(Lex (!'=') : (Ast q_a29h : (!s_a29i)))))","!(Ast p_a29g : (!(Lex (!'=') : (Ast q_a29h : (!s_a29i)))))","(!(Ast p_a29g : (!(Lex (!'=') : (Ast q_a29h : (!s_a29i))))))","((!(Ast p_a29g : (!(Lex (!'=') : (Ast q_a29h : (!s_a29i)))))))","p_a29j","safebang@!p_a29j","(!p_a29j)","Ast (!p_a29j)","'>'","Lex '>'","q_a29k","safebang@!q_a29k","(!q_a29k)","Ast (!q_a29k)","(Ast (!q_a29k))","!(Ast (!q_a29k))","(!(Ast (!q_a29k)))","s_a29l","investigate@!s_a29l","(!s_a29l)","(!(Ast (!q_a29k))) : (!s_a29l)","((!(Ast (!q_a29k))) : (!s_a29l))","!((!(Ast (!q_a29k))) : (!s_a29l))","(!((!(Ast (!q_a29k))) : (!s_a29l)))","Lex '>' : (!((!(Ast (!q_a29k))) : (!s_a29l)))","(Lex '>' : (!((!(Ast (!q_a29k))) : (!s_a29l))))","Ast (!p_a29j) : (Lex '>' : (!((!(Ast (!q_a29k))) : (!s_a29l))))","(Ast (!p_a29j) : (Lex '>' : (!((!(Ast (!q_a29k))) : (!s_a29l)))))","!(Ast (!p_a29j) : (Lex '>' : (!((!(Ast (!q_a29k))) : (!s_a29l)))))","(!(Ast (!p_a29j) :\n     (Lex '>' : (!((!(Ast (!q_a29k))) : (!s_a29l))))))","((!(Ast (!p_a29j) :\n      (Lex '>' : (!((!(Ast (!q_a29k))) : (!s_a29l)))))))","!((!(Ast (!p_a29j) :\n       (Lex '>' : (!((!(Ast (!q_a29k))) : (!s_a29l)))))))","(!((!(Ast (!p_a29j) :\n        (Lex '>' : (!((!(Ast (!q_a29k))) : (!s_a29l))))))))","p_a29m","Ast p_a29m","'|'","!'|'","(!'|')","Lex (!'|')","q_a29n","Ast q_a29n","s_a29o","Ast q_a29n : s_a29o","(Ast q_a29n : s_a29o)","!(Ast q_a29n : s_a29o)","(!(Ast q_a29n : s_a29o))","Lex (!'|') : (!(Ast q_a29n : s_a29o))","(Lex (!'|') : (!(Ast q_a29n : s_a29o)))","!(Lex (!'|') : (!(Ast q_a29n : s_a29o)))","(!(Lex (!'|') : (!(Ast q_a29n : s_a29o))))","Ast p_a29m : (!(Lex (!'|') : (!(Ast q_a29n : s_a29o))))","(Ast p_a29m : (!(Lex (!'|') : (!(Ast q_a29n : s_a29o)))))","!(Ast p_a29m : (!(Lex (!'|') : (!(Ast q_a29n : s_a29o)))))","(!(Ast p_a29m : (!(Lex (!'|') : (!(Ast q_a29n : s_a29o))))))","((!(Ast p_a29m : (!(Lex (!'|') : (!(Ast q_a29n : s_a29o)))))))","p_a29p","Ast p_a29p","'&'","!'&'","(!'&')","Lex (!'&')","q_a29q","Ast q_a29q","(Ast q_a29q)","!(Ast q_a29q)","(!(Ast q_a29q))","s_a29r","(!(Ast q_a29q)) : s_a29r","((!(Ast q_a29q)) : s_a29r)","!((!(Ast q_a29q)) : s_a29r)","(!((!(Ast q_a29q)) : s_a29r))","Lex (!'&') : (!((!(Ast q_a29q)) : s_a29r))","(Lex (!'&') : (!((!(Ast q_a29q)) : s_a29r)))","Ast p_a29p : (Lex (!'&') : (!((!(Ast q_a29q)) : s_a29r)))","(Ast p_a29p : (Lex (!'&') : (!((!(Ast q_a29q)) : s_a29r))))","!(Ast p_a29p : (Lex (!'&') : (!((!(Ast q_a29q)) : s_a29r))))","(!(Ast p_a29p : (Lex (!'&') : (!((!(Ast q_a29q)) : s_a29r)))))","((!(Ast p_a29p : (Lex (!'&') : (!((!(Ast q_a29q)) : s_a29r))))))","p_a29s","safebang@!p_a29s","(!p_a29s)","Ast (!p_a29s)","'~'","Lex '~'","s_a29t","safebang@!s_a29t","(!s_a29t)","Lex '~' : (!s_a29t)","(Lex '~' : (!s_a29t))","Ast (!p_a29s) : (Lex '~' : (!s_a29t))","(Ast (!p_a29s) : (Lex '~' : (!s_a29t)))","!(Ast (!p_a29s) : (Lex '~' : (!s_a29t)))","(!(Ast (!p_a29s) : (Lex '~' : (!s_a29t))))","((!(Ast (!p_a29s) : (Lex '~' : (!s_a29t)))))","!((!(Ast (!p_a29s) : (Lex '~' : (!s_a29t)))))","(!((!(Ast (!p_a29s) : (Lex '~' : (!s_a29t))))))","redstar","spaces","p_a29u","safebang@!p_a29u","(!p_a29u)","p_a29w","q_a29x","safebang@!q_a29x","(!q_a29x)","Con p_a29w (!q_a29x)","(Con p_a29w (!q_a29x))","!(Con p_a29w (!q_a29x))","(!(Con p_a29w (!q_a29x)))","((!(Con p_a29w (!q_a29x))))","a_a29y","safebang@!a_a29y","(!a_a29y)","p_a29z","a_a29A","!a_a29A","(!a_a29A)","x_a29B","Ast x_a29B","c_a29C","!c_a29C","(!c_a29C)","Lex (!c_a29C)","(Lex (!c_a29C))","!(Lex (!c_a29C))","(!(Lex (!c_a29C)))","s_a29D","investigate@!s_a29D","(!s_a29D)","(!(Lex (!c_a29C))) : (!s_a29D)","((!(Lex (!c_a29C))) : (!s_a29D))","Ast x_a29B : ((!(Lex (!c_a29C))) : (!s_a29D))","(Ast x_a29B : ((!(Lex (!c_a29C))) : (!s_a29D)))","!(Ast x_a29B : ((!(Lex (!c_a29C))) : (!s_a29D)))","(!(Ast x_a29B : ((!(Lex (!c_a29C))) : (!s_a29D))))","((!(Ast x_a29B : ((!(Lex (!c_a29C))) : (!s_a29D)))))","s_a29E","!s_a29E","(!s_a29E)","c_a29F","a_a29G","safebang@!a_a29G","(!a_a29G)","(c_a29F, (!a_a29G))","!(c_a29F, (!a_a29G))","(!(c_a29F, (!a_a29G)))","x_a29H","a_a29I","p_a29K","x_a29L","cp_a29M","p_a29N","safebang@!p_a29N","(!p_a29N)","f_a29O","safebang@!f_a29O","(!f_a29O)","x_a29P","safebang@!x_a29P","(!x_a29P)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Ix
import System.Environment
res n_aGQ = concat (map clauses xs_aGR)
  where xs_aGR
          = take n_aGQ (repeat "(a = a = a) = (a = a = a) = (a = a = a)")
        
        {-# NOINLINE xs_aGR #-}
clause (!p_a13n) = clause'_a13o p_a13n ([], [])
  where clause'_a13o ((investigate@(Dis (!p_a13p) (!q_a13q)))) x_a13r
          = clause'_a13o p_a13p (clause'_a13o q_a13q x_a13r)
        clause'_a13o (investigate@(Sym s_a13s))
          (investigate@(c_a13t, (!a_a13u))) = (insert s_a13s c_a13t, a_a13u)
        clause'_a13o (investigate@((investigate@(Not (Sym s_a13v)))))
          (c_a13w, (!a_a13x)) = (c_a13w, insert s_a13v a_a13x)
clauses
  = concat . map disp . unicl . split . disin . negin . elim . parse
conjunct (investigate@(Con (!p_a13y) (!q_a13z))) = True
conjunct (investigate@p_a13A) = False
disin
  (investigate@((investigate@(Dis (!p_a13B)
                                ((investigate@(Con q_a13C r_a13D)))))))
  = Con (disin (Dis p_a13B q_a13C)) (disin (Dis p_a13B r_a13D))
disin
  (Dis (investigate@(Con (!p_a13E) q_a13F)) (investigate@r_a13G))
  = Con (disin (Dis p_a13E r_a13G)) (disin (Dis q_a13F r_a13G))
disin (investigate@((investigate@(Dis (!p_a13H) (!q_a13I)))))
  = if conjunct dp_a13J || conjunct dq_a13K then
      disin (Dis dp_a13J dq_a13K) else (Dis dp_a13J dq_a13K)
  where dp_a13J = disin p_a13H
        (investigate@dq_a13K) = disin q_a13I
disin (Con (!p_a1Zr) q_a1Zs) = Con (disin p_a1Zr) (disin q_a1Zs)
disin (investigate@p_a1Zt) = p_a1Zt
disp (l_a1Zu, (!r_a1Zv))
  = interleave l_a1Zu spaces ++ "<=" ++ interleave spaces r_a1Zv ++
      "\n"
elim (Sym (!s_a1Zw)) = Sym s_a1Zw
elim (investigate@(Not (!p_a1Zx))) = Not (elim p_a1Zx)
elim ((investigate@(Dis p_a1Zy (!q_a1Zz))))
  = Dis (elim p_a1Zy) (elim q_a1Zz)
elim (investigate@((investigate@(Con (!p_a1ZA) q_a1ZB))))
  = Con (elim p_a1ZA) (elim q_a1ZB)
elim ((investigate@(Imp p_a1ZC (!q_a1ZD))))
  = Dis (Not (elim p_a1ZC)) (elim q_a1ZD)
elim (Eqv (!f_a1ZE) (!f'_a1ZF))
  = Con (elim (Imp f_a1ZE f'_a1ZF)) (elim (Imp f'_a1ZF f_a1ZE))
insert x_a1ZG [] = [x_a1ZG]
insert x_a1ZH p_a1ZI@(y_a1ZJ : ys_a1ZK)
  = if x_a1ZH < y_a1ZJ then x_a1ZH : p_a1ZI else
      if x_a1ZH > y_a1ZJ then y_a1ZJ : insert x_a1ZH ys_a1ZK else p_a1ZI
interleave ((investigate@((!x_a1ZL) : xs_a1ZM))) ys_a1ZN
  = x_a1ZL : interleave ys_a1ZN xs_a1ZM
interleave [] (investigate@_) = []
negin (investigate@(Not ((investigate@(Not p_a1ZO)))))
  = negin p_a1ZO
negin ((investigate@(Not (investigate@(Con p_a1ZP (!q_a1ZQ))))))
  = Dis (negin (Not p_a1ZP)) (negin (Not q_a1ZQ))
negin (Not ((investigate@(Dis p_a1ZR q_a1ZS))))
  = Con (negin (Not p_a1ZR)) (negin (Not q_a1ZS))
negin (investigate@((investigate@(Dis (!p_a1ZT) (!q_a1ZU)))))
  = Dis (negin p_a1ZT) (negin q_a1ZU)
negin (investigate@(Con (!p_a1ZV) q_a1ZW))
  = Con (negin p_a1ZV) (negin q_a1ZW)
negin (investigate@p_a1ZX) = p_a1ZX
opri '(' = 0
opri (investigate@'=') = 1
opri '>' = 2
opri (investigate@'|') = 3
opri '&' = 4
opri '~' = 5
parse t_a1ZY = f_a1ZZ
  where [Ast f_a1ZZ] = parse' t_a1ZY []
parse' [] (!s_a200) = redstar s_a200
parse' (investigate@(' ' : (investigate@t_a201)))
  (investigate@s_a202) = parse' t_a201 s_a202
parse' ((investigate@((investigate@'(') : t_a203)))
  (investigate@s_a204) = parse' t_a203 (Lex '(' : s_a204)
parse' (investigate@((investigate@((investigate@')') : t_a205))))
  (investigate@s_a206) = parse' t_a205 (x_a207 : s'_a208)
  where ((investigate@(x_a207 :
                         (investigate@((investigate@(Lex (investigate@'('))) :
                                         (investigate@s'_a208))))))
          = redstar s_a206
parse' ((investigate@c_a209) : t_a20a) (investigate@s_a20b)
  = if inRange ('a', 'z') c_a209 then
      parse' t_a20a (Ast (Sym c_a209) : s_a20b) else
      if spri s_a20b > opri c_a209 then
        parse' (c_a209 : t_a20a) (red s_a20b) else
        parse' t_a20a (Lex c_a209 : s_a20b)
red
  ((investigate@(Ast p_a29g :
                   (investigate@(Lex (investigate@'=') :
                                   (Ast q_a29h : (investigate@s_a29i)))))))
  = Ast (Eqv q_a29h p_a29g) : s_a29i
red
  (investigate@((investigate@(Ast (!p_a29j) :
                                (Lex '>' :
                                   (investigate@((investigate@(Ast (!q_a29k))) :
                                                   (investigate@s_a29l))))))))
  = Ast (Imp q_a29k p_a29j) : s_a29l
red
  ((investigate@(Ast p_a29m :
                   (investigate@(Lex (investigate@'|') :
                                   (investigate@(Ast q_a29n : s_a29o)))))))
  = Ast (Dis q_a29n p_a29m) : s_a29o
red
  ((investigate@(Ast p_a29p :
                   (Lex (investigate@'&') :
                      (investigate@((investigate@(Ast q_a29q)) : s_a29r))))))
  = Ast (Con q_a29q p_a29p) : s_a29r
red
  (investigate@((investigate@(Ast (!p_a29s) :
                                (Lex '~' : (!s_a29t))))))
  = Ast (Not p_a29s) : s_a29t
redstar = while ((/=) 0 . spri) red
spaces = repeat ' '
split (!p_a29u) = split'_a29v p_a29u []
  where split'_a29v ((investigate@(Con p_a29w (!q_a29x)))) (!a_a29y)
          = split'_a29v p_a29w (split'_a29v q_a29x a_a29y)
        split'_a29v p_a29z (investigate@a_a29A) = p_a29z : a_a29A
spri
  ((investigate@(Ast x_a29B :
                   ((investigate@(Lex (investigate@c_a29C))) :
                      (investigate@s_a29D)))))
  = opri c_a29C
spri (investigate@s_a29E) = 0
tautclause (investigate@(c_a29F, (!a_a29G)))
  = [x_a29H | x_a29H <- c_a29F, x_a29H `elem` a_a29G] /= []
unicl a_a29I = foldr unicl'_a29J [] a_a29I
  where unicl'_a29J p_a29K x_a29L
          = if tautclause cp_a29M then x_a29L else insert cp_a29M x_a29L
          where cp_a29M = clause p_a29K
while (!p_a29N) (!f_a29O) (!x_a29P)
  = if p_a29N x_a29P then while p_a29N f_a29O (f_a29O x_a29P) else
      x_a29P

data Formula = Sym Char
             | Not Formula
             | Dis Formula Formula
             | Con Formula Formula
             | Imp Formula Formula
             | Eqv Formula Formula

data StackFrame = Ast Formula
                | Lex Char
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infix 9 Dum.<*>
infixl 9 Dum..*

Dum.test :: Dum.StateStream
Dum.test
  = Dum.runExperiment
      Dum.testforce 2.0e-2 [1.0] (Dum.State [1.0] [0.0])
Dum.testforce :: Dum.ForceLaw [Float]
Dum.testforce (!k_aLT) [] = []
Dum.testforce
  (!k_aLU)
  (!((!((!(Dum.State (!pos_aLV) (!vel_aLW))) : atoms_aLX))))
  = (- 1.0) Dum..* k_aLU * pos_aLV : Dum.testforce k_aLU atoms_aLX
Dum.runExperiment ::
  Dum.ForceLaw a_aLS
  -> Float -> a_aLS -> Dum.AtomState -> Dum.StateStream
Dum.runExperiment (!law_aLY) dt_aLZ (!param_aM0) init_aM1
  = init_aM1
    : zipWith
        (Dum.propagate dt_aLZ) (law_aLY param_aM0 stream_aM2) stream_aM2
  where
      stream_aM2 = Dum.runExperiment law_aLY dt_aLZ param_aM0 init_aM1
Dum.propagate ::
  Float -> Dum.Force -> Dum.AtomState -> Dum.AtomState
Dum.propagate
  (!dt_aPU)
  (!aforce_aPV)
  (!(Dum.State pos_aPW vel_aPX))
  = Dum.State newpos_aPY newvel_aPZ
  where
      (!newpos_aPY) = pos_aPW + (dt_aPU Dum..* vel_aPX)
      (!newvel_aPZ) = vel_aPX + (dt_aPU Dum..* aforce_aPV)
(Dum..*) :: Num a_aLR => a_aLR -> [a_aLR] -> [a_aLR]
c_aQ0 Dum..* (![]) = []
c_aQ1 Dum..* (!((!f_aQ2) : (!fs_aQ3)))
  = c_aQ1 * f_aQ2 : c_aQ1 Dum..* fs_aQ3
(Dum.<*>) :: Num a_aLQ => [a_aLQ] -> [a_aLQ] -> a_aLQ
f_aQ4 Dum.<*> g_aQ5 = sum (f_aQ4 * g_aQ5)

type Dum.Position = [Float]
type Dum.Velocity = [Float]
data Dum.AtomState = Dum.State Dum.Position Dum.Velocity
type Dum.Force = [Float]
type Dum.StateStream = [Dum.AtomState]
type Dum.ForceLaw a_aEL = a_aEL -> Dum.StateStream -> [Dum.Force]

instance Num a_a18L => Num [a_a18L] where
  negate (!(f_a18M : (!fs_a18N)))
    = (negate f_a18M) : (negate fs_a18N)
  l_a18O + [] = l_a18O
  (![]) + l_a18P = l_a18P
  ((!((!f_a18Q) : (!fs_a18R)))) + (!((!g_a18S) : (!gs_a18T)))
    = (f_a18Q + g_a18S) : fs_a18R + gs_a18T
  (!_) * [] = []
  (![]) * _ = []
  ((!((!f_a18U) : fs_a18V))) * ((!((!g_a18W) : gs_a18X)))
    = (f_a18U * g_a18W) : (gs_a18X * gs_a18X)
  fromInteger (!c_a18Y) = fromInteger c_a18Y : [0]
instance Show Dum.AtomState where
  show ((!(Dum.State (!pos_a18Z) (!vel_a190))))
    = concat
        [(show component_a191) ++ "\t" | component_a191 <- pos_a18Z]
  showList states_a192
    = showString
        (concat [(show state_a193) ++ "\n" | (!state_a193) <- states_a192])


["test","k_aLT","safebang@!k_aLT","(!k_aLT)","[]","k_aLU","!k_aLU","(!k_aLU)","pos_aLV","safebang@!pos_aLV","(!pos_aLV)","vel_aLW","safebang@!vel_aLW","(!vel_aLW)","State (!pos_aLV) (!vel_aLW)","(State (!pos_aLV) (!vel_aLW))","!(State (!pos_aLV) (!vel_aLW))","(!(State (!pos_aLV) (!vel_aLW)))","atoms_aLX","(!(State (!pos_aLV) (!vel_aLW))) : atoms_aLX","((!(State (!pos_aLV) (!vel_aLW))) : atoms_aLX)","!((!(State (!pos_aLV) (!vel_aLW))) : atoms_aLX)","(!((!(State (!pos_aLV) (!vel_aLW))) : atoms_aLX))","((!((!(State (!pos_aLV) (!vel_aLW))) : atoms_aLX)))","!((!((!(State (!pos_aLV) (!vel_aLW))) : atoms_aLX)))","(!((!((!(State (!pos_aLV) (!vel_aLW))) : atoms_aLX))))","law_aLY","safebang@!law_aLY","(!law_aLY)","dt_aLZ","param_aM0","safebang@!param_aM0","(!param_aM0)","init_aM1","stream_aM2","dt_aPU","safebang@!dt_aPU","(!dt_aPU)","aforce_aPV","safebang@!aforce_aPV","(!aforce_aPV)","pos_aPW","vel_aPX","State pos_aPW vel_aPX","(State pos_aPW vel_aPX)","!(State pos_aPW vel_aPX)","(!(State pos_aPW vel_aPX))","newpos_aPY","!newpos_aPY","(!newpos_aPY)","newvel_aPZ","!newvel_aPZ","(!newvel_aPZ)","c_aQ0","[]","![]","(![])","c_aQ1","f_aQ2","safebang@!f_aQ2","(!f_aQ2)","fs_aQ3","safebang@!fs_aQ3","(!fs_aQ3)","(!f_aQ2) : (!fs_aQ3)","((!f_aQ2) : (!fs_aQ3))","!((!f_aQ2) : (!fs_aQ3))","(!((!f_aQ2) : (!fs_aQ3)))","f_aQ4","g_aQ5","f_a18M","fs_a18N","safebang@!fs_a18N","(!fs_a18N)","f_a18M : (!fs_a18N)","(f_a18M : (!fs_a18N))","!(f_a18M : (!fs_a18N))","(!(f_a18M : (!fs_a18N)))","l_a18O","[]","[]","![]","(![])","l_a18P","f_a18Q","safebang@!f_a18Q","(!f_a18Q)","fs_a18R","safebang@!fs_a18R","(!fs_a18R)","(!f_a18Q) : (!fs_a18R)","((!f_a18Q) : (!fs_a18R))","!((!f_a18Q) : (!fs_a18R))","(!((!f_a18Q) : (!fs_a18R)))","((!((!f_a18Q) : (!fs_a18R))))","g_a18S","!g_a18S","(!g_a18S)","gs_a18T","!gs_a18T","(!gs_a18T)","(!g_a18S) : (!gs_a18T)","((!g_a18S) : (!gs_a18T))","!((!g_a18S) : (!gs_a18T))","(!((!g_a18S) : (!gs_a18T)))","_","!_","(!_)","[]","[]","![]","(![])","_","f_a18U","safebang@!f_a18U","(!f_a18U)","fs_a18V","(!f_a18U) : fs_a18V","((!f_a18U) : fs_a18V)","!((!f_a18U) : fs_a18V)","(!((!f_a18U) : fs_a18V))","((!((!f_a18U) : fs_a18V)))","g_a18W","!g_a18W","(!g_a18W)","gs_a18X","(!g_a18W) : gs_a18X","((!g_a18W) : gs_a18X)","!((!g_a18W) : gs_a18X)","(!((!g_a18W) : gs_a18X))","((!((!g_a18W) : gs_a18X)))","c_a18Y","safebang@!c_a18Y","(!c_a18Y)","pos_a18Z","safebang@!pos_a18Z","(!pos_a18Z)","vel_a190","safebang@!vel_a190","(!vel_a190)","State (!pos_a18Z) (!vel_a190)","(State (!pos_a18Z) (!vel_a190))","!(State (!pos_a18Z) (!vel_a190))","(!(State (!pos_a18Z) (!vel_a190)))","((!(State (!pos_a18Z) (!vel_a190))))","component_a191","states_a192","state_a193","!state_a193","(!state_a193)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.Environment

infix 9 <*>

infixl 9 .*

test :: StateStream
test = runExperiment testforce 2.0e-2 [1.0] (State [1.0] [0.0])

testforce :: ForceLaw [Float]
testforce (!k_aLT) [] = []
testforce (investigate@k_aLU)
  (investigate@((investigate@((investigate@(State (!pos_aLV)
                                              (!vel_aLW)))
                                : atoms_aLX))))
  = (-1.0) .* k_aLU * pos_aLV : testforce k_aLU atoms_aLX

runExperiment ::
              ForceLaw a_aLS -> Float -> a_aLS -> AtomState -> StateStream
runExperiment (!law_aLY) dt_aLZ (!param_aM0) init_aM1
  = init_aM1 :
      zipWith (propagate dt_aLZ) (law_aLY param_aM0 stream_aM2)
        stream_aM2
  where stream_aM2 = runExperiment law_aLY dt_aLZ param_aM0 init_aM1

propagate :: Float -> Force -> AtomState -> AtomState
propagate (!dt_aPU) (!aforce_aPV)
  (investigate@(State pos_aPW vel_aPX)) = State newpos_aPY newvel_aPZ
  where (investigate@newpos_aPY) = pos_aPW + (dt_aPU .* vel_aPX)
        (investigate@newvel_aPZ) = vel_aPX + (dt_aPU .* aforce_aPV)

(.*) :: Num a_aLR => a_aLR -> [a_aLR] -> [a_aLR]
c_aQ0 .* (investigate@[]) = []
c_aQ1 .* (investigate@((!f_aQ2) : (!fs_aQ3)))
  = c_aQ1 * f_aQ2 : c_aQ1 .* fs_aQ3

(<*>) :: Num a_aLQ => [a_aLQ] -> [a_aLQ] -> a_aLQ
f_aQ4 <*> g_aQ5 = sum (f_aQ4 * g_aQ5)

type Position = [Float]

type Velocity = [Float]

data AtomState = State Position Velocity

type Force = [Float]

type StateStream = [AtomState]

type ForceLaw a_aEL = a_aEL -> StateStream -> [Force]

instance Num a_a18L => Num [a_a18L] where
        negate (investigate@(f_a18M : (!fs_a18N)))
          = (negate f_a18M) : (negate fs_a18N)
        l_a18O + [] = l_a18O
        (investigate@[]) + l_a18P = l_a18P
        ((investigate@((!f_a18Q) : (!fs_a18R)))) +
          (investigate@((investigate@g_a18S) : (investigate@gs_a18T)))
          = (f_a18Q + g_a18S) : fs_a18R + gs_a18T
        (investigate@_) * [] = []
        (investigate@[]) * _ = []
        ((investigate@((!f_a18U) : fs_a18V))) *
          ((investigate@((investigate@g_a18W) : gs_a18X)))
          = (f_a18U * g_a18W) : (gs_a18X * gs_a18X)
        fromInteger (!c_a18Y) = fromInteger c_a18Y : [0]

instance Show AtomState where
        show ((investigate@(State (!pos_a18Z) (!vel_a190))))
          = concat
              [(show component_a191) ++ "\t" | component_a191 <- pos_a18Z]
        showList states_a192
          = showString
              (concat
                 [(show state_a193) ++ "\n" |
                  (investigate@state_a193) <- states_a192])
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.algb :: (Eq a_a1vv) => [a_a1vv] -> [a_a1vv] -> [Int]
Dum.algb (!xs_a1vw) ys_a1vx
  = 0 : algb1_a1vy xs_a1vw [(y_a1x8, 0) | y_a1x8 <- ys_a1vx]
  where
      algb1_a1vy [] (!ys'_a1vz) = map snd ys'_a1vz
      algb1_a1vy ((!(x_a1vM : xs_a1vN))) (!ys'_a1vO)
        = algb1_a1vy xs_a1vN (algb2_a1vP 0 0 ys'_a1vO)
        where
            algb2_a1vP (!_) (!_) [] = []
            algb2_a1vP
              k0j1_a1vQ
              (!k1j1_a1vR)
              ((!((!((!y_a1vS), (!k0j_a1vT))) : ys_a1vU)))
              = let
                  (!kjcurr_a1vV)
                    = if x_a1vM == y_a1vS then
                          k0j1_a1vQ + 1
                      else
                          max k1j1_a1vR k0j_a1vT
                in (y_a1vS, kjcurr_a1vV) : algb2_a1vP k0j_a1vT kjcurr_a1vV ys_a1vU
Dum.algc ::
  (Eq a_a1oq) =>
  Int -> Int -> [a_a1oq] -> [a_a1oq] -> [a_a1oq] -> [a_a1oq]
Dum.algc (!m_a1x9) n_a1xa (!xs_a1xb) [] = id
Dum.algc (!m_a1xc) n_a1xd (![(!x_a1xe)]) (!ys_a1xf)
  = if x_a1xe `elem` ys_a1xf then (x_a1xe :) else id
Dum.algc (!m_a1Q5) n_a1Q6 (!xs_a1Q7) ys_a1Q8
  = Dum.algc m2_a1Q9 k_a1Qe xs1_a1Qa (take k_a1Qe ys_a1Q8)
    . Dum.algc
        (m_a1Q5 - m2_a1Q9) (n_a1Q6 - k_a1Qe) xs2_a1Qb (drop k_a1Qe ys_a1Q8)
  where
      m2_a1Q9 = m_a1Q5 `div` 2
      xs1_a1Qa = take m2_a1Q9 xs_a1Q7
      xs2_a1Qb = drop m2_a1Q9 xs_a1Q7
      (!l1_a1Qc) = Dum.algb xs1_a1Qa ys_a1Q8
      (!l2_a1Qd)
        = reverse (Dum.algb (reverse xs2_a1Qb) (reverse ys_a1Q8))
      (!k_a1Qe) = findk_a1Qf 0 0 (- 1) (zip l1_a1Qc l2_a1Qd)
      findk_a1Qf k_a23z km_a23A m_a23B [] = km_a23A
      findk_a1Qf
        k_a23C
        (!km_a23D)
        m_a23E
        ((!((!((!x_a23F), (!y_a23G))) : (!xys_a23H))))
        | x_a23F + y_a23G >= m_a23E
        = findk_a1Qf (k_a23C + 1) k_a23C (x_a23F + y_a23G) xys_a23H
        | otherwise = findk_a1Qf (k_a23C + 1) km_a23D m_a23E xys_a23H
Dum.lcss :: (Eq a_asH) => [a_asH] -> [a_asH] -> [a_asH]
Dum.lcss xs_a23I (!ys_a23J)
  = Dum.algc (length xs_a23I) (length ys_a23J) xs_a23I ys_a23J []


["xs_a1vw","safebang@!xs_a1vw","(!xs_a1vw)","ys_a1vx","y_a1x8","[]","ys'_a1vz","safebang@!ys'_a1vz","(!ys'_a1vz)","x_a1vM","xs_a1vN","x_a1vM : xs_a1vN","(x_a1vM : xs_a1vN)","!(x_a1vM : xs_a1vN)","(!(x_a1vM : xs_a1vN))","((!(x_a1vM : xs_a1vN)))","ys'_a1vO","!ys'_a1vO","(!ys'_a1vO)","_","!_","(!_)","_","!_","(!_)","[]","k0j1_a1vQ","k1j1_a1vR","!k1j1_a1vR","(!k1j1_a1vR)","y_a1vS","safebang@!y_a1vS","(!y_a1vS)","k0j_a1vT","safebang@!k0j_a1vT","(!k0j_a1vT)","((!y_a1vS), (!k0j_a1vT))","!((!y_a1vS), (!k0j_a1vT))","(!((!y_a1vS), (!k0j_a1vT)))","ys_a1vU","(!((!y_a1vS), (!k0j_a1vT))) : ys_a1vU","((!((!y_a1vS), (!k0j_a1vT))) : ys_a1vU)","!((!((!y_a1vS), (!k0j_a1vT))) : ys_a1vU)","(!((!((!y_a1vS), (!k0j_a1vT))) : ys_a1vU))","((!((!((!y_a1vS), (!k0j_a1vT))) : ys_a1vU)))","kjcurr_a1vV","!kjcurr_a1vV","(!kjcurr_a1vV)","m_a1x9","safebang@!m_a1x9","(!m_a1x9)","n_a1xa","xs_a1xb","safebang@!xs_a1xb","(!xs_a1xb)","[]","m_a1xc","!m_a1xc","(!m_a1xc)","n_a1xd","x_a1xe","safebang@!x_a1xe","(!x_a1xe)","[(!x_a1xe)]","![(!x_a1xe)]","(![(!x_a1xe)])","ys_a1xf","!ys_a1xf","(!ys_a1xf)","m_a1Q5","!m_a1Q5","(!m_a1Q5)","n_a1Q6","xs_a1Q7","!xs_a1Q7","(!xs_a1Q7)","ys_a1Q8","m2_a1Q9","xs1_a1Qa","xs2_a1Qb","l1_a1Qc","!l1_a1Qc","(!l1_a1Qc)","l2_a1Qd","!l2_a1Qd","(!l2_a1Qd)","k_a1Qe","!k_a1Qe","(!k_a1Qe)","k_a23z","km_a23A","m_a23B","[]","k_a23C","km_a23D","!km_a23D","(!km_a23D)","m_a23E","x_a23F","!x_a23F","(!x_a23F)","y_a23G","!y_a23G","(!y_a23G)","((!x_a23F), (!y_a23G))","!((!x_a23F), (!y_a23G))","(!((!x_a23F), (!y_a23G)))","xys_a23H","!xys_a23H","(!xys_a23H)","(!((!x_a23F), (!y_a23G))) : (!xys_a23H)","((!((!x_a23F), (!y_a23G))) : (!xys_a23H))","!((!((!x_a23F), (!y_a23G))) : (!xys_a23H))","(!((!((!x_a23F), (!y_a23G))) : (!xys_a23H)))","((!((!((!x_a23F), (!y_a23G))) : (!xys_a23H))))","xs_a23I","ys_a23J","safebang@!ys_a23J","(!ys_a23J)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.Environment

algb :: (Eq a_a1vv) => [a_a1vv] -> [a_a1vv] -> [Int]
algb (!xs_a1vw) ys_a1vx
  = 0 : algb1_a1vy xs_a1vw [(y_a1x8, 0) | y_a1x8 <- ys_a1vx]
  where algb1_a1vy [] (!ys'_a1vz) = map snd ys'_a1vz
        algb1_a1vy ((investigate@(x_a1vM : xs_a1vN)))
          (investigate@ys'_a1vO)
          = algb1_a1vy xs_a1vN (algb2_a1vP 0 0 ys'_a1vO)
          where algb2_a1vP (investigate@_) (investigate@_) [] = []
                algb2_a1vP k0j1_a1vQ (investigate@k1j1_a1vR)
                  ((investigate@((investigate@((!y_a1vS), (!k0j_a1vT))) : ys_a1vU)))
                  = let (investigate@kjcurr_a1vV)
                          = if x_a1vM == y_a1vS then k0j1_a1vQ + 1 else
                              max k1j1_a1vR k0j_a1vT
                      in (y_a1vS, kjcurr_a1vV) : algb2_a1vP k0j_a1vT kjcurr_a1vV ys_a1vU

algc ::
       (Eq a_a1oq) =>
       Int -> Int -> [a_a1oq] -> [a_a1oq] -> [a_a1oq] -> [a_a1oq]
algc (!m_a1x9) n_a1xa (!xs_a1xb) [] = id
algc (investigate@m_a1xc) n_a1xd (investigate@[(!x_a1xe)])
  (investigate@ys_a1xf)
  = if x_a1xe `elem` ys_a1xf then (x_a1xe :) else id
algc (investigate@m_a1Q5) n_a1Q6 (investigate@xs_a1Q7) ys_a1Q8
  = algc m2_a1Q9 k_a1Qe xs1_a1Qa (take k_a1Qe ys_a1Q8) .
      algc (m_a1Q5 - m2_a1Q9) (n_a1Q6 - k_a1Qe) xs2_a1Qb
        (drop k_a1Qe ys_a1Q8)
  where m2_a1Q9 = m_a1Q5 `div` 2
        xs1_a1Qa = take m2_a1Q9 xs_a1Q7
        xs2_a1Qb = drop m2_a1Q9 xs_a1Q7
        (investigate@l1_a1Qc) = algb xs1_a1Qa ys_a1Q8
        (investigate@l2_a1Qd)
          = reverse (algb (reverse xs2_a1Qb) (reverse ys_a1Q8))
        (investigate@k_a1Qe) = findk_a1Qf 0 0 (-1) (zip l1_a1Qc l2_a1Qd)
        findk_a1Qf k_a23z km_a23A m_a23B [] = km_a23A
        findk_a1Qf k_a23C (investigate@km_a23D) m_a23E
          ((investigate@((investigate@((investigate@x_a23F),
                                       (investigate@y_a23G)))
                           : (investigate@xys_a23H))))
          | x_a23F + y_a23G >= m_a23E =
            findk_a1Qf (k_a23C + 1) k_a23C (x_a23F + y_a23G) xys_a23H
          | otherwise = findk_a1Qf (k_a23C + 1) km_a23D m_a23E xys_a23H

lcss :: (Eq a_asH) => [a_asH] -> [a_asH] -> [a_asH]
lcss xs_a23I (!ys_a23J)
  = algc (length xs_a23I) (length ys_a23J) xs_a23I ys_a23J []
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.test (!(x_aLb, y_aLc, ((!d_aLd), (!u_aLe), v_aLf)))
  = d_aLd == (u_aLe * x_aLb + v_aLf * y_aLc)
    && d_aLd == (gcd x_aLb y_aLc)
Dum.gcdE ::
  Integral a_aBt => a_aBt -> a_aBt -> (a_aBt, a_aBt, a_aBt)
Dum.gcdE 0 y_a1HX = (y_a1HX, 0, 1)
Dum.gcdE (!x_a1HY) (!y_a1HZ)
  = g_a1I0 (1, 0, x_a1HY) (0, 1, y_a1HZ)
  where
      g_a1I0
        (u1_a1I1, u2_a1I2, u3_a1I3)
        ((!v1_a1I4), (!v2_a1I5), (!v3_a1I6))
        = if v3_a1I6 == 0 then
              (u3_a1I3, u1_a1I1, u2_a1I2)
          else
              case quotRem u3_a1I3 v3_a1I6 of {
                ((!q_a1I7), (!r_a1I8))
                  -> g_a1I0
                       (v1_a1I4, v2_a1I5, v3_a1I6)
                       (u1_a1I1 - q_a1I7 * v1_a1I4, u2_a1I2 - q_a1I7 * v2_a1I5, r_a1I8) }

type Dum.Z = Integer


["x_aLb","y_aLc","d_aLd","safebang@!d_aLd","(!d_aLd)","u_aLe","safebang@!u_aLe","(!u_aLe)","v_aLf","((!d_aLd), (!u_aLe), v_aLf)","(x_aLb, y_aLc, ((!d_aLd), (!u_aLe), v_aLf))","!(x_aLb, y_aLc, ((!d_aLd), (!u_aLe), v_aLf))","(!(x_aLb, y_aLc, ((!d_aLd), (!u_aLe), v_aLf)))","0","y_a1HX","x_a1HY","!x_a1HY","(!x_a1HY)","y_a1HZ","!y_a1HZ","(!y_a1HZ)","u1_a1I1","u2_a1I2","u3_a1I3","(u1_a1I1, u2_a1I2, u3_a1I3)","v1_a1I4","safebang@!v1_a1I4","(!v1_a1I4)","v2_a1I5","safebang@!v2_a1I5","(!v2_a1I5)","v3_a1I6","safebang@!v3_a1I6","(!v3_a1I6)","((!v1_a1I4), (!v2_a1I5), (!v3_a1I6))","q_a1I7","safebang@!q_a1I7","(!q_a1I7)","r_a1I8","safebang@!r_a1I8","(!r_a1I8)","((!q_a1I7), (!r_a1I8))"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.Environment
test (investigate@(x_aLb, y_aLc, ((!d_aLd), (!u_aLe), v_aLf)))
  = d_aLd == (u_aLe * x_aLb + v_aLf * y_aLc) && d_aLd ==
      (gcd x_aLb y_aLc)

gcdE :: Integral a_aBt => a_aBt -> a_aBt -> (a_aBt, a_aBt, a_aBt)
gcdE 0 y_a1HX = (y_a1HX, 0, 1)
gcdE (investigate@x_a1HY) (investigate@y_a1HZ)
  = g_a1I0 (1, 0, x_a1HY) (0, 1, y_a1HZ)
  where g_a1I0 (u1_a1I1, u2_a1I2, u3_a1I3)
          ((!v1_a1I4), (!v2_a1I5), (!v3_a1I6))
          = if v3_a1I6 == 0 then (u3_a1I3, u1_a1I1, u2_a1I2) else
              case quotRem u3_a1I3 v3_a1I6 of
                  ((!q_a1I7), (!r_a1I8)) -> g_a1I0 (v1_a1I4, v2_a1I5, v3_a1I6)
                                              (u1_a1I1 - q_a1I7 * v1_a1I4,
                                               u2_a1I2 - q_a1I7 * v2_a1I5, r_a1I8)

type Z = Integer
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infixr 5 `Dum.above`
infixr 5 `Dum.beside`

Dum.height, Dum.width :: Dum.Picture -> Int
Dum.height (!p_aHv) = length p_aHv
Dum.width p_a10c = length (head p_a10c)
Dum.above, Dum.beside :: Dum.Picture -> Dum.Picture -> Dum.Picture
Dum.above = (++)
Dum.beside = zipWith (++)
Dum.stack, Dum.spread :: [Dum.Picture] -> Dum.Picture
Dum.stack = foldr1 Dum.above
Dum.spread = foldr1 Dum.beside
Dum.emptyPic :: (Int, Int) -> Dum.Picture
Dum.emptyPic (h_a13P, (!w_a13Q))
  = Dum.copy h_a13P (Dum.copy w_a13Q ' ')
Dum.block, Dum.blockT :: Int -> [Dum.Picture] -> Dum.Picture
Dum.block (!n_a13R) = Dum.stack . map Dum.spread . Dum.groop n_a13R
Dum.blockT n_a13S = Dum.spread . map Dum.stack . Dum.groop n_a13S
Dum.groop :: Int -> [a_aHu] -> [[a_aHu]]
Dum.groop n_a13T [] = []
Dum.groop (!n_a13U) xs_a13V
  = take n_a13U xs_a13V : Dum.groop n_a13U (drop n_a13U xs_a13V)
Dum.lframe :: (Int, Int) -> Dum.Picture -> Dum.Picture
Dum.lframe (!(m_a13W, n_a13X)) p_a13Y
  = (p_a13Y `Dum.beside` Dum.emptyPic (h_a13Z, n_a13X - w_a140))
    `Dum.above` Dum.emptyPic (m_a13W - h_a13Z, n_a13X)
  where
      (!h_a13Z) = Dum.height p_a13Y
      (!w_a140) = Dum.width p_a13Y
Dum.monthLengths (!year_a15d)
  = [31, feb_a15e, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  where
      (!feb_a15e)
        | Dum.leap year_a15d = 29
        | otherwise = 28
Dum.leap year_a15f
  = if year_a15f `mod` 100 == 0 then
        year_a15f `mod` 400 == 0
    else
        year_a15f `mod` 4 == 0
Dum.monthNames
  = ["January", "February", "March", "April", "May", "June", "July",
     "August", "September", "October", "November", "December"]
Dum.jan1st year_a2aA
  = (year_a2aA + last_a2aB `div` 4 - last_a2aB `div` 100
     + last_a2aB `div` 400)
    `mod` 7
  where
      (!last_a2aB) = year_a2aA - 1
Dum.firstDays year_a2aC
  = take
      12
      (map
         (`mod` 7)
         (scanl (+) (Dum.jan1st year_a2aC) (Dum.monthLengths year_a2aC)))
Dum.dates fd_a2aD (!ml_a2aE)
  = map (date_a2aF ml_a2aE) [1 - fd_a2aD .. 42 - fd_a2aD]
  where
      date_a2aF (!ml_a2aG) (!d_a2aH)
        | d_a2aH < 1 || ml_a2aG < d_a2aH = ["   "]
        | otherwise = [Dum.rjustify 3 (show d_a2aH)]
Dum.calendar :: Int -> String
Dum.calendar
  = unlines . Dum.block 3 . map picture_a2kN . months_a2kS
  where
      picture_a2kN (mn_a2kT, yr_a2kU, fd_a2kV, ml_a2kW)
        = title_a2kO mn_a2kT yr_a2kU `Dum.above` table_a2kP fd_a2kV ml_a2kW
      title_a2kO mn_a2kX yr_a2kY
        = Dum.lframe (2, 25) [mn_a2kX ++ " " ++ show yr_a2kY]
      table_a2kP (!fd_a2kZ) ml_a2l0
        = Dum.lframe
            (8, 25) (daynames_a2kQ `Dum.beside` entries_a2kR fd_a2kZ ml_a2l0)
      daynames_a2kQ = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
      entries_a2kR (!fd_a2l1) (!ml_a2l2)
        = Dum.blockT 7 (Dum.dates fd_a2l1 ml_a2l2)
      months_a2kS (!year_a2l3)
        = zip4
            Dum.monthNames
            (Dum.copy 12 year_a2l3)
            (Dum.firstDays year_a2l3)
            (Dum.monthLengths year_a2l3)
Dum.cal year_a2nv
  = unlines (banner_a2nw year_a2nv `Dum.above` body_a2nx year_a2nv)
  where
      banner_a2nw yr_a2nH
        = [Dum.cjustify 75 (show yr_a2nH)] `Dum.above` Dum.emptyPic (1, 75)
      body_a2nx = Dum.block 3 . map (pad_a2nz . pic_a2ny) . months_a2nG
      pic_a2ny (mn_a2nI, fd_a2nJ, ml_a2nK)
        = title_a2nC mn_a2nI `Dum.above` table_a2nD fd_a2nJ ml_a2nK
      pad_a2nz p_a2nL
        = (side_a2nA `Dum.beside` p_a2nL `Dum.beside` side_a2nA)
          `Dum.above` end_a2nB
      side_a2nA = Dum.emptyPic (8, 2)
      end_a2nB = Dum.emptyPic (1, 25)
      title_a2nC mn_a2nM = [Dum.cjustify 21 mn_a2nM]
      table_a2nD fd_a2nN ml_a2nO
        = daynames_a2nE `Dum.above` entries_a2nF fd_a2nN ml_a2nO
      daynames_a2nE = [" Su Mo Tu We Th Fr Sa"]
      entries_a2nF fd_a2nP ml_a2nQ
        = Dum.block 7 (Dum.dates fd_a2nP ml_a2nQ)
      months_a2nG year_a2nR
        = zip3
            Dum.monthNames
            (Dum.firstDays year_a2nR)
            (Dum.monthLengths year_a2nR)
Dum.calFor year_a2nS
  | illFormed_a2nT = ioError (userError "Bad argument")
  | otherwise = print (length (Dum.cal yr_a2nW))
  where
      illFormed_a2nT = null ds_a2nU || not (null rs_a2nV)
      (ds_a2nU, rs_a2nV) = span isDigit year_a2nS
      (!yr_a2nW) = atoi_a2nX ds_a2nU
      atoi_a2nX (!s_a2sx)
        = foldl
            (\ (!a_a2sy) (!d_a2sz) -> 10 * a_a2sy + d_a2sz)
            0
            (map toDigit_a2nY s_a2sx)
      toDigit_a2nY d_a2sA = fromEnum d_a2sA - fromEnum '0'
Dum.copy :: Int -> a_aHt -> [a_aHt]
Dum.copy n_a2Nl x_a2Nm = take n_a2Nl (repeat x_a2Nm)
Dum.cjustify, Dum.ljustify, Dum.rjustify :: Int -> String -> String
Dum.cjustify (!n_a2Nn) s_a2No
  = Dum.space halfm_a2Nq ++ s_a2No ++ Dum.space (m_a2Np - halfm_a2Nq)
  where
      m_a2Np = n_a2Nn - length s_a2No
      halfm_a2Nq = m_a2Np `div` 2
Dum.ljustify (!n_a2Nr) (!s_a2Ns)
  = s_a2Ns ++ Dum.space (n_a2Nr - length s_a2Ns)
Dum.rjustify (!n_a2Nt) (!s_a2Nu)
  = Dum.space (n_a2Nt - length s_a2Nu) ++ s_a2Nu
Dum.space :: Int -> String
Dum.space (!n_a2Nv) = Dum.copy n_a2Nv ' '

type Dum.Picture = [[Char]]


["p_aHv","safebang@!p_aHv","(!p_aHv)","p_a10c","above","beside","stack","spread","h_a13P","w_a13Q","safebang@!w_a13Q","(!w_a13Q)","(h_a13P, (!w_a13Q))","n_a13R","safebang@!n_a13R","(!n_a13R)","n_a13S","n_a13T","[]","n_a13U","!n_a13U","(!n_a13U)","xs_a13V","m_a13W","n_a13X","(m_a13W, n_a13X)","!(m_a13W, n_a13X)","(!(m_a13W, n_a13X))","p_a13Y","h_a13Z","!h_a13Z","(!h_a13Z)","w_a140","!w_a140","(!w_a140)","year_a15d","safebang@!year_a15d","(!year_a15d)","feb_a15e","!feb_a15e","(!feb_a15e)","year_a15f","monthNames","year_a2aA","last_a2aB","!last_a2aB","(!last_a2aB)","year_a2aC","fd_a2aD","ml_a2aE","safebang@!ml_a2aE","(!ml_a2aE)","ml_a2aG","!ml_a2aG","(!ml_a2aG)","d_a2aH","!d_a2aH","(!d_a2aH)","calendar","mn_a2kT","yr_a2kU","fd_a2kV","ml_a2kW","(mn_a2kT, yr_a2kU, fd_a2kV, ml_a2kW)","mn_a2kX","yr_a2kY","fd_a2kZ","!fd_a2kZ","(!fd_a2kZ)","ml_a2l0","daynames_a2kQ","fd_a2l1","!fd_a2l1","(!fd_a2l1)","ml_a2l2","!ml_a2l2","(!ml_a2l2)","year_a2l3","!year_a2l3","(!year_a2l3)","year_a2nv","yr_a2nH","body_a2nx","mn_a2nI","fd_a2nJ","ml_a2nK","(mn_a2nI, fd_a2nJ, ml_a2nK)","p_a2nL","side_a2nA","end_a2nB","mn_a2nM","fd_a2nN","ml_a2nO","daynames_a2nE","fd_a2nP","ml_a2nQ","year_a2nR","year_a2nS","illFormed_a2nT","ds_a2nU","rs_a2nV","(ds_a2nU, rs_a2nV)","yr_a2nW","!yr_a2nW","(!yr_a2nW)","s_a2sx","!s_a2sx","(!s_a2sx)","a_a2sy","!a_a2sy","(!a_a2sy)","d_a2sz","!d_a2sz","(!d_a2sz)","d_a2sA","n_a2Nl","x_a2Nm","n_a2Nn","!n_a2Nn","(!n_a2Nn)","s_a2No","m_a2Np","halfm_a2Nq","n_a2Nr","safebang@!n_a2Nr","(!n_a2Nr)","s_a2Ns","safebang@!s_a2Ns","(!s_a2Ns)","n_a2Nt","!n_a2Nt","(!n_a2Nt)","s_a2Nu","safebang@!s_a2Nu","(!s_a2Nu)","n_a2Nv","!n_a2Nv","(!n_a2Nv)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.IO
import Data.List
import Data.Char
import System.Environment
import Control.Monad

infixr 5 `above`

infixr 5 `beside`

height, width :: Picture -> Int
height (!p_aHv) = length p_aHv
width p_a10c = length (head p_a10c)

above, beside :: Picture -> Picture -> Picture
above = (++)
beside = zipWith (++)

stack, spread :: [Picture] -> Picture
stack = foldr1 above
spread = foldr1 beside

emptyPic :: (Int, Int) -> Picture
emptyPic (h_a13P, (!w_a13Q)) = copy h_a13P (copy w_a13Q ' ')

block, blockT :: Int -> [Picture] -> Picture
block (!n_a13R) = stack . map spread . groop n_a13R
blockT n_a13S = spread . map stack . groop n_a13S

groop :: Int -> [a_aHu] -> [[a_aHu]]
groop n_a13T [] = []
groop (investigate@n_a13U) xs_a13V
  = take n_a13U xs_a13V : groop n_a13U (drop n_a13U xs_a13V)

lframe :: (Int, Int) -> Picture -> Picture
lframe (investigate@(m_a13W, n_a13X)) p_a13Y
  = (p_a13Y `beside` emptyPic (h_a13Z, n_a13X - w_a140)) `above`
      emptyPic (m_a13W - h_a13Z, n_a13X)
  where (investigate@h_a13Z) = height p_a13Y
        (investigate@w_a140) = width p_a13Y
monthLengths (!year_a15d)
  = [31, feb_a15e, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  where (investigate@feb_a15e)
          | leap year_a15d = 29
          | otherwise = 28
leap year_a15f
  = if year_a15f `mod` 100 == 0 then year_a15f `mod` 400 == 0 else
      year_a15f `mod` 4 == 0
monthNames
  = ["January", "February", "March", "April", "May", "June", "July",
     "August", "September", "October", "November", "December"]
jan1st year_a2aA
  = (year_a2aA + last_a2aB `div` 4 - last_a2aB `div` 100 + last_a2aB
       `div` 400)
      `mod` 7
  where (investigate@last_a2aB) = year_a2aA - 1
firstDays year_a2aC
  = take 12
      (map (`mod` 7)
         (scanl (+) (jan1st year_a2aC) (monthLengths year_a2aC)))
dates fd_a2aD (!ml_a2aE)
  = map (date_a2aF ml_a2aE) [1 - fd_a2aD .. 42 - fd_a2aD]
  where date_a2aF (investigate@ml_a2aG) (investigate@d_a2aH)
          | d_a2aH < 1 || ml_a2aG < d_a2aH = ["   "]
          | otherwise = [rjustify 3 (show d_a2aH)]

calendar :: Int -> String
calendar = unlines . block 3 . map picture_a2kN . months_a2kS
  where picture_a2kN (mn_a2kT, yr_a2kU, fd_a2kV, ml_a2kW)
          = title_a2kO mn_a2kT yr_a2kU `above` table_a2kP fd_a2kV ml_a2kW
        title_a2kO mn_a2kX yr_a2kY
          = lframe (2, 25) [mn_a2kX ++ " " ++ show yr_a2kY]
        table_a2kP (investigate@fd_a2kZ) ml_a2l0
          = lframe (8, 25)
              (daynames_a2kQ `beside` entries_a2kR fd_a2kZ ml_a2l0)
        daynames_a2kQ = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
        entries_a2kR (investigate@fd_a2l1) (investigate@ml_a2l2)
          = blockT 7 (dates fd_a2l1 ml_a2l2)
        months_a2kS (investigate@year_a2l3)
          = zip4 monthNames (copy 12 year_a2l3) (firstDays year_a2l3)
              (monthLengths year_a2l3)
cal year_a2nv
  = unlines (banner_a2nw year_a2nv `above` body_a2nx year_a2nv)
  where banner_a2nw yr_a2nH
          = [cjustify 75 (show yr_a2nH)] `above` emptyPic (1, 75)
        body_a2nx = block 3 . map (pad_a2nz . pic_a2ny) . months_a2nG
        pic_a2ny (mn_a2nI, fd_a2nJ, ml_a2nK)
          = title_a2nC mn_a2nI `above` table_a2nD fd_a2nJ ml_a2nK
        pad_a2nz p_a2nL
          = (side_a2nA `beside` p_a2nL `beside` side_a2nA) `above` end_a2nB
        side_a2nA = emptyPic (8, 2)
        end_a2nB = emptyPic (1, 25)
        title_a2nC mn_a2nM = [cjustify 21 mn_a2nM]
        table_a2nD fd_a2nN ml_a2nO
          = daynames_a2nE `above` entries_a2nF fd_a2nN ml_a2nO
        daynames_a2nE = [" Su Mo Tu We Th Fr Sa"]
        entries_a2nF fd_a2nP ml_a2nQ = block 7 (dates fd_a2nP ml_a2nQ)
        months_a2nG year_a2nR
          = zip3 monthNames (firstDays year_a2nR) (monthLengths year_a2nR)
calFor year_a2nS
  | illFormed_a2nT = ioError (userError "Bad argument")
  | otherwise = print (length (cal yr_a2nW))
  where illFormed_a2nT = null ds_a2nU || not (null rs_a2nV)
        (ds_a2nU, rs_a2nV) = span isDigit year_a2nS
        (investigate@yr_a2nW) = atoi_a2nX ds_a2nU
        atoi_a2nX (investigate@s_a2sx)
          = foldl
              (\ (investigate@a_a2sy) (investigate@d_a2sz) ->
                 10 * a_a2sy + d_a2sz)
              0
              (map toDigit_a2nY s_a2sx)
        toDigit_a2nY d_a2sA = fromEnum d_a2sA - fromEnum '0'

copy :: Int -> a_aHt -> [a_aHt]
copy n_a2Nl x_a2Nm = take n_a2Nl (repeat x_a2Nm)

cjustify, ljustify, rjustify :: Int -> String -> String
cjustify (investigate@n_a2Nn) s_a2No
  = space halfm_a2Nq ++ s_a2No ++ space (m_a2Np - halfm_a2Nq)
  where m_a2Np = n_a2Nn - length s_a2No
        halfm_a2Nq = m_a2Np `div` 2
ljustify (!n_a2Nr) (!s_a2Ns)
  = s_a2Ns ++ space (n_a2Nr - length s_a2Ns)
rjustify (investigate@n_a2Nt) (!s_a2Nu)
  = space (n_a2Nt - length s_a2Nu) ++ s_a2Nu

space :: Int -> String
space (investigate@n_a2Nv) = copy n_a2Nv ' '

type Picture = [[Char]]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.vec_add :: Dum.Vec -> Dum.Vec -> Dum.Vec
Dum.vec_add ((!x1_aAx), (!y1_aAy)) (!((!x2_aAz), (!y2_aAA)))
  = (x1_aAx + x2_aAz, y1_aAy + y2_aAA)
Dum.vec_sub :: Dum.Vec -> Dum.Vec -> Dum.Vec
Dum.vec_sub (!(x1_aBN, (!y1_aBO))) (x2_aBP, (!y2_aBQ))
  = (x1_aBN - x2_aBP, y1_aBO - y2_aBQ)
Dum.scale_vec2 :: Dum.Vec -> Int -> Int -> Dum.Vec
Dum.scale_vec2 (!((!x_aBR), (!y_aBS))) a_aBT b_aBU
  = ((x_aBR * a_aBT) `div` b_aBU, (y_aBS * a_aBT) `div` b_aBU)
Dum.p_tile :: [(Int, Int, Int, Int)]
Dum.q_tile :: [(Int, Int, Int, Int)]
Dum.r_tile :: [(Int, Int, Int, Int)]
Dum.s_tile :: [(Int, Int, Int, Int)]
Dum.p_tile
  = [(0, 3, 3, 4), (3, 4, 0, 8), (0, 8, 0, 3), (6, 0, 4, 4),
     (4, 5, 4, 10), (4, 10, 7, 6), (7, 6, 4, 5), (11, 0, 10, 4),
     (10, 4, 9, 6), (9, 6, 8, 8), (8, 8, 4, 13), (4, 13, 0, 16),
     (0, 16, 6, 15), (6, 15, 8, 16), (8, 16, 12, 12), (12, 12, 16, 12),
     (10, 16, 12, 14), (12, 14, 16, 13), (12, 16, 13, 15),
     (13, 15, 16, 14), (14, 16, 16, 15), (8, 12, 16, 10), (8, 8, 12, 9),
     (12, 9, 16, 8), (9, 6, 12, 7), (12, 7, 16, 6), (10, 4, 13, 5),
     (13, 5, 16, 4), (11, 0, 14, 2), (14, 2, 16, 2)]
Dum.q_tile
  = [(0, 8, 4, 7), (4, 7, 6, 7), (6, 7, 8, 8), (8, 8, 12, 10),
     (12, 10, 16, 16), (0, 12, 3, 13), (3, 13, 5, 14), (5, 14, 7, 15),
     (7, 15, 8, 16), (2, 16, 3, 13), (4, 16, 5, 14), (6, 16, 7, 15),
     (0, 10, 7, 11), (9, 13, 8, 15), (8, 15, 11, 15), (11, 15, 9, 13),
     (10, 10, 8, 12), (8, 12, 12, 12), (12, 12, 10, 10), (2, 0, 4, 5),
     (4, 5, 4, 7), (4, 0, 6, 5), (6, 5, 6, 7), (6, 0, 8, 5),
     (8, 5, 8, 8), (10, 0, 14, 11), (12, 0, 13, 4), (13, 4, 16, 8),
     (16, 8, 15, 10), (15, 10, 16, 16), (13, 0, 16, 6), (14, 0, 16, 4),
     (15, 0, 16, 2), (0, 0, 8, 0), (12, 0, 16, 0), (0, 0, 0, 8),
     (0, 12, 0, 16)]
Dum.r_tile
  = [(0, 0, 8, 8), (12, 12, 16, 16), (0, 4, 5, 10), (0, 8, 2, 12),
     (0, 12, 1, 14), (16, 6, 11, 10), (11, 10, 6, 16), (16, 4, 14, 6),
     (14, 6, 8, 8), (8, 8, 5, 10), (5, 10, 2, 12), (2, 12, 0, 16),
     (16, 8, 12, 12), (12, 12, 11, 16), (1, 1, 4, 0), (2, 2, 8, 0),
     (3, 3, 8, 2), (8, 2, 12, 0), (5, 5, 12, 3), (12, 3, 16, 0),
     (11, 16, 12, 12), (12, 12, 16, 8), (13, 13, 16, 10),
     (14, 14, 16, 12), (15, 15, 16, 14)]
Dum.s_tile
  = [(0, 0, 4, 2), (4, 2, 8, 2), (8, 2, 16, 0), (0, 4, 2, 1),
     (0, 6, 7, 4), (0, 8, 8, 6), (0, 10, 7, 8), (0, 12, 7, 10),
     (0, 14, 7, 13), (13, 13, 16, 14), (14, 11, 16, 12),
     (15, 9, 16, 10), (16, 0, 10, 4), (10, 4, 8, 6), (8, 6, 7, 8),
     (7, 8, 7, 13), (7, 13, 8, 16), (12, 16, 13, 13), (13, 13, 14, 11),
     (14, 11, 15, 9), (15, 9, 16, 8), (10, 16, 11, 10), (12, 4, 10, 6),
     (10, 6, 12, 7), (12, 7, 12, 4), (15, 5, 13, 7), (13, 7, 15, 8),
     (15, 8, 15, 5)]
Dum.nil a_aLB b_aLC c_aLD = []
Dum.grid ::
  Int
  -> Int
     -> [Dum.Line_segment]
        -> Dum.Vec -> Dum.Vec -> Dum.Vec -> [Dum.Line_segment]
Dum.grid m_aLE (!n_aLF) (!segments_aLG) a_aLH b_aLI c_aLJ
  = [Dum.tup2
       (a_aLH `Dum.vec_add` (Dum.scale_vec2 b_aLI x0_aLK m_aLE)
        `Dum.vec_add` (Dum.scale_vec2 c_aLJ y0_aLL n_aLF))
       (a_aLH `Dum.vec_add` (Dum.scale_vec2 b_aLI x1_aLM m_aLE)
        `Dum.vec_add` (Dum.scale_vec2 c_aLJ y1_aLN n_aLF)) |
       (!((!x0_aLK), (!y0_aLL), (!x1_aLM), y1_aLN)) <- segments_aLG]
Dum.rot p_aLO (!a_aLP) b_aLQ (!c_aLR)
  = p_aLO
      (a_aLP `Dum.vec_add` b_aLQ) c_aLR ((0, 0) `Dum.vec_sub` b_aLQ)
Dum.beside m_aLS n_aLT p_aLU q_aLV a_aLW b_aLX (!c_aLY)
  = p_aLU a_aLW (Dum.scale_vec2 b_aLX m_aLS (m_aLS + n_aLT)) c_aLY
    ++
      q_aLV
        (a_aLW `Dum.vec_add` (Dum.scale_vec2 b_aLX m_aLS (m_aLS + n_aLT)))
        (Dum.scale_vec2 b_aLX n_aLT (n_aLT + m_aLS))
        c_aLY
Dum.above (!m_aLZ) n_aM0 p_aM1 q_aM2 (!a_aM3) (!b_aM4) c_aM5
  = p_aM1
      (a_aM3 `Dum.vec_add` (Dum.scale_vec2 c_aM5 n_aM0 (m_aLZ + n_aM0)))
      b_aM4
      (Dum.scale_vec2 c_aM5 m_aLZ (n_aM0 + m_aLZ))
    ++ q_aM2 a_aM3 b_aM4 (Dum.scale_vec2 c_aM5 n_aM0 (m_aLZ + n_aM0))
Dum.tup2 ::
  (a_aAt, b_aAu) -> (c_aAv, d_aAw) -> (a_aAt, b_aAu, c_aAv, d_aAw)
Dum.tup2 (!((!a_aM6), b_aM7)) ((!c_aM8), (!d_aM9))
  = (a_aM6, b_aM7, c_aM8, d_aM9)
Dum.tile_to_grid = Dum.grid 16 16
Dum.p = Dum.tile_to_grid Dum.p_tile
Dum.q = Dum.tile_to_grid Dum.q_tile
Dum.r = Dum.tile_to_grid Dum.r_tile
Dum.s = Dum.tile_to_grid Dum.s_tile
Dum.quartet (!a_aMa) (!b_aMb) c_aMc (!d_aMd)
  = Dum.above
      1 1 (Dum.beside 1 1 a_aMa b_aMb) (Dum.beside 1 1 c_aMc d_aMd)
Dum.t = Dum.quartet Dum.p Dum.q Dum.r Dum.s
Dum.cycle' p1_aMe
  = Dum.quartet
      p1_aMe
      (Dum.rot (Dum.rot (Dum.rot p1_aMe)))
      (Dum.rot p1_aMe)
      (Dum.rot (Dum.rot p1_aMe))
Dum.u = Dum.cycle' (Dum.rot Dum.q)
Dum.side1 = Dum.quartet Dum.nil Dum.nil (Dum.rot Dum.t) Dum.t
Dum.side2 = Dum.quartet Dum.side1 Dum.side1 (Dum.rot Dum.t) Dum.t
Dum.corner1 = Dum.quartet Dum.nil Dum.nil Dum.nil Dum.u
Dum.corner2
  = Dum.quartet Dum.corner1 Dum.side1 (Dum.rot Dum.side1) Dum.u
Dum.pseudocorner
  = Dum.quartet
      Dum.corner2 Dum.side2 (Dum.rot Dum.side2) (Dum.rot Dum.t)
Dum.pseudolimit = Dum.cycle' Dum.pseudocorner
Dum.nonet
  (!p1_aMf)
  p2_aMg
  (!p3_aMh)
  p4_aMi
  p5_aMj
  p6_aMk
  p7_aMl
  p8_aMm
  (!p9_aMn)
  = Dum.above
      1
      2
      (Dum.beside 1 2 p1_aMf (Dum.beside 1 1 p2_aMg p3_aMh))
      (Dum.above
         1
         1
         (Dum.beside 1 2 p4_aMi (Dum.beside 1 1 p5_aMj p6_aMk))
         (Dum.beside 1 2 p7_aMl (Dum.beside 1 1 p8_aMm p9_aMn)))
Dum.corner
  = Dum.nonet
      Dum.corner2
      Dum.side2
      Dum.side2
      (Dum.rot Dum.side2)
      Dum.u
      (Dum.rot Dum.t)
      (Dum.rot Dum.side2)
      (Dum.rot Dum.t)
      (Dum.rot Dum.q)
Dum.squarelimit = Dum.cycle' Dum.corner
Dum.fmt (![]) = "[]"
Dum.fmt (x_aMo : xs_aMp)
  = (showString "[\n" . showsPrec 0 x_aMo . showl_aMq xs_aMp) ""
  where
      showl_aMq [] s_aMr = showChar ']' s_aMr
      showl_aMq ((!(x_aWx : (!xs_aWy)))) (!s_aWz)
        = (showString ",\n" . showsPrec 0 x_aWx . showl_aMq xs_aWy) s_aWz

type Dum.Vec = (Int, Int)
type Dum.Line_segment = (Int, Int, Int, Int)
type Dum.Picture =
    Dum.Vec -> Dum.Vec -> Dum.Vec -> [Dum.Line_segment]


["x1_aAx","safebang@!x1_aAx","(!x1_aAx)","y1_aAy","safebang@!y1_aAy","(!y1_aAy)","((!x1_aAx), (!y1_aAy))","x2_aAz","safebang@!x2_aAz","(!x2_aAz)","y2_aAA","safebang@!y2_aAA","(!y2_aAA)","((!x2_aAz), (!y2_aAA))","!((!x2_aAz), (!y2_aAA))","(!((!x2_aAz), (!y2_aAA)))","x1_aBN","y1_aBO","safebang@!y1_aBO","(!y1_aBO)","(x1_aBN, (!y1_aBO))","!(x1_aBN, (!y1_aBO))","(!(x1_aBN, (!y1_aBO)))","x2_aBP","y2_aBQ","safebang@!y2_aBQ","(!y2_aBQ)","(x2_aBP, (!y2_aBQ))","x_aBR","safebang@!x_aBR","(!x_aBR)","y_aBS","safebang@!y_aBS","(!y_aBS)","((!x_aBR), (!y_aBS))","!((!x_aBR), (!y_aBS))","(!((!x_aBR), (!y_aBS)))","a_aBT","b_aBU","p_tile","q_tile","r_tile","s_tile","a_aLB","b_aLC","c_aLD","m_aLE","n_aLF","safebang@!n_aLF","(!n_aLF)","segments_aLG","safebang@!segments_aLG","(!segments_aLG)","a_aLH","b_aLI","c_aLJ","x0_aLK","safebang@!x0_aLK","(!x0_aLK)","y0_aLL","safebang@!y0_aLL","(!y0_aLL)","x1_aLM","safebang@!x1_aLM","(!x1_aLM)","y1_aLN","((!x0_aLK), (!y0_aLL), (!x1_aLM), y1_aLN)","!((!x0_aLK), (!y0_aLL), (!x1_aLM), y1_aLN)","(!((!x0_aLK), (!y0_aLL), (!x1_aLM), y1_aLN))","p_aLO","a_aLP","safebang@!a_aLP","(!a_aLP)","b_aLQ","c_aLR","safebang@!c_aLR","(!c_aLR)","m_aLS","n_aLT","p_aLU","q_aLV","a_aLW","b_aLX","c_aLY","safebang@!c_aLY","(!c_aLY)","m_aLZ","safebang@!m_aLZ","(!m_aLZ)","n_aM0","p_aM1","q_aM2","a_aM3","safebang@!a_aM3","(!a_aM3)","b_aM4","safebang@!b_aM4","(!b_aM4)","c_aM5","a_aM6","safebang@!a_aM6","(!a_aM6)","b_aM7","((!a_aM6), b_aM7)","!((!a_aM6), b_aM7)","(!((!a_aM6), b_aM7))","c_aM8","safebang@!c_aM8","(!c_aM8)","d_aM9","safebang@!d_aM9","(!d_aM9)","((!c_aM8), (!d_aM9))","tile_to_grid","p","q","r","s","a_aMa","safebang@!a_aMa","(!a_aMa)","b_aMb","safebang@!b_aMb","(!b_aMb)","c_aMc","d_aMd","safebang@!d_aMd","(!d_aMd)","t","p1_aMe","u","side1","side2","corner1","corner2","pseudocorner","pseudolimit","p1_aMf","safebang@!p1_aMf","(!p1_aMf)","p2_aMg","p3_aMh","safebang@!p3_aMh","(!p3_aMh)","p4_aMi","p5_aMj","p6_aMk","p7_aMl","p8_aMm","p9_aMn","safebang@!p9_aMn","(!p9_aMn)","corner","squarelimit","[]","![]","(![])","x_aMo","xs_aMp","x_aMo : xs_aMp","(x_aMo : xs_aMp)","[]","s_aMr","x_aWx","xs_aWy","safebang@!xs_aWy","(!xs_aWy)","x_aWx : (!xs_aWy)","(x_aWx : (!xs_aWy))","!(x_aWx : (!xs_aWy))","(!(x_aWx : (!xs_aWy)))","((!(x_aWx : (!xs_aWy))))","s_aWz","!s_aWz","(!s_aWz)"]
{-# LANGUAGE BangPatterns #-}
module Dum where

vec_add :: Vec -> Vec -> Vec
vec_add ((!x1_aAx), (!y1_aAy)) (investigate@((!x2_aAz), (!y2_aAA)))
  = (x1_aAx + x2_aAz, y1_aAy + y2_aAA)

vec_sub :: Vec -> Vec -> Vec
vec_sub (investigate@(x1_aBN, (!y1_aBO))) (x2_aBP, (!y2_aBQ))
  = (x1_aBN - x2_aBP, y1_aBO - y2_aBQ)

scale_vec2 :: Vec -> Int -> Int -> Vec
scale_vec2 (investigate@((!x_aBR), (!y_aBS))) a_aBT b_aBU
  = ((x_aBR * a_aBT) `div` b_aBU, (y_aBS * a_aBT) `div` b_aBU)

p_tile :: [(Int, Int, Int, Int)]

q_tile :: [(Int, Int, Int, Int)]

r_tile :: [(Int, Int, Int, Int)]

s_tile :: [(Int, Int, Int, Int)]
p_tile
  = [(0, 3, 3, 4), (3, 4, 0, 8), (0, 8, 0, 3), (6, 0, 4, 4),
     (4, 5, 4, 10), (4, 10, 7, 6), (7, 6, 4, 5), (11, 0, 10, 4),
     (10, 4, 9, 6), (9, 6, 8, 8), (8, 8, 4, 13), (4, 13, 0, 16),
     (0, 16, 6, 15), (6, 15, 8, 16), (8, 16, 12, 12), (12, 12, 16, 12),
     (10, 16, 12, 14), (12, 14, 16, 13), (12, 16, 13, 15),
     (13, 15, 16, 14), (14, 16, 16, 15), (8, 12, 16, 10), (8, 8, 12, 9),
     (12, 9, 16, 8), (9, 6, 12, 7), (12, 7, 16, 6), (10, 4, 13, 5),
     (13, 5, 16, 4), (11, 0, 14, 2), (14, 2, 16, 2)]
q_tile
  = [(0, 8, 4, 7), (4, 7, 6, 7), (6, 7, 8, 8), (8, 8, 12, 10),
     (12, 10, 16, 16), (0, 12, 3, 13), (3, 13, 5, 14), (5, 14, 7, 15),
     (7, 15, 8, 16), (2, 16, 3, 13), (4, 16, 5, 14), (6, 16, 7, 15),
     (0, 10, 7, 11), (9, 13, 8, 15), (8, 15, 11, 15), (11, 15, 9, 13),
     (10, 10, 8, 12), (8, 12, 12, 12), (12, 12, 10, 10), (2, 0, 4, 5),
     (4, 5, 4, 7), (4, 0, 6, 5), (6, 5, 6, 7), (6, 0, 8, 5),
     (8, 5, 8, 8), (10, 0, 14, 11), (12, 0, 13, 4), (13, 4, 16, 8),
     (16, 8, 15, 10), (15, 10, 16, 16), (13, 0, 16, 6), (14, 0, 16, 4),
     (15, 0, 16, 2), (0, 0, 8, 0), (12, 0, 16, 0), (0, 0, 0, 8),
     (0, 12, 0, 16)]
r_tile
  = [(0, 0, 8, 8), (12, 12, 16, 16), (0, 4, 5, 10), (0, 8, 2, 12),
     (0, 12, 1, 14), (16, 6, 11, 10), (11, 10, 6, 16), (16, 4, 14, 6),
     (14, 6, 8, 8), (8, 8, 5, 10), (5, 10, 2, 12), (2, 12, 0, 16),
     (16, 8, 12, 12), (12, 12, 11, 16), (1, 1, 4, 0), (2, 2, 8, 0),
     (3, 3, 8, 2), (8, 2, 12, 0), (5, 5, 12, 3), (12, 3, 16, 0),
     (11, 16, 12, 12), (12, 12, 16, 8), (13, 13, 16, 10),
     (14, 14, 16, 12), (15, 15, 16, 14)]
s_tile
  = [(0, 0, 4, 2), (4, 2, 8, 2), (8, 2, 16, 0), (0, 4, 2, 1),
     (0, 6, 7, 4), (0, 8, 8, 6), (0, 10, 7, 8), (0, 12, 7, 10),
     (0, 14, 7, 13), (13, 13, 16, 14), (14, 11, 16, 12),
     (15, 9, 16, 10), (16, 0, 10, 4), (10, 4, 8, 6), (8, 6, 7, 8),
     (7, 8, 7, 13), (7, 13, 8, 16), (12, 16, 13, 13), (13, 13, 14, 11),
     (14, 11, 15, 9), (15, 9, 16, 8), (10, 16, 11, 10), (12, 4, 10, 6),
     (10, 6, 12, 7), (12, 7, 12, 4), (15, 5, 13, 7), (13, 7, 15, 8),
     (15, 8, 15, 5)]
nil a_aLB b_aLC c_aLD = []

grid ::
     Int -> Int -> [Line_segment] -> Vec -> Vec -> Vec -> [Line_segment]
grid m_aLE (!n_aLF) (!segments_aLG) a_aLH b_aLI c_aLJ
  = [tup2
       (a_aLH `vec_add` (scale_vec2 b_aLI x0_aLK m_aLE) `vec_add`
          (scale_vec2 c_aLJ y0_aLL n_aLF))
       (a_aLH `vec_add` (scale_vec2 b_aLI x1_aLM m_aLE) `vec_add`
          (scale_vec2 c_aLJ y1_aLN n_aLF))
     |
     (investigate@((!x0_aLK), (!y0_aLL), (!x1_aLM),
                   y1_aLN)) <- segments_aLG]
rot p_aLO (!a_aLP) b_aLQ (!c_aLR)
  = p_aLO (a_aLP `vec_add` b_aLQ) c_aLR ((0, 0) `vec_sub` b_aLQ)
beside m_aLS n_aLT p_aLU q_aLV a_aLW b_aLX (!c_aLY)
  = p_aLU a_aLW (scale_vec2 b_aLX m_aLS (m_aLS + n_aLT)) c_aLY ++
      q_aLV (a_aLW `vec_add` (scale_vec2 b_aLX m_aLS (m_aLS + n_aLT)))
        (scale_vec2 b_aLX n_aLT (n_aLT + m_aLS))
        c_aLY
above (!m_aLZ) n_aM0 p_aM1 q_aM2 (!a_aM3) (!b_aM4) c_aM5
  = p_aM1 (a_aM3 `vec_add` (scale_vec2 c_aM5 n_aM0 (m_aLZ + n_aM0)))
      b_aM4
      (scale_vec2 c_aM5 m_aLZ (n_aM0 + m_aLZ))
      ++ q_aM2 a_aM3 b_aM4 (scale_vec2 c_aM5 n_aM0 (m_aLZ + n_aM0))

tup2 ::
     (a_aAt, b_aAu) -> (c_aAv, d_aAw) -> (a_aAt, b_aAu, c_aAv, d_aAw)
tup2 (investigate@((!a_aM6), b_aM7)) ((!c_aM8), (!d_aM9))
  = (a_aM6, b_aM7, c_aM8, d_aM9)
tile_to_grid = grid 16 16
p = tile_to_grid p_tile
q = tile_to_grid q_tile
r = tile_to_grid r_tile
s = tile_to_grid s_tile
quartet (!a_aMa) (!b_aMb) c_aMc (!d_aMd)
  = above 1 1 (beside 1 1 a_aMa b_aMb) (beside 1 1 c_aMc d_aMd)
t = quartet p q r s
cycle' p1_aMe
  = quartet p1_aMe (rot (rot (rot p1_aMe))) (rot p1_aMe)
      (rot (rot p1_aMe))
u = cycle' (rot q)
side1 = quartet nil nil (rot t) t
side2 = quartet side1 side1 (rot t) t
corner1 = quartet nil nil nil u
corner2 = quartet corner1 side1 (rot side1) u
pseudocorner = quartet corner2 side2 (rot side2) (rot t)
pseudolimit = cycle' pseudocorner
nonet (!p1_aMf) p2_aMg (!p3_aMh) p4_aMi p5_aMj p6_aMk p7_aMl p8_aMm
  (!p9_aMn)
  = above 1 2 (beside 1 2 p1_aMf (beside 1 1 p2_aMg p3_aMh))
      (above 1 1 (beside 1 2 p4_aMi (beside 1 1 p5_aMj p6_aMk))
         (beside 1 2 p7_aMl (beside 1 1 p8_aMm p9_aMn)))
corner
  = nonet corner2 side2 side2 (rot side2) u (rot t) (rot side2)
      (rot t)
      (rot q)
squarelimit = cycle' corner
fmt (investigate@[]) = "[]"
fmt (x_aMo : xs_aMp)
  = (showString "[\n" . showsPrec 0 x_aMo . showl_aMq xs_aMp) ""
  where showl_aMq [] s_aMr = showChar ']' s_aMr
        showl_aMq ((investigate@(x_aWx : (!xs_aWy)))) (investigate@s_aWz)
          = (showString ",\n" . showsPrec 0 x_aWx . showl_aMq xs_aWy) s_aWz

type Vec = (Int, Int)

type Line_segment = (Int, Int, Int, Int)

type Picture = Vec -> Vec -> Vec -> [Line_segment]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.start :: [[Int]]
Dum.start
  = [[], [], [], [], [], [], [], [], [], [], [], [], [], [],
     [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1,
      1, 1, 1, 1, 0]]
Dum.gen n_aCA board_aCB
  = map Dum.row (Dum.shift (Dum.copy n_aCA 0) board_aCB)
Dum.row (!((!last_aCC), (!this_aCD), (!next_aCE)))
  = zipWith3
      Dum.elt
      (Dum.shift 0 last_aCC)
      (Dum.shift 0 this_aCD)
      (Dum.shift 0 next_aCE)
Dum.elt
  (a_aGy, b_aGz, c_aGA)
  (d_aGB, e_aGC, f_aGD)
  (g_aGE, h_aGF, (!i_aGG))
  | tot_aGH < 2 || tot_aGH > 3 = 0
  | tot_aGH == 3 = 1
  | otherwise = e_aGC
  where
      tot_aGH
        = a_aGy + b_aGz + c_aGA + d_aGB + f_aGD + g_aGE + h_aGF + i_aGG
Dum.shiftr x_a1DC xs_a1DD = [x_a1DC] ++ init xs_a1DD
Dum.shiftl x_a1DE xs_a1DF = tail xs_a1DF ++ [x_a1DE]
Dum.shift (!x_a1DG) xs_a1DH
  = zip3
      (Dum.shiftr x_a1DG xs_a1DH) xs_a1DH (Dum.shiftl x_a1DG xs_a1DH)
Dum.copy (!0) (!x_a1DI) = []
Dum.copy n_a1DJ (!x_a1DK) = x_a1DK : Dum.copy (n_a1DJ - 1) x_a1DK
Dum.disp ((!gen_a1DL), (!xss_a1DM))
  = gen_a1DL
    ++
      "\n\
      \\n"
      ++
        (foldr (Dum.glue "\n") "" . map (concat . map Dum.star)) xss_a1DM
Dum.star 0 = "  "
Dum.star 1 = " o"
Dum.glue (!s_a1Ws) xs_a1Wt (!ys_a1Wu)
  = xs_a1Wt ++ s_a1Ws ++ ys_a1Wu
Dum.limit ((!((!x_a1Wv) : (!(y_a1Ww : xs_a1Wx)))))
  | x_a1Wv == y_a1Ww = [x_a1Wv]
  | otherwise = x_a1Wv : Dum.limit (y_a1Ww : xs_a1Wx)


["start","n_aCA","board_aCB","last_aCC","safebang@!last_aCC","(!last_aCC)","this_aCD","safebang@!this_aCD","(!this_aCD)","next_aCE","safebang@!next_aCE","(!next_aCE)","((!last_aCC), (!this_aCD), (!next_aCE))","!((!last_aCC), (!this_aCD), (!next_aCE))","(!((!last_aCC), (!this_aCD), (!next_aCE)))","a_aGy","b_aGz","c_aGA","(a_aGy, b_aGz, c_aGA)","d_aGB","e_aGC","f_aGD","(d_aGB, e_aGC, f_aGD)","g_aGE","h_aGF","i_aGG","safebang@!i_aGG","(!i_aGG)","(g_aGE, h_aGF, (!i_aGG))","tot_aGH","x_a1DC","xs_a1DD","x_a1DE","xs_a1DF","x_a1DG","safebang@!x_a1DG","(!x_a1DG)","xs_a1DH","0","!0","(!0)","x_a1DI","safebang@!x_a1DI","(!x_a1DI)","n_a1DJ","x_a1DK","!x_a1DK","(!x_a1DK)","gen_a1DL","safebang@!gen_a1DL","(!gen_a1DL)","xss_a1DM","safebang@!xss_a1DM","(!xss_a1DM)","((!gen_a1DL), (!xss_a1DM))","0","1","s_a1Ws","safebang@!s_a1Ws","(!s_a1Ws)","xs_a1Wt","ys_a1Wu","safebang@!ys_a1Wu","(!ys_a1Wu)","x_a1Wv","safebang@!x_a1Wv","(!x_a1Wv)","y_a1Ww","xs_a1Wx","y_a1Ww : xs_a1Wx","(y_a1Ww : xs_a1Wx)","!(y_a1Ww : xs_a1Wx)","(!(y_a1Ww : xs_a1Wx))","(!x_a1Wv) : (!(y_a1Ww : xs_a1Wx))","((!x_a1Wv) : (!(y_a1Ww : xs_a1Wx)))","!((!x_a1Wv) : (!(y_a1Ww : xs_a1Wx)))","(!((!x_a1Wv) : (!(y_a1Ww : xs_a1Wx))))","((!((!x_a1Wv) : (!(y_a1Ww : xs_a1Wx)))))"]
{-# LANGUAGE BangPatterns #-}
module Dum where

start :: [[Int]]
start
  = [[], [], [], [], [], [], [], [], [], [], [], [], [], [],
     [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1,
      1, 1, 1, 1, 0]]
gen n_aCA board_aCB = map row (shift (copy n_aCA 0) board_aCB)
row (investigate@((!last_aCC), (!this_aCD), (!next_aCE)))
  = zipWith3 elt (shift 0 last_aCC) (shift 0 this_aCD)
      (shift 0 next_aCE)
elt (a_aGy, b_aGz, c_aGA) (d_aGB, e_aGC, f_aGD)
  (g_aGE, h_aGF, (!i_aGG))
  | tot_aGH < 2 || tot_aGH > 3 = 0
  | tot_aGH == 3 = 1
  | otherwise = e_aGC
  where tot_aGH
          = a_aGy + b_aGz + c_aGA + d_aGB + f_aGD + g_aGE + h_aGF + i_aGG
shiftr x_a1DC xs_a1DD = [x_a1DC] ++ init xs_a1DD
shiftl x_a1DE xs_a1DF = tail xs_a1DF ++ [x_a1DE]
shift (!x_a1DG) xs_a1DH
  = zip3 (shiftr x_a1DG xs_a1DH) xs_a1DH (shiftl x_a1DG xs_a1DH)
copy (investigate@0) (!x_a1DI) = []
copy n_a1DJ (investigate@x_a1DK)
  = x_a1DK : copy (n_a1DJ - 1) x_a1DK
disp ((!gen_a1DL), (!xss_a1DM))
  = gen_a1DL ++ "\n\n" ++
      (foldr (glue "\n") "" . map (concat . map star)) xss_a1DM
star 0 = "  "
star 1 = " o"
glue (!s_a1Ws) xs_a1Wt (!ys_a1Wu) = xs_a1Wt ++ s_a1Ws ++ ys_a1Wu
limit
  ((investigate@((!x_a1Wv) : (investigate@(y_a1Ww : xs_a1Wx)))))
  | x_a1Wv == y_a1Ww = [x_a1Wv]
  | otherwise = x_a1Wv : limit (y_a1Ww : xs_a1Wx)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.say
  = ('\n' :) . unlines . map join_atZ . transpose . map Dum.picChar
  where
      join_atZ = foldr1 (\ (!xs_aMM) ys_aMN -> xs_aMM ++ "  " ++ ys_aMN)
Dum.picChar (!c_aPp)
  | isUpper c_aPp = Dum.alphas !! (fromEnum c_aPp - fromEnum 'A')
  | isLower c_aPp = Dum.alphas !! (fromEnum c_aPp - fromEnum 'a')
  | isSpace c_aPp = Dum.blank
  | isDigit c_aPp = Dum.digits !! (fromEnum c_aPp - fromEnum '0')
  | c_aPp == '/' = Dum.slant
  | c_aPp == '\\' = reverse Dum.slant
  | otherwise
  = head
      ([letter_a222 |
          (!((!c'_a221), letter_a222)) <- Dum.punct, c'_a221 == c_aPp]
       ++ [Dum.nothing])
Dum.blank = ["     ", "     ", "     ", "     ", "     "]
Dum.slant = ["    ", "   ", "  ", " ", ""]
Dum.nothing = repeat ""
Dum.punct
  = [('.', ["     ", "     ", "     ", "  .. ", "  .. "]),
     ('?', [" ??? ", "?   ?", "   ? ", "  ?  ", "  .  "]),
     ('!', ["  !  ", "  !  ", "  !  ", "  !  ", "  .  "]),
     ('-', ["     ", "     ", "-----", "     ", "     "]),
     ('+', ["  +  ", "  +  ", "+++++", "  +  ", "  +  "]),
     (':', ["     ", "  :: ", "     ", "  :: ", "     "]),
     (';', ["     ", "  ;; ", "     ", "  ;; ", " ;;  "])]
Dum.digits
  = [[" OOO ", "0  00", "0 0 0", "00  0", " 000 "],
     ["  1  ", " 11  ", "  1  ", "  1  ", "11111"],
     [" 222 ", "2   2", "   2 ", "  2  ", "22222"],
     ["3333 ", "    3", " 333 ", "    3", "3333 "],
     ["   4 ", "  44 ", " 4 4 ", "44444", "   4 "],
     ["55555", "5    ", "5555 ", "    5", "5555 "],
     ["   66", "  6  ", " 666 ", "6   6", " 666 "],
     ["77777", "    7", "   7 ", "   7 ", "  7  "],
     [" 888 ", "8   8", " 888 ", "8   8", " 888 "],
     [" 999 ", "9   9", " 999 ", "  9  ", "99   "]]
Dum.alphas
  = [["  A  ", " A A ", "AAAAA", "A   A", "A   A"],
     ["BBBB ", "B   B", "BBBB ", "B   B", "BBBB "],
     [" CCCC", "C    ", "C    ", "C    ", " CCCC"],
     ["DDDD ", "D   D", "D   D", "D   D", "DDDD "],
     ["EEEEE", "E    ", "EEEEE", "E    ", "EEEEE"],
     ["FFFFF", "F    ", "FFFF ", "F    ", "F    "],
     [" GGGG", "G    ", "G  GG", "G   G", " GGG "],
     ["H   H", "H   H", "HHHHH", "H   H", "H   H"],
     ["IIIII", "  I  ", "  I  ", "  I  ", "IIIII"],
     ["JJJJJ", "   J ", "   J ", "J  J ", " JJ  "],
     ["K   K", "K  K ", "KKK  ", "K  K ", "K   K"],
     ["L    ", "L    ", "L    ", "L    ", "LLLLL"],
     ["M   M", "MM MM", "M M M", "M   M", "M   M"],
     ["N   N", "NN  N", "N N N", "N  NN", "N   N"],
     [" OOO ", "O   O", "O   O", "O   O", " OOO "],
     ["PPPP ", "P   P", "PPPP ", "P    ", "P    "],
     [" QQQ ", "Q   Q", "Q Q Q", "Q  Q ", " QQ Q"],
     ["RRRR ", "R   R", "RRRR ", "R  R ", "R   R"],
     [" SSSS", "S    ", " SSS ", "    S", "SSSS "],
     ["TTTTT", "  T  ", "  T  ", "  T  ", "  T  "],
     ["U   U", "U   U", "U   U", "U   U", " UUU "],
     ["V   V", "V   V", "V   V", " V V ", "  V  "],
     ["W   W", "W   W", "W   W", "W W W", " W W "],
     ["X   X", " X X ", "  X  ", " X X ", "X   X"],
     ["Y   Y", " Y Y ", "  Y  ", "  Y  ", "  Y  "],
     ["ZZZZZ", "   Z ", "  Z  ", " Z   ", "ZZZZZ"]]


["say","join_atZ","xs_aMM","!xs_aMM","(!xs_aMM)","ys_aMN","c_aPp","!c_aPp","(!c_aPp)","c'_a221","!c'_a221","(!c'_a221)","letter_a222","((!c'_a221), letter_a222)","!((!c'_a221), letter_a222)","(!((!c'_a221), letter_a222))","blank","slant","nothing","punct","digits","alphas"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Char
import Data.List
say = ('\n' :) . unlines . map join_atZ . transpose . map picChar
  where join_atZ
          = foldr1
              (\ (investigate@xs_aMM) ys_aMN -> xs_aMM ++ "  " ++ ys_aMN)
picChar (investigate@c_aPp)
  | isUpper c_aPp = alphas !! (fromEnum c_aPp - fromEnum 'A')
  | isLower c_aPp = alphas !! (fromEnum c_aPp - fromEnum 'a')
  | isSpace c_aPp = blank
  | isDigit c_aPp = digits !! (fromEnum c_aPp - fromEnum '0')
  | c_aPp == '/' = slant
  | c_aPp == '\\' = reverse slant
  | otherwise =
    head
      ([letter_a222 |
        (investigate@((investigate@c'_a221), letter_a222)) <- punct,
        c'_a221 == c_aPp]
         ++ [nothing])
blank = ["     ", "     ", "     ", "     ", "     "]
slant = ["    ", "   ", "  ", " ", ""]
nothing = repeat ""
punct
  = [('.', ["     ", "     ", "     ", "  .. ", "  .. "]),
     ('?', [" ??? ", "?   ?", "   ? ", "  ?  ", "  .  "]),
     ('!', ["  !  ", "  !  ", "  !  ", "  !  ", "  .  "]),
     ('-', ["     ", "     ", "-----", "     ", "     "]),
     ('+', ["  +  ", "  +  ", "+++++", "  +  ", "  +  "]),
     (':', ["     ", "  :: ", "     ", "  :: ", "     "]),
     (';', ["     ", "  ;; ", "     ", "  ;; ", " ;;  "])]
digits
  = [[" OOO ", "0  00", "0 0 0", "00  0", " 000 "],
     ["  1  ", " 11  ", "  1  ", "  1  ", "11111"],
     [" 222 ", "2   2", "   2 ", "  2  ", "22222"],
     ["3333 ", "    3", " 333 ", "    3", "3333 "],
     ["   4 ", "  44 ", " 4 4 ", "44444", "   4 "],
     ["55555", "5    ", "5555 ", "    5", "5555 "],
     ["   66", "  6  ", " 666 ", "6   6", " 666 "],
     ["77777", "    7", "   7 ", "   7 ", "  7  "],
     [" 888 ", "8   8", " 888 ", "8   8", " 888 "],
     [" 999 ", "9   9", " 999 ", "  9  ", "99   "]]
alphas
  = [["  A  ", " A A ", "AAAAA", "A   A", "A   A"],
     ["BBBB ", "B   B", "BBBB ", "B   B", "BBBB "],
     [" CCCC", "C    ", "C    ", "C    ", " CCCC"],
     ["DDDD ", "D   D", "D   D", "D   D", "DDDD "],
     ["EEEEE", "E    ", "EEEEE", "E    ", "EEEEE"],
     ["FFFFF", "F    ", "FFFF ", "F    ", "F    "],
     [" GGGG", "G    ", "G  GG", "G   G", " GGG "],
     ["H   H", "H   H", "HHHHH", "H   H", "H   H"],
     ["IIIII", "  I  ", "  I  ", "  I  ", "IIIII"],
     ["JJJJJ", "   J ", "   J ", "J  J ", " JJ  "],
     ["K   K", "K  K ", "KKK  ", "K  K ", "K   K"],
     ["L    ", "L    ", "L    ", "L    ", "LLLLL"],
     ["M   M", "MM MM", "M M M", "M   M", "M   M"],
     ["N   N", "NN  N", "N N N", "N  NN", "N   N"],
     [" OOO ", "O   O", "O   O", "O   O", " OOO "],
     ["PPPP ", "P   P", "PPPP ", "P    ", "P    "],
     [" QQQ ", "Q   Q", "Q Q Q", "Q  Q ", " QQ Q"],
     ["RRRR ", "R   R", "RRRR ", "R  R ", "R   R"],
     [" SSSS", "S    ", " SSS ", "    S", "SSSS "],
     ["TTTTT", "  T  ", "  T  ", "  T  ", "  T  "],
     ["U   U", "U   U", "U   U", "U   U", " UUU "],
     ["V   V", "V   V", "V   V", " V V ", "  V  "],
     ["W   W", "W   W", "W   W", "W W W", " W W "],
     ["X   X", " X X ", "  X  ", " X X ", "X   X"],
     ["Y   Y", " Y Y ", "  Y  ", "  Y  ", "  Y  "],
     ["ZZZZZ", "   Z ", "  Z  ", " Z   ", "ZZZZZ"]]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.say
  = ('\n' :) . unlines . map join_atZ . transpose . map Dum.picChar
  where
      join_atZ = foldr1 (\ (!xs_aMM) ys_aMN -> xs_aMM ++ "  " ++ ys_aMN)
Dum.picChar (!c_aPp)
  | isUpper c_aPp = Dum.alphas !! (fromEnum c_aPp - fromEnum 'A')
  | isLower c_aPp = Dum.alphas !! (fromEnum c_aPp - fromEnum 'a')
  | isSpace c_aPp = Dum.blank
  | isDigit c_aPp = Dum.digits !! (fromEnum c_aPp - fromEnum '0')
  | c_aPp == '/' = Dum.slant
  | c_aPp == '\\' = reverse Dum.slant
  | otherwise
  = head
      ([letter_a222 |
          (!((!c'_a221), letter_a222)) <- Dum.punct, c'_a221 == c_aPp]
       ++ [Dum.nothing])
Dum.blank = ["     ", "     ", "     ", "     ", "     "]
Dum.slant = ["    ", "   ", "  ", " ", ""]
Dum.nothing = repeat ""
Dum.punct
  = [('.', ["     ", "     ", "     ", "  .. ", "  .. "]),
     ('?', [" ??? ", "?   ?", "   ? ", "  ?  ", "  .  "]),
     ('!', ["  !  ", "  !  ", "  !  ", "  !  ", "  .  "]),
     ('-', ["     ", "     ", "-----", "     ", "     "]),
     ('+', ["  +  ", "  +  ", "+++++", "  +  ", "  +  "]),
     (':', ["     ", "  :: ", "     ", "  :: ", "     "]),
     (';', ["     ", "  ;; ", "     ", "  ;; ", " ;;  "])]
Dum.digits
  = [[" OOO ", "0  00", "0 0 0", "00  0", " 000 "],
     ["  1  ", " 11  ", "  1  ", "  1  ", "11111"],
     [" 222 ", "2   2", "   2 ", "  2  ", "22222"],
     ["3333 ", "    3", " 333 ", "    3", "3333 "],
     ["   4 ", "  44 ", " 4 4 ", "44444", "   4 "],
     ["55555", "5    ", "5555 ", "    5", "5555 "],
     ["   66", "  6  ", " 666 ", "6   6", " 666 "],
     ["77777", "    7", "   7 ", "   7 ", "  7  "],
     [" 888 ", "8   8", " 888 ", "8   8", " 888 "],
     [" 999 ", "9   9", " 999 ", "  9  ", "99   "]]
Dum.alphas
  = [["  A  ", " A A ", "AAAAA", "A   A", "A   A"],
     ["BBBB ", "B   B", "BBBB ", "B   B", "BBBB "],
     [" CCCC", "C    ", "C    ", "C    ", " CCCC"],
     ["DDDD ", "D   D", "D   D", "D   D", "DDDD "],
     ["EEEEE", "E    ", "EEEEE", "E    ", "EEEEE"],
     ["FFFFF", "F    ", "FFFF ", "F    ", "F    "],
     [" GGGG", "G    ", "G  GG", "G   G", " GGG "],
     ["H   H", "H   H", "HHHHH", "H   H", "H   H"],
     ["IIIII", "  I  ", "  I  ", "  I  ", "IIIII"],
     ["JJJJJ", "   J ", "   J ", "J  J ", " JJ  "],
     ["K   K", "K  K ", "KKK  ", "K  K ", "K   K"],
     ["L    ", "L    ", "L    ", "L    ", "LLLLL"],
     ["M   M", "MM MM", "M M M", "M   M", "M   M"],
     ["N   N", "NN  N", "N N N", "N  NN", "N   N"],
     [" OOO ", "O   O", "O   O", "O   O", " OOO "],
     ["PPPP ", "P   P", "PPPP ", "P    ", "P    "],
     [" QQQ ", "Q   Q", "Q Q Q", "Q  Q ", " QQ Q"],
     ["RRRR ", "R   R", "RRRR ", "R  R ", "R   R"],
     [" SSSS", "S    ", " SSS ", "    S", "SSSS "],
     ["TTTTT", "  T  ", "  T  ", "  T  ", "  T  "],
     ["U   U", "U   U", "U   U", "U   U", " UUU "],
     ["V   V", "V   V", "V   V", " V V ", "  V  "],
     ["W   W", "W   W", "W   W", "W W W", " W W "],
     ["X   X", " X X ", "  X  ", " X X ", "X   X"],
     ["Y   Y", " Y Y ", "  Y  ", "  Y  ", "  Y  "],
     ["ZZZZZ", "   Z ", "  Z  ", " Z   ", "ZZZZZ"]]


["say","join_atZ","xs_aMM","!xs_aMM","(!xs_aMM)","ys_aMN","c_aPp","!c_aPp","(!c_aPp)","c'_a221","!c'_a221","(!c'_a221)","letter_a222","((!c'_a221), letter_a222)","!((!c'_a221), letter_a222)","(!((!c'_a221), letter_a222))","blank","slant","nothing","punct","digits","alphas"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Pretty
say = ('\n' :) . unlines . map join_atZ . transpose . map picChar
  where join_atZ
          = foldr1
              (\ (investigate@xs_aMM) ys_aMN -> xs_aMM ++ "  " ++ ys_aMN)
picChar (investigate@c_aPp)
  | isUpper c_aPp = alphas !! (fromEnum c_aPp - fromEnum 'A')
  | isLower c_aPp = alphas !! (fromEnum c_aPp - fromEnum 'a')
  | isSpace c_aPp = blank
  | isDigit c_aPp = digits !! (fromEnum c_aPp - fromEnum '0')
  | c_aPp == '/' = slant
  | c_aPp == '\\' = reverse slant
  | otherwise =
    head
      ([letter_a222 |
        (investigate@((investigate@c'_a221), letter_a222)) <- punct,
        c'_a221 == c_aPp]
         ++ [nothing])
blank = ["     ", "     ", "     ", "     ", "     "]
slant = ["    ", "   ", "  ", " ", ""]
nothing = repeat ""
punct
  = [('.', ["     ", "     ", "     ", "  .. ", "  .. "]),
     ('?', [" ??? ", "?   ?", "   ? ", "  ?  ", "  .  "]),
     ('!', ["  !  ", "  !  ", "  !  ", "  !  ", "  .  "]),
     ('-', ["     ", "     ", "-----", "     ", "     "]),
     ('+', ["  +  ", "  +  ", "+++++", "  +  ", "  +  "]),
     (':', ["     ", "  :: ", "     ", "  :: ", "     "]),
     (';', ["     ", "  ;; ", "     ", "  ;; ", " ;;  "])]
digits
  = [[" OOO ", "0  00", "0 0 0", "00  0", " 000 "],
     ["  1  ", " 11  ", "  1  ", "  1  ", "11111"],
     [" 222 ", "2   2", "   2 ", "  2  ", "22222"],
     ["3333 ", "    3", " 333 ", "    3", "3333 "],
     ["   4 ", "  44 ", " 4 4 ", "44444", "   4 "],
     ["55555", "5    ", "5555 ", "    5", "5555 "],
     ["   66", "  6  ", " 666 ", "6   6", " 666 "],
     ["77777", "    7", "   7 ", "   7 ", "  7  "],
     [" 888 ", "8   8", " 888 ", "8   8", " 888 "],
     [" 999 ", "9   9", " 999 ", "  9  ", "99   "]]
alphas
  = [["  A  ", " A A ", "AAAAA", "A   A", "A   A"],
     ["BBBB ", "B   B", "BBBB ", "B   B", "BBBB "],
     [" CCCC", "C    ", "C    ", "C    ", " CCCC"],
     ["DDDD ", "D   D", "D   D", "D   D", "DDDD "],
     ["EEEEE", "E    ", "EEEEE", "E    ", "EEEEE"],
     ["FFFFF", "F    ", "FFFF ", "F    ", "F    "],
     [" GGGG", "G    ", "G  GG", "G   G", " GGG "],
     ["H   H", "H   H", "HHHHH", "H   H", "H   H"],
     ["IIIII", "  I  ", "  I  ", "  I  ", "IIIII"],
     ["JJJJJ", "   J ", "   J ", "J  J ", " JJ  "],
     ["K   K", "K  K ", "KKK  ", "K  K ", "K   K"],
     ["L    ", "L    ", "L    ", "L    ", "LLLLL"],
     ["M   M", "MM MM", "M M M", "M   M", "M   M"],
     ["N   N", "NN  N", "N N N", "N  NN", "N   N"],
     [" OOO ", "O   O", "O   O", "O   O", " OOO "],
     ["PPPP ", "P   P", "PPPP ", "P    ", "P    "],
     [" QQQ ", "Q   Q", "Q Q Q", "Q  Q ", " QQ Q"],
     ["RRRR ", "R   R", "RRRR ", "R  R ", "R   R"],
     [" SSSS", "S    ", " SSS ", "    S", "SSSS "],
     ["TTTTT", "  T  ", "  T  ", "  T  ", "  T  "],
     ["U   U", "U   U", "U   U", "U   U", " UUU "],
     ["V   V", "V   V", "V   V", " V V ", "  V  "],
     ["W   W", "W   W", "W   W", "W W W", " W W "],
     ["X   X", " X X ", "  X  ", " X X ", "X   X"],
     ["Y   Y", " Y Y ", "  Y  ", "  Y  ", "  Y  "],
     ["ZZZZZ", "   Z ", "  Z  ", " Z   ", "ZZZZZ"]]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.say
  = ('\n' :) . unlines . map join_atZ . transpose . map Dum.picChar
  where
      join_atZ = foldr1 (\ (!xs_aMM) ys_aMN -> xs_aMM ++ "  " ++ ys_aMN)
Dum.picChar (!c_aPp)
  | isUpper c_aPp = Dum.alphas !! (fromEnum c_aPp - fromEnum 'A')
  | isLower c_aPp = Dum.alphas !! (fromEnum c_aPp - fromEnum 'a')
  | isSpace c_aPp = Dum.blank
  | isDigit c_aPp = Dum.digits !! (fromEnum c_aPp - fromEnum '0')
  | c_aPp == '/' = Dum.slant
  | c_aPp == '\\' = reverse Dum.slant
  | otherwise
  = head
      ([letter_a222 |
          (!((!c'_a221), letter_a222)) <- Dum.punct, c'_a221 == c_aPp]
       ++ [Dum.nothing])
Dum.blank = ["     ", "     ", "     ", "     ", "     "]
Dum.slant = ["    ", "   ", "  ", " ", ""]
Dum.nothing = repeat ""
Dum.punct
  = [('.', ["     ", "     ", "     ", "  .. ", "  .. "]),
     ('?', [" ??? ", "?   ?", "   ? ", "  ?  ", "  .  "]),
     ('!', ["  !  ", "  !  ", "  !  ", "  !  ", "  .  "]),
     ('-', ["     ", "     ", "-----", "     ", "     "]),
     ('+', ["  +  ", "  +  ", "+++++", "  +  ", "  +  "]),
     (':', ["     ", "  :: ", "     ", "  :: ", "     "]),
     (';', ["     ", "  ;; ", "     ", "  ;; ", " ;;  "])]
Dum.digits
  = [[" OOO ", "0  00", "0 0 0", "00  0", " 000 "],
     ["  1  ", " 11  ", "  1  ", "  1  ", "11111"],
     [" 222 ", "2   2", "   2 ", "  2  ", "22222"],
     ["3333 ", "    3", " 333 ", "    3", "3333 "],
     ["   4 ", "  44 ", " 4 4 ", "44444", "   4 "],
     ["55555", "5    ", "5555 ", "    5", "5555 "],
     ["   66", "  6  ", " 666 ", "6   6", " 666 "],
     ["77777", "    7", "   7 ", "   7 ", "  7  "],
     [" 888 ", "8   8", " 888 ", "8   8", " 888 "],
     [" 999 ", "9   9", " 999 ", "  9  ", "99   "]]
Dum.alphas
  = [["  A  ", " A A ", "AAAAA", "A   A", "A   A"],
     ["BBBB ", "B   B", "BBBB ", "B   B", "BBBB "],
     [" CCCC", "C    ", "C    ", "C    ", " CCCC"],
     ["DDDD ", "D   D", "D   D", "D   D", "DDDD "],
     ["EEEEE", "E    ", "EEEEE", "E    ", "EEEEE"],
     ["FFFFF", "F    ", "FFFF ", "F    ", "F    "],
     [" GGGG", "G    ", "G  GG", "G   G", " GGG "],
     ["H   H", "H   H", "HHHHH", "H   H", "H   H"],
     ["IIIII", "  I  ", "  I  ", "  I  ", "IIIII"],
     ["JJJJJ", "   J ", "   J ", "J  J ", " JJ  "],
     ["K   K", "K  K ", "KKK  ", "K  K ", "K   K"],
     ["L    ", "L    ", "L    ", "L    ", "LLLLL"],
     ["M   M", "MM MM", "M M M", "M   M", "M   M"],
     ["N   N", "NN  N", "N N N", "N  NN", "N   N"],
     [" OOO ", "O   O", "O   O", "O   O", " OOO "],
     ["PPPP ", "P   P", "PPPP ", "P    ", "P    "],
     [" QQQ ", "Q   Q", "Q Q Q", "Q  Q ", " QQ Q"],
     ["RRRR ", "R   R", "RRRR ", "R  R ", "R   R"],
     [" SSSS", "S    ", " SSS ", "    S", "SSSS "],
     ["TTTTT", "  T  ", "  T  ", "  T  ", "  T  "],
     ["U   U", "U   U", "U   U", "U   U", " UUU "],
     ["V   V", "V   V", "V   V", " V V ", "  V  "],
     ["W   W", "W   W", "W   W", "W W W", " W W "],
     ["X   X", " X X ", "  X  ", " X X ", "X   X"],
     ["Y   Y", " Y Y ", "  Y  ", "  Y  ", "  Y  "],
     ["ZZZZZ", "   Z ", "  Z  ", " Z   ", "ZZZZZ"]]


["say","join_atZ","xs_aMM","!xs_aMM","(!xs_aMM)","ys_aMN","c_aPp","!c_aPp","(!c_aPp)","c'_a221","!c'_a221","(!c'_a221)","letter_a222","((!c'_a221), letter_a222)","!((!c'_a221), letter_a222)","(!((!c'_a221), letter_a222))","blank","slant","nothing","punct","digits","alphas"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import CharSeq
say = ('\n' :) . unlines . map join_atZ . transpose . map picChar
  where join_atZ
          = foldr1
              (\ (investigate@xs_aMM) ys_aMN -> xs_aMM ++ "  " ++ ys_aMN)
picChar (investigate@c_aPp)
  | isUpper c_aPp = alphas !! (fromEnum c_aPp - fromEnum 'A')
  | isLower c_aPp = alphas !! (fromEnum c_aPp - fromEnum 'a')
  | isSpace c_aPp = blank
  | isDigit c_aPp = digits !! (fromEnum c_aPp - fromEnum '0')
  | c_aPp == '/' = slant
  | c_aPp == '\\' = reverse slant
  | otherwise =
    head
      ([letter_a222 |
        (investigate@((investigate@c'_a221), letter_a222)) <- punct,
        c'_a221 == c_aPp]
         ++ [nothing])
blank = ["     ", "     ", "     ", "     ", "     "]
slant = ["    ", "   ", "  ", " ", ""]
nothing = repeat ""
punct
  = [('.', ["     ", "     ", "     ", "  .. ", "  .. "]),
     ('?', [" ??? ", "?   ?", "   ? ", "  ?  ", "  .  "]),
     ('!', ["  !  ", "  !  ", "  !  ", "  !  ", "  .  "]),
     ('-', ["     ", "     ", "-----", "     ", "     "]),
     ('+', ["  +  ", "  +  ", "+++++", "  +  ", "  +  "]),
     (':', ["     ", "  :: ", "     ", "  :: ", "     "]),
     (';', ["     ", "  ;; ", "     ", "  ;; ", " ;;  "])]
digits
  = [[" OOO ", "0  00", "0 0 0", "00  0", " 000 "],
     ["  1  ", " 11  ", "  1  ", "  1  ", "11111"],
     [" 222 ", "2   2", "   2 ", "  2  ", "22222"],
     ["3333 ", "    3", " 333 ", "    3", "3333 "],
     ["   4 ", "  44 ", " 4 4 ", "44444", "   4 "],
     ["55555", "5    ", "5555 ", "    5", "5555 "],
     ["   66", "  6  ", " 666 ", "6   6", " 666 "],
     ["77777", "    7", "   7 ", "   7 ", "  7  "],
     [" 888 ", "8   8", " 888 ", "8   8", " 888 "],
     [" 999 ", "9   9", " 999 ", "  9  ", "99   "]]
alphas
  = [["  A  ", " A A ", "AAAAA", "A   A", "A   A"],
     ["BBBB ", "B   B", "BBBB ", "B   B", "BBBB "],
     [" CCCC", "C    ", "C    ", "C    ", " CCCC"],
     ["DDDD ", "D   D", "D   D", "D   D", "DDDD "],
     ["EEEEE", "E    ", "EEEEE", "E    ", "EEEEE"],
     ["FFFFF", "F    ", "FFFF ", "F    ", "F    "],
     [" GGGG", "G    ", "G  GG", "G   G", " GGG "],
     ["H   H", "H   H", "HHHHH", "H   H", "H   H"],
     ["IIIII", "  I  ", "  I  ", "  I  ", "IIIII"],
     ["JJJJJ", "   J ", "   J ", "J  J ", " JJ  "],
     ["K   K", "K  K ", "KKK  ", "K  K ", "K   K"],
     ["L    ", "L    ", "L    ", "L    ", "LLLLL"],
     ["M   M", "MM MM", "M M M", "M   M", "M   M"],
     ["N   N", "NN  N", "N N N", "N  NN", "N   N"],
     [" OOO ", "O   O", "O   O", "O   O", " OOO "],
     ["PPPP ", "P   P", "PPPP ", "P    ", "P    "],
     [" QQQ ", "Q   Q", "Q Q Q", "Q  Q ", " QQ Q"],
     ["RRRR ", "R   R", "RRRR ", "R  R ", "R   R"],
     [" SSSS", "S    ", " SSS ", "    S", "SSSS "],
     ["TTTTT", "  T  ", "  T  ", "  T  ", "  T  "],
     ["U   U", "U   U", "U   U", "U   U", " UUU "],
     ["V   V", "V   V", "V   V", " V V ", "  V  "],
     ["W   W", "W   W", "W   W", "W W W", " W W "],
     ["X   X", " X X ", "  X  ", " X X ", "X   X"],
     ["Y   Y", " Y Y ", "  Y  ", "  Y  ", "  Y  "],
     ["ZZZZZ", "   Z ", "  Z  ", " Z   ", "ZZZZZ"]]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.cShow :: Dum.CSeq -> [Char]
Dum.cNil :: Dum.CSeq
Dum.cAppend :: Dum.CSeq -> Dum.CSeq -> Dum.CSeq
Dum.cIndent :: Int -> Dum.CSeq -> Dum.CSeq
Dum.cNL :: Dum.CSeq
Dum.cStr :: [Char] -> Dum.CSeq
Dum.cCh :: Char -> Dum.CSeq
Dum.cNil = Dum.CNil
Dum.cAppend cs1_aEr cs2_aEs = Dum.CAppend cs1_aEr cs2_aEs
Dum.cIndent n_aEt (!cs_aEu) = Dum.CIndent n_aEt cs_aEu
Dum.cNL = Dum.CNewline
Dum.cStr = Dum.CStr
Dum.cCh = Dum.CCh
Dum.cShow seq_aEv = Dum.flatten 0 True seq_aEv []
Dum.flatten ::
  Int -> Bool -> Dum.CSeq -> [(Int, Dum.CSeq)] -> String
Dum.flatten n_aEw nlp_aEx Dum.CNil seqs_aEy
  = Dum.flattenS nlp_aEx seqs_aEy
Dum.flatten
  (!n_aEz)
  nlp_aEA
  (Dum.CAppend seq1_aEB seq2_aEC)
  (!seqs_aED)
  = Dum.flatten n_aEz nlp_aEA seq1_aEB ((n_aEz, seq2_aEC) : seqs_aED)
Dum.flatten
  (!n_aEE)
  (!nlp_aEF)
  (!((!(Dum.CIndent (!n'_aEG) seq_aEH))))
  (!seqs_aEI)
  = Dum.flatten (n'_aEG + n_aEE) nlp_aEF seq_aEH seqs_aEI
Dum.flatten (!n_aFV) nlp_aFW (!Dum.CNewline) seqs_aFX
  = '\n' : Dum.flattenS True seqs_aFX
Dum.flatten n_aFY False (Dum.CStr s_aFZ) (!seqs_aG0)
  = s_aFZ ++ Dum.flattenS False seqs_aG0
Dum.flatten (!n_aG1) False ((!(Dum.CCh c_aG2))) (!seqs_aG3)
  = c_aG2 : Dum.flattenS False seqs_aG3
Dum.flatten n_aG4 True ((!(Dum.CStr s_aG5))) (!seqs_aG6)
  = Dum.mkIndent n_aG4 (s_aG5 ++ Dum.flattenS False seqs_aG6)
Dum.flatten n_aG7 True ((!(Dum.CCh c_aG8))) seqs_aG9
  = Dum.mkIndent n_aG7 (c_aG8 : Dum.flattenS False seqs_aG9)
Dum.flattenS :: Bool -> [(Int, Dum.CSeq)] -> String
Dum.flattenS (!nlp_aGa) [] = ""
Dum.flattenS nlp_aGb (!((col_aGc, seq_aGd) : (!seqs_aGe)))
  = Dum.flatten col_aGc nlp_aGb seq_aGd seqs_aGe
Dum.mkIndent :: Int -> String -> String
Dum.mkIndent (!0) (!s_aGf) = s_aGf
Dum.mkIndent n_aGg s_aGh
  = if (n_aGg >= 8) then
        '\t' : Dum.mkIndent (n_aGg - 8) s_aGh
    else
        ' ' : Dum.mkIndent (n_aGg - 1) s_aGh

data Dum.CSeq
  = Dum.CNil |
    Dum.CAppend Dum.CSeq Dum.CSeq |
    Dum.CIndent Int Dum.CSeq |
    Dum.CNewline |
    Dum.CStr [Char] |
    Dum.CCh Char


["cNil","cs1_aEr","cs2_aEs","n_aEt","cs_aEu","safebang@!cs_aEu","(!cs_aEu)","cNL","cStr","cCh","seq_aEv","n_aEw","nlp_aEx","CNil","seqs_aEy","n_aEz","!n_aEz","(!n_aEz)","nlp_aEA","seq1_aEB","seq2_aEC","CAppend seq1_aEB seq2_aEC","(CAppend seq1_aEB seq2_aEC)","seqs_aED","!seqs_aED","(!seqs_aED)","n_aEE","!n_aEE","(!n_aEE)","nlp_aEF","!nlp_aEF","(!nlp_aEF)","n'_aEG","safebang@!n'_aEG","(!n'_aEG)","seq_aEH","CIndent (!n'_aEG) seq_aEH","(CIndent (!n'_aEG) seq_aEH)","!(CIndent (!n'_aEG) seq_aEH)","(!(CIndent (!n'_aEG) seq_aEH))","((!(CIndent (!n'_aEG) seq_aEH)))","!((!(CIndent (!n'_aEG) seq_aEH)))","(!((!(CIndent (!n'_aEG) seq_aEH))))","seqs_aEI","!seqs_aEI","(!seqs_aEI)","n_aFV","!n_aFV","(!n_aFV)","nlp_aFW","CNewline","!CNewline","(!CNewline)","seqs_aFX","n_aFY","False","s_aFZ","CStr s_aFZ","(CStr s_aFZ)","seqs_aG0","!seqs_aG0","(!seqs_aG0)","n_aG1","!n_aG1","(!n_aG1)","False","c_aG2","CCh c_aG2","(CCh c_aG2)","!(CCh c_aG2)","(!(CCh c_aG2))","((!(CCh c_aG2)))","seqs_aG3","!seqs_aG3","(!seqs_aG3)","n_aG4","True","s_aG5","CStr s_aG5","(CStr s_aG5)","!(CStr s_aG5)","(!(CStr s_aG5))","((!(CStr s_aG5)))","seqs_aG6","!seqs_aG6","(!seqs_aG6)","n_aG7","True","c_aG8","CCh c_aG8","(CCh c_aG8)","!(CCh c_aG8)","(!(CCh c_aG8))","((!(CCh c_aG8)))","seqs_aG9","nlp_aGa","safebang@!nlp_aGa","(!nlp_aGa)","[]","nlp_aGb","col_aGc","seq_aGd","(col_aGc, seq_aGd)","seqs_aGe","!seqs_aGe","(!seqs_aGe)","(col_aGc, seq_aGd) : (!seqs_aGe)","((col_aGc, seq_aGd) : (!seqs_aGe))","!((col_aGc, seq_aGd) : (!seqs_aGe))","(!((col_aGc, seq_aGd) : (!seqs_aGe)))","0","!0","(!0)","s_aGf","investigate@!s_aGf","(!s_aGf)","n_aGg","s_aGh"]
{-# LANGUAGE BangPatterns #-}
module Dum where

cShow :: CSeq -> [Char]

cNil :: CSeq

cAppend :: CSeq -> CSeq -> CSeq

cIndent :: Int -> CSeq -> CSeq

cNL :: CSeq

cStr :: [Char] -> CSeq

cCh :: Char -> CSeq
cNil = CNil
cAppend cs1_aEr cs2_aEs = CAppend cs1_aEr cs2_aEs
cIndent n_aEt (!cs_aEu) = CIndent n_aEt cs_aEu
cNL = CNewline
cStr = CStr
cCh = CCh
cShow seq_aEv = flatten 0 True seq_aEv []

flatten :: Int -> Bool -> CSeq -> [(Int, CSeq)] -> String
flatten n_aEw nlp_aEx CNil seqs_aEy = flattenS nlp_aEx seqs_aEy
flatten (investigate@n_aEz) nlp_aEA (CAppend seq1_aEB seq2_aEC)
  (investigate@seqs_aED)
  = flatten n_aEz nlp_aEA seq1_aEB ((n_aEz, seq2_aEC) : seqs_aED)
flatten (investigate@n_aEE) (investigate@nlp_aEF)
  (investigate@((investigate@(CIndent (!n'_aEG) seq_aEH))))
  (investigate@seqs_aEI)
  = flatten (n'_aEG + n_aEE) nlp_aEF seq_aEH seqs_aEI
flatten (investigate@n_aFV) nlp_aFW (investigate@CNewline) seqs_aFX
  = '\n' : flattenS True seqs_aFX
flatten n_aFY False (CStr s_aFZ) (investigate@seqs_aG0)
  = s_aFZ ++ flattenS False seqs_aG0
flatten (investigate@n_aG1) False ((investigate@(CCh c_aG2)))
  (investigate@seqs_aG3) = c_aG2 : flattenS False seqs_aG3
flatten n_aG4 True ((investigate@(CStr s_aG5)))
  (investigate@seqs_aG6)
  = mkIndent n_aG4 (s_aG5 ++ flattenS False seqs_aG6)
flatten n_aG7 True ((investigate@(CCh c_aG8))) seqs_aG9
  = mkIndent n_aG7 (c_aG8 : flattenS False seqs_aG9)

flattenS :: Bool -> [(Int, CSeq)] -> String
flattenS (!nlp_aGa) [] = ""
flattenS nlp_aGb
  (investigate@((col_aGc, seq_aGd) : (investigate@seqs_aGe)))
  = flatten col_aGc nlp_aGb seq_aGd seqs_aGe

mkIndent :: Int -> String -> String
mkIndent (investigate@0) (investigate@s_aGf) = s_aGf
mkIndent n_aGg s_aGh
  = if (n_aGg >= 8) then '\t' : mkIndent (n_aGg - 8) s_aGh else
      ' ' : mkIndent (n_aGg - 1) s_aGh

data CSeq = CNil
          | CAppend CSeq CSeq
          | CIndent Int CSeq
          | CNewline
          | CStr [Char]
          | CCh Char
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.powers :: [[Integer]]
Dum.powers
  = [2 .. ] : map (zipWith (*) (head Dum.powers)) Dum.powers
Dum.neg_powers :: [[Integer]]
Dum.neg_powers
  = map
      (zipWith
         (\ (!n_aO3) (!x_aO4) -> if n_aO3 then x_aO4 else - x_aO4)
         (iterate not True))
      Dum.powers
Dum.pascal :: [[Integer]]
Dum.pascal
  = [1, 2, 1]
    : map
        (\ (!line_a1JM) -> zipWith (+) (line_a1JM ++ [0]) (0 : line_a1JM))
        Dum.pascal
Dum.bernoulli 0 = 1
Dum.bernoulli 1 = - (1 % 2)
Dum.bernoulli n_a1Tl | odd n_a1Tl = 0
Dum.bernoulli n_a1Tm
  = (- 1) % 2
    + sum
        [fromIntegral
           ((sum $ zipWith (*) powers_a1Tn (tail $ tail combs_a2c4))
            - fromIntegral k_a2c3)
         % fromIntegral (k_a2c3 + 1) |
           (!((!k_a2c3), combs_a2c4)) <- zip [2 .. n_a1Tm] Dum.pascal]
  where
      (!powers_a1Tn) = (Dum.neg_powers !! (n_a1Tm - 1))


["powers","neg_powers","n_aO3","investigate@!n_aO3","(!n_aO3)","x_aO4","!x_aO4","(!x_aO4)","pascal","line_a1JM","!line_a1JM","(!line_a1JM)","0","1","n_a1Tl","n_a1Tm","k_a2c3","!k_a2c3","(!k_a2c3)","combs_a2c4","((!k_a2c3), combs_a2c4)","!((!k_a2c3), combs_a2c4)","(!((!k_a2c3), combs_a2c4))","powers_a1Tn","!powers_a1Tn","(!powers_a1Tn)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Ratio
import System.Environment

powers :: [[Integer]]
powers = [2 ..] : map (zipWith (*) (head powers)) powers

neg_powers :: [[Integer]]
neg_powers
  = map
      (zipWith
         (\ (investigate@n_aO3) (investigate@x_aO4) ->
            if n_aO3 then x_aO4 else -x_aO4)
         (iterate not True))
      powers

pascal :: [[Integer]]
pascal
  = [1, 2, 1] :
      map
        (\ (investigate@line_a1JM) ->
           zipWith (+) (line_a1JM ++ [0]) (0 : line_a1JM))
        pascal
bernoulli 0 = 1
bernoulli 1 = -(1 % 2)
bernoulli n_a1Tl | odd n_a1Tl = 0
bernoulli n_a1Tm
  = (-1) % 2 +
      sum
        [fromIntegral
           ((sum $ zipWith (*) powers_a1Tn (tail $ tail combs_a2c4)) -
              fromIntegral k_a2c3)
           % fromIntegral (k_a2c3 + 1)
         |
         (investigate@((investigate@k_a2c3), combs_a2c4)) <- zip
                                                               [2 .. n_a1Tm]
                                                               pascal]
  where (investigate@powers_a1Tn) = (neg_powers !! (n_a1Tm - 1))
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.numchars :: [String] -> Int
Dum.numchars (!l_ayY) = sum $ map length l_ayY
Dum.expand (![]) = [""]
Dum.expand (!((!('<' : (!x_aRP))))) = Dum.numericRule x_aRP
Dum.expand ((!'[') : x_aRQ) = Dum.alphabeticRule x_aRQ
Dum.expand (!x_aRR) = Dum.constantRule x_aRR
Dum.constantRule (!((!(c_aRS : rest_aRT))))
  = [c_aRS : z_aRU | z_aRU <- Dum.expand rest_aRT]
Dum.alphabeticRule
  (!(a_aRV : ('-' : ((!b_aRW) : (!((!']') : rest_aRX))))))
  | a_aRV <= b_aRW
  = [c_a1NH : z_a1NI |
       (!c_a1NH) <- [a_aRV .. b_aRW], (!z_a1NI) <- Dum.expand rest_aRX]
  | otherwise
  = [c_a1Rp : z_a1Rq |
       c_a1Rp <- reverse [b_aRW .. a_aRV], z_a1Rq <- Dum.expand rest_aRX]
Dum.numericRule x_a1Rr
  = [pad_a1Rz (show i_a22Y) ++ z_a22Z |
       (!i_a22Y) <- if u_a1Rw < v_a1Rx then
                        [u_a1Rw .. v_a1Rx]
                    else
                        [u_a1Rw, u_a1Rw - 1 .. v_a1Rx],
       (!z_a22Z) <- Dum.expand s_a1Rv]
  where
      (p_a1Rs, _ : q_a1Rt) = span (/= '-') x_a1Rr
      ((!r_a1Ru), _ : (!s_a1Rv)) = span (/= '>') q_a1Rt
      ((!u_a1Rw), (!v_a1Rx)) = (mknum_a1Ry p_a1Rs, mknum_a1Ry r_a1Ru)
      mknum_a1Ry (!s_a1RB)
        = foldl
            (\ (!u_a1RC) c_a1RD -> u_a1RC * 10 + (ord c_a1RD - ord '0'))
            0
            s_a1RB
      pad_a1Rz s_a1SQ
        = ['0' | i_a1SR <- [1 .. (width_a1RA - (length s_a1SQ))]] ++ s_a1SQ
      width_a1RA = max (length (show u_a1Rw)) (length (show v_a1Rx))


["l_ayY","safebang@!l_ayY","(!l_ayY)","[]","![]","(![])","'<'","x_aRP","!x_aRP","(!x_aRP)","'<' : (!x_aRP)","('<' : (!x_aRP))","!('<' : (!x_aRP))","(!('<' : (!x_aRP)))","((!('<' : (!x_aRP))))","!((!('<' : (!x_aRP))))","(!((!('<' : (!x_aRP)))))","'['","!'['","(!'[')","x_aRQ","(!'[') : x_aRQ","((!'[') : x_aRQ)","x_aRR","!x_aRR","(!x_aRR)","c_aRS","rest_aRT","c_aRS : rest_aRT","(c_aRS : rest_aRT)","!(c_aRS : rest_aRT)","(!(c_aRS : rest_aRT))","((!(c_aRS : rest_aRT)))","!((!(c_aRS : rest_aRT)))","(!((!(c_aRS : rest_aRT))))","z_aRU","a_aRV","'-'","b_aRW","!b_aRW","(!b_aRW)","']'","!']'","(!']')","rest_aRX","(!']') : rest_aRX","((!']') : rest_aRX)","!((!']') : rest_aRX)","(!((!']') : rest_aRX))","(!b_aRW) : (!((!']') : rest_aRX))","((!b_aRW) : (!((!']') : rest_aRX)))","'-' : ((!b_aRW) : (!((!']') : rest_aRX)))","('-' : ((!b_aRW) : (!((!']') : rest_aRX))))","a_aRV : ('-' : ((!b_aRW) : (!((!']') : rest_aRX))))","(a_aRV : ('-' : ((!b_aRW) : (!((!']') : rest_aRX)))))","!(a_aRV : ('-' : ((!b_aRW) : (!((!']') : rest_aRX)))))","(!(a_aRV : ('-' : ((!b_aRW) : (!((!']') : rest_aRX))))))","c_a1NH","!c_a1NH","(!c_a1NH)","z_a1NI","!z_a1NI","(!z_a1NI)","c_a1Rp","z_a1Rq","x_a1Rr","i_a22Y","!i_a22Y","(!i_a22Y)","z_a22Z","!z_a22Z","(!z_a22Z)","p_a1Rs","_","q_a1Rt","_ : q_a1Rt","(p_a1Rs, _ : q_a1Rt)","r_a1Ru","!r_a1Ru","(!r_a1Ru)","_","s_a1Rv","!s_a1Rv","(!s_a1Rv)","_ : (!s_a1Rv)","((!r_a1Ru), _ : (!s_a1Rv))","u_a1Rw","!u_a1Rw","(!u_a1Rw)","v_a1Rx","!v_a1Rx","(!v_a1Rx)","((!u_a1Rw), (!v_a1Rx))","s_a1RB","!s_a1RB","(!s_a1RB)","u_a1RC","!u_a1RC","(!u_a1RC)","c_a1RD","s_a1SQ","i_a1SR","width_a1RA"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Char

numchars :: [String] -> Int
numchars (!l_ayY) = sum $ map length l_ayY
expand (investigate@[]) = [""]
expand (investigate@((investigate@('<' : (investigate@x_aRP)))))
  = numericRule x_aRP
expand ((investigate@'[') : x_aRQ) = alphabeticRule x_aRQ
expand (investigate@x_aRR) = constantRule x_aRR
constantRule (investigate@((investigate@(c_aRS : rest_aRT))))
  = [c_aRS : z_aRU | z_aRU <- expand rest_aRT]
alphabeticRule
  (investigate@(a_aRV :
                  ('-' :
                     ((investigate@b_aRW) :
                        (investigate@((investigate@']') : rest_aRX))))))
  | a_aRV <= b_aRW =
    [c_a1NH : z_a1NI | (investigate@c_a1NH) <- [a_aRV .. b_aRW],
     (investigate@z_a1NI) <- expand rest_aRX]
  | otherwise =
    [c_a1Rp : z_a1Rq | c_a1Rp <- reverse [b_aRW .. a_aRV],
     z_a1Rq <- expand rest_aRX]
numericRule x_a1Rr
  = [pad_a1Rz (show i_a22Y) ++ z_a22Z |
     (investigate@i_a22Y) <- if u_a1Rw < v_a1Rx then [u_a1Rw .. v_a1Rx]
                               else [u_a1Rw, u_a1Rw - 1 .. v_a1Rx],
     (investigate@z_a22Z) <- expand s_a1Rv]
  where (p_a1Rs, _ : q_a1Rt) = span (/= '-') x_a1Rr
        ((investigate@r_a1Ru), _ : (investigate@s_a1Rv))
          = span (/= '>') q_a1Rt
        ((investigate@u_a1Rw), (investigate@v_a1Rx))
          = (mknum_a1Ry p_a1Rs, mknum_a1Ry r_a1Ru)
        mknum_a1Ry (investigate@s_a1RB)
          = foldl
              (\ (investigate@u_a1RC) c_a1RD ->
                 u_a1RC * 10 + (ord c_a1RD - ord '0'))
              0
              s_a1RB
        pad_a1Rz s_a1SQ
          = ['0' | i_a1SR <- [1 .. (width_a1RA - (length s_a1SQ))]] ++ s_a1SQ
        width_a1RA = max (length (show u_a1Rw)) (length (show v_a1Rx))
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.f :: Int -> Complex Double
Dum.f (!n_a2Kk)
  = mkPolar 1 ((2 * pi) / fromIntegral n_a2Kk) ^ n_a2Kk


["n_a2Kk","!n_a2Kk","(!n_a2Kk)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Complex
import System.Environment

f :: Int -> Complex Double
f (investigate@n_a2Kk)
  = mkPolar 1 ((2 * pi) / fromIntegral n_a2Kk) ^ n_a2Kk
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.primes :: [Int]
Dum.primes = Dum.spiral Dum.wheels Dum.primes Dum.squares
Dum.spiral
  ((!(Dum.Wheel s_azc ms_azd ns_aze)) : ws_azf)
  ps_azg
  qs_azh
  = foldr turn0_azj (roll_azi s_azc) ns_aze
  where
      roll_azi o_azn
        = foldr
            (turn_azk o_azn)
            (foldr (turn_azk o_azn) (roll_azi (o_azn + s_azc)) ns_aze)
            ms_azd
      turn0_azj (!n_aTp) rs_aTq
        = if n_aTp < q_azm then n_aTp : rs_aTq else sp_azl
      turn_azk o_a1P9 n_a1Pa rs_a1Pb
        = let (!n'_a1Pc) = o_a1P9 + n_a1Pa
          in
            if n'_a1Pc == 2 || n'_a1Pc < q_azm then
                n'_a1Pc : rs_a1Pb
            else
                dropWhile (< n'_a1Pc) sp_azl
      sp_azl = Dum.spiral ws_azf (tail ps_azg) (tail qs_azh)
      q_azm = head qs_azh
Dum.squares :: [Int]
Dum.squares = [p_a1ST * p_a1ST | (!p_a1ST) <- Dum.primes]
Dum.wheels :: [Dum.Wheel]
Dum.wheels
  = Dum.Wheel 1 [1] []
    : zipWith3 Dum.nextSize Dum.wheels Dum.primes Dum.squares
Dum.nextSize
  (!(Dum.Wheel (!s_a1SU) ms_a1SV (!ns_a1SW)))
  (!p_a1SX)
  q_a1SY
  = Dum.Wheel (s_a1SU * p_a1SX) ms'_a1T1 ns'_a1T0
  where
      (xs_a1SZ, (!ns'_a1T0))
        = span
            (<= q_a1SY)
            (foldr turn0_a1T3 (roll_a1T2 (p_a1SX - 1) s_a1SU) ns_a1SW)
      ms'_a1T1 = foldr turn0_a1T3 xs_a1SZ ms_a1SV
      roll_a1T2 0 _ = []
      roll_a1T2 t_a1T5 (!o_a1T6)
        = foldr
            (turn_a1T4 o_a1T6)
            (foldr
               (turn_a1T4 o_a1T6)
               (roll_a1T2 (t_a1T5 - 1) (o_a1T6 + s_a1SU))
               ns_a1SW)
            ms_a1SV
      turn0_a1T3 n_a1T7 rs_a1T8
        = if n_a1T7 `mod` p_a1SX > 0 then n_a1T7 : rs_a1T8 else rs_a1T8
      turn_a1T4 o_a22M (!n_a22N) rs_a22O
        = let (!n'_a22P) = o_a22M + n_a22N
          in if n'_a22P `mod` p_a1SX > 0 then n'_a22P : rs_a22O else rs_a22O

data Dum.Wheel = Dum.Wheel Int [Int] [Int]


["primes","s_azc","ms_azd","ns_aze","Wheel s_azc ms_azd ns_aze","(Wheel s_azc ms_azd ns_aze)","!(Wheel s_azc ms_azd ns_aze)","(!(Wheel s_azc ms_azd ns_aze))","ws_azf","(!(Wheel s_azc ms_azd ns_aze)) : ws_azf","((!(Wheel s_azc ms_azd ns_aze)) : ws_azf)","ps_azg","qs_azh","o_azn","n_aTp","!n_aTp","(!n_aTp)","rs_aTq","o_a1P9","n_a1Pa","rs_a1Pb","n'_a1Pc","!n'_a1Pc","(!n'_a1Pc)","sp_azl","q_azm","squares","p_a1ST","!p_a1ST","(!p_a1ST)","wheels","s_a1SU","safebang@!s_a1SU","(!s_a1SU)","ms_a1SV","ns_a1SW","safebang@!ns_a1SW","(!ns_a1SW)","Wheel (!s_a1SU) ms_a1SV (!ns_a1SW)","(Wheel (!s_a1SU) ms_a1SV (!ns_a1SW))","!(Wheel (!s_a1SU) ms_a1SV (!ns_a1SW))","(!(Wheel (!s_a1SU) ms_a1SV (!ns_a1SW)))","p_a1SX","safebang@!p_a1SX","(!p_a1SX)","q_a1SY","xs_a1SZ","ns'_a1T0","!ns'_a1T0","(!ns'_a1T0)","(xs_a1SZ, (!ns'_a1T0))","ms'_a1T1","0","_","t_a1T5","o_a1T6","!o_a1T6","(!o_a1T6)","n_a1T7","rs_a1T8","o_a22M","n_a22N","!n_a22N","(!n_a22N)","rs_a22O","n'_a22P","!n'_a22P","(!n'_a22P)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.Environment

primes :: [Int]
primes = spiral wheels primes squares
spiral ((investigate@(Wheel s_azc ms_azd ns_aze)) : ws_azf) ps_azg
  qs_azh = foldr turn0_azj (roll_azi s_azc) ns_aze
  where roll_azi o_azn
          = foldr (turn_azk o_azn)
              (foldr (turn_azk o_azn) (roll_azi (o_azn + s_azc)) ns_aze)
              ms_azd
        turn0_azj (investigate@n_aTp) rs_aTq
          = if n_aTp < q_azm then n_aTp : rs_aTq else sp_azl
        turn_azk o_a1P9 n_a1Pa rs_a1Pb
          = let (investigate@n'_a1Pc) = o_a1P9 + n_a1Pa in
              if n'_a1Pc == 2 || n'_a1Pc < q_azm then n'_a1Pc : rs_a1Pb else
                dropWhile (< n'_a1Pc) sp_azl
        sp_azl = spiral ws_azf (tail ps_azg) (tail qs_azh)
        q_azm = head qs_azh

squares :: [Int]
squares = [p_a1ST * p_a1ST | (investigate@p_a1ST) <- primes]

wheels :: [Wheel]
wheels = Wheel 1 [1] [] : zipWith3 nextSize wheels primes squares
nextSize (investigate@(Wheel (!s_a1SU) ms_a1SV (!ns_a1SW)))
  (!p_a1SX) q_a1SY = Wheel (s_a1SU * p_a1SX) ms'_a1T1 ns'_a1T0
  where (xs_a1SZ, (investigate@ns'_a1T0))
          = span (<= q_a1SY)
              (foldr turn0_a1T3 (roll_a1T2 (p_a1SX - 1) s_a1SU) ns_a1SW)
        ms'_a1T1 = foldr turn0_a1T3 xs_a1SZ ms_a1SV
        roll_a1T2 0 _ = []
        roll_a1T2 t_a1T5 (investigate@o_a1T6)
          = foldr (turn_a1T4 o_a1T6)
              (foldr (turn_a1T4 o_a1T6)
                 (roll_a1T2 (t_a1T5 - 1) (o_a1T6 + s_a1SU))
                 ns_a1SW)
              ms_a1SV
        turn0_a1T3 n_a1T7 rs_a1T8
          = if n_a1T7 `mod` p_a1SX > 0 then n_a1T7 : rs_a1T8 else rs_a1T8
        turn_a1T4 o_a22M (investigate@n_a22N) rs_a22O
          = let (investigate@n'_a22P) = o_a22M + n_a22N in
              if n'_a22P `mod` p_a1SX > 0 then n'_a22P : rs_a22O else rs_a22O

data Wheel = Wheel Int [Int] [Int]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.suCC :: Int -> Int
Dum.suCC x_azj = x_azj + 1
Dum.isdivs :: Int -> Int -> Bool
Dum.isdivs (!n_aAw) (!x_aAx) = mod x_aAx n_aAw /= 0
Dum.the_filter :: [Int] -> [Int]
Dum.the_filter (!(n_a1FT : (!ns_a1FU)))
  = filter (Dum.isdivs n_a1FT) ns_a1FU
Dum.primes :: [Int]
Dum.primes = map head (iterate Dum.the_filter (iterate Dum.suCC 2))


["x_azj","n_aAw","!n_aAw","(!n_aAw)","x_aAx","safebang@!x_aAx","(!x_aAx)","n_a1FT","ns_a1FU","safebang@!ns_a1FU","(!ns_a1FU)","n_a1FT : (!ns_a1FU)","(n_a1FT : (!ns_a1FU))","!(n_a1FT : (!ns_a1FU))","(!(n_a1FT : (!ns_a1FU)))","primes"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.Environment

suCC :: Int -> Int
suCC x_azj = x_azj + 1

isdivs :: Int -> Int -> Bool
isdivs (investigate@n_aAw) (!x_aAx) = mod x_aAx n_aAw /= 0

the_filter :: [Int] -> [Int]
the_filter (investigate@(n_a1FT : (!ns_a1FU)))
  = filter (isdivs n_a1FT) ns_a1FU

primes :: [Int]
primes = map head (iterate the_filter (iterate suCC 2))
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
infix 8 Dum.^^^

Dum.int :: Dum.Nat -> Int
Dum.int Dum.Z = 0
Dum.int (Dum.S x_a1Gg) = 1 + Dum.int x_a1Gg
x_a1Gh Dum.^^^ Dum.Z = Dum.S Dum.Z
(!x_a1Gi) Dum.^^^ (Dum.S (!y_a1Gj))
  = x_a1Gi * (x_a1Gi Dum.^^^ y_a1Gj)

data Dum.Nat
  = Dum.Z | Dum.S Dum.Nat
  deriving (Eq, Ord, Show)

instance Num Dum.Nat where
  (!Dum.Z) + y_a1Gk = y_a1Gk
  (Dum.S (!x_a1Gl)) + y_a1Gm = Dum.S (x_a1Gl + y_a1Gm)
  (!x_a1Gn) * (!Dum.Z) = Dum.Z
  (!x_a1Go) * (Dum.S (!y_a1Gp)) = x_a1Go * y_a1Gp + x_a1Go
  fromInteger x_a1Gq
    = if x_a1Gq < 1 then Dum.Z else Dum.S (fromInteger (x_a1Gq - 1))


["Z","x_a1Gg","S x_a1Gg","(S x_a1Gg)","x_a1Gh","Z","x_a1Gi","!x_a1Gi","(!x_a1Gi)","y_a1Gj","!y_a1Gj","(!y_a1Gj)","S (!y_a1Gj)","(S (!y_a1Gj))","Z","!Z","(!Z)","y_a1Gk","x_a1Gl","safebang@!x_a1Gl","(!x_a1Gl)","S (!x_a1Gl)","(S (!x_a1Gl))","y_a1Gm","x_a1Gn","safebang@!x_a1Gn","(!x_a1Gn)","Z","!Z","(!Z)","x_a1Go","!x_a1Go","(!x_a1Go)","y_a1Gp","safebang@!y_a1Gp","(!y_a1Gp)","S (!y_a1Gp)","(S (!y_a1Gp))","x_a1Gq"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.Environment

infix 8 ^^^

int :: Nat -> Int
int Z = 0
int (S x_a1Gg) = 1 + int x_a1Gg
x_a1Gh ^^^ Z = S Z
(investigate@x_a1Gi) ^^^ (S (investigate@y_a1Gj))
  = x_a1Gi * (x_a1Gi ^^^ y_a1Gj)

data Nat = Z
         | S Nat
         deriving (Eq, Ord, Show)

instance Num Nat where
        (investigate@Z) + y_a1Gk = y_a1Gk
        (S (!x_a1Gl)) + y_a1Gm = S (x_a1Gl + y_a1Gm)
        (!x_a1Gn) * (investigate@Z) = Z
        (investigate@x_a1Go) * (S (!y_a1Gp)) = x_a1Go * y_a1Gp + x_a1Go
        fromInteger x_a1Gq
          = if x_a1Gq < 1 then Z else S (fromInteger (x_a1Gq - 1))
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.nsoln nq_asx
  = length (gen_asz nq_asx)
  where
      safe_asy :: Int -> Int -> [Int] -> Bool
      safe_asy x_azE d_azF (![]) = True
      safe_asy (!x_azG) d_azH ((!q_azI) : l_azJ)
        = x_azG /= q_azI
          &&
            x_azG /= q_azI + d_azH
            && x_azG /= q_azI - d_azH && safe_asy x_azG (d_azH + 1) l_azJ
      gen_asz :: Int -> [[Int]]
      gen_asz 0 = [[]]
      gen_asz n_a1wE
        = [(q_a1wG : b_a1wF) |
             b_a1wF <- gen_asz (n_a1wE - 1),
             q_a1wG <- [1 .. nq_asx],
             safe_asy q_a1wG 1 b_a1wF]


["nq_asx","x_azE","d_azF","[]","![]","(![])","x_azG","!x_azG","(!x_azG)","d_azH","q_azI","!q_azI","(!q_azI)","l_azJ","(!q_azI) : l_azJ","((!q_azI) : l_azJ)","0","n_a1wE","b_a1wF","q_a1wG"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.Environment
nsoln nq_asx = length (gen_asz nq_asx)
  where safe_asy :: Int -> Int -> [Int] -> Bool
        safe_asy x_azE d_azF (investigate@[]) = True
        safe_asy (investigate@x_azG) d_azH ((investigate@q_azI) : l_azJ)
          = x_azG /= q_azI && x_azG /= q_azI + d_azH && x_azG /= q_azI -
              d_azH
              && safe_asy x_azG (d_azH + 1) l_azJ
        
        gen_asz :: Int -> [[Int]]
        gen_asz 0 = [[]]
        gen_asz n_a1wE
          = [(q_a1wG : b_a1wF) | b_a1wF <- gen_asz (n_a1wE - 1),
             q_a1wG <- [1 .. nq_asx], safe_asy q_a1wG 1 b_a1wF]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.three_partitions :: Int -> [(Int, Int, Int)]
Dum.three_partitions m_aJe
  = [(i_aST, j_aU2, k_aU3) |
       (!i_aST) <- [0 .. (div m_aJe 3)],
       j_aU2 <- [i_aST .. (div (m_aJe - i_aST) 2)],
       (!k_aU3) <- [m_aJe - (i_aST + j_aU2)]]
Dum.remainders (![]) = []
Dum.remainders ((!(r_aU4 : (!rs_aU5))))
  = (r_aU4 : rs_aU5) : (Dum.remainders rs_aU5)
Dum.radical_generator :: Int -> Array Int [Dum.Radical]
Dum.radical_generator n_aU6
  = radicals_aU7
  where
      radicals_aU7
        = array
            (0, n_aU6)
            ((0, [Dum.H])
             : [(j_aU8, Dum.rads_of_size_n radicals_aU7 j_aU8) |
                  (!j_aU8) <- [1 .. n_aU6]])
Dum.rads_of_size_n ::
  Array Int [Dum.Radical] -> Int -> [Dum.Radical]
Dum.rads_of_size_n radicals_aU9 n_aUa
  = [(Dum.C ri_aUe rj_a1Pp rk_a1Pr) |
       (!((!i_aUb), j_aUc, (!k_aUd))) <- (Dum.three_partitions
                                            (n_aUa - 1)),
       (!((!((!ri_aUe) : (!ris_aUf))))) <- (Dum.remainders
                                              (radicals_aU9 ! i_aUb)),
       ((!((!rj_a1Pp) : (!rjs_a1Pq)))) <- (Dum.remainders
                                             (if (i_aUb == j_aUc) then
                                                  (ri_aUe : ris_aUf)
                                              else
                                                  radicals_aU9 ! j_aUc)),
       (!rk_a1Pr) <- (if (j_aUc == k_aUd) then
                          (rj_a1Pp : rjs_a1Pq)
                      else
                          radicals_aU9 ! k_aUd)]
Dum.bcp_generator ::
  Array Int [Dum.Radical] -> Int -> [Dum.Paraffin]
Dum.bcp_generator radicals_a1Ps n_a1Pt
  = if (odd n_a1Pt) then
        []
    else
        [(Dum.BCP r1_a1Pu r2_a1Pw) |
           (!((!((!r1_a1Pu) : r1s_a1Pv)))) <- (Dum.remainders
                                                 (radicals_a1Ps ! (div n_a1Pt 2))),
           r2_a1Pw <- (r1_a1Pu : r1s_a1Pv)]
Dum.four_partitions :: Int -> [(Int, Int, Int, Int)]
Dum.four_partitions m_a1Px
  = [(i_a1Py, j_a1Pz, k_a1PA, l_a1PB) |
       i_a1Py <- [0 .. (div m_a1Px 4)],
       (!j_a1Pz) <- [i_a1Py .. (div (m_a1Px - i_a1Py) 3)],
       (!k_a1PA) <- [(max
                        j_a1Pz
                        (ceiling ((fromIntegral m_a1Px) / (fromInteger 2)) - i_a1Py
                         - j_a1Pz)) .. (div (m_a1Px - i_a1Py - j_a1Pz) 2)],
       l_a1PB <- [(m_a1Px - (i_a1Py + j_a1Pz + k_a1PA))]]
Dum.ccp_generator ::
  Array Int [Dum.Radical] -> Int -> [Dum.Paraffin]
Dum.ccp_generator radicals_a1PC n_a1PD
  = [(Dum.CCP ri_a1PI rj_a1PK rk_a1PM rl_a1PO) |
       (!((!i_a1PE), j_a1PF, k_a1PG, l_a1PH)) <- (Dum.four_partitions
                                                    (n_a1PD - 1)),
       (!((!(ri_a1PI : ris_a1PJ)))) <- (Dum.remainders
                                          (radicals_a1PC ! i_a1PE)),
       (!(rj_a1PK : (!rjs_a1PL))) <- (Dum.remainders
                                        (if (i_a1PE == j_a1PF) then
                                             (ri_a1PI : ris_a1PJ)
                                         else
                                             radicals_a1PC ! j_a1PF)),
       (rk_a1PM : (!rks_a1PN)) <- (Dum.remainders
                                     (if (j_a1PF == k_a1PG) then
                                          (rj_a1PK : rjs_a1PL)
                                      else
                                          radicals_a1PC ! k_a1PG)),
       rl_a1PO <- (if (k_a1PG == l_a1PH) then
                       (rk_a1PM : rks_a1PN)
                   else
                       radicals_a1PC ! l_a1PH)]
Dum.bcp_until :: Int -> [Int]
Dum.bcp_until n_a1PP
  = [length (Dum.bcp_generator radicals_a1PQ j_a1PR) |
       (!j_a1PR) <- [1 .. n_a1PP]]
  where
      (!radicals_a1PQ) = Dum.radical_generator (div n_a1PP 2)
Dum.ccp_until :: Int -> [Int]
Dum.ccp_until (!n_a28z)
  = [length (Dum.ccp_generator radicals_a28A j_a28B) |
       j_a28B <- [1 .. n_a28z]]
  where
      (!radicals_a28A) = Dum.radical_generator (div n_a28z 2)
Dum.paraffins_until :: Int -> [Int]
Dum.paraffins_until (!n_a28C)
  = [length (Dum.bcp_generator radicals_a28D j_a28E)
     + length (Dum.ccp_generator radicals_a28D j_a28E) |
       j_a28E <- [1 .. n_a28C]]
  where
      (!radicals_a28D) = Dum.radical_generator (div n_a28C 2)

data Dum.Radical
  = Dum.H | Dum.C Dum.Radical Dum.Radical Dum.Radical
data Dum.Paraffin
  = Dum.BCP Dum.Radical Dum.Radical |
    Dum.CCP Dum.Radical Dum.Radical Dum.Radical Dum.Radical


["m_aJe","i_aST","!i_aST","(!i_aST)","j_aU2","k_aU3","!k_aU3","(!k_aU3)","[]","![]","(![])","r_aU4","rs_aU5","safebang@!rs_aU5","(!rs_aU5)","r_aU4 : (!rs_aU5)","(r_aU4 : (!rs_aU5))","!(r_aU4 : (!rs_aU5))","(!(r_aU4 : (!rs_aU5)))","((!(r_aU4 : (!rs_aU5))))","n_aU6","radicals_aU7","j_aU8","!j_aU8","(!j_aU8)","radicals_aU9","n_aUa","i_aUb","!i_aUb","(!i_aUb)","j_aUc","k_aUd","safebang@!k_aUd","(!k_aUd)","((!i_aUb), j_aUc, (!k_aUd))","!((!i_aUb), j_aUc, (!k_aUd))","(!((!i_aUb), j_aUc, (!k_aUd)))","ri_aUe","safebang@!ri_aUe","(!ri_aUe)","ris_aUf","safebang@!ris_aUf","(!ris_aUf)","(!ri_aUe) : (!ris_aUf)","((!ri_aUe) : (!ris_aUf))","!((!ri_aUe) : (!ris_aUf))","(!((!ri_aUe) : (!ris_aUf)))","((!((!ri_aUe) : (!ris_aUf))))","!((!((!ri_aUe) : (!ris_aUf))))","(!((!((!ri_aUe) : (!ris_aUf)))))","rj_a1Pp","safebang@!rj_a1Pp","(!rj_a1Pp)","rjs_a1Pq","safebang@!rjs_a1Pq","(!rjs_a1Pq)","(!rj_a1Pp) : (!rjs_a1Pq)","((!rj_a1Pp) : (!rjs_a1Pq))","!((!rj_a1Pp) : (!rjs_a1Pq))","(!((!rj_a1Pp) : (!rjs_a1Pq)))","((!((!rj_a1Pp) : (!rjs_a1Pq))))","rk_a1Pr","!rk_a1Pr","(!rk_a1Pr)","radicals_a1Ps","n_a1Pt","r1_a1Pu","safebang@!r1_a1Pu","(!r1_a1Pu)","r1s_a1Pv","(!r1_a1Pu) : r1s_a1Pv","((!r1_a1Pu) : r1s_a1Pv)","!((!r1_a1Pu) : r1s_a1Pv)","(!((!r1_a1Pu) : r1s_a1Pv))","((!((!r1_a1Pu) : r1s_a1Pv)))","!((!((!r1_a1Pu) : r1s_a1Pv)))","(!((!((!r1_a1Pu) : r1s_a1Pv))))","r2_a1Pw","m_a1Px","i_a1Py","j_a1Pz","!j_a1Pz","(!j_a1Pz)","k_a1PA","!k_a1PA","(!k_a1PA)","l_a1PB","radicals_a1PC","n_a1PD","i_a1PE","!i_a1PE","(!i_a1PE)","j_a1PF","k_a1PG","l_a1PH","((!i_a1PE), j_a1PF, k_a1PG, l_a1PH)","!((!i_a1PE), j_a1PF, k_a1PG, l_a1PH)","(!((!i_a1PE), j_a1PF, k_a1PG, l_a1PH))","ri_a1PI","ris_a1PJ","ri_a1PI : ris_a1PJ","(ri_a1PI : ris_a1PJ)","!(ri_a1PI : ris_a1PJ)","(!(ri_a1PI : ris_a1PJ))","((!(ri_a1PI : ris_a1PJ)))","!((!(ri_a1PI : ris_a1PJ)))","(!((!(ri_a1PI : ris_a1PJ))))","rj_a1PK","rjs_a1PL","safebang@!rjs_a1PL","(!rjs_a1PL)","rj_a1PK : (!rjs_a1PL)","(rj_a1PK : (!rjs_a1PL))","!(rj_a1PK : (!rjs_a1PL))","(!(rj_a1PK : (!rjs_a1PL)))","rk_a1PM","rks_a1PN","safebang@!rks_a1PN","(!rks_a1PN)","rk_a1PM : (!rks_a1PN)","(rk_a1PM : (!rks_a1PN))","rl_a1PO","n_a1PP","j_a1PR","!j_a1PR","(!j_a1PR)","radicals_a1PQ","!radicals_a1PQ","(!radicals_a1PQ)","n_a28z","!n_a28z","(!n_a28z)","j_a28B","radicals_a28A","!radicals_a28A","(!radicals_a28A)","n_a28C","!n_a28C","(!n_a28C)","j_a28E","radicals_a28D","!radicals_a28D","(!radicals_a28D)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import Data.Array
import System.Environment

three_partitions :: Int -> [(Int, Int, Int)]
three_partitions m_aJe
  = [(i_aST, j_aU2, k_aU3) |
     (investigate@i_aST) <- [0 .. (div m_aJe 3)],
     j_aU2 <- [i_aST .. (div (m_aJe - i_aST) 2)],
     (investigate@k_aU3) <- [m_aJe - (i_aST + j_aU2)]]
remainders (investigate@[]) = []
remainders ((investigate@(r_aU4 : (!rs_aU5))))
  = (r_aU4 : rs_aU5) : (remainders rs_aU5)

radical_generator :: Int -> Array Int [Radical]
radical_generator n_aU6 = radicals_aU7
  where radicals_aU7
          = array (0, n_aU6)
              ((0, [H]) :
                 [(j_aU8, rads_of_size_n radicals_aU7 j_aU8) |
                  (investigate@j_aU8) <- [1 .. n_aU6]])

rads_of_size_n :: Array Int [Radical] -> Int -> [Radical]
rads_of_size_n radicals_aU9 n_aUa
  = [(C ri_aUe rj_a1Pp rk_a1Pr) |
     (investigate@((investigate@i_aUb), j_aUc,
                   (!k_aUd))) <- (three_partitions (n_aUa - 1)),
     (investigate@((investigate@((!ri_aUe) :
                                   (!ris_aUf))))) <- (remainders (radicals_aU9 ! i_aUb)),
     ((investigate@((!rj_a1Pp) : (!rjs_a1Pq)))) <- (remainders
                                                      (if (i_aUb == j_aUc) then (ri_aUe : ris_aUf)
                                                         else radicals_aU9 ! j_aUc)),
     (investigate@rk_a1Pr) <- (if (j_aUc == k_aUd) then
                                 (rj_a1Pp : rjs_a1Pq) else radicals_aU9 ! k_aUd)]

bcp_generator :: Array Int [Radical] -> Int -> [Paraffin]
bcp_generator radicals_a1Ps n_a1Pt
  = if (odd n_a1Pt) then [] else
      [(BCP r1_a1Pu r2_a1Pw) |
       (investigate@((investigate@((!r1_a1Pu) :
                                     r1s_a1Pv)))) <- (remainders (radicals_a1Ps ! (div n_a1Pt 2))),
       r2_a1Pw <- (r1_a1Pu : r1s_a1Pv)]

four_partitions :: Int -> [(Int, Int, Int, Int)]
four_partitions m_a1Px
  = [(i_a1Py, j_a1Pz, k_a1PA, l_a1PB) |
     i_a1Py <- [0 .. (div m_a1Px 4)],
     (investigate@j_a1Pz) <- [i_a1Py .. (div (m_a1Px - i_a1Py) 3)],
     (investigate@k_a1PA) <- [(max j_a1Pz
                                 (ceiling ((fromIntegral m_a1Px) / (fromInteger 2)) - i_a1Py -
                                    j_a1Pz))
                              .. (div (m_a1Px - i_a1Py - j_a1Pz) 2)],
     l_a1PB <- [(m_a1Px - (i_a1Py + j_a1Pz + k_a1PA))]]

ccp_generator :: Array Int [Radical] -> Int -> [Paraffin]
ccp_generator radicals_a1PC n_a1PD
  = [(CCP ri_a1PI rj_a1PK rk_a1PM rl_a1PO) |
     (investigate@((investigate@i_a1PE), j_a1PF, k_a1PG,
                   l_a1PH)) <- (four_partitions (n_a1PD - 1)),
     (investigate@((investigate@(ri_a1PI : ris_a1PJ)))) <- (remainders
                                                              (radicals_a1PC ! i_a1PE)),
     (investigate@(rj_a1PK : (!rjs_a1PL))) <- (remainders
                                                 (if (i_a1PE == j_a1PF) then (ri_a1PI : ris_a1PJ)
                                                    else radicals_a1PC ! j_a1PF)),
     (rk_a1PM : (!rks_a1PN)) <- (remainders
                                   (if (j_a1PF == k_a1PG) then (rj_a1PK : rjs_a1PL) else
                                      radicals_a1PC ! k_a1PG)),
     rl_a1PO <- (if (k_a1PG == l_a1PH) then (rk_a1PM : rks_a1PN) else
                   radicals_a1PC ! l_a1PH)]

bcp_until :: Int -> [Int]
bcp_until n_a1PP
  = [length (bcp_generator radicals_a1PQ j_a1PR) |
     (investigate@j_a1PR) <- [1 .. n_a1PP]]
  where (investigate@radicals_a1PQ)
          = radical_generator (div n_a1PP 2)

ccp_until :: Int -> [Int]
ccp_until (investigate@n_a28z)
  = [length (ccp_generator radicals_a28A j_a28B) |
     j_a28B <- [1 .. n_a28z]]
  where (investigate@radicals_a28A)
          = radical_generator (div n_a28z 2)

paraffins_until :: Int -> [Int]
paraffins_until (investigate@n_a28C)
  = [length (bcp_generator radicals_a28D j_a28E) +
       length (ccp_generator radicals_a28D j_a28E)
     | j_a28E <- [1 .. n_a28C]]
  where (investigate@radicals_a28D)
          = radical_generator (div n_a28C 2)

data Radical = H
             | C Radical Radical Radical

data Paraffin = BCP Radical Radical
              | CCP Radical Radical Radical Radical
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.primes :: [Int]
Dum.primes = Dum.sieve Dum.wheels Dum.primes Dum.squares
Dum.sieve (!(Dum.Wheel s_azL ns_azM : ws_azN)) ps_azO qs_azP
  = [n'_a1AC |
       (!o_a1AA) <- s_azL
                    : [s_azL * 2, s_azL * 3 .. (head ps_azO - 1) * s_azL],
       n_a1AB <- ns_azM,
       (!n'_a1AC) <- [n_a1AB + o_a1AA],
       noFactor_azQ n'_a1AC]
    ++ Dum.sieve ws_azN (tail ps_azO) (tail qs_azP)
  where
      (!noFactor_azQ)
        = if s_azL <= 2 then const True else Dum.notDivBy ps_azO qs_azP
Dum.notDivBy (p_a1AD : ps_a1AE) ((!q_a1AF) : qs_a1AG) (!n_a1AH)
  = q_a1AF > n_a1AH
    || n_a1AH `mod` p_a1AD > 0 && Dum.notDivBy ps_a1AE qs_a1AG n_a1AH
Dum.squares :: [Int]
Dum.squares = [p_a1Kl * p_a1Kl | (!p_a1Kl) <- Dum.primes]
Dum.wheels :: [Dum.Wheel]
Dum.wheels
  = Dum.Wheel 1 [1] : zipWith Dum.nextSize Dum.wheels Dum.primes
Dum.nextSize (!(Dum.Wheel s_a1Km ns_a1Kn)) (!p_a1Ko)
  = Dum.Wheel (s_a1Km * p_a1Ko) ns'_a1Kp
  where
      (!ns'_a1Kp)
        = [n'_a1Ks |
             o_a1Kq <- [0, s_a1Km .. (p_a1Ko - 1) * s_a1Km],
             (!n_a1Kr) <- ns_a1Kn,
             (!n'_a1Ks) <- [n_a1Kr + o_a1Kq],
             n'_a1Ks `mod` p_a1Ko > 0]

data Dum.Wheel = Dum.Wheel Int [Int]


["primes","s_azL","ns_azM","Wheel s_azL ns_azM","ws_azN","Wheel s_azL ns_azM : ws_azN","(Wheel s_azL ns_azM : ws_azN)","!(Wheel s_azL ns_azM : ws_azN)","(!(Wheel s_azL ns_azM : ws_azN))","ps_azO","qs_azP","o_a1AA","!o_a1AA","(!o_a1AA)","n_a1AB","n'_a1AC","!n'_a1AC","(!n'_a1AC)","noFactor_azQ","!noFactor_azQ","(!noFactor_azQ)","p_a1AD","ps_a1AE","p_a1AD : ps_a1AE","(p_a1AD : ps_a1AE)","q_a1AF","safebang@!q_a1AF","(!q_a1AF)","qs_a1AG","(!q_a1AF) : qs_a1AG","((!q_a1AF) : qs_a1AG)","n_a1AH","safebang@!n_a1AH","(!n_a1AH)","squares","p_a1Kl","!p_a1Kl","(!p_a1Kl)","wheels","s_a1Km","ns_a1Kn","Wheel s_a1Km ns_a1Kn","(Wheel s_a1Km ns_a1Kn)","!(Wheel s_a1Km ns_a1Kn)","(!(Wheel s_a1Km ns_a1Kn))","p_a1Ko","!p_a1Ko","(!p_a1Ko)","ns'_a1Kp","!ns'_a1Kp","(!ns'_a1Kp)","o_a1Kq","n_a1Kr","!n_a1Kr","(!n_a1Kr)","n'_a1Ks","!n'_a1Ks","(!n'_a1Ks)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.Environment

primes :: [Int]
primes = sieve wheels primes squares
sieve (investigate@(Wheel s_azL ns_azM : ws_azN)) ps_azO qs_azP
  = [n'_a1AC |
     (investigate@o_a1AA) <- s_azL :
                               [s_azL * 2, s_azL * 3 .. (head ps_azO - 1) * s_azL],
     n_a1AB <- ns_azM, (investigate@n'_a1AC) <- [n_a1AB + o_a1AA],
     noFactor_azQ n'_a1AC]
      ++ sieve ws_azN (tail ps_azO) (tail qs_azP)
  where (investigate@noFactor_azQ)
          = if s_azL <= 2 then const True else notDivBy ps_azO qs_azP
notDivBy (p_a1AD : ps_a1AE) ((!q_a1AF) : qs_a1AG) (!n_a1AH)
  = q_a1AF > n_a1AH || n_a1AH `mod` p_a1AD > 0 &&
      notDivBy ps_a1AE qs_a1AG n_a1AH

squares :: [Int]
squares = [p_a1Kl * p_a1Kl | (investigate@p_a1Kl) <- primes]

wheels :: [Wheel]
wheels = Wheel 1 [1] : zipWith nextSize wheels primes
nextSize (investigate@(Wheel s_a1Km ns_a1Kn)) (investigate@p_a1Ko)
  = Wheel (s_a1Km * p_a1Ko) ns'_a1Kp
  where (investigate@ns'_a1Kp)
          = [n'_a1Ks | o_a1Kq <- [0, s_a1Km .. (p_a1Ko - 1) * s_a1Km],
             (investigate@n_a1Kr) <- ns_a1Kn,
             (investigate@n'_a1Ks) <- [n_a1Kr + o_a1Kq],
             n'_a1Ks `mod` p_a1Ko > 0]

data Wheel = Wheel Int [Int]
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.tak :: Int -> Int -> Int -> Int
Dum.tak (!x_azj) y_azk (!z_azl)
  = if not (y_azk < x_azj) then
        z_azl
    else
        Dum.tak
          (Dum.tak (x_azj - 1) y_azk z_azl)
          (Dum.tak (y_azk - 1) z_azl x_azj)
          (Dum.tak (z_azl - 1) x_azj y_azk)


["x_azj","!x_azj","(!x_azj)","y_azk","z_azl","safebang@!z_azl","(!z_azl)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.Environment

tak :: Int -> Int -> Int -> Int
tak (investigate@x_azj) y_azk (!z_azl)
  = if not (y_azk < x_azj) then z_azl else
      tak (tak (x_azj - 1) y_azk z_azl) (tak (y_azk - 1) z_azl x_azj)
        (tak (z_azl - 1) x_azj y_azk)
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.nfib :: Double -> Double
Dum.nfib n_az1
  = if n_az1 <= 1 then
        1
    else
        Dum.nfib (n_az1 - 1) + Dum.nfib (n_az1 - 2) + 1


["n_az1"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.Environment

nfib :: Double -> Double
nfib n_az1
  = if n_az1 <= 1 then 1 else nfib (n_az1 - 1) + nfib (n_az1 - 2) + 1
[1 of 1] Compiling Dum              ( Dum.hs, Dum.o )

==================== Renamer ====================
Dum.integrate1D :: Double -> Double -> (Double -> Double) -> Double
Dum.integrate1D (!l_azc) u_azd (!f_aze)
  = let (!d_azf) = (u_azd - l_azc) / 8.0
    in
      d_azf
      * sum
          [(f_aze l_azc) * 0.5, f_aze (l_azc + d_azf),
           f_aze (l_azc + (2.0 * d_azf)), f_aze (l_azc + (3.0 * d_azf)),
           f_aze (l_azc + (4.0 * d_azf)), f_aze (u_azd - (3.0 * d_azf)),
           f_aze (u_azd - (2.0 * d_azf)), f_aze (u_azd - d_azf),
           (f_aze u_azd) * 0.5]
Dum.integrate2D l1_a12X u1_a12Y (!l2_a12Z) (!u2_a130) f_a131
  = Dum.integrate1D
      l2_a12Z
      u2_a130
      (\ (!y_a132)
         -> Dum.integrate1D
              l1_a12X u1_a12Y (\ x_a133 -> f_a131 x_a133 y_a132))
Dum.zark u_a134 v_a135
  = Dum.integrate2D
      0.0 u_a134 0.0 v_a135 (\ x_a136 -> (\ y_a137 -> x_a136 * y_a137))
Dum.ints = [1.0 .. ] :: [Double]
Dum.zarks = zipWith Dum.zark Dum.ints (map (2.0 *) Dum.ints)
Dum.rtotals
  = head Dum.zarks : zipWith (+) (tail Dum.zarks) Dum.rtotals
Dum.rtotal n_a16O = Dum.rtotals !! n_a16O
Dum.is = map (^ 4) Dum.ints
Dum.itotals = head Dum.is : zipWith (+) (tail Dum.is) Dum.itotals
Dum.itotal (!n_a16P) = Dum.itotals !! n_a16P
Dum.es = map (^ 2) (zipWith (-) Dum.rtotals Dum.itotals)
Dum.etotal (!n_a16Q) = sum (take n_a16Q Dum.es)


["l_azc","!l_azc","(!l_azc)","u_azd","f_aze","safebang@!f_aze","(!f_aze)","d_azf","!d_azf","(!d_azf)","l1_a12X","u1_a12Y","l2_a12Z","!l2_a12Z","(!l2_a12Z)","u2_a130","!u2_a130","(!u2_a130)","f_a131","y_a132","safebang@!y_a132","(!y_a132)","x_a133","u_a134","v_a135","x_a136","y_a137","ints","zarks","rtotals","n_a16O","is","itotals","n_a16P","!n_a16P","(!n_a16P)","es","n_a16Q","!n_a16Q","(!n_a16Q)"]
{-# LANGUAGE BangPatterns #-}
module Dum where
import System.Environment

integrate1D :: Double -> Double -> (Double -> Double) -> Double
integrate1D (investigate@l_azc) u_azd (!f_aze)
  = let (investigate@d_azf) = (u_azd - l_azc) / 8.0 in
      d_azf *
        sum
          [(f_aze l_azc) * 0.5, f_aze (l_azc + d_azf),
           f_aze (l_azc + (2.0 * d_azf)), f_aze (l_azc + (3.0 * d_azf)),
           f_aze (l_azc + (4.0 * d_azf)), f_aze (u_azd - (3.0 * d_azf)),
           f_aze (u_azd - (2.0 * d_azf)), f_aze (u_azd - d_azf),
           (f_aze u_azd) * 0.5]
integrate2D l1_a12X u1_a12Y (investigate@l2_a12Z)
  (investigate@u2_a130) f_a131
  = integrate1D l2_a12Z u2_a130
      (\ (!y_a132) ->
         integrate1D l1_a12X u1_a12Y (\ x_a133 -> f_a131 x_a133 y_a132))
zark u_a134 v_a135
  = integrate2D 0.0 u_a134 0.0 v_a135
      (\ x_a136 -> (\ y_a137 -> x_a136 * y_a137))
ints = [1.0 ..] :: [Double]
zarks = zipWith zark ints (map (2.0 *) ints)
rtotals = head zarks : zipWith (+) (tail zarks) rtotals
rtotal n_a16O = rtotals !! n_a16O
is = map (^ 4) ints
itotals = head is : zipWith (+) (tail is) itotals
itotal (investigate@n_a16P) = itotals !! n_a16P
es = map (^ 2) (zipWith (-) rtotals itotals)
etotal (investigate@n_a16Q) = sum (take n_a16Q es)
