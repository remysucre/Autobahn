START PROG /h/ywang30/nofib/shootout/n-body/
STARTLOG
ENDLOG
START PROG /h/ywang30/nofib/shootout/fasta/
STARTLOG
ENDLOG
START PROG /h/ywang30/nofib/shootout/binary-trees/
STARTLOG
ENDLOG
START PROG /h/ywang30/nofib/shootout/pidigits/
STARTLOG
ENDLOG
START PROG /h/ywang30/nofib/shootout/fannkuch-redux/
STARTLOG
ENDLOG
START PROG /h/ywang30/nofib/real/reptile/
STARTLOG
["x1_apZ","y1_aq0","x2_aq1","safebang@!x2_aq1","(!x2_aq1)","y2_aq2","[x1_apZ, y1_aq0, (!x2_aq1), y2_aq2]","f_aq3","x1_aq4","y1_aq5","x2_aq6","y2_aq7","safebang@!y2_aq7","(!y2_aq7)","[x1_aq4, y1_aq5, x2_aq6, (!y2_aq7)]","f_aq8","x1_aq9","safebang@!x1_aq9","(!x1_aq9)","y1_aqa","safebang@!y1_aqa","(!y1_aqa)","x2_aqb","safebang@!x2_aqb","(!x2_aqb)","y2_aqc","safebang@!y2_aqc","(!y2_aqc)","[(!x1_aq9), (!y1_aqa), (!x2_aqb), (!y2_aqc)]","![(!x1_aq9), (!y1_aqa), (!x2_aqb), (!y2_aqc)]","(![(!x1_aq9), (!y1_aqa), (!x2_aqb), (!y2_aqc)])","toright","down","x_arb","!x_arb","(!x_arb)","y_arc","x_ard","safebang@!x_ard","(!x_ard)","y_are","safebang@!y_are","(!y_are)","xymax","m_arf","x_arg","m_arh","safebang@!m_arh","(!m_arh)","x_ari","m_arj","safebang@!m_arj","(!m_arj)","x_ark","m_arl","x_arm","!x_arm","(!x_arm)","c1_arn","c2_aro","c3_arp","safebang@!c3_arp","(!c3_arp)","c4_arq","[c1_arn, c2_aro, (!c3_arp), c4_arq]","ss_arr","!ss_arr","(!ss_arr)","_","_","_","0","coords_ars","_","_","!_","(!_)","0","_","coords_art","x_aru","!x_aru","(!x_aru)","y_arv","c_arw","!c_arw","(!c_arw)","r_arx","!r_arx","(!r_arx)","coords_ary","!coords_ary","(!coords_ary)","x_arz","y_arA","0","!0","(!0)","coords_arB","x_arC","y_arD","n_arE","!n_arE","(!n_arE)","coords_arF","y'_arG","x_arH","safebang@!x_arH","(!x_arH)","y_arI","safebang@!y_arI","(!y_arI)","0","coords_arJ","x_arK","y_arL","n_arM","!n_arM","(!n_arM)","coords_arN","!coords_arN","(!coords_arN)","x'_arO"]
module Geomfuns
       (mapx, mapy, col, row, lrinvert, antirotate, place, rotatecw,
        tbinvert, tile, t4, xymax)
       where
import Mgrfuns
import Drawfuns

swapxy :: [Int] -> [Int]
swapxy [x1_apZ, y1_aq0, (!x2_aq1), y2_aq2]
  = [y1_aq0, x1_apZ, y2_aq2, x2_aq1]

mapx, mapy :: (Int -> Int) -> [Int] -> [Int]
mapx f_aq3 [x1_aq4, y1_aq5, x2_aq6, (!y2_aq7)]
  = [f_aq3 x1_aq4, y1_aq5, f_aq3 x2_aq6, y2_aq7]
mapy f_aq8 (norecord@[(!x1_aq9), (!y1_aqa), (!x2_aqb), (!y2_aqc)])
  = [x1_aq9, f_aq8 y1_aqa, x2_aqb, f_aq8 y2_aqc]

toright, down :: Int -> [[Int]] -> [[Int]]
toright = map . mapx . (+)
down = map . mapy . (+)

origin :: Int -> Int -> [[Int]] -> [[Int]]
origin (norecord@x_arb) y_arc = (toright x_arb) . (down y_arc)

place :: Int -> Int -> [[Int]] -> [Char]
place (!x_ard) (!y_are) = drawlines . (origin x_ard y_are)

xymax :: Int
xymax = 72

lrinvert, tbinvert, rotatecw, antirotate ::
          Int -> [[Int]] -> [[Int]]
lrinvert m_arf = map (mapx (\ x_arg -> m_arf - x_arg))
tbinvert (!m_arh) = map (mapy (\ x_ari -> m_arh - x_ari))
rotatecw (!m_arj)
  = map (swapxy . (mapy (\ x_ark -> m_arj - x_ark)))
antirotate m_arl
  = map (swapxy . (mapx (\ (norecord@x_arm) -> m_arl - x_arm)))

t4 :: [[[Int]]] -> [[Int]]
t4 [c1_arn, c2_aro, (!c3_arp), c4_arq]
  = c1_arn ++ toright ss_arr c2_aro ++ down ss_arr c3_arp ++
      (down ss_arr . toright ss_arr) c4_arq
  where (norecord@ss_arr) = xymax

tile :: Int -> Int -> Int -> Int -> [[Int]] -> [Char]
tile _ _ _ 0 coords_ars = ""
tile _ (norecord@_) 0 _ coords_art = ""
tile (norecord@x_aru) y_arv (norecord@c_arw) (norecord@r_arx)
  (norecord@coords_ary)
  = col x_aru y_arv r_arx coords_ary ++
      row (x_aru + 2 * xymax) y_arv (c_arw - 1) coords_ary
      ++
      tile (x_aru + 2 * xymax) (y_arv + 2 * xymax) (c_arw - 1)
        (r_arx - 1)
        coords_ary

col, row :: Int -> Int -> Int -> [[Int]] -> [Char]
col x_arz y_arA (norecord@0) coords_arB = ""
col x_arC y_arD (norecord@n_arE) coords_arF
  = place x_arC y_arD coords_arF ++
      col x_arC y'_arG (n_arE - 1) coords_arF
  where y'_arG = y_arD + (2 * xymax)
row (!x_arH) (!y_arI) 0 coords_arJ = ""
row x_arK y_arL (norecord@n_arM) (norecord@coords_arN)
  = place x_arK y_arL coords_arN ++
      row x'_arO y_arL (n_arM - 1) coords_arN
  where x'_arO = x_arK + (2 * xymax)
ENDLOG
STARTLOG
ENDLOG
STARTLOG
ENDLOG
STARTLOG
["n_ap3","x1_ap4","y1_ap5","safebang@!y1_ap5","(!y1_ap5)","x2_ap6","y2_ap7","[x1_ap4, (!y1_ap5), x2_ap6, y2_ap7]","x0_ap8","y0_ap9","x1_apa","y1_apb","safebang@!y1_apb","(!y1_apb)","[x0_ap8, y0_ap9, x1_apa, (!y1_apb)]","m_apc","n_aCH","!n_aCH","(!n_aCH)","0","!0","(!0)","n_aCI","!n_aCI","(!n_aCI)","n_aDH","safebang@!n_aDH","(!n_aDH)","x_aDI","safebang@!x_aDI","(!x_aDI)","y_aDJ","safebang@!y_aDJ","(!y_aDJ)","n_aDK","x_aDL","safebang@!x_aDL","(!x_aDL)","y_aDM","x_aDN","safebang@!x_aDN","(!x_aDN)","y_aDO","safebang@!y_aDO","(!y_aDO)","f_aDP","safebang@!f_aDP","(!f_aDP)","undraw","drawlines","_","!_","(!_)","[]","_","!_","(!_)","_","_","[]","![]","(![])","f_aJX","x_aJY","xs_aJZ","!xs_aJZ","(!xs_aJZ)","x_aJY : (!xs_aJZ)","(x_aJY : (!xs_aJZ))","ys_aK0","!ys_aK0","(!ys_aK0)","xor_aK1","yor_aK2","xgap_aK3","ygap_aK4","xlength_aK5","ylength_aK6","drawf_aK7","safebang@!drawf_aK7","(!drawf_aK7)","x0list_aK8","y0list_aK9","orig_aKb","gap_aKc","safebang@!gap_aKc","(!gap_aKc)","len_aKd","n_aKf","safebang@!n_aKf","(!n_aKf)"]
module Drawfuns
       (drawdot, grid, squ, circ, gowin, rectangle, fillrect, undo,
        undraw, drawlines)
       where
import Mgrfuns
import Diff

gowin :: Int -> [Char]
gowin n_ap3 = selectwin n_ap3 ++ setmode 7 ++ setmode 8

rectangle :: [Int] -> [Char]
rectangle [x1_ap4, (!y1_ap5), x2_ap6, y2_ap7]
  = line [x1_ap4, y1_ap5, x2_ap6, y1_ap5] ++
      line [x2_ap6, y1_ap5, x2_ap6, y2_ap7]
      ++ line [x1_ap4, y1_ap5, x1_ap4, y2_ap7]
      ++ line [x1_ap4, y2_ap7, x2_ap6, y2_ap7]

fillrect :: [Int] -> [Char]
fillrect [x0_ap8, y0_ap9, x1_apa, (!y1_apb)]
  = shade_ape (diff x0_ap8 x1_apa)
  where m_apc = min x0_ap8 x1_apa
        vline_apd (norecord@n_aCH) = line [n_aCH, y0_ap9, n_aCH, y1_apb]
        shade_ape (norecord@0) = vline_apd m_apc
        shade_ape (norecord@n_aCI)
          = vline_apd (m_apc + n_aCI) ++ shade_ape (n_aCI - 1)

squ :: Int -> Int -> Int -> [Char]
squ (!n_aDH) (!x_aDI) (!y_aDJ)
  = rectangle [x_aDI, y_aDJ, x_aDI + n_aDH, y_aDJ + n_aDH]

circ :: Int -> Int -> Int -> [Char]
circ n_aDK (!x_aDL) y_aDM = circle [x_aDL, y_aDM, n_aDK]

drawdot :: Int -> Int -> [Char]
drawdot (!x_aDN) (!y_aDO)
  = fillrect [x_aDN - 1, y_aDO - 1, x_aDN + 1, y_aDO + 1]

undo :: [Char] -> [Char]
undo (!f_aDP) = func 0 ++ f_aDP ++ func 15

undraw :: [Int] -> [Char]
undraw = undo . line

drawlines :: [[Int]] -> [Char]
drawlines = concat . map line
allpairs (norecord@_) [] (norecord@_) = []
allpairs _ _ (norecord@[]) = []
allpairs f_aJX (x_aJY : (norecord@xs_aJZ)) (norecord@ys_aK0)
  = map (f_aJX x_aJY) ys_aK0 ++ allpairs f_aJX xs_aJZ ys_aK0

grid ::
     Int ->
       Int ->
         Int -> Int -> Int -> Int -> (Int -> Int -> [a_aoV]) -> [a_aoV]
grid xor_aK1 yor_aK2 xgap_aK3 ygap_aK4 xlength_aK5 ylength_aK6
  (!drawf_aK7) = concat (allpairs drawf_aK7 x0list_aK8 y0list_aK9)
  where x0list_aK8 = gridlist_aKa xor_aK1 xgap_aK3 xlength_aK5
        y0list_aK9 = gridlist_aKa yor_aK2 ygap_aK4 ylength_aK6
        gridlist_aKa orig_aKb (!gap_aKc) len_aKd
          = take len_aKd (gridlist'_aKe orig_aKb)
          where gridlist'_aKe (!n_aKf)
                  = n_aKf : gridlist'_aKe (n_aKf + gap_aKc)
ENDLOG
STARTLOG
["x_an7","y_an8","(x_an7, y_an8)","!(x_an7, y_an8)","(!(x_an7, y_an8))","u_an9","v_ana","d_anb","0","n2_aBD","n1_aBE","0","!0","(!0)","n1_aBF","n2_aBG","x_aKN","safebang@!x_aKN","(!x_aKN)","y_aKO","safebang@!y_aKO","(!y_aKO)","((!x_aKN), (!y_aKO))","!((!x_aKN), (!y_aKO))","(!((!x_aKN), (!y_aKO)))","u_aKP","safebang@!u_aKP","(!u_aKP)","v_aKQ","safebang@!v_aKQ","(!v_aKQ)","((!u_aKP), (!v_aKQ))","!((!u_aKP), (!v_aKQ))","(!((!u_aKP), (!v_aKQ)))","x_aKR","y_aKS","safebang@!y_aKS","(!y_aKS)","(x_aKR, (!y_aKS))","u_aKT","safebang@!u_aKT","(!u_aKT)","v_aKU","safebang@!v_aKU","(!v_aKU)","((!u_aKT), (!v_aKU))","!((!u_aKT), (!v_aKU))","(!((!u_aKT), (!v_aKU)))","x_aKV","y_aKW","(x_aKV, y_aKW)","!(x_aKV, y_aKW)","(!(x_aKV, y_aKW))","u_aKX","v_aKY","safebang@!v_aKY","(!v_aKY)","(u_aKX, (!v_aKY))","x_aKZ","y_aL0","safebang@!y_aL0","(!y_aL0)","(x_aKZ, (!y_aL0))","u_aL1","v_aL2","safebang@!v_aL2","(!v_aL2)","(u_aL1, (!v_aL2))","x_aL3","y_aL4","safebang@!y_aL4","(!y_aL4)","(x_aL3, (!y_aL4))","u_aL5","v_aL6","(u_aL5, v_aL6)","a_aL7","b_aL8","(a_aL7, b_aL8)","!(a_aL7, b_aL8)","(!(a_aL7, b_aL8))","x_aL9","y_aLa","(x_aL9, y_aLa)","x_aLb","safebang@!x_aLb","(!x_aLb)","y_aLc","((!x_aLb), y_aLc)","!((!x_aLb), y_aLc)","(!((!x_aLb), y_aLc))","x_aLd","safebang@!x_aLd","(!x_aLd)","y_aLe","safebang@!y_aLe","(!y_aLe)","((!x_aLd), (!y_aLe))","n_aTD"]
module Rational
       (radd, rsub, rmul, rdiv, rmin, rabs, intval, show_rat, torat) where

norm :: (Int, Int) -> (Int, Int)
norm (norecord@(x_an7, y_an8))
  = (u_an9 `div` d_anb, v_ana `div` d_anb)
  where u_an9 = if y_an8 > 0 then x_an7 else -x_an7
        v_ana = abs y_an8
        d_anb = gcd_anc (abs u_an9) v_ana
        
        gcd_anc :: Int -> Int -> Int
        gcd_anc 0 n2_aBD = n2_aBD
        gcd_anc n1_aBE (norecord@0) = n1_aBE
        gcd_anc n1_aBF n2_aBG
          = if n1_aBF < n2_aBG then gcd_anc n1_aBF (n2_aBG `mod` n1_aBF) else
              gcd_anc (n1_aBF `mod` n2_aBG) n2_aBG

radd, rsub, rmul, rdiv :: (Int, Int) -> (Int, Int) -> (Int, Int)
radd (norecord@((!x_aKN), (!y_aKO)))
  (norecord@((!u_aKP), (!v_aKQ)))
  = norm (x_aKN * v_aKQ + u_aKP * y_aKO, y_aKO * v_aKQ)
rsub (x_aKR, (!y_aKS)) (norecord@((!u_aKT), (!v_aKU)))
  = norm (x_aKR * v_aKU - u_aKT * y_aKS, y_aKS * v_aKU)
rmul (norecord@(x_aKV, y_aKW)) (u_aKX, (!v_aKY))
  = norm (x_aKV * u_aKX, y_aKW * v_aKY)
rdiv (x_aKZ, (!y_aL0)) (u_aL1, (!v_aL2))
  = norm (x_aKZ * v_aL2, y_aL0 * u_aL1)
rmin (x_aL3, (!y_aL4)) (u_aL5, v_aL6)
  = if a_aL7 > 0 then (u_aL5, v_aL6) else (x_aL3, y_aL4)
  where (norecord@(a_aL7, b_aL8))
          = rsub (x_aL3, y_aL4) (u_aL5, v_aL6)

rabs :: (Int, Int) -> (Int, Int)
rabs (x_aL9, y_aLa)
  = if x_aL9 < 0 then (-x_aL9, y_aLa) else (x_aL9, y_aLa)

intval :: (Int, Int) -> Int
intval (norecord@((!x_aLb), y_aLc)) = x_aLb `div` y_aLc

show_rat :: (Int, Int) -> [Char]
show_rat ((!x_aLd), (!y_aLe)) = show x_aLd ++ "/" ++ show y_aLe

torat :: Int -> (Int, Int)
torat n_aTD = (n_aTD, 1)
ENDLOG
STARTLOG
["prompt_an1","endp_an2","transact_an3","safebang@!transact_an3","(!transact_an3)","state_an5","inpt_an6","response_an7","newstate_an8","restofinput_an9","(response_an7, newstate_an8, restofinput_an9)"]
module Interstate (inter) where

inter ::
      (a_amR -> [b_amS]) ->
        (a_amR -> c_amT -> Bool) ->
          (a_amR -> c_amT -> ([b_amS], a_amR, c_amT)) ->
            (a_amR -> c_amT -> [b_amS])
inter prompt_an1 endp_an2 (!transact_an3) = interprog_an4
  where interprog_an4 state_an5 inpt_an6
          = prompt_an1 state_an5 ++
              if endp_an2 state_an5 inpt_an6 then [] else
                response_an7 ++ interprog_an4 newstate_an8 restofinput_an9
          where (response_an7, newstate_an8, restofinput_an9)
                  = transact_an3 state_an5 inpt_an6
ENDLOG
STARTLOG
["helpsetup","helpend","helpdraw","helptile","helpalter","helptsave","helptclear","helptget","helpt4","helpquit","helpbt","helppic","helpdesign","helpdsave","helpdclear","helpdget","inithelp","errmes","endmes"]
module Help
       (helpend, helpdraw, helptile, helpalter, helptsave, helptclear,
        helptget, helpt4, helpquit, helpbt, helppic, helpdesign, helpdsave,
        helpdclear, helpdget, inithelp, errmes)
       where
import Layout
import Mgrfuns

helpsetup, helpend :: [Char]

helpdraw, helpdsave, helpdclear, helpdget :: [Char]

helptile, helpalter, helptsave, helptclear, helptget, helpt4 ::
          [Char]

helpquit, helpbt, helppic, helpdesign :: [Char]
helpsetup = textregion helptextarea ++ font 8
helpend = cleara helptextarea ++ font 13
helpdraw
  = "This button puts you in drawing mode.\n" ++
      "Lines can be drawn in the STAMP DESIGN \n"
      ++ "area by holding down the middle button,\n"
      ++ "and deleted by clicking\n"
      ++ "with the right one.\n"
      ++ "\nLittle circles will appear if a line\n"
      ++ "touches the edge of the square.\n"
      ++ "These indicate positions on all the sides\n"
      ++ "that would contact that line in each of\n"
      ++ "the possible orientations of the print.\n"
      ++ "Unless special effects are being sought,\n"
      ++ "the recommendation is that all little\n"
      ++ "circles be attached to a line.\n"
      ++ endmes
helptile
  = "In this mode, orientations of the print\n" ++
      "can be placed in the TILE DESIGN area\n"
      ++ "to create a 64 X 64 big tile\n"
      ++ "\nUse the right button to select a print\n"
      ++ "and the middle button to place it.\n"
      ++ "\nWithin the tiling area the right button\n"
      ++ "may also be used to delete a square\n"
      ++ "\nTo rotate or invert squares within\n"
      ++ "the big tile it may be more convenient\n"
      ++ "to use the ALTER mode."
      ++ endmes
helpalter
  = "In ALTER mode, squares within the\n" ++
      "big tile can be adjusted.\n"
      ++ "The middle button causes them to \n"
      ++ "rotate clockwise.\n"
      ++ "The right button causes them to\n"
      ++ "invert."
      ++ endmes
helptsave = "Sorry, SAVE is temporarily inoperative." ++ endmes
helptclear
  = "This CLEAR button clears the TILE DESIGN\n" ++
      "region and draws an empty grid."
      ++ endmes
helptget = "Sorry, GET is temporarily inoperative." ++ endmes
helpt4
  = "The T4 button tiles the whole big tile\n" ++
      "with the pattern of the four squares\n"
      ++ "in the top left hand corner\n"
      ++ endmes
helpquit
  = "\n\n\nClicking on QUIT allows you\n" ++
      "to leave the program.\n"
      ++ endmes
helpbt
  = "\n\n\nWithin the TILE DESIGN area,\n" ++
      "a big tile, based on orientations of\n"
      ++ "a print design, can be built.\n"
      ++ "\nUsing TILE mode the right button\n"
      ++ "will select from a palette at the bottom\n"
      ++ "of the screen, and the middle button will\n"
      ++ "place the selection within the big tile.\n"
      ++ "Within the area the right button will\n"
      ++ "delete squares.\n"
      ++ "\nUsing ALTER mode the right button will\n"
      ++ "invert squares, and the middle button \n"
      ++ "will rotate them."
      ++ endmes
helppic
  = "\nThese boxes show the eight possible\n" ++
      "orientations of the print that is\n"
      ++ "to be used in tiling\n"
      ++ "\nWhen in tiling mode, clicking with the\n"
      ++ "right button over one of these\n"
      ++ "will make it the \"current selection\".\n"
      ++ "Clicking with the middle button in\n"
      ++ "the TILE DESIGN grid, will put that\n"
      ++ "orientation of the print at that place"
      ++ endmes
helpdesign
  = "\n\n\nThis is the area in which to design \nyour print.\n" ++
      "\nDraw lines by holding down the\n middle button.\n"
      ++ "Delete lines by clicking with the\n right button.\n"
      ++ "\n\nA print that has previously been saved\n"
      ++ "can be restored by clicking on GET\n"
      ++ "then typing in the filename at the prompt.\n"
      ++ endmes
helpdsave = "Sorry, SAVE is temporarily inoperative." ++ endmes
helpdclear
  = "\n\n\nThis clears the PRINT DESIGN grid.\n" ++
      "The print currently being worked on\n"
      ++ "will be lost, unless it has been\n"
      ++ "explicitly SAVEd first\n"
      ++ endmes
helpdget = "Sorry, GET is temporarily inoperative." ++ endmes

inithelp, errmes, endmes :: [Char]
inithelp
  = helpsetup ++ clear ++
      "\n\n\n\nTo find out the use of a particular\n"
      ++ "menu button or region of the screen, \n"
      ++ "click over the item you wish to\n"
      ++ "investigate.\n"
errmes
  = "\n\n\nYou have clicked over an area \n" ++
      "of no particular interest.\n"
      ++ endmes
endmes
  = "\n\n PRESS RETURN TO RETURN TO THE PROGRAM\n" ++
      "OR CLICK SOMEWHERE ELSE TO FIND OUT MORE\n"
ENDLOG
STARTLOG
ENDLOG
STARTLOG
["n_an0","a_anZ","b_ao0","safebang@!b_ao0","(!b_ao0)","n_aBt","a_aBv","b_aBw","m_aBx","s_aBy"]
module Diff (diff, bcroot, square) where

square :: Int -> Int
square n_an0 = n_an0 * n_an0

diff :: Int -> Int -> Int
diff a_anZ (!b_ao0)
  = if a_anZ > b_ao0 then a_anZ - b_ao0 else b_ao0 - a_anZ

bcroot :: Int -> Int
bcroot n_aBt = root'_aBu 0 n_aBt
  where root'_aBu a_aBv b_aBw
          = if a_aBv + 1 >= b_aBw then b_aBw else
              if s_aBy < n_aBt then root'_aBu m_aBx b_aBw else
                if n_aBt < s_aBy then root'_aBu a_aBv m_aBx else m_aBx
          where m_aBx = (a_aBv + b_aBw) `div` 2
                s_aBy = m_aBx * m_aBx
ENDLOG
STARTLOG
["_","_","'q'","!'q'","(!'q')","_","(!'q') : _","((!'q') : _)","_","((!'q') : _) : _","(((!'q') : _) : _)","_","!_","(!_)","[]","_","_","!_","(!_)","dlist_aTd","safebang@!dlist_aTd","(!dlist_aTd)","sel_aTe","safebang@!sel_aTe","(!sel_aTe)","tilist_aTf","safebang@!tilist_aTf","(!tilist_aTf)","((!dlist_aTd), (!sel_aTe), (!tilist_aTf))","!((!dlist_aTd), (!sel_aTe), (!tilist_aTf))","(!((!dlist_aTd), (!sel_aTe), (!tilist_aTf)))","'m'","!'m'","(!'m')","'s'","'a'","!'a'","(!'a')","' '","rest_aTg","lazydmd@!rest_aTg","(!rest_aTg)","' ' : (!rest_aTg)","(' ' : (!rest_aTg))","!(' ' : (!rest_aTg))","(!(' ' : (!rest_aTg)))","(!'a') : (!(' ' : (!rest_aTg)))","((!'a') : (!(' ' : (!rest_aTg))))","!((!'a') : (!(' ' : (!rest_aTg))))","(!((!'a') : (!(' ' : (!rest_aTg)))))","'s' : (!((!'a') : (!(' ' : (!rest_aTg)))))","('s' : (!((!'a') : (!(' ' : (!rest_aTg))))))","(!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg))))))","((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))","!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))","(!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg))))))))","inpt_aTh","(!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n  inpt_aTh","((!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n   inpt_aTh)","!((!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n    inpt_aTh)","(!((!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n     inpt_aTh))","((!((!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n      inpt_aTh)))","x_aTi","y_aTj","!y_aTj","(!y_aTj)","[x_aTi, (!y_aTj)]","fun_aTl","dlist_aTm","!dlist_aTm","(!dlist_aTm)","sel_aTn","tilist_aTo","((!dlist_aTm), sel_aTn, tilist_aTo)","!((!dlist_aTm), sel_aTn, tilist_aTo)","(!((!dlist_aTm), sel_aTn, tilist_aTo))","'m'","'s'","'b'","' '","rest_aTp","' ' : rest_aTp","(' ' : rest_aTp)","'b' : (' ' : rest_aTp)","('b' : (' ' : rest_aTp))","!('b' : (' ' : rest_aTp))","(!('b' : (' ' : rest_aTp)))","'s' : (!('b' : (' ' : rest_aTp)))","('s' : (!('b' : (' ' : rest_aTp))))","'m' : ('s' : (!('b' : (' ' : rest_aTp))))","('m' : ('s' : (!('b' : (' ' : rest_aTp)))))","inpt_aTq","lazydmd@!inpt_aTq","(!inpt_aTq)","('m' : ('s' : (!('b' : (' ' : rest_aTp))))) : (!inpt_aTq)","(('m' : ('s' : (!('b' : (' ' : rest_aTp))))) : (!inpt_aTq))","!(('m' : ('s' : (!('b' : (' ' : rest_aTp))))) : (!inpt_aTq))","(!(('m' : ('s' : (!('b' : (' ' : rest_aTp))))) : (!inpt_aTq)))","x_aTr","!x_aTr","(!x_aTr)","y_aTs","!y_aTs","(!y_aTs)","[(!x_aTr), (!y_aTs)]","dlist_aTt","sel_aTu","!sel_aTu","(!sel_aTu)","tilist_aTv","(dlist_aTt, (!sel_aTu), tilist_aTv)","'m'","'s'","!'s'","(!'s')","'c'","' '","rest_aTw","lazydmd@!rest_aTw","(!rest_aTw)","' ' : (!rest_aTw)","(' ' : (!rest_aTw))","!(' ' : (!rest_aTw))","(!(' ' : (!rest_aTw)))","'c' : (!(' ' : (!rest_aTw)))","('c' : (!(' ' : (!rest_aTw))))","(!'s') : ('c' : (!(' ' : (!rest_aTw))))","((!'s') : ('c' : (!(' ' : (!rest_aTw)))))","'m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))","('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw))))))","inpt_aTx","lazydmd@!inpt_aTx","(!inpt_aTx)","('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) : (!inpt_aTx)","(('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) : (!inpt_aTx))","!(('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) : (!inpt_aTx))","(!(('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) :\n     (!inpt_aTx)))","((!(('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) :\n      (!inpt_aTx))))","x_aTy","y_aTz","[x_aTy, y_aTz]","![x_aTy, y_aTz]","(![x_aTy, y_aTz])","fun_aTB","!fun_aTB","(!fun_aTB)","state_aTC","'m'","'s'","!'s'","(!'s')","'d'","!'d'","(!'d')","' '","!' '","(!' ')","rest_aTD","lazydmd@!rest_aTD","(!rest_aTD)","(!' ') : (!rest_aTD)","((!' ') : (!rest_aTD))","(!'d') : ((!' ') : (!rest_aTD))","((!'d') : ((!' ') : (!rest_aTD)))","(!'s') : ((!'d') : ((!' ') : (!rest_aTD)))","((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))","'m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))","('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD)))))","!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD)))))","(!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))))","((!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD)))))))","inpt_aTE","lazydmd@!inpt_aTE","(!inpt_aTE)","((!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))))) :\n  (!inpt_aTE)","(((!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))))) :\n   (!inpt_aTE))","x_aTF","y_aTG","[x_aTF, y_aTG]","![x_aTF, y_aTG]","(![x_aTF, y_aTG])","str_aTJ","!str_aTJ","(!str_aTJ)","out_aTI","dlist_aTK","!dlist_aTK","(!dlist_aTK)","sel_aTL","!sel_aTL","(!sel_aTL)","tilist_aTM","((!dlist_aTK), (!sel_aTL), tilist_aTM)","'c'","'s'","!'s'","(!'s')","' '","rest_aTN","lazydmd@!rest_aTN","(!rest_aTN)","' ' : (!rest_aTN)","(' ' : (!rest_aTN))","!(' ' : (!rest_aTN))","(!(' ' : (!rest_aTN)))","(!'s') : (!(' ' : (!rest_aTN)))","((!'s') : (!(' ' : (!rest_aTN))))","!((!'s') : (!(' ' : (!rest_aTN))))","(!((!'s') : (!(' ' : (!rest_aTN)))))","'c' : (!((!'s') : (!(' ' : (!rest_aTN)))))","('c' : (!((!'s') : (!(' ' : (!rest_aTN))))))","inpt_aTO","('c' : (!((!'s') : (!(' ' : (!rest_aTN)))))) : inpt_aTO","(('c' : (!((!'s') : (!(' ' : (!rest_aTN)))))) : inpt_aTO)","x0_aTV","safebang@!x0_aTV","(!x0_aTV)","y0_aTW","x1_aTX","safebang@!x1_aTX","(!x1_aTX)","y1_aTY","[(!x0_aTV), y0_aTW, (!x1_aTX), y1_aTY]","![(!x0_aTV), y0_aTW, (!x1_aTX), y1_aTY]","(![(!x0_aTV), y0_aTW, (!x1_aTX), y1_aTY])","nstoilrest_aTQ","safebang@!nstoilrest_aTQ","(!nstoilrest_aTQ)","wnstoilrest_aTR","!wnstoilrest_aTR","(!wnstoilrest_aTR)","cssr_aTS","!cssr_aTS","(!cssr_aTS)","newele_aTT","linecircs_aTU","lazydmd@!linecircs_aTU","(!linecircs_aTU)","dlist_aU5","!dlist_aU5","(!dlist_aU5)","sel_aU6","tilist_aU7","!tilist_aU7","(!tilist_aU7)","((!dlist_aU5), sel_aU6, (!tilist_aU7))","!((!dlist_aU5), sel_aU6, (!tilist_aU7))","(!((!dlist_aU5), sel_aU6, (!tilist_aU7)))","'r'","'o'","'t'","' '","rest_aU8","' ' : rest_aU8","(' ' : rest_aU8)","'t' : (' ' : rest_aU8)","('t' : (' ' : rest_aU8))","'o' : ('t' : (' ' : rest_aU8))","('o' : ('t' : (' ' : rest_aU8)))","'r' : ('o' : ('t' : (' ' : rest_aU8)))","('r' : ('o' : ('t' : (' ' : rest_aU8))))","!('r' : ('o' : ('t' : (' ' : rest_aU8))))","(!('r' : ('o' : ('t' : (' ' : rest_aU8)))))","((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))","!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))","(!((!('r' : ('o' : ('t' : (' ' : rest_aU8)))))))","inpt_aU9","(!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9","((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9)","!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9)","(!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9))","((!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9)))","!((!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9)))","(!((!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) :\n        inpt_aU9))))","stoilrest_aUa","wcoords_aUb","oldas_aUc","!oldas_aUc","(!oldas_aUc)","newtilist_aUd","lsrest_aUe","dlist_aUf","!dlist_aUf","(!dlist_aUf)","sel_aUg","!sel_aUg","(!sel_aUg)","tilist_aUh","!tilist_aUh","(!tilist_aUh)","((!dlist_aUf), (!sel_aUg), (!tilist_aUh))","'p'","!'p'","(!'p')","'u'","!'u'","(!'u')","'t'","!'t'","(!'t')","' '","!' '","(!' ')","rest_aUi","(!' ') : rest_aUi","((!' ') : rest_aUi)","(!'t') : ((!' ') : rest_aUi)","((!'t') : ((!' ') : rest_aUi))","(!'u') : ((!'t') : ((!' ') : rest_aUi))","((!'u') : ((!'t') : ((!' ') : rest_aUi)))","!((!'u') : ((!'t') : ((!' ') : rest_aUi)))","(!((!'u') : ((!'t') : ((!' ') : rest_aUi))))","(!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))","((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi)))))","!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi)))))","(!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))","((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi)))))))","inpt_aUj","!inpt_aUj","(!inpt_aUj)","((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n  (!inpt_aUj)","(((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n   (!inpt_aUj))","!(((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n    (!inpt_aUj))","(!(((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n     (!inpt_aUj)))","((!(((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n      (!inpt_aUj))))","stoilrest_aUk","newtilist_aUl","lsrest_aUm","safebang@!lsrest_aUm","(!lsrest_aUm)","coords_aUn","oldas_aUo","!oldas_aUo","(!oldas_aUo)","wcoords_aUp","state_aUq","\"\"","inpt_aUr","\"\" : inpt_aUr","(\"\" : inpt_aUr)","!(\"\" : inpt_aUr)","(!(\"\" : inpt_aUr))","((!(\"\" : inpt_aUr)))","!((!(\"\" : inpt_aUr)))","(!((!(\"\" : inpt_aUr))))","state_aUs","!state_aUs","(!state_aUs)","_","inpt_aUt","_ : inpt_aUt","(_ : inpt_aUt)","_","!_","(!_)","dlist_aUu","sel_aUv","tilist_aUw","!tilist_aUw","(!tilist_aUw)","(dlist_aUu, sel_aUv, (!tilist_aUw))","!(dlist_aUu, sel_aUv, (!tilist_aUw))","(!(dlist_aUu, sel_aUv, (!tilist_aUw)))","inpt_aUx","_","dlist_aUy","!dlist_aUy","(!dlist_aUy)","sel_aUz","tilist_aUA","!tilist_aUA","(!tilist_aUA)","((!dlist_aUy), sel_aUz, (!tilist_aUA))","inpt_aUB","!inpt_aUB","(!inpt_aUB)","coords_aUC","_","!_","(!_)","dlist_a10K","!dlist_a10K","(!dlist_a10K)","sel_a10L","tilist_a10M","!tilist_a10M","(!tilist_a10M)","((!dlist_a10K), sel_a10L, (!tilist_a10M))","inpt_a10N","!inpt_a10N","(!inpt_a10N)","_","!_","(!_)","dlist_a10O","!dlist_a10O","(!dlist_a10O)","sel_a10P","tilist_a10Q","!tilist_a10Q","(!tilist_a10Q)","((!dlist_a10O), sel_a10P, (!tilist_a10Q))","!((!dlist_a10O), sel_a10P, (!tilist_a10Q))","(!((!dlist_a10O), sel_a10P, (!tilist_a10Q)))","inpt_a10R","!inpt_a10R","(!inpt_a10R)","rest_a10S","dlist_a10T","sel_a10U","!sel_a10U","(!sel_a10U)","tilist_a10V","!tilist_a10V","(!tilist_a10V)","(dlist_a10T, (!sel_a10U), (!tilist_a10V))","!(dlist_a10T, (!sel_a10U), (!tilist_a10V))","(!(dlist_a10T, (!sel_a10U), (!tilist_a10V)))","inpt_a10W","!inpt_a10W","(!inpt_a10W)","out_a10X","newdlist_a10Y","!newdlist_a10Y","(!newdlist_a10Y)","(out_a10X, (!newdlist_a10Y))","!(out_a10X, (!newdlist_a10Y))","(!(out_a10X, (!newdlist_a10Y)))","_","!_","(!_)","state_a10Z","inpt_a110","!inpt_a110","(!inpt_a110)","rest_a111","dlist_a112","sel_a113","tilist_a114","!tilist_a114","(!tilist_a114)","(dlist_a112, sel_a113, (!tilist_a114))","inpt_a115","!inpt_a115","(!inpt_a115)","_","!_","(!_)","state_a116","!state_a116","(!state_a116)","inpt_a117","rest_a118","!rest_a118","(!rest_a118)","dlist_a119","!dlist_a119","(!dlist_a119)","sel_a11a","slist_a11b","((!dlist_a119), sel_a11a, slist_a11b)","!((!dlist_a119), sel_a11a, slist_a11b)","(!((!dlist_a119), sel_a11a, slist_a11b))","inpt_a11c","!inpt_a11c","(!inpt_a11c)","new_a11d","newsel_a11e","!newsel_a11e","(!newsel_a11e)","rest_a11f","dlist_a11g","!dlist_a11g","(!dlist_a11g)","sel_a11h","tilist_a11i","((!dlist_a11g), sel_a11h, tilist_a11i)","!((!dlist_a11g), sel_a11h, tilist_a11i)","(!((!dlist_a11g), sel_a11h, tilist_a11i))","inpt_a11j","wcoords_a11k","lazydmd@!wcoords_a11k","(!wcoords_a11k)","stoilrest_a11l","oldas_a11m","lsrest_a11n","newtilist_a11o","!newtilist_a11o","(!newtilist_a11o)","rest_a11p","dlist_a11q","sel_a11r","tilist_a11s","!tilist_a11s","(!tilist_a11s)","(dlist_a11q, sel_a11r, (!tilist_a11s))","!(dlist_a11q, sel_a11r, (!tilist_a11s))","(!(dlist_a11q, sel_a11r, (!tilist_a11s)))","inpt_a11t","!inpt_a11t","(!inpt_a11t)","stoilrest_a11u","safebang@!stoilrest_a11u","(!stoilrest_a11u)","wcoords_a11v","!wcoords_a11v","(!wcoords_a11v)","oldas_a11w","newtilist_a11x","lsrest_a11y","_","!_","(!_)","dlist_a11z","sel_a11A","tilist_a11B","!tilist_a11B","(!tilist_a11B)","(dlist_a11z, sel_a11A, (!tilist_a11B))","inpt_a11C","_","state_a11D","!state_a11D","(!state_a11D)","inpt_a11E","!inpt_a11E","(!inpt_a11E)","_","state_a11F","inpt_a11G","!inpt_a11G","(!inpt_a11G)","_","!_","(!_)","dlist_a11H","!dlist_a11H","(!dlist_a11H)","sel_a11I","tilist_a11J","!tilist_a11J","(!tilist_a11J)","((!dlist_a11H), sel_a11I, (!tilist_a11J))","!((!dlist_a11H), sel_a11I, (!tilist_a11J))","(!((!dlist_a11H), sel_a11I, (!tilist_a11J)))","inpt_a11K","!inpt_a11K","(!inpt_a11K)","orilist_a11L","!orilist_a11L","(!orilist_a11L)","wcoords_a11M","!wcoords_a11M","(!wcoords_a11M)","pic_a11N","newtilist_a11O","cr12_a11Q","cr34_a11R","n1_a11S","n2_a11T","safebang@!n2_a11T","(!n2_a11T)","n3_a11U","n4_a11V","[n1_a11S, (!n2_a11T), n3_a11U, n4_a11V]","![n1_a11S, (!n2_a11T), n3_a11U, n4_a11V]","(![n1_a11S, (!n2_a11T), n3_a11U, n4_a11V])","out_a11P","!out_a11P","(!out_a11P)","i_a15j","!i_a15j","(!i_a15j)","j_a15k","v_a15l","(j_a15k, v_a15l)","!(j_a15k, v_a15l)","(!(j_a15k, v_a15l))","ivs_a15m","safebang@!ivs_a15m","(!ivs_a15m)","(!(j_a15k, v_a15l)) : (!ivs_a15m)","((!(j_a15k, v_a15l)) : (!ivs_a15m))","!((!(j_a15k, v_a15l)) : (!ivs_a15m))","(!((!(j_a15k, v_a15l)) : (!ivs_a15m)))","_","!_","(!_)","state_a15n","_","!_","(!_)","newdraw","potatotile","stoil"]
module Progfuns
       (tileprompt, tilequit, tiletrans, potatotile, State) where
import Mgrfuns
import Drawfuns
import Geomfuns
import Psfuns
import Interstate
import Auxprogfuns
import Layout
import Tilefuns
import Help

tileprompt :: a_aTc -> [Char]
tileprompt _ = ""

tilequit :: a_aTb -> [[Char]] -> Bool
tilequit _ (((norecord@'q') : _) : _) = True
tilequit (norecord@_) [] = True
tilequit _ (norecord@_) = False

tiletrans :: Trans
tiletrans (norecord@((!dlist_aTd), (!sel_aTe), (!tilist_aTf)))
  ((norecord@((norecord@((norecord@'m') :
                           ('s' :
                              (norecord@((norecord@'a') :
                                           (norecord@(' ' : (lazydmd@rest_aTg))))))))
                : inpt_aTh)))
  = if intsave x_aTi y_aTj then doo_aTk tsave else
      if intclear x_aTi y_aTj then doo_aTk tclear else
        if intget x_aTi y_aTj then doo_aTk tget else
          if intile4 x_aTi y_aTj then doo_aTk t4' else
            if inquit x_aTi y_aTj then doo_aTk q else
              if inbigtile x_aTi y_aTj then doo_aTk delsq else
                if intoalter x_aTi y_aTj then doo_aTk tofiddle' else
                  if intotile x_aTi y_aTj then doo_aTk totile' else
                    if intodraw x_aTi y_aTj then doo_aTk todesign' else
                      if inpicarea x_aTi y_aTj then doo_aTk sel' else
                        if inhelp x_aTi y_aTj then doo_aTk tohelp' else
                          tiletrans (dlist_aTd, sel_aTe, tilist_aTf) inpt_aTh
  where [x_aTi, (norecord@y_aTj)] = stoil rest_aTg
        doo_aTk fun_aTl
          = fun_aTl rest_aTg (dlist_aTd, sel_aTe, tilist_aTf) inpt_aTh
tiletrans (norecord@((norecord@dlist_aTm), sel_aTn, tilist_aTo))
  (norecord@(('m' : ('s' : (norecord@('b' : (' ' : rest_aTp))))) :
               (lazydmd@inpt_aTq)))
  = if inbigtile x_aTr y_aTs then
      inv' rest_aTp (dlist_aTm, sel_aTn, tilist_aTo) inpt_aTq else
      tiletrans (dlist_aTm, sel_aTn, tilist_aTo)
        (('m' : 's' : 'a' : ' ' : rest_aTp) : inpt_aTq)
  where [(norecord@x_aTr), (norecord@y_aTs)] = stoil rest_aTp
tiletrans (dlist_aTt, (norecord@sel_aTu), tilist_aTv)
  ((norecord@(('m' :
                 ((norecord@'s') : ('c' : (norecord@(' ' : (lazydmd@rest_aTw))))))
                : (lazydmd@inpt_aTx))))
  = if indesign x_aTy y_aTz then doo_aTA rl else
      if indsave x_aTy y_aTz then doo_aTA dsave else
        if indclear x_aTy y_aTz then doo_aTA dclear else
          if indget x_aTy y_aTz then doo_aTA dget else
            tiletrans (dlist_aTt, sel_aTu, tilist_aTv)
              (('m' : 's' : 'a' : ' ' : rest_aTw) : inpt_aTx)
  where (norecord@[x_aTy, y_aTz]) = stoil rest_aTw
        doo_aTA (norecord@fun_aTB)
          = fun_aTB rest_aTw (dlist_aTt, sel_aTu, tilist_aTv) inpt_aTx
tiletrans state_aTC
  (((norecord@('m' :
                 ((norecord@'s') :
                    ((norecord@'d') : ((norecord@' ') : (lazydmd@rest_aTD)))))))
     : (lazydmd@inpt_aTE))
  = (inithelp ++ out_aTI, state_aTC, inpt_aTE)
  where (norecord@[x_aTF, y_aTG]) = stoil rest_aTD
        cf_aTH (norecord@str_aTJ) = clear ++ str_aTJ
        out_aTI
          = if intodraw x_aTF y_aTG then cf_aTH helpdraw else
              if intotile x_aTF y_aTG then cf_aTH helptile else
                if intoalter x_aTF y_aTG then cf_aTH helpalter else
                  if intsave x_aTF y_aTG then cf_aTH helptsave else
                    if intclear x_aTF y_aTG then cf_aTH helptclear else
                      if intget x_aTF y_aTG then cf_aTH helptget else
                        if intile4 x_aTF y_aTG then cf_aTH helpt4 else
                          if inquit x_aTF y_aTG then cf_aTH helpquit else
                            if inbigtile x_aTF y_aTG then cf_aTH helpbt else
                              if inpicarea x_aTF y_aTG then cf_aTH helppic else
                                if indesign x_aTF y_aTG then cf_aTH helpdesign else
                                  if indsave x_aTF y_aTG then cf_aTH helpdsave else
                                    if indclear x_aTF y_aTG then cf_aTH helpdclear else
                                      if indget x_aTF y_aTG then cf_aTH helpdget else
                                        if inhelp x_aTF y_aTG then cf_aTH inithelp else
                                          cf_aTH errmes
tiletrans ((norecord@dlist_aTK), (norecord@sel_aTL), tilist_aTM)
  (('c' :
      (norecord@((norecord@'s') :
                   (norecord@(' ' : (lazydmd@rest_aTN))))))
     : inpt_aTO)
  = if indgrid nstoilrest_aTQ then
      (linecircs_aTU ++ wnstoilrest_aTR,
       (newele_aTT : dlist_aTK, sel_aTL, tilist_aTM), inpt_aTO)
      else ("", (dlist_aTK, sel_aTL, tilist_aTM), inpt_aTO)
  where nearline_aTP
          (norecord@[(!x0_aTV), y0_aTW, (!x1_aTX), y1_aTY])
          = [nearx x0_aTV, neary y0_aTW, nearx x1_aTX, neary y1_aTY]
        (!nstoilrest_aTQ) = nearline_aTP (stoil rest_aTN)
        (norecord@wnstoilrest_aTR) = wline nstoilrest_aTQ
        (norecord@cssr_aTS) = cs nstoilrest_aTQ
        newele_aTT = (nstoilrest_aTQ, snd cssr_aTS)
        (lazydmd@linecircs_aTU) = fst cssr_aTS
tiletrans
  (norecord@((norecord@dlist_aU5), sel_aU6, (norecord@tilist_aU7)))
  (norecord@((norecord@((norecord@((norecord@('r' :
                                                ('o' : ('t' : (' ' : rest_aU8)))))))
                          : inpt_aU9))))
  = if lsrest_aUe == [0, 0] then
      ("", (dlist_aU5, sel_aU6, tilist_aU7), inpt_aU9) else
      (undo (put lsrest_aUe (orient xymax oldas_aUc wcoords_aUb)) ++
         put lsrest_aUe (orient xymax (rot oldas_aUc) wcoords_aUb),
       (dlist_aU5, sel_aU6, newtilist_aUd), inpt_aU9)
  where stoilrest_aUa = stoil rest_aU8
        wcoords_aUb = map (map wscale) (map fst dlist_aU5)
        (norecord@oldas_aUc) = assoc (sqid stoilrest_aUa) tilist_aU7
        newtilist_aUd
          = newas (sqid stoilrest_aUa) (rot oldas_aUc) tilist_aU7
        lsrest_aUe = btlocate stoilrest_aUa
tiletrans
  ((norecord@dlist_aUf), (norecord@sel_aUg), (norecord@tilist_aUh))
  ((norecord@(((norecord@((norecord@'p') :
                            (norecord@((norecord@'u') :
                                         ((norecord@'t') : ((norecord@' ') : rest_aUi)))))))
                : (norecord@inpt_aUj))))
  = if lsrest_aUm == [0, 0] then
      ("", (dlist_aUf, sel_aUg, tilist_aUh), inpt_aUj) else
      (undo (put lsrest_aUm (orient xymax oldas_aUo wcoords_aUp)) ++
         put lsrest_aUm (orient xymax sel_aUg wcoords_aUp),
       (dlist_aUf, sel_aUg, newtilist_aUl), inpt_aUj)
  where stoilrest_aUk = stoil rest_aUi
        newtilist_aUl = newas (sqid stoilrest_aUk) sel_aUg tilist_aUh
        (!lsrest_aUm) = btlocate stoilrest_aUk
        coords_aUn = map fst dlist_aUf
        (norecord@oldas_aUo) = assoc (sqid stoilrest_aUk) tilist_aUh
        wcoords_aUp = map (map wscale) coords_aUn
tiletrans state_aUq (norecord@((norecord@("" : inpt_aUr))))
  = (helpend ++ todesign, state_aUq, inpt_aUr)
tiletrans (norecord@state_aUs) (_ : inpt_aUt)
  = ("", state_aUs, inpt_aUt)

todesign', totile', tofiddle', tohelp' :: [Char] -> Trans
todesign' (norecord@_)
  (norecord@(dlist_aUu, sel_aUv, (norecord@tilist_aUw))) inpt_aUx
  = (cleara picarea ++ picgrid ++ cleara tilearea ++ tpgrid ++
       showoris (map fst dlist_aUu) 1
       ++ todesign,
     (dlist_aUu, sel_aUv, tilist_aUw), inpt_aUx)
totile' _ ((norecord@dlist_aUy), sel_aUz, (norecord@tilist_aUA))
  (norecord@inpt_aUB)
  = (concat (map (showoris coords_aUC) [1 .. 8]) ++ totile,
     (dlist_aUy, sel_aUz, tilist_aUA), inpt_aUB)
  where coords_aUC = map fst dlist_aUy
tofiddle' (norecord@_)
  ((norecord@dlist_a10K), sel_a10L, (norecord@tilist_a10M))
  (norecord@inpt_a10N)
  = (tofiddle, (dlist_a10K, sel_a10L, tilist_a10M), inpt_a10N)
tohelp' (norecord@_)
  (norecord@((norecord@dlist_a10O), sel_a10P,
             (norecord@tilist_a10Q)))
  (norecord@inpt_a10R)
  = (tohelp, (dlist_a10O, sel_a10P, tilist_a10Q), inpt_a10R)

rl, dsave, dclear, dget :: [Char] -> Trans
rl rest_a10S
  (norecord@(dlist_a10T, (norecord@sel_a10U),
             (norecord@tilist_a10V)))
  (norecord@inpt_a10W)
  = (out_a10X, (newdlist_a10Y, sel_a10U, tilist_a10V), inpt_a10W)
  where (norecord@(out_a10X, (norecord@newdlist_a10Y)))
          = deline dlist_a10T (stoil rest_a10S)
dsave (norecord@_) state_a10Z (norecord@inpt_a110)
  = ("", state_a10Z, inpt_a110)
dclear rest_a111 (dlist_a112, sel_a113, (norecord@tilist_a114))
  (norecord@inpt_a115)
  = (menumark "dclear" ++ newdraw ++ unmark sel_a113 ++
       unmenumark "dclear",
     ([], 1, initalist), inpt_a115)
dget (norecord@_) (norecord@state_a116) inpt_a117
  = ("", state_a116, inpt_a117)

sel', delsq, inv' :: [Char] -> Trans
sel' (norecord@rest_a118)
  (norecord@((norecord@dlist_a119), sel_a11a, slist_a11b))
  (norecord@inpt_a11c)
  = (unmark sel_a11a ++ mark newsel_a11e,
     (dlist_a119, newsel_a11e, slist_a11b), inpt_a11c)
  where new_a11d = inbox (stoil rest_a118)
        (norecord@newsel_a11e)
          = if new_a11d == 0 then sel_a11a else new_a11d
delsq rest_a11f
  (norecord@((norecord@dlist_a11g), sel_a11h, tilist_a11i)) inpt_a11j
  = (undo (put lsrest_a11n (orient xymax oldas_a11m wcoords_a11k)),
     (dlist_a11g, sel_a11h, newtilist_a11o), inpt_a11j)
  where (lazydmd@wcoords_a11k)
          = map (map wscale) (map fst dlist_a11g)
        stoilrest_a11l = stoil rest_a11f
        oldas_a11m = assoc (sqid stoilrest_a11l) tilist_a11i
        lsrest_a11n = btlocate stoilrest_a11l
        (norecord@newtilist_a11o)
          = newas (sqid stoilrest_a11l) 0 tilist_a11i
inv' rest_a11p
  (norecord@(dlist_a11q, sel_a11r, (norecord@tilist_a11s)))
  (norecord@inpt_a11t)
  = if lsrest_a11y == [0, 0] then
      ("", (dlist_a11q, sel_a11r, tilist_a11s), inpt_a11t) else
      (undo (put lsrest_a11y (orient xymax oldas_a11w wcoords_a11v)) ++
         put lsrest_a11y (orient xymax (inv oldas_a11w) wcoords_a11v),
       (dlist_a11q, sel_a11r, newtilist_a11x), inpt_a11t)
  where (!stoilrest_a11u) = stoil rest_a11p
        (norecord@wcoords_a11v) = map (map wscale) (map fst dlist_a11q)
        oldas_a11w = assoc (sqid stoilrest_a11u) tilist_a11s
        newtilist_a11x
          = newas (sqid stoilrest_a11u) (inv oldas_a11w) tilist_a11s
        lsrest_a11y = btlocate stoilrest_a11u

tclear, tsave, tget, t4' :: [Char] -> Trans
tclear (norecord@_) (dlist_a11z, sel_a11A, (norecord@tilist_a11B))
  inpt_a11C
  = (menumark "tclear" ++ cleara tilearea ++ tpgrid ++ totile ++
       unmenumark "tclear",
     (dlist_a11z, sel_a11A, initalist), inpt_a11C)
tsave _ (norecord@state_a11D) (norecord@inpt_a11E)
  = ("", state_a11D, inpt_a11E)
tget _ state_a11F (norecord@inpt_a11G)
  = ("", state_a11F, inpt_a11G)
t4' (norecord@_)
  (norecord@((norecord@dlist_a11H), sel_a11I,
             (norecord@tilist_a11J)))
  (norecord@inpt_a11K)
  = (out_a11P, (dlist_a11H, sel_a11I, newtilist_a11O), inpt_a11K)
  where (norecord@orilist_a11L)
          = pam assoc [(0, 0), (0, 1), (1, 0), (1, 1)] tilist_a11J
        (norecord@wcoords_a11M) = map (map wscale) (map fst dlist_a11H)
        pic_a11N = t4 (pam (orient xymax) orilist_a11L wcoords_a11M)
        newtilist_a11O = zip alistind (concrep 4 (cr12_a11Q ++ cr34_a11R))
          where cr12_a11Q = concrep 4 [n1_a11S, n2_a11T]
                cr34_a11R = concrep 4 [n3_a11U, n4_a11V]
                (norecord@[n1_a11S, (!n2_a11T), n3_a11U, n4_a11V]) = orilist_a11L
        (norecord@out_a11P)
          = menumark "t4" ++ cleara tilearea ++
              tile tpxorig tpyorig 4 4 pic_a11N
              ++ unmenumark "t4"

assoc :: (Eq a_aFH) => a_aFH -> [(a_aFH, b_aFI)] -> b_aFI
assoc (norecord@i_a15j)
  (norecord@((norecord@(j_a15k, v_a15l)) : (!ivs_a15m)))
  = if i_a15j == j_a15k then v_a15l else assoc i_a15j ivs_a15m

q :: [Char] -> Trans
q (norecord@_) state_a15n (norecord@_) = ("", state_a15n, [])

newdraw :: [Char]
newdraw
  = cleara designarea ++ dpgrid ++ cleara picarea ++ picgrid ++
      cleara tilearea
      ++ tpgrid
      ++ invisibletext
      ++ todesign

potatotile :: State -> [[Char]] -> [Char]
potatotile = inter tileprompt tilequit tiletrans

stoil :: [Char] -> [Int]
stoil = map read . words

type State = ([([Int], [Int])], Int, [((Int, Int), Int)])

type Trans = State -> [[Char]] -> ([Char], State, [[Char]])
ENDLOG
STARTLOG
["str_anx","ns_any","n_anA","!n_anA","(!n_anA)","\"\"","n_aw1","s_aw2","aligntext","bitcopy","circle","clear","event_aCa","mode_aCb","n_aCc","safebang@!n_aCc","(!n_aCc)","x1_aCd","safebang@!x1_aCd","(!x1_aCd)","y1_aCe","safebang@!y1_aCe","(!y1_aCe)","x2_aCf","safebang@!x2_aCf","(!x2_aCf)","y2_aCg","safebang@!y2_aCg","(!y2_aCg)","[(!x1_aCd), (!y1_aCe), (!x2_aCf), (!y2_aCg)]","![(!x1_aCd), (!y1_aCe), (!x2_aCf), (!y2_aCg)]","(![(!x1_aCd), (!y1_aCe), (!x2_aCf), (!y2_aCg)])","r_aCh","dragline","dragrect","x_aDg","safebang@!x_aDg","(!x_aDg)","mode_aDh","safebang@!mode_aDh","(!mode_aDh)","go","highlight","line","event_aDi","safebang@!event_aDi","(!event_aDi)","newwin","r_aQL","safebang@!r_aQL","(!r_aQL)","n_aQM","event_aQN","str_aQO","safebang@!str_aQO","(!str_aQO)","mode_aQP","shapewindow","standend","standout","win_aQQ","x_aQR","safebang@!x_aQR","(!x_aQR)","y_aQS","str_aQT","textregion","textreset"]
module Mgrfuns
       (aligntext, bitcopy, circle, clear, clearevent, clearmode,
        destroywin, dragcircle, dragline, dragrect, font, func, go,
        highlight, line, mapevent, newwin, rcircle, selectwin, setevent,
        setmode, shapewindow, standend, stringto, standout, textregion,
        textreset)
       where
import Diff

escom :: [Char] -> [Int] -> [Char]
escom str_anx ns_any = '\ESC' : foldr f_anz "" ns_any
  where f_anz (norecord@n_anA) "" = show n_anA ++ str_anx
        f_anz n_aw1 s_aw2 = show n_aw1 ++ "," ++ s_aw2
aligntext = '\ESC' : "l"
bitcopy = escom "b"
circle = escom "o"
clear = "\f"
clearevent event_aCa = escom "e" [mapevent event_aCa]
clearmode mode_aCb = escom "s" [mode_aCb]
destroywin (!n_aCc) = escom ",OZ" [n_aCc]
dragcircle (norecord@[(!x1_aCd), (!y1_aCe), (!x2_aCf), (!y2_aCg)])
  = circle [x1_aCd, y1_aCe, r_aCh]
  where r_aCh
          = bcroot
              (square (diff x1_aCd x2_aCf) + square (diff y1_aCe y2_aCg))
dragline = "%l\n"
dragrect = "%r\n"
font (!x_aDg) = escom "F" [x_aDg]
func (!mode_aDh) = escom "b" [mode_aDh]
go = escom "g"
highlight = escom "H"
line = escom "l"
mapevent (!event_aDi)
  = if event_aDi == 3 || event_aDi == 4 then 2 - event_aDi else
      event_aDi
newwin = escom "Z"
rcircle (!r_aQL) = escom "o" [r_aQL]
selectwin n_aQM = escom "Z" [n_aQM]
setevent event_aQN (!str_aQO)
  = escom ("e" ++ str_aQO) [mapevent event_aQN, length str_aQO]
setmode mode_aQP = escom "S" [mode_aQP]
shapewindow = escom "W"
standend = '\ESC' : ",n"
standout = '\ESC' : "i"
stringto win_aQQ (!x_aQR) y_aQS str_aQT
  = escom ("." ++ str_aQT) [win_aQQ, x_aQR, y_aQS, length str_aQT]
textregion = escom "t"
textreset = '\ESC' : "t"
ENDLOG
STARTLOG
["x_apq","y_apr","coords_ayY","safebang@!coords_ayY","(!coords_ayY)","header_ayZ","x1_az4","y1_az5","x2_az6","y2_az7","[x1_az4, y1_az5, x2_az6, y2_az7]","f_aHx","safebang@!f_aHx","(!f_aHx)","fs_aHy","(!f_aHx) : fs_aHy","((!f_aHx) : fs_aHy)","!((!f_aHx) : fs_aHy)","(!((!f_aHx) : fs_aHy))","a_aHz","safebang@!a_aHz","(!a_aHz)","[]","![]","(![])","a_aHA","!a_aHA","(!a_aHA)","h_aHB","!h_aHB","(!h_aHB)","f_aHC","!f_aHC","(!f_aHC)","coords_aHD","n_aHE","!n_aHE","(!n_aHE)","introline","rowline","ss","num_aHF","!num_aHF","(!num_aHF)","list_aHG","n1_aHH","n2_aHI","safebang@!n2_aHI","(!n2_aHI)","n3_aHJ","n4_aHK","safebang@!n4_aHK","(!n4_aHK)","[n1_aHH, (!n2_aHI), n3_aHJ, (!n4_aHK)]","i_aHM","j_aHN","safebang@!j_aHN","(!j_aHN)","psmax"]
module Psfuns (pos8head, introline, lf, tile4, concrep) where
import Geomfuns
import Auxprogfuns

concrep :: Int -> [a_app] -> [a_app]
concrep x_apq y_apr = concat (take x_apq (repeat y_apr))

pos8head :: [[Int]] -> [Char]
pos8head (!coords_ayY)
  = header_ayZ ++ pamcat_az1 (map newf_az3 [1 .. 8]) coords_ayY
  where header_ayZ
          = "%!PS-Adobe-1.0\n0.75 setlinewidth\n" ++ "/print0\n{\n} def\n"
        topos_az0 [x1_az4, y1_az5, x2_az6, y2_az7]
          = show x1_az4 ++ " " ++ show y1_az5 ++ " moveto\n" ++ show x2_az6
              ++ " "
              ++ show y2_az7
              ++ " lineto\n"
        pamcat_az1 (norecord@((!f_aHx) : fs_aHy)) (!a_aHz)
          = f_aHx a_aHz ++ pamcat_az1 fs_aHy a_aHz
        pamcat_az1 (norecord@[]) (norecord@a_aHA) = []
        fpat_az2 (norecord@h_aHB) (norecord@f_aHC) coords_aHD
          = h_aHB ++ (concat . map topos_az0 . f_aHC) coords_aHD ++
              "stroke} def\n"
        newf_az3 (norecord@n_aHE)
          = fpat_az2 ("/print" ++ show n_aHE ++ "\n{") (orient psmax n_aHE)

introline, rowline, ss :: [Char]
introline = "400 400 translate"
rowline = "\n-288 36 translate"
ss = "\n36 0 translate\nprint"

sq :: Int -> [Char]
sq (norecord@num_aHF) = ss ++ show num_aHF

lf :: [Int] -> [Char]
lf list_aHG = rowline ++ concat (map sq list_aHG)

tile4 :: [Int] -> [Char]
tile4 [n1_aHH, (!n2_aHI), n3_aHJ, (!n4_aHK)]
  = introline ++
      concrep 4 (posrow_aHL n1_aHH n2_aHI ++ posrow_aHL n3_aHJ n4_aHK)
      ++ "\nshowpage\n"
  where posrow_aHL i_aHM (!j_aHN)
          = rowline ++ concrep 4 (sq i_aHM ++ sq j_aHN)

psmax :: Int
psmax = 36
ENDLOG
STARTLOG
ENDLOG
START PROG /h/ywang30/nofib/real/fem/
STARTLOG
["main","s_arV","s_arW","a_arX","lazydmd@!a_arX","(!a_arX)","db_arY","!db_arY","(!db_arY)","uvwres_arZ","lazydmd@!uvwres_arZ","(!uvwres_arZ)","frc_as0"]
module Main (main) where
import Database
import Vector
import Displacement
import Elemforce
import PrintSource
import Printuvwforce
main = getContents >>= \ s_arV -> process s_arV

process :: [Char] -> IO ()
process s_arW = putStr a_arX
  where (lazydmd@a_arX)
          = source_data db_arY ++ uvwresult db_arY uvwres_arZ ++
              forceresult db_arY frc_as0
        (norecord@db_arY) = (idatabase s_arW, rdatabase s_arW)
        (lazydmd@uvwres_arZ) = uvw db_arY
        frc_as0 = forces db_arY uvwres_arZ
ENDLOG
STARTLOG
["n_apB","!n_apB","(!n_apB)","addiag_apC","elems_apD","VBMAT (!n_apB) addiag_apC elems_apD","(VBMAT (!n_apB) addiag_apC elems_apD)","!(VBMAT (!n_apB) addiag_apC elems_apD)","(!(VBMAT (!n_apB) addiag_apC elems_apD))","((!(VBMAT (!n_apB) addiag_apC elems_apD)))","!((!(VBMAT (!n_apB) addiag_apC elems_apD)))","(!((!(VBMAT (!n_apB) addiag_apC elems_apD))))","i_apE","!i_apE","(!i_apE)","n_aD7","addiag_aD8","elems_aD9","VBMAT n_aD7 addiag_aD8 elems_aD9","(VBMAT n_aD7 addiag_aD8 elems_aD9)","!(VBMAT n_aD7 addiag_aD8 elems_aD9)","(!(VBMAT n_aD7 addiag_aD8 elems_aD9))","((!(VBMAT n_aD7 addiag_aD8 elems_aD9)))","!((!(VBMAT n_aD7 addiag_aD8 elems_aD9)))","(!((!(VBMAT n_aD7 addiag_aD8 elems_aD9))))","i_aDa","vbm_aDb","i_aDc","j_aDd","(i_aDc, j_aDd)","n_aDe","addiag_aDf","!addiag_aDf","(!addiag_aDf)","elementlist_aDg","VBMAT n_aDe (!addiag_aDf) elementlist_aDg","(VBMAT n_aDe (!addiag_aDf) elementlist_aDg)","!(VBMAT n_aDe (!addiag_aDf) elementlist_aDg)","(!(VBMAT n_aDe (!addiag_aDf) elementlist_aDg))","((!(VBMAT n_aDe (!addiag_aDf) elementlist_aDg)))","bounds_aDh","safebang@!bounds_aDh","(!bounds_aDh)","addiag_aDi","elementlist_aDj","safebang@!elementlist_aDj","(!elementlist_aDj)","VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj)","(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj))","!(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj))","(!(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj)))","((!(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj))))","bounds_aDk","safebang@!bounds_aDk","(!bounds_aDk)","addiag_aDl","elementlist_aDm","safebang@!elementlist_aDm","(!elementlist_aDm)","VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm)","(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm))","!(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm))","(!(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm)))","((!(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm))))","bounds_aDn","addiag_aDo","elementlist_aDp","safebang@!elementlist_aDp","(!elementlist_aDp)","n_aDq","addiag_aDr","safebang@!addiag_aDr","(!addiag_aDr)","generator_aDs","i_aDx","elemts_aDu","!elemts_aDu","(!elemts_aDu)","ls_aN3","i_aN4","j_aN5","!j_aN5","(!j_aN5)","i_aN6","vbm_aN7","updates_aN8","safebang@!updates_aN8","(!updates_aN8)","n_aN9","addiag_aNa","elements_aNb","VBMAT n_aN9 addiag_aNa elements_aNb","(VBMAT n_aN9 addiag_aNa elements_aNb)","!(VBMAT n_aN9 addiag_aNa elements_aNb)","(!(VBMAT n_aN9 addiag_aNa elements_aNb))","((!(VBMAT n_aN9 addiag_aNa elements_aNb)))","new_elements_aNc","!new_elements_aNc","(!new_elements_aNc)","new_s_aNd","safebang@!new_s_aNd","(!new_s_aNd)","i_aNe","j_aNf","safebang@!j_aNf","(!j_aNf)","(i_aNe, (!j_aNf))","!(i_aNe, (!j_aNf))","(!(i_aNe, (!j_aNf)))","x_aNg","safebang@!x_aNg","(!x_aNg)","((!(i_aNe, (!j_aNf))), (!x_aNg))","!((!(i_aNe, (!j_aNf))), (!x_aNg))","(!((!(i_aNe, (!j_aNf))), (!x_aNg)))","vbm_aNh","safebang@!vbm_aNh","(!vbm_aNh)","updates_aNi","n_aNj","addiag_aNk","!addiag_aNk","(!addiag_aNk)","elements_aNl","!elements_aNl","(!elements_aNl)","VBMAT n_aNj (!addiag_aNk) (!elements_aNl)","new_elements_aNm","new_s_aNn","i_aNo","safebang@!i_aNo","(!i_aNo)","j_aNp","((!i_aNo), j_aNp)","!((!i_aNo), j_aNp)","(!((!i_aNo), j_aNp))","x_aNq","((!((!i_aNo), j_aNp)), x_aNq)","!((!((!i_aNo), j_aNp)), x_aNq)","(!((!((!i_aNo), j_aNp)), x_aNq))","vbm_aNr","!vbm_aNr","(!vbm_aNr)","i_aNs","j_aNt","(i_aNs, j_aNt)","!(i_aNs, j_aNt)","(!(i_aNs, j_aNt))","n_aNu","addiag_aNv","elements_aNw","VBMAT n_aNu addiag_aNv elements_aNw","vbm_aNx","!vbm_aNx","(!vbm_aNx)","rows_aNy","lazydmd@!rows_aNy","(!rows_aNy)","i_aNA","!i_aNA","(!i_aNA)","n_aNz","!n_aNz","(!n_aNz)","vbm_aNB","!vbm_aNB","(!vbm_aNB)","rows_aNC","i_aNE","!i_aNE","(!i_aNE)","n_aND","!n_aND","(!n_aND)","vbm_aNF","!vbm_aNF","(!vbm_aNF)","i_aNG","!i_aNG","(!i_aNG)","n_aNH","!n_aNH","(!n_aNH)","j_aNJ","safebang@!j_aNJ","(!j_aNJ)","vbm_aNK","!vbm_aNK","(!vbm_aNK)","i_aNL","!i_aNL","(!i_aNL)","n_aNM","!n_aNM","(!n_aNM)","j_aNO","safebang@!j_aNO","(!j_aNO)"]
module VBmatrix
       (Vbm, defvbmat, makevbmat, incrvbmat, updvbmat, vbmatsub,
        boundvbmat, addrvbmat, lengrvbmat, fstclvbmat, diagadrvbm,
        displayvbmati, displayvbmatr)
       where
import Basics
import Vector

defvbmat :: Int -> Vec Int -> Vec a_apA -> Vbm a_apA

makevbmat :: Int -> Vec Int -> ((Int, Int) -> a_apz) -> Vbm a_apz

updvbmat :: Vbm a_apy -> [((Int, Int), a_apy)] -> Vbm a_apy

incrvbmat ::
            (Num a_aoz) => Vbm a_aoz -> [((Int, Int), a_aoz)] -> Vbm a_aoz

vbmatsub :: Vbm a_aoy -> (Int, Int) -> a_aoy

boundvbmat :: Vbm a_aox -> Int

addrvbmat :: Vbm a_aow -> (Int, Int) -> Int

lengrvbmat :: Vbm a_aov -> Int -> Int

fstclvbmat :: Vbm a_aou -> Int -> Int

diagadrvbm :: Vbm a_aot -> Vec Int

displayvbmati :: Vbm Int -> [Char]

displayvbmatr :: Vbm Float -> [Char]
lengrvbmat
  (norecord@((norecord@(VBMAT (norecord@n_apB) addiag_apC
                          elems_apD))))
  (norecord@i_apE)
  = if (i_apE == 1) then 1 else
      (vecsub addiag_apC i_apE) - (vecsub addiag_apC (i_apE - 1))
fstclvbmat
  (norecord@((norecord@(VBMAT n_aD7 addiag_aD8 elems_aD9)))) i_aDa
  = if (i_aDa == 1) then 1 else
      i_aDa - (lengrvbmat (VBMAT n_aD7 addiag_aD8 elems_aD9) i_aDa) + 1
addrvbmat vbm_aDb (i_aDc, j_aDd)
  = vecsub addiag_aDf i_aDc + j_aDd - i_aDc
  where ((norecord@(VBMAT n_aDe (norecord@addiag_aDf)
                      elementlist_aDg)))
          = vbm_aDb
boundvbmat
  ((norecord@(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj))))
  = bounds_aDh
diagadrvbm
  ((norecord@(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm))))
  = addiag_aDl
defvbmat bounds_aDn addiag_aDo (!elementlist_aDp)
  = VBMAT bounds_aDn addiag_aDo elementlist_aDp
makevbmat n_aDq (!addiag_aDr) generator_aDs
  = VBMAT n_aDq addiag_aDr (makevec (vecsub addiag_aDr n_aDq) f_aDt)
  where f_aDt i_aDx = elemts_aDu !! (i_aDx - 1)
        (norecord@elemts_aDu) = foldl irow_aDv [] [1 .. n_aDq]
        irow_aDv ls_aN3 i_aN4
          = ls_aN3 ++
              [generator_aDs (i_aN4, j_aN5) |
               (norecord@j_aN5) <- [(fstcl_aDw i_aN4) .. i_aN4]]
        fstcl_aDw i_aN6
          = if (i_aN6 == 1) then 1 else
              i_aN6 - vecsub addiag_aDr i_aN6 + vecsub addiag_aDr (i_aN6 - 1) + 1
incrvbmat vbm_aN7 (!updates_aN8)
  = VBMAT n_aN9 addiag_aNa new_elements_aNc
  where ((norecord@(VBMAT n_aN9 addiag_aNa elements_aNb))) = vbm_aN7
        (norecord@new_elements_aNc) = incrvec elements_aNb new_s_aNd
        (!new_s_aNd)
          = map
              (\ (norecord@((norecord@(i_aNe, (!j_aNf))), (!x_aNg))) ->
                 (addrvbmat vbm_aN7 (i_aNe, j_aNf), x_aNg))
              updates_aN8
updvbmat (!vbm_aNh) updates_aNi
  = VBMAT n_aNj addiag_aNk new_elements_aNm
  where VBMAT n_aNj (norecord@addiag_aNk) (norecord@elements_aNl)
          = vbm_aNh
        new_elements_aNm = updvec elements_aNl new_s_aNn
        new_s_aNn
          = map
              (\ (norecord@((norecord@((!i_aNo), j_aNp)), x_aNq)) ->
                 (addrvbmat vbm_aNh (i_aNo, j_aNp), x_aNq))
              updates_aNi
vbmatsub (norecord@vbm_aNr) (norecord@(i_aNs, j_aNt))
  = vecsub elements_aNw (addrvbmat vbm_aNr (i_aNs, j_aNt))
  where VBMAT n_aNu addiag_aNv elements_aNw = vbm_aNr
displayvbmati (norecord@vbm_aNx)
  = "<  \n" ++ concat (map displayvec rows_aNy) ++ "> \n"
  where (lazydmd@rows_aNy)
          = [rowi vbm_aNx i_aNA | (norecord@i_aNA) <- [1 .. n_aNz]]
        (norecord@n_aNz) = boundvbmat vbm_aNx
displayvbmatr (norecord@vbm_aNB)
  = "<  \n" ++ concat (map displayvec rows_aNC) ++ "> \n"
  where rows_aNC
          = [rowr vbm_aNB i_aNE | (norecord@i_aNE) <- [1 .. n_aND]]
        (norecord@n_aND) = boundvbmat vbm_aNB
rowi (norecord@vbm_aNF) (norecord@i_aNG) = makevec n_aNH f_aNI
  where (norecord@n_aNH) = boundvbmat vbm_aNF
        f_aNI (!j_aNJ)
          = if ((j_aNJ >= (fstclvbmat vbm_aNF i_aNG)) && (j_aNJ <= i_aNG))
              then vbmatsub vbm_aNF (i_aNG, j_aNJ) else 0
rowr (norecord@vbm_aNK) (norecord@i_aNL) = makevec n_aNM f_aNN
  where (norecord@n_aNM) = boundvbmat vbm_aNK
        f_aNN (!j_aNO)
          = if ((j_aNO >= (fstclvbmat vbm_aNK i_aNL)) && (j_aNO <= i_aNL))
              then vbmatsub vbm_aNK (i_aNL, j_aNO) else 0.0

data Vbm a_aol = VBMAT Int (Vec Int) (Vec a_aol)
ENDLOG
STARTLOG
ENDLOG
STARTLOG
ENDLOG
STARTLOG
["idb_aw4","!idb_aw4","(!idb_aw4)","rdb_aw5","((!idb_aw4), rdb_aw5)","idb_aw6","!idb_aw6","(!idb_aw6)","rdb_aw7","!rdb_aw7","(!rdb_aw7)","((!idb_aw6), (!rdb_aw7))","!((!idb_aw6), (!rdb_aw7))","(!((!idb_aw6), (!rdb_aw7)))","idb_aw8","rdb_aw9","(idb_aw8, rdb_aw9)","idb_awa","!idb_awa","(!idb_awa)","rdb_awb","!rdb_awb","(!rdb_awb)","((!idb_awa), (!rdb_awb))","idb_awc","rdb_awd","(idb_awc, rdb_awd)","node_awe","x_awf","y_awg","!y_awg","(!y_awg)","index_awh","idb_axf","!idb_axf","(!idb_axf)","rdb_axg","((!idb_axf), rdb_axg)","!((!idb_axf), rdb_axg)","(!((!idb_axf), rdb_axg))","node_axh","idb_axi","!idb_axi","(!idb_axi)","rdb_axj","!rdb_axj","(!rdb_axj)","((!idb_axi), (!rdb_axj))","material_axk","safebang@!material_axk","(!material_axk)","ea_axl","ei_axm","!ei_axm","(!ei_axm)","index_axn","!index_axn","(!index_axn)","idb_axo","rdb_axp","(idb_axo, rdb_axp)","element_axq","safebang@!element_axq","(!element_axq)","nodel_axr","noder_axs","!noder_axs","(!noder_axs)","index_axt","idb_axu","rdb_axv","!rdb_axv","(!rdb_axv)","(idb_axu, (!rdb_axv))","element_axw","idb_axx","!idb_axx","(!idb_axx)","rdb_axy","((!idb_axx), rdb_axy)","j_axz","safebang@!j_axz","(!j_axz)","to_node_axA","px_axB","py_axC","m_axD","!m_axD","(!m_axD)","indexi_axE","indexr_axF","!indexr_axF","(!indexr_axF)","nnodes_axG","!nnodes_axG","(!nnodes_axG)","nelems_axH","nmatss_axI","!nmatss_axI","(!nmatss_axI)"]
module DB_interface
       (nnode, nmats, getnxy, getnbc, getmpro, nelem, nplds, getenlr,
        getemat, getpld)
       where
import Data.Array
import Database

nnode, nelem, nmats, nplds ::
       (Array Int Int, Array Int Float) -> Int
nnode ((norecord@idb_aw4), rdb_aw5) = idb_aw4 ! 0
nelem (norecord@((norecord@idb_aw6), (norecord@rdb_aw7)))
  = idb_aw6 ! 1
nmats (idb_aw8, rdb_aw9) = idb_aw8 ! 2
nplds ((norecord@idb_awa), (norecord@rdb_awb)) = idb_awa ! 3

getnxy :: (Array Int Int, Array Int Float) -> Int -> (Float, Float)
getnxy (idb_awc, rdb_awd) node_awe = (x_awf, y_awg)
  where x_awf = rdb_awd ! index_awh
        (norecord@y_awg) = rdb_awd ! (index_awh + 1)
        index_awh = (node_awe - 1) * 2

getnbc :: (Array Int Int, Array Int Float) -> Int -> Int
getnbc (norecord@((norecord@idb_axf), rdb_axg)) node_axh
  = idb_axf ! (3 + node_axh)

getmpro ::
        (Array Int Int, Array Int Float) -> Int -> (Float, Float)
getmpro ((norecord@idb_axi), (norecord@rdb_axj)) (!material_axk)
  = (ea_axl, ei_axm)
  where ea_axl = rdb_axj ! index_axn
        (norecord@ei_axm) = rdb_axj ! (index_axn + 1)
        (norecord@index_axn)
          = (nnode (idb_axi, rdb_axj)) * 2 + (material_axk - 1) * 2

getenlr :: (Array Int Int, Array Int Float) -> Int -> (Int, Int)
getenlr (idb_axo, rdb_axp) (!element_axq) = (nodel_axr, noder_axs)
  where nodel_axr = idb_axo ! index_axt
        (norecord@noder_axs) = idb_axo ! (index_axt + 1)
        index_axt = 4 + (nnode (idb_axo, rdb_axp)) + (element_axq - 1) * 3

getemat :: (Array Int Int, Array Int Float) -> Int -> Int
getemat (idb_axu, (norecord@rdb_axv)) element_axw
  = idb_axu ! (3 + (nnode (idb_axu, rdb_axv)) + element_axw * 3)

getpld ::
       (Array Int Int, Array Int Float) ->
         Int -> (Int, Float, Float, Float)
getpld ((norecord@idb_axx), rdb_axy) (!j_axz)
  = (to_node_axA, px_axB, py_axC, m_axD)
  where to_node_axA = idb_axx ! indexi_axE
        px_axB = rdb_axy ! (indexr_axF)
        py_axC = rdb_axy ! (indexr_axF + 1)
        (norecord@m_axD) = rdb_axy ! (indexr_axF + 2)
        indexi_axE = 4 + nnodes_axG + nelems_axH * 3 + (j_axz - 1)
        (norecord@indexr_axF)
          = nnodes_axG * 2 + nmatss_axI * 2 + (j_axz - 1) * 3
        (norecord@nnodes_axG) = nnode (idb_axx, rdb_axy)
        nelems_axH = nelem (idb_axx, rdb_axy)
        (norecord@nmatss_axI) = nmats (idb_axx, rdb_axy)
ENDLOG
STARTLOG
["s_azG","!s_azG","(!s_azG)","initial_value_azH","i_azJ","index_value_assoc_s_azI","safebang@!index_value_assoc_s_azI","(!index_value_assoc_s_azI)","s_azK","!s_azK","(!s_azK)","assemble_s_azL","!assemble_s_azL","(!assemble_s_azL)","s_aFL","till_now_dd_aFM","element_aFN","dd_this'_aFO","lazydmd@!dd_this'_aFO","(!dd_this'_aFO)","i_aGW","!i_aGW","(!i_aGW)","j_aGX","dgrs_list_aFP","nodel_aFQ","noder_aFR","(nodel_aFQ, noder_aFR)","node_aTT","eindex_dgrs_list_aFT","safebang@!eindex_dgrs_list_aFT","(!eindex_dgrs_list_aFT)","aindex_dgrs_list_aFU","i_aXi","safebang@!i_aXi","(!i_aXi)","dgr_aXj","((!i_aXi), dgr_aXj)","!((!i_aXi), dgr_aXj)","(!((!i_aXi), dgr_aXj))","n_aFW","i_aXk","!i_aXk","(!i_aXk)","j_aXl","!j_aXl","(!j_aXl)","i_aXs"]
module Assemble_stiffness (kdd) where
import Basics
import Vector
import Matrix
import VBmatrix
import DB_interface
import Degrees
import Pre_assemble
import Elemstif

kdd :: (Array Int Int, Array Int Float) -> Vbm Float
kdd (norecord@s_azG)
  = incrvbmat initial_value_azH index_value_assoc_s_azI
  where initial_value_azH
          = makevbmat (ndgrs s_azG) (diagadr s_azG) (\ i_azJ -> 0.0)
        (!index_value_assoc_s_azI) = index_value_assoc s_azG
index_value_assoc (norecord@s_azK)
  = foldl assemble_s_azL [] [1 .. (nelem s_azK)]
  where (norecord@assemble_s_azL) = assemble s_azK
assemble s_aFL till_now_dd_aFM element_aFN
  = (till_now_dd_aFM ++ dd_this'_aFO)
  where (lazydmd@dd_this'_aFO)
          = [((f_aFY i_aGW, f_aFY j_aGX), x_aFX i_aGW j_aGX) |
             (norecord@i_aGW) <- [0 .. n_aFW - 1], j_aGX <- [0 .. i_aGW],
             f_aFY i_aGW > 0, f_aFY j_aGX > 0]
        dgrs_list_aFP
          = (dgrs_list_node_aFS nodel_aFQ) ++ (dgrs_list_node_aFS noder_aFR)
        (nodel_aFQ, noder_aFR) = getenlr s_aFL element_aFN
        dgrs_list_node_aFS node_aTT = getndgr s_aFL node_aTT
        (!eindex_dgrs_list_aFT) = zip [1 .. 6] dgrs_list_aFP
        aindex_dgrs_list_aFU = filter valid_index_aFV eindex_dgrs_list_aFT
        valid_index_aFV (norecord@((!i_aXi), dgr_aXj)) = (dgr_aXj /= 0)
        n_aFW = length aindex_dgrs_list_aFU
        x_aFX (norecord@i_aXk) (norecord@j_aXl)
          = matsub (beam2d s_aFL element_aFN)
              (fst (aindex_dgrs_list_aFU !! i_aXk),
               fst (aindex_dgrs_list_aFU !! j_aXl))
        f_aFY i_aXs = (snd (aindex_dgrs_list_aFU !! i_aXs))
ENDLOG
STARTLOG
ENDLOG
STARTLOG
ENDLOG
STARTLOG
["s_aDH","safebang@!s_aDH","(!s_aDH)","il_aDI","n_aDJ","s_aKG","safebang@!s_aKG","(!s_aKG)","rl_aKH","safebang@!rl_aKH","(!rl_aKH)","n_aKI","!n_aKI","(!n_aKI)","s_aKJ","s_aKQ","s_aKR","[]","![]","(![])","x_aO9","safebang@!x_aO9","(!x_aO9)","ls_aOa","(!x_aO9) : ls_aOa","((!x_aO9) : ls_aOa)","idb_aOb","rdb_aOc","(idb_aOb, rdb_aOc)","c_aOd","!c_aOd","(!c_aOd)","x_aOe","(!c_aOd) : x_aOe","((!c_aOd) : x_aOe)","!((!c_aOd) : x_aOe)","(!((!c_aOd) : x_aOe))","((!((!c_aOd) : x_aOe)))","s_a119","!s_a119","(!s_a119)","[]","c_a14o","!c_a14o","(!c_a14o)","ls_a14p","safebang@!ls_a14p","(!ls_a14p)","(!c_a14o) : (!ls_a14p)","((!c_a14o) : (!ls_a14p))","!((!c_a14o) : (!ls_a14p))","(!((!c_a14o) : (!ls_a14p)))","c_a14q","c_a14r","!c_a14r","(!c_a14r)","x_a14s","safebang@!x_a14s","(!x_a14s)","(!c_a14r) : (!x_a14s)","((!c_a14r) : (!x_a14s))","s_a14t","x_a14u","!x_a14u","(!x_a14u)","s_a14R","[]","![]","(![])","c_a14S","s_a14T","c_a14S : s_a14T","(c_a14S : s_a14T)","!(c_a14S : s_a14T)","(!(c_a14S : s_a14T))","((!(c_a14S : s_a14T)))","c_a14U","x_a14V","!x_a14V","(!x_a14V)","s_a14W","0","i_a1e2","!i_a1e2","(!i_a1e2)"]
module Database (idatabase, rdatabase) where
import Data.Array
import Data.Char (isDigit)

idatabase :: [Char] -> Array Int Int
idatabase (!s_aDH) = listArray (0, n_aDJ - 1) il_aDI
  where il_aDI = isource s_aDH
        n_aDJ = length il_aDI

rdatabase :: [Char] -> Array Int Float
rdatabase (!s_aKG) = listArray (0, n_aKI - 1) rl_aKH
  where (!rl_aKH) = rsource s_aKG
        (norecord@n_aKI) = length rl_aKH

isource :: [Char] -> [Int]
isource s_aKJ = fst (irsource s_aKJ)

rsource :: [Char] -> [Float]
rsource s_aKQ = snd (irsource s_aKQ)
irsource s_aKR = intreal (words s_aKR)
intreal (norecord@[]) = ([], [])
intreal ((!x_aO9) : ls_aOa)
  = if (elem '.' x_aO9) then (idb_aOb, (realreal x_aO9) : rdb_aOc)
      else ((intint x_aO9) : idb_aOb, rdb_aOc)
  where (idb_aOb, rdb_aOc) = intreal ls_aOa

intint :: [Char] -> Int
intint ((norecord@((norecord@c_aOd) : x_aOe)))
  = if (c_aOd == '-') then (-1) * (stoi x_aOe) else
      if (c_aOd == '+') then stoi x_aOe else stoi (c_aOd : x_aOe)

stoi :: [Char] -> Int
stoi (norecord@s_a119) = stoi' (reverse s_a119)
stoi' [] = 0
stoi' (norecord@((norecord@c_a14o) : (!ls_a14p)))
  = (stoi' ls_a14p) * 10 + ctoi c_a14o
ctoi c_a14q
  = if (c_a14q == '0') then 0 else
      if (c_a14q == '1') then 1 else
        if (c_a14q == '2') then 2 else
          if (c_a14q == '3') then 3 else
            if (c_a14q == '4') then 4 else
              if (c_a14q == '5') then 5 else
                if (c_a14q == '6') then 6 else
                  if (c_a14q == '7') then 7 else if (c_a14q == '8') then 8 else 9

realreal :: [Char] -> Float
realreal ((norecord@c_a14r) : (!x_a14s))
  = if (c_a14r == '-') then (-1.0) * (stor x_a14s) else
      if (c_a14r == '+') then stor x_a14s else stor (c_a14r : x_a14s)

stor :: [Char] -> Float
stor s_a14t = (intpart s_a14t) + (floatpart s_a14t)

intpart :: [Char] -> Float
intpart (norecord@x_a14u) = intpart' (takeWhile isDigit x_a14u)

intpart' :: [Char] -> Float
intpart' s_a14R = intparts (reverse s_a14R)
intparts (norecord@[]) = 0.0
intparts ((norecord@(c_a14S : s_a14T)))
  = (intparts s_a14T) * 10.0 + intpartss c_a14S
intpartss c_a14U
  = if (c_a14U == '0') then 0.0 else
      if (c_a14U == '1') then 1.0 else
        if (c_a14U == '2') then 2.0 else
          if (c_a14U == '3') then 3.0 else
            if (c_a14U == '4') then 4.0 else
              if (c_a14U == '5') then 5.0 else
                if (c_a14U == '6') then 6.0 else
                  if (c_a14U == '7') then 7.0 else
                    if (c_a14U == '8') then 8.0 else 9.0

floatpart :: [Char] -> Float
floatpart (norecord@x_a14V)
  = floatpart' (drop 1 (dropWhile isDigit x_a14V))

floatpart' :: [Char] -> Float
floatpart' s_a14W = (intpart' s_a14W) / (e10 (length s_a14W))
e10 0 = 1.0
e10 (norecord@i_a1e2) = 10.0 * (e10 (i_a1e2 - 1))
ENDLOG
STARTLOG
["db_axF","!db_axF","(!db_axF)","uvw_axG","force_2d_bar_s_axH","db_axI","safebang@!db_axI","(!db_axI)","element_axJ","safebang@!element_axJ","(!element_axJ)","frc_axK","!frc_axK","(!frc_axK)","db_axL","uvw_axM","element_axN","nodel_axO","!nodel_axO","(!nodel_axO)","noder_axP","!noder_axP","(!noder_axP)","((!nodel_axO), (!noder_axP))","ea_axQ","ei_axR","(ea_axQ, ei_axR)","xl_axS","yl_axT","(xl_axS, yl_axT)","!(xl_axS, yl_axT)","(!(xl_axS, yl_axT))","xr_axU","yr_axV","!yr_axV","(!yr_axV)","(xr_axU, (!yr_axV))","c_axW","!c_axW","(!c_axW)","s_axX","det_x_axY","!det_x_axY","(!det_x_axY)","det_y_axZ","!det_y_axZ","(!det_y_axZ)","length_ay0","ul_ay1","!ul_ay1","(!ul_ay1)","vl_ay2","thetal_ay3","!thetal_ay3","(!thetal_ay3)","((!ul_ay1), vl_ay2, (!thetal_ay3))","!((!ul_ay1), vl_ay2, (!thetal_ay3))","(!((!ul_ay1), vl_ay2, (!thetal_ay3)))","ur_ay4","vr_ay5","thetar_ay6","(ur_ay4, vr_ay5, thetar_ay6)","!(ur_ay4, vr_ay5, thetar_ay6)","(!(ur_ay4, vr_ay5, thetar_ay6))"]
module Elemforce (forces, getefrc) where
import Basics
import Vector
import DB_interface
import Displacement

forces ::
       (Array Int Int, Array Int Float) -> Vec Float -> Vec Float

getefrc ::
        (Array Int Int, Array Int Float) -> Int -> Vec Float -> Float
forces (norecord@db_axF) uvw_axG
  = makevec (nelem db_axF) force_2d_bar_s_axH
  where force_2d_bar_s_axH = force_2d_bar db_axF uvw_axG
getefrc (!db_axI) (!element_axJ) (norecord@frc_axK)
  = vecsub frc_axK element_axJ
force_2d_bar db_axL uvw_axM element_axN
  = (ea_axQ / length_ay0) *
      ((ur_ay4 - ul_ay1) * c_axW + (vr_ay5 - vl_ay2) * s_axX)
  where ((norecord@nodel_axO), (norecord@noder_axP))
          = getenlr db_axL element_axN
        (ea_axQ, ei_axR) = getmpro db_axL (getemat db_axL element_axN)
        (norecord@(xl_axS, yl_axT)) = getnxy db_axL nodel_axO
        (xr_axU, (norecord@yr_axV)) = getnxy db_axL noder_axP
        (norecord@c_axW) = det_x_axY / length_ay0
        s_axX = det_y_axZ / length_ay0
        (norecord@det_x_axY) = xr_axU - xl_axS
        (norecord@det_y_axZ) = yr_axV - yl_axT
        length_ay0 = sqrt (det_x_axY * det_x_axY + det_y_axZ * det_y_axZ)
        (norecord@((norecord@ul_ay1), vl_ay2, (norecord@thetal_ay3)))
          = getnuvw db_axL nodel_axO uvw_axM
        (norecord@(ur_ay4, vr_ay5, thetar_ay6))
          = getnuvw db_axL noder_axP uvw_axM
ENDLOG
STARTLOG
ENDLOG
STARTLOG
["n_aSw","safebang@!n_aSw","(!n_aSw)","f_aSx","i_aSy","n_aSz","safebang@!n_aSz","(!n_aSz)","_","!_","(!_)","VEC (!n_aSz) (!_)","(VEC (!n_aSz) (!_))","!(VEC (!n_aSz) (!_))","(!(VEC (!n_aSz) (!_)))","((!(VEC (!n_aSz) (!_))))","n_aSA","va_aSB","VEC n_aSA va_aSB","(VEC n_aSA va_aSB)","!(VEC n_aSA va_aSB)","(!(VEC n_aSA va_aSB))","((!(VEC n_aSA va_aSB)))","!((!(VEC n_aSA va_aSB)))","(!((!(VEC n_aSA va_aSB))))","i_aSC","n_aSD","va_aSE","VEC n_aSD va_aSE","(VEC n_aSD va_aSE)","s_aSF","b_aSH","!b_aSH","(!b_aSH)","c_aSI","n_aSJ","safebang@!n_aSJ","(!n_aSJ)","va_aSK","VEC (!n_aSJ) va_aSK","(VEC (!n_aSJ) va_aSK)","!(VEC (!n_aSJ) va_aSK)","(!(VEC (!n_aSJ) va_aSK))","((!(VEC (!n_aSJ) va_aSK)))","s_aSL","safebang@!s_aSL","(!s_aSL)","n_aSM","safebang@!n_aSM","(!n_aSM)","va_aSN","VEC (!n_aSM) va_aSN","(VEC (!n_aSM) va_aSN)","!(VEC (!n_aSM) va_aSN)","(!(VEC (!n_aSM) va_aSN))","((!(VEC (!n_aSM) va_aSN)))","s_aSO","safebang@!s_aSO","(!s_aSO)","v1_aSP","!v1_aSP","(!v1_aSP)","v2_aSQ","i_aYR","n_aSR","v_aYS","!v_aYS","(!v_aYS)","i_aYU","n_aYT","!n_aYT","(!n_aYT)"]
module Vector
       (Vec, makevec, boundvec, vecsub, incrvec, updvec, maxupdvec,
        vecprod, displayvec)
       where
import Data.Array
import Basics

displayvec :: (Show a_aKa) => Vec a_aKa -> [Char]

vecprod :: (Num a_aK9) => Vec a_aK9 -> Vec a_aK9 -> a_aK9

updvec :: Vec a_aK8 -> [(Int, a_aK8)] -> Vec a_aK8

maxupdvec ::
            (Num a_axc, Ord a_axc) => Vec a_axc -> [(Int, a_axc)] -> Vec a_axc

incrvec :: (Num a_awe) => Vec a_awe -> [(Int, a_awe)] -> Vec a_awe

vecsub :: Vec a_awd -> Int -> a_awd

boundvec :: Vec a_awc -> Int

makevec :: Int -> (Int -> a_awb) -> Vec a_awb
makevec (!n_aSw) f_aSx
  = VEC n_aSw
      (array (1, n_aSw) [(i_aSy, f_aSx i_aSy) | i_aSy <- [1 .. n_aSw]])
boundvec ((norecord@(VEC (!n_aSz) (norecord@_)))) = n_aSz
vecsub (norecord@((norecord@(VEC n_aSA va_aSB)))) i_aSC
  = va_aSB ! i_aSC
updvec (VEC n_aSD va_aSE) s_aSF
  = VEC n_aSD (accum f_aSG va_aSE s_aSF)
  where f_aSG (norecord@b_aSH) c_aSI = c_aSI
maxupdvec ((norecord@(VEC (!n_aSJ) va_aSK))) (!s_aSL)
  = VEC n_aSJ (accum max va_aSK s_aSL)
incrvec ((norecord@(VEC (!n_aSM) va_aSN))) (!s_aSO)
  = VEC n_aSM (accum (+) va_aSN s_aSO)
vecprod (norecord@v1_aSP) v2_aSQ
  = sum
      [(vecsub v1_aSP i_aYR) * (vecsub v2_aSQ i_aYR) |
       i_aYR <- [1 .. n_aSR]]
  where n_aSR = boundvec v1_aSP
displayvec (norecord@v_aYS)
  = "< " ++
      concat ([(showrj 8 (vecsub v_aYS i_aYU)) | i_aYU <- [1 .. n_aYT]])
      ++ ">\n"
  where (norecord@n_aYT) = boundvec v_aYS

data Vec a_anu = VEC Int (Array Int a_anu)
ENDLOG
STARTLOG
ENDLOG
STARTLOG
ENDLOG
STARTLOG
ENDLOG
STARTLOG
ENDLOG
STARTLOG
ENDLOG
START PROG /h/ywang30/nofib/real/hidden/
STARTLOG
ENDLOG
STARTLOG
ENDLOG
STARTLOG
ENDLOG
STARTLOG
["ls_aA8","safebang@!ls_aA8","(!ls_aA8)","iniplot_aA9","exiplot_aAa","lazydmd@!exiplot_aAa","(!exiplot_aAa)","[]","s_aAb","!s_aAb","(!s_aAb)","l_aAd","_","l_aAd : _","(l_aAd : _)","!(l_aAd : _)","(!(l_aAd : _))","ls_aAc@(!(l_aAd : _))","!ls_aAc@(!(l_aAd : _))","(!ls_aAc@(!(l_aAd : _)))","currentPoint_aAl","safebang@!currentPoint_aAl","(!currentPoint_aAl)","[]","s_aAm","!s_aAm","(!s_aAm)","currentPoint_aAn","l_aAo","!l_aAo","(!l_aAo)","ls_aAp","!ls_aAp","(!ls_aAp)","(!l_aAo) : (!ls_aAp)","((!l_aAo) : (!ls_aAp))","v_aNR","!v_aNR","(!v_aNR)","v_aNS","flush"]
module Postscript (Output, draw) where
import Numbers
import Vectors
import EdgePlate

draw :: [Edge] -> Output
draw (!ls_aA8) = iniplot_aA9 ++ plot ls_aA8 exiplot_aAa
  where iniplot_aA9
          = "\nerasepage gsave 100 100 translate 0 setlinewidth newpath\n"
        (lazydmd@exiplot_aAa) = "\nstroke grestore\n"

plot :: [Edge] -> ShowS

plotFrom :: Vector -> [Edge] -> ShowS

moveTo, lineTo :: Vector -> ShowS

flush :: ShowS
plot [] = \ (norecord@s_aAb) -> s_aAb
plot (norecord@ls_aAc@(norecord@(l_aAd : _)))
  = moveTo (s (l_aAd)) . plotFrom (s (l_aAd)) ls_aAc
plotFrom (!currentPoint_aAl) [] = \ (norecord@s_aAm) -> s_aAm
plotFrom currentPoint_aAn ((norecord@l_aAo) : (norecord@ls_aAp))
  | s (l_aAo) == currentPoint_aAn =
    lineTo (t (l_aAo)) . plotFrom (t (l_aAo)) ls_aAp
  | s (l_aAo) /= currentPoint_aAn = flush . plot (l_aAo : ls_aAp)
moveTo (norecord@v_aNR)
  = shows (x (v_aNR)) . showChar ' ' . shows (y (v_aNR)) .
      showString " moveto "
lineTo v_aNS
  = shows (x (v_aNS)) . showChar ' ' . shows (y (v_aNS)) .
      showString " lineto "
flush = showString "\nstroke newpath\n"

type Output = String
ENDLOG
STARTLOG
["plt1_ash","plt2_asi","!plt2_asi","(!plt2_asi)","plt_asj","v_aFL","safebang@!v_aFL","(!v_aFL)","n_aFM","safebang@!n_aFM","(!n_aFM)","ls_aFN","safebang@!ls_aFN","(!ls_aFN)","Plt (!n_aFM) (!ls_aFN)","(Plt (!n_aFM) (!ls_aFN))","!(Plt (!n_aFM) (!ls_aFN))","(!(Plt (!n_aFM) (!ls_aFN)))","l_aFO","n_aFP","safebang@!n_aFP","(!n_aFP)","ls_aFQ","Plt (!n_aFP) ls_aFQ","(Plt (!n_aFP) ls_aFQ)","!(Plt (!n_aFP) ls_aFQ)","(!(Plt (!n_aFP) ls_aFQ))","l_aFR","!l_aFR","(!l_aFR)","l_aFS","!l_aFS","(!l_aFS)","k_aFT","l_aFU","!l_aFU","(!l_aFU)","v_aFV","!v_aFV","(!v_aFV)","l_aFW","l_aFX","f_aFY","safebang@!f_aFY","(!f_aFY)","b_aFZ","l_aG0","v_aG1","safebang@!v_aG1","(!v_aG1)","w_aG2","v_aH1","rot","v_aH2","safebang@!v_aH2","(!v_aH2)","factor_aH3","safebang@!factor_aH3","(!factor_aH3)","base_aH4","safebang@!base_aH4","(!base_aH4)","v_aH5","viewdir_aH7","safebang@!viewdir_aH7","(!viewdir_aH7)","proj","f_aH8","safebang@!f_aH8","(!f_aH8)","b_aH9"]
module Geometric (Geom(..)) where
import Numbers
import Vectors
import EdgePlate
import Rotate

class Geom a_as9 where
        (|||) :: a_as9 -> a_as9 -> Bool
        
        vertical :: a_as9 -> Bool
        
        rot :: Vector -> a_as9 -> a_as9
        
        proj :: a_as9 -> a_as9
        
        scale :: Number -> Vector -> a_as9 -> a_as9

instance Geom Plate where
        plt1_ash ||| (norecord@plt2_asi) = n (plt1_ash) ||| n (plt2_asi)
        vertical plt_asj = z (n (plt_asj)) == 0
        rot (!v_aFL) (norecord@(Plt (!n_aFM) (!ls_aFN)))
          = Plt n_aFM [v_aFL `rot` l_aFO | l_aFO <- ls_aFN]
        proj (norecord@(Plt (!n_aFP) ls_aFQ))
          = Plt n_aFP [proj l_aFR | (norecord@l_aFR) <- ls_aFQ]

instance Geom Edge where
        (norecord@l_aFS) ||| k_aFT = h (l_aFS) ||| h (k_aFT)
        vertical (norecord@l_aFU) = vertical (h (l_aFU))
        rot (norecord@v_aFV) l_aFW
          = edgeT (v_aFV `rot` s (l_aFW)) (v_aFV `rot` t (l_aFW))
        proj l_aFX = edgeT (proj (s (l_aFX))) (proj (t (l_aFX)))
        scale (!f_aFY) b_aFZ l_aG0
          = edgeT (scale f_aFY b_aFZ (s (l_aG0)))
              (scale f_aFY b_aFZ (t (l_aG0)))

instance Geom Vector where
        (!v_aG1) ||| w_aG2 = v_aG1 * w_aG2 == 0
        vertical v_aH1 = v_aH1 ||| vec [0, 0, 1]
        rot = rotate
        proj (!v_aH2) = vec [x (v_aH2), y (v_aH2), 0]
        scale (!factor_aH3) (!base_aH4) v_aH5
          = factor_aH3 `mulv` (v_aH5 - base_aH4)

instance Geom a_aH6 => Geom [a_aH6] where
        rot (!viewdir_aH7) = map (rot viewdir_aH7)
        proj = map proj
        scale (!f_aH8) b_aH9 = map (scale f_aH8 b_aH9)
ENDLOG
STARTLOG
