
==================== Renamer ====================
infix 8 Main.^^^

Main.int :: Main.Nat -> Int
Main.int Main.Z = 0
Main.int (Main.S x_aLo) = 1 + Main.int x_aLo
x_aLp Main.^^^ Main.Z = Main.S Main.Z
(!x_aLq) Main.^^^ (Main.S (!y_aLr))
  = x_aLq * (x_aLq Main.^^^ y_aLr)
Main.main
  = do { [(!power_aLs)] <- getArgs;
         print $ Main.int (3 Main.^^^ (fromInteger $ read power_aLs)) }

data Main.Nat
  = Main.Z | Main.S Main.Nat
  deriving (Eq, Ord, Show)

instance Num Main.Nat where
  (!Main.Z) + y_aPZ = y_aPZ
  (Main.S (!x_aQ0)) + y_aQ1 = Main.S (x_aQ0 + y_aQ1)
  (!x_aQ2) * (!Main.Z) = Main.Z
  (!x_aQ3) * (Main.S (!y_aQ4)) = x_aQ3 * y_aQ4 + x_aQ3
  fromInteger x_aQ5
    = if x_aQ5 < 1 then Main.Z else Main.S (fromInteger (x_aQ5 - 1))


["Z","x_aLo","S x_aLo","(S x_aLo)","x_aLp","Z","x_aLq","!x_aLq","(!x_aLq)","y_aLr","!y_aLr","(!y_aLr)","S (!y_aLr)","(S (!y_aLr))","main","power_aLs","safebang@!power_aLs","(!power_aLs)","[(!power_aLs)]","Z","!Z","(!Z)","y_aPZ","x_aQ0","safebang@!x_aQ0","(!x_aQ0)","S (!x_aQ0)","(S (!x_aQ0))","y_aQ1","x_aQ2","safebang@!x_aQ2","(!x_aQ2)","Z","!Z","(!Z)","x_aQ3","!x_aQ3","(!x_aQ3)","y_aQ4","safebang@!y_aQ4","(!y_aQ4)","S (!y_aQ4)","(S (!y_aQ4))","x_aQ5"]
module Main (main) where
import System.Environment

infix 8 ^^^

int :: Nat -> Int
int Z = 0
int (S x_aLo) = 1 + int x_aLo
x_aLp ^^^ Z = S Z
(investigate@x_aLq) ^^^ (S (investigate@y_aLr))
  = x_aLq * (x_aLq ^^^ y_aLr)
main
  = do [(!power_aLs)] <- getArgs
       print $ int (3 ^^^ (fromInteger $ read power_aLs))

data Nat = Z
         | S Nat
         deriving (Eq, Ord, Show)

instance Num Nat where
        (investigate@Z) + y_aPZ = y_aPZ
        (S (!x_aQ0)) + y_aQ1 = S (x_aQ0 + y_aQ1)
        (!x_aQ2) * (investigate@Z) = Z
        (investigate@x_aQ3) * (S (!y_aQ4)) = x_aQ3 * y_aQ4 + x_aQ3
        fromInteger x_aQ5
          = if x_aQ5 < 1 then Z else S (fromInteger (x_aQ5 - 1))

==================== Renamer ====================
Main.main
  = interact
      (("Enter a generator: " ++)
       . show . Main.numchars . Main.expand . head . lines)
Main.numchars :: [String] -> Int
Main.numchars (!l_aNq) = sum $ map length l_aNq
Main.expand (![]) = [""]
Main.expand (!((!('<' : (!x_aTn))))) = Main.numericRule x_aTn
Main.expand ((!'[') : x_aTo) = Main.alphabeticRule x_aTo
Main.expand (!x_aTp) = Main.constantRule x_aTp
Main.constantRule (!((!(c_aTq : rest_aTr))))
  = [c_aTq : z_aTs | z_aTs <- Main.expand rest_aTr]
Main.alphabeticRule
  (!(a_aTt : ('-' : ((!b_aTu) : (!((!']') : rest_aTv))))))
  | a_aTt <= b_aTu
  = [c_a16X : z_a16Y |
       (!c_a16X) <- [a_aTt .. b_aTu], (!z_a16Y) <- Main.expand rest_aTv]
  | otherwise
  = [c_a16Z : z_a170 |
       c_a16Z <- reverse [b_aTu .. a_aTt], z_a170 <- Main.expand rest_aTv]
Main.numericRule x_a171
  = [pad_a179 (show i_a18e) ++ z_a18f |
       (!i_a18e) <- if u_a176 < v_a177 then
                        [u_a176 .. v_a177]
                    else
                        [u_a176, u_a176 - 1 .. v_a177],
       (!z_a18f) <- Main.expand s_a175]
  where
      (p_a172, _ : q_a173) = span (/= '-') x_a171
      ((!r_a174), _ : (!s_a175)) = span (/= '>') q_a173
      ((!u_a176), (!v_a177)) = (mknum_a178 p_a172, mknum_a178 r_a174)
      mknum_a178 (!s_a17b)
        = foldl
            (\ (!u_a17c) c_a17d -> u_a17c * 10 + (ord c_a17d - ord '0'))
            0
            s_a17b
      pad_a179 s_a18c
        = ['0' | i_a18d <- [1 .. (width_a17a - (length s_a18c))]] ++ s_a18c
      width_a17a = max (length (show u_a176)) (length (show v_a177))


["main","l_aNq","!l_aNq","(!l_aNq)","[]","![]","(![])","'<'","x_aTn","!x_aTn","(!x_aTn)","'<' : (!x_aTn)","('<' : (!x_aTn))","!('<' : (!x_aTn))","(!('<' : (!x_aTn)))","((!('<' : (!x_aTn))))","!((!('<' : (!x_aTn))))","(!((!('<' : (!x_aTn)))))","'['","!'['","(!'[')","x_aTo","(!'[') : x_aTo","((!'[') : x_aTo)","x_aTp","!x_aTp","(!x_aTp)","c_aTq","rest_aTr","c_aTq : rest_aTr","(c_aTq : rest_aTr)","!(c_aTq : rest_aTr)","(!(c_aTq : rest_aTr))","((!(c_aTq : rest_aTr)))","!((!(c_aTq : rest_aTr)))","(!((!(c_aTq : rest_aTr))))","z_aTs","a_aTt","'-'","b_aTu","safebang@!b_aTu","(!b_aTu)","']'","!']'","(!']')","rest_aTv","(!']') : rest_aTv","((!']') : rest_aTv)","!((!']') : rest_aTv)","(!((!']') : rest_aTv))","(!b_aTu) : (!((!']') : rest_aTv))","((!b_aTu) : (!((!']') : rest_aTv)))","'-' : ((!b_aTu) : (!((!']') : rest_aTv)))","('-' : ((!b_aTu) : (!((!']') : rest_aTv))))","a_aTt : ('-' : ((!b_aTu) : (!((!']') : rest_aTv))))","(a_aTt : ('-' : ((!b_aTu) : (!((!']') : rest_aTv)))))","!(a_aTt : ('-' : ((!b_aTu) : (!((!']') : rest_aTv)))))","(!(a_aTt : ('-' : ((!b_aTu) : (!((!']') : rest_aTv))))))","c_a16X","!c_a16X","(!c_a16X)","z_a16Y","!z_a16Y","(!z_a16Y)","c_a16Z","z_a170","x_a171","i_a18e","!i_a18e","(!i_a18e)","z_a18f","!z_a18f","(!z_a18f)","p_a172","_","q_a173","_ : q_a173","(p_a172, _ : q_a173)","r_a174","!r_a174","(!r_a174)","_","s_a175","!s_a175","(!s_a175)","_ : (!s_a175)","((!r_a174), _ : (!s_a175))","u_a176","!u_a176","(!u_a176)","v_a177","!v_a177","(!v_a177)","((!u_a176), (!v_a177))","s_a17b","!s_a17b","(!s_a17b)","u_a17c","safebang@!u_a17c","(!u_a17c)","c_a17d","s_a18c","i_a18d","width_a17a"]
module Main (main) where
import Data.Char
main
  = interact
      (("Enter a generator: " ++) . show . numchars . expand . head .
         lines)

numchars :: [String] -> Int
numchars (investigate@l_aNq) = sum $ map length l_aNq
expand (investigate@[]) = [""]
expand (investigate@((investigate@('<' : (investigate@x_aTn)))))
  = numericRule x_aTn
expand ((investigate@'[') : x_aTo) = alphabeticRule x_aTo
expand (investigate@x_aTp) = constantRule x_aTp
constantRule (investigate@((investigate@(c_aTq : rest_aTr))))
  = [c_aTq : z_aTs | z_aTs <- expand rest_aTr]
alphabeticRule
  (investigate@(a_aTt :
                  ('-' : ((!b_aTu) : (investigate@((investigate@']') : rest_aTv))))))
  | a_aTt <= b_aTu =
    [c_a16X : z_a16Y | (investigate@c_a16X) <- [a_aTt .. b_aTu],
     (investigate@z_a16Y) <- expand rest_aTv]
  | otherwise =
    [c_a16Z : z_a170 | c_a16Z <- reverse [b_aTu .. a_aTt],
     z_a170 <- expand rest_aTv]
numericRule x_a171
  = [pad_a179 (show i_a18e) ++ z_a18f |
     (investigate@i_a18e) <- if u_a176 < v_a177 then [u_a176 .. v_a177]
                               else [u_a176, u_a176 - 1 .. v_a177],
     (investigate@z_a18f) <- expand s_a175]
  where (p_a172, _ : q_a173) = span (/= '-') x_a171
        ((investigate@r_a174), _ : (investigate@s_a175))
          = span (/= '>') q_a173
        ((investigate@u_a176), (investigate@v_a177))
          = (mknum_a178 p_a172, mknum_a178 r_a174)
        mknum_a178 (investigate@s_a17b)
          = foldl
              (\ (!u_a17c) c_a17d -> u_a17c * 10 + (ord c_a17d - ord '0'))
              0
              s_a17b
        pad_a179 s_a18c
          = ['0' | i_a18d <- [1 .. (width_a17a - (length s_a18c))]] ++ s_a18c
        width_a17a = max (length (show u_a176)) (length (show v_a177))

==================== Renamer ====================
Main.integrate1D ::
  Double -> Double -> (Double -> Double) -> Double
Main.integrate1D (!l_aoG) u_aoH (!f_aoI)
  = let (!d_aoJ) = (u_aoH - l_aoG) / 8.0
    in
      d_aoJ
      * sum
          [(f_aoI l_aoG) * 0.5, f_aoI (l_aoG + d_aoJ),
           f_aoI (l_aoG + (2.0 * d_aoJ)), f_aoI (l_aoG + (3.0 * d_aoJ)),
           f_aoI (l_aoG + (4.0 * d_aoJ)), f_aoI (u_aoH - (3.0 * d_aoJ)),
           f_aoI (u_aoH - (2.0 * d_aoJ)), f_aoI (u_aoH - d_aoJ),
           (f_aoI u_aoH) * 0.5]
Main.integrate2D l1_aEX u1_aEY (!l2_aEZ) (!u2_aF0) f_aF1
  = Main.integrate1D
      l2_aEZ
      u2_aF0
      (\ (!y_aF2)
         -> Main.integrate1D l1_aEX u1_aEY (\ x_aF3 -> f_aF1 x_aF3 y_aF2))
Main.zark u_aF4 v_aF5
  = Main.integrate2D
      0.0 u_aF4 0.0 v_aF5 (\ x_aF6 -> (\ y_aF7 -> x_aF6 * y_aF7))
Main.ints = [1.0 .. ] :: [Double]
Main.zarks = zipWith Main.zark Main.ints (map (2.0 *) Main.ints)
Main.rtotals
  = head Main.zarks : zipWith (+) (tail Main.zarks) Main.rtotals
Main.rtotal n_aIx = Main.rtotals !! n_aIx
Main.is = map (^ 4) Main.ints
Main.itotals
  = head Main.is : zipWith (+) (tail Main.is) Main.itotals
Main.itotal (!n_aIy) = Main.itotals !! n_aIy
Main.es = map (^ 2) (zipWith (-) Main.rtotals Main.itotals)
Main.etotal (!n_aIz) = sum (take n_aIz Main.es)
Main.main
  = do { [range_aIA] <- getArgs;
         putStrLn $ show $ Main.etotal $ read range_aIA }


["l_aoG","safebang@!l_aoG","(!l_aoG)","u_aoH","f_aoI","safebang@!f_aoI","(!f_aoI)","d_aoJ","!d_aoJ","(!d_aoJ)","l1_aEX","u1_aEY","l2_aEZ","!l2_aEZ","(!l2_aEZ)","u2_aF0","!u2_aF0","(!u2_aF0)","f_aF1","y_aF2","safebang@!y_aF2","(!y_aF2)","x_aF3","u_aF4","v_aF5","x_aF6","y_aF7","ints","zarks","rtotals","n_aIx","is","itotals","n_aIy","!n_aIy","(!n_aIy)","es","n_aIz","!n_aIz","(!n_aIz)","main","range_aIA","[range_aIA]"]
module Main (integrate1D, main) where
import System.Environment

integrate1D :: Double -> Double -> (Double -> Double) -> Double
integrate1D (!l_aoG) u_aoH (!f_aoI)
  = let (investigate@d_aoJ) = (u_aoH - l_aoG) / 8.0 in
      d_aoJ *
        sum
          [(f_aoI l_aoG) * 0.5, f_aoI (l_aoG + d_aoJ),
           f_aoI (l_aoG + (2.0 * d_aoJ)), f_aoI (l_aoG + (3.0 * d_aoJ)),
           f_aoI (l_aoG + (4.0 * d_aoJ)), f_aoI (u_aoH - (3.0 * d_aoJ)),
           f_aoI (u_aoH - (2.0 * d_aoJ)), f_aoI (u_aoH - d_aoJ),
           (f_aoI u_aoH) * 0.5]
integrate2D l1_aEX u1_aEY (investigate@l2_aEZ) (investigate@u2_aF0)
  f_aF1
  = integrate1D l2_aEZ u2_aF0
      (\ (!y_aF2) ->
         integrate1D l1_aEX u1_aEY (\ x_aF3 -> f_aF1 x_aF3 y_aF2))
zark u_aF4 v_aF5
  = integrate2D 0.0 u_aF4 0.0 v_aF5
      (\ x_aF6 -> (\ y_aF7 -> x_aF6 * y_aF7))
ints = [1.0 ..] :: [Double]
zarks = zipWith zark ints (map (2.0 *) ints)
rtotals = head zarks : zipWith (+) (tail zarks) rtotals
rtotal n_aIx = rtotals !! n_aIx
is = map (^ 4) ints
itotals = head is : zipWith (+) (tail is) itotals
itotal (investigate@n_aIy) = itotals !! n_aIy
es = map (^ 2) (zipWith (-) rtotals itotals)
etotal (investigate@n_aIz) = sum (take n_aIz es)
main
  = do [range_aIA] <- getArgs
       putStrLn $ show $ etotal $ read range_aIA

==================== Renamer ====================
Main.suCC :: Int -> Int
Main.suCC x_aoy = x_aoy + 1
Main.isdivs :: Int -> Int -> Bool
Main.isdivs (!n_apx) (!x_apy) = mod x_apy n_apx /= 0
Main.the_filter :: [Int] -> [Int]
Main.the_filter (!(n_aM6 : (!ns_aM7)))
  = filter (Main.isdivs n_aM6) ns_aM7
Main.primes :: [Int]
Main.primes
  = map head (iterate Main.the_filter (iterate Main.suCC 2))
Main.main
  = do { [(!arg_aPH)] <- getArgs;
         print $ Main.primes !! (read arg_aPH) }


["x_aoy","n_apx","!n_apx","(!n_apx)","x_apy","!x_apy","(!x_apy)","n_aM6","ns_aM7","safebang@!ns_aM7","(!ns_aM7)","n_aM6 : (!ns_aM7)","(n_aM6 : (!ns_aM7))","!(n_aM6 : (!ns_aM7))","(!(n_aM6 : (!ns_aM7)))","primes","main","arg_aPH","safebang@!arg_aPH","(!arg_aPH)","[(!arg_aPH)]"]
module Main (main) where
import System.Environment

suCC :: Int -> Int
suCC x_aoy = x_aoy + 1

isdivs :: Int -> Int -> Bool
isdivs (investigate@n_apx) (investigate@x_apy)
  = mod x_apy n_apx /= 0

the_filter :: [Int] -> [Int]
the_filter (investigate@(n_aM6 : (!ns_aM7)))
  = filter (isdivs n_aM6) ns_aM7

primes :: [Int]
primes = map head (iterate the_filter (iterate suCC 2))
main
  = do [(!arg_aPH)] <- getArgs
       print $ primes !! (read arg_aPH)

==================== Renamer ====================
Main.main
  = do { (![arg_aoo]) <- getArgs;
         print $ Main.nsoln $ read arg_aoo }
Main.nsoln nq_asV
  = length (gen_asX nq_asV)
  where
      safe_asW :: Int -> Int -> [Int] -> Bool
      safe_asW x_at5 d_at6 (![]) = True
      safe_asW (!x_at7) d_at8 ((!q_at9) : l_ata)
        = x_at7 /= q_at9
          &&
            x_at7 /= q_at9 + d_at8
            && x_at7 /= q_at9 - d_at8 && safe_asW x_at7 (d_at8 + 1) l_ata
      gen_asX :: Int -> [[Int]]
      gen_asX 0 = [[]]
      gen_asX n_aHA
        = [(q_aHC : b_aHB) |
             b_aHB <- gen_asX (n_aHA - 1),
             q_aHC <- [1 .. nq_asV],
             safe_asW q_aHC 1 b_aHB]


["main","arg_aoo","[arg_aoo]","![arg_aoo]","(![arg_aoo])","nq_asV","x_at5","d_at6","[]","![]","(![])","x_at7","!x_at7","(!x_at7)","d_at8","q_at9","!q_at9","(!q_at9)","l_ata","(!q_at9) : l_ata","((!q_at9) : l_ata)","0","n_aHA","b_aHB","q_aHC"]
module Main (main) where
import System.Environment
main
  = do (investigate@[arg_aoo]) <- getArgs
       print $ nsoln $ read arg_aoo
nsoln nq_asV = length (gen_asX nq_asV)
  where safe_asW :: Int -> Int -> [Int] -> Bool
        safe_asW x_at5 d_at6 (investigate@[]) = True
        safe_asW (investigate@x_at7) d_at8 ((investigate@q_at9) : l_ata)
          = x_at7 /= q_at9 && x_at7 /= q_at9 + d_at8 && x_at7 /= q_at9 -
              d_at8
              && safe_asW x_at7 (d_at8 + 1) l_ata
        
        gen_asX :: Int -> [[Int]]
        gen_asX 0 = [[]]
        gen_asX n_aHA
          = [(q_aHC : b_aHB) | b_aHB <- gen_asX (n_aHA - 1),
             q_aHC <- [1 .. nq_asV], safe_asW q_aHC 1 b_aHB]

==================== Renamer ====================
Main.main
  = do { [arg_aov] <- getArgs;
         print $ Main.nfib $ read arg_aov }
Main.nfib :: Double -> Double
Main.nfib n_at2
  = if n_at2 <= 1 then
        1
    else
        Main.nfib (n_at2 - 1) + Main.nfib (n_at2 - 2) + 1


["main","arg_aov","[arg_aov]","n_at2"]
module Main (main) where
import System.Environment
main
  = do [arg_aov] <- getArgs
       print $ nfib $ read arg_aov

nfib :: Double -> Double
nfib n_at2
  = if n_at2 <= 1 then 1 else nfib (n_at2 - 1) + nfib (n_at2 - 2) + 1

==================== Renamer ====================
Main.tak :: Int -> Int -> Int -> Int
Main.tak (!x_aov) y_aow (!z_aox)
  = if not (y_aow < x_aov) then
        z_aox
    else
        Main.tak
          (Main.tak (x_aov - 1) y_aow z_aox)
          (Main.tak (y_aow - 1) z_aox x_aov)
          (Main.tak (z_aox - 1) x_aov y_aow)
Main.main
  = do { (![xs_aCX, ys_aCY, (!zs_aCZ)]) <- getArgs;
         print (Main.tak (read xs_aCX) (read ys_aCY) (read zs_aCZ)) }


["x_aov","safebang@!x_aov","(!x_aov)","y_aow","z_aox","safebang@!z_aox","(!z_aox)","main","xs_aCX","ys_aCY","zs_aCZ","safebang@!zs_aCZ","(!zs_aCZ)","[xs_aCX, ys_aCY, (!zs_aCZ)]","![xs_aCX, ys_aCY, (!zs_aCZ)]","(![xs_aCX, ys_aCY, (!zs_aCZ)])"]
module Main (main) where
import System.Environment

tak :: Int -> Int -> Int -> Int
tak (!x_aov) y_aow (!z_aox)
  = if not (y_aow < x_aov) then z_aox else
      tak (tak (x_aov - 1) y_aow z_aox) (tak (y_aow - 1) z_aox x_aov)
        (tak (z_aox - 1) x_aov y_aow)
main
  = do (investigate@[xs_aCX, ys_aCY, (!zs_aCZ)]) <- getArgs
       print (tak (read xs_aCX) (read ys_aCY) (read zs_aCZ))

==================== Renamer ====================
Main.primes :: [Int]
Main.primes = Main.sieve Main.wheels Main.primes Main.squares
Main.sieve (!(Main.Wheel s_aoC ns_aoD : ws_aoE)) ps_aoF qs_aoG
  = [n'_aGI |
       (!o_aGG) <- s_aoC
                   : [s_aoC * 2, s_aoC * 3 .. (head ps_aoF - 1) * s_aoC],
       n_aGH <- ns_aoD,
       (!n'_aGI) <- [n_aGH + o_aGG],
       noFactor_aoH n'_aGI]
    ++ Main.sieve ws_aoE (tail ps_aoF) (tail qs_aoG)
  where
      (!noFactor_aoH)
        = if s_aoC <= 2 then const True else Main.notDivBy ps_aoF qs_aoG
Main.notDivBy (p_aGJ : ps_aGK) ((!q_aGL) : qs_aGM) (!n_aGN)
  = q_aGL > n_aGN
    || n_aGN `mod` p_aGJ > 0 && Main.notDivBy ps_aGK qs_aGM n_aGN
Main.squares :: [Int]
Main.squares = [p_aPU * p_aPU | (!p_aPU) <- Main.primes]
Main.wheels :: [Main.Wheel]
Main.wheels
  = Main.Wheel 1 [1] : zipWith Main.nextSize Main.wheels Main.primes
Main.nextSize (!(Main.Wheel s_aPV ns_aPW)) (!p_aPX)
  = Main.Wheel (s_aPV * p_aPX) ns'_aPY
  where
      (!ns'_aPY)
        = [n'_aQ1 |
             o_aPZ <- [0, s_aPV .. (p_aPX - 1) * s_aPV],
             (!n_aQ0) <- ns_aPW,
             (!n'_aQ1) <- [n_aQ0 + o_aPZ],
             n'_aQ1 `mod` p_aPX > 0]
Main.main
  = do { [arg_aQ2] <- getArgs;
         print (Main.primes !! ((read arg_aQ2) :: Int)) }

data Main.Wheel = Main.Wheel Int [Int]


["primes","s_aoC","ns_aoD","Wheel s_aoC ns_aoD","ws_aoE","Wheel s_aoC ns_aoD : ws_aoE","(Wheel s_aoC ns_aoD : ws_aoE)","!(Wheel s_aoC ns_aoD : ws_aoE)","(!(Wheel s_aoC ns_aoD : ws_aoE))","ps_aoF","qs_aoG","o_aGG","!o_aGG","(!o_aGG)","n_aGH","n'_aGI","!n'_aGI","(!n'_aGI)","noFactor_aoH","investigate@!noFactor_aoH","(!noFactor_aoH)","p_aGJ","ps_aGK","p_aGJ : ps_aGK","(p_aGJ : ps_aGK)","q_aGL","safebang@!q_aGL","(!q_aGL)","qs_aGM","(!q_aGL) : qs_aGM","((!q_aGL) : qs_aGM)","n_aGN","safebang@!n_aGN","(!n_aGN)","squares","p_aPU","!p_aPU","(!p_aPU)","wheels","s_aPV","ns_aPW","Wheel s_aPV ns_aPW","(Wheel s_aPV ns_aPW)","!(Wheel s_aPV ns_aPW)","(!(Wheel s_aPV ns_aPW))","p_aPX","!p_aPX","(!p_aPX)","ns'_aPY","!ns'_aPY","(!ns'_aPY)","o_aPZ","n_aQ0","!n_aQ0","(!n_aQ0)","n'_aQ1","!n'_aQ1","(!n'_aQ1)","main","arg_aQ2","[arg_aQ2]"]
module Main (main) where
import System.Environment

primes :: [Int]
primes = sieve wheels primes squares
sieve (investigate@(Wheel s_aoC ns_aoD : ws_aoE)) ps_aoF qs_aoG
  = [n'_aGI |
     (investigate@o_aGG) <- s_aoC :
                              [s_aoC * 2, s_aoC * 3 .. (head ps_aoF - 1) * s_aoC],
     n_aGH <- ns_aoD, (investigate@n'_aGI) <- [n_aGH + o_aGG],
     noFactor_aoH n'_aGI]
      ++ sieve ws_aoE (tail ps_aoF) (tail qs_aoG)
  where (investigate@noFactor_aoH)
          = if s_aoC <= 2 then const True else notDivBy ps_aoF qs_aoG
notDivBy (p_aGJ : ps_aGK) ((!q_aGL) : qs_aGM) (!n_aGN)
  = q_aGL > n_aGN || n_aGN `mod` p_aGJ > 0 &&
      notDivBy ps_aGK qs_aGM n_aGN

squares :: [Int]
squares = [p_aPU * p_aPU | (investigate@p_aPU) <- primes]

wheels :: [Wheel]
wheels = Wheel 1 [1] : zipWith nextSize wheels primes
nextSize (investigate@(Wheel s_aPV ns_aPW)) (investigate@p_aPX)
  = Wheel (s_aPV * p_aPX) ns'_aPY
  where (investigate@ns'_aPY)
          = [n'_aQ1 | o_aPZ <- [0, s_aPV .. (p_aPX - 1) * s_aPV],
             (investigate@n_aQ0) <- ns_aPW,
             (investigate@n'_aQ1) <- [n_aQ0 + o_aPZ], n'_aQ1 `mod` p_aPX > 0]
main
  = do [arg_aQ2] <- getArgs
       print (primes !! ((read arg_aQ2) :: Int))

data Wheel = Wheel Int [Int]

==================== Renamer ====================
Main.primes :: [Int]
Main.primes = Main.spiral Main.wheels Main.primes Main.squares
Main.spiral
  ((!(Main.Wheel s_aoB ms_aoC ns_aoD)) : ws_aoE)
  ps_aoF
  qs_aoG
  = foldr turn0_aoI (roll_aoH s_aoB) ns_aoD
  where
      roll_aoH o_aoM
        = foldr
            (turn_aoJ o_aoM)
            (foldr (turn_aoJ o_aoM) (roll_aoH (o_aoM + s_aoB)) ns_aoD)
            ms_aoC
      turn0_aoI (!n_avR) rs_avS
        = if n_avR < q_aoL then n_avR : rs_avS else sp_aoK
      turn_aoJ o_aJk n_aJl rs_aJm
        = let (!n'_aJn) = o_aJk + n_aJl
          in
            if n'_aJn == 2 || n'_aJn < q_aoL then
                n'_aJn : rs_aJm
            else
                dropWhile (< n'_aJn) sp_aoK
      sp_aoK = Main.spiral ws_aoE (tail ps_aoF) (tail qs_aoG)
      q_aoL = head qs_aoG
Main.squares :: [Int]
Main.squares = [p_aMN * p_aMN | (!p_aMN) <- Main.primes]
Main.wheels :: [Main.Wheel]
Main.wheels
  = Main.Wheel 1 [1] []
    : zipWith3 Main.nextSize Main.wheels Main.primes Main.squares
Main.nextSize
  (!(Main.Wheel (!s_aMO) ms_aMP (!ns_aMQ)))
  (!p_aMR)
  q_aMS
  = Main.Wheel (s_aMO * p_aMR) ms'_aMV ns'_aMU
  where
      (xs_aMT, (!ns'_aMU))
        = span
            (<= q_aMS) (foldr turn0_aMX (roll_aMW (p_aMR - 1) s_aMO) ns_aMQ)
      ms'_aMV = foldr turn0_aMX xs_aMT ms_aMP
      roll_aMW 0 _ = []
      roll_aMW t_aMZ (!o_aN0)
        = foldr
            (turn_aMY o_aN0)
            (foldr
               (turn_aMY o_aN0) (roll_aMW (t_aMZ - 1) (o_aN0 + s_aMO)) ns_aMQ)
            ms_aMP
      turn0_aMX n_aN1 rs_aN2
        = if n_aN1 `mod` p_aMR > 0 then n_aN1 : rs_aN2 else rs_aN2
      turn_aMY o_aW9 (!n_aWa) rs_aWb
        = let (!n'_aWc) = o_aW9 + n_aWa
          in if n'_aWc `mod` p_aMR > 0 then n'_aWc : rs_aWb else rs_aWb
Main.main
  = do { (![arg_aWd]) <- getArgs;
         print (Main.primes !! ((read arg_aWd) :: Int)) }

data Main.Wheel = Main.Wheel Int [Int] [Int]


["primes","s_aoB","ms_aoC","ns_aoD","Wheel s_aoB ms_aoC ns_aoD","(Wheel s_aoB ms_aoC ns_aoD)","!(Wheel s_aoB ms_aoC ns_aoD)","(!(Wheel s_aoB ms_aoC ns_aoD))","ws_aoE","(!(Wheel s_aoB ms_aoC ns_aoD)) : ws_aoE","((!(Wheel s_aoB ms_aoC ns_aoD)) : ws_aoE)","ps_aoF","qs_aoG","o_aoM","n_avR","!n_avR","(!n_avR)","rs_avS","o_aJk","n_aJl","rs_aJm","n'_aJn","!n'_aJn","(!n'_aJn)","sp_aoK","q_aoL","squares","p_aMN","!p_aMN","(!p_aMN)","wheels","s_aMO","safebang@!s_aMO","(!s_aMO)","ms_aMP","ns_aMQ","safebang@!ns_aMQ","(!ns_aMQ)","Wheel (!s_aMO) ms_aMP (!ns_aMQ)","(Wheel (!s_aMO) ms_aMP (!ns_aMQ))","!(Wheel (!s_aMO) ms_aMP (!ns_aMQ))","(!(Wheel (!s_aMO) ms_aMP (!ns_aMQ)))","p_aMR","!p_aMR","(!p_aMR)","q_aMS","xs_aMT","ns'_aMU","!ns'_aMU","(!ns'_aMU)","(xs_aMT, (!ns'_aMU))","ms'_aMV","0","_","t_aMZ","o_aN0","!o_aN0","(!o_aN0)","n_aN1","rs_aN2","o_aW9","n_aWa","!n_aWa","(!n_aWa)","rs_aWb","n'_aWc","!n'_aWc","(!n'_aWc)","main","arg_aWd","[arg_aWd]","![arg_aWd]","(![arg_aWd])"]
module Main (main) where
import System.Environment

primes :: [Int]
primes = spiral wheels primes squares
spiral ((investigate@(Wheel s_aoB ms_aoC ns_aoD)) : ws_aoE) ps_aoF
  qs_aoG = foldr turn0_aoI (roll_aoH s_aoB) ns_aoD
  where roll_aoH o_aoM
          = foldr (turn_aoJ o_aoM)
              (foldr (turn_aoJ o_aoM) (roll_aoH (o_aoM + s_aoB)) ns_aoD)
              ms_aoC
        turn0_aoI (investigate@n_avR) rs_avS
          = if n_avR < q_aoL then n_avR : rs_avS else sp_aoK
        turn_aoJ o_aJk n_aJl rs_aJm
          = let (investigate@n'_aJn) = o_aJk + n_aJl in
              if n'_aJn == 2 || n'_aJn < q_aoL then n'_aJn : rs_aJm else
                dropWhile (< n'_aJn) sp_aoK
        sp_aoK = spiral ws_aoE (tail ps_aoF) (tail qs_aoG)
        q_aoL = head qs_aoG

squares :: [Int]
squares = [p_aMN * p_aMN | (investigate@p_aMN) <- primes]

wheels :: [Wheel]
wheels = Wheel 1 [1] [] : zipWith3 nextSize wheels primes squares
nextSize (investigate@(Wheel (!s_aMO) ms_aMP (!ns_aMQ)))
  (investigate@p_aMR) q_aMS = Wheel (s_aMO * p_aMR) ms'_aMV ns'_aMU
  where (xs_aMT, (investigate@ns'_aMU))
          = span (<= q_aMS)
              (foldr turn0_aMX (roll_aMW (p_aMR - 1) s_aMO) ns_aMQ)
        ms'_aMV = foldr turn0_aMX xs_aMT ms_aMP
        roll_aMW 0 _ = []
        roll_aMW t_aMZ (investigate@o_aN0)
          = foldr (turn_aMY o_aN0)
              (foldr (turn_aMY o_aN0) (roll_aMW (t_aMZ - 1) (o_aN0 + s_aMO))
                 ns_aMQ)
              ms_aMP
        turn0_aMX n_aN1 rs_aN2
          = if n_aN1 `mod` p_aMR > 0 then n_aN1 : rs_aN2 else rs_aN2
        turn_aMY o_aW9 (investigate@n_aWa) rs_aWb
          = let (investigate@n'_aWc) = o_aW9 + n_aWa in
              if n'_aWc `mod` p_aMR > 0 then n'_aWc : rs_aWb else rs_aWb
main
  = do (investigate@[arg_aWd]) <- getArgs
       print (primes !! ((read arg_aWd) :: Int))

data Wheel = Wheel Int [Int] [Int]

==================== Renamer ====================
Main.main
  = do { [arg_axG] <- getArgs;
         print
           (round
              (realPart (sum [Main.f n_aRg | n_aRg <- [1 .. (read arg_axG)]]))) }
Main.f :: Int -> Complex Double
Main.f (!n_aRh) = mkPolar 1 ((2 * pi) / fromIntegral n_aRh) ^ n_aRh


["main","arg_axG","[arg_axG]","n_aRg","n_aRh","!n_aRh","(!n_aRh)"]
module Main (main) where
import Data.Complex
import System.Environment
main
  = do [arg_axG] <- getArgs
       print
         (round (realPart (sum [f n_aRg | n_aRg <- [1 .. (read arg_axG)]])))

f :: Int -> Complex Double
f (investigate@n_aRh)
  = mkPolar 1 ((2 * pi) / fromIntegral n_aRh) ^ n_aRh
