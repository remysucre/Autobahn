STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
["x1_apZ","y1_aq0","x2_aq1","safebang@!x2_aq1","(!x2_aq1)","y2_aq2","[x1_apZ, y1_aq0, (!x2_aq1), y2_aq2]","f_aq3","x1_aq4","y1_aq5","x2_aq6","y2_aq7","safebang@!y2_aq7","(!y2_aq7)","[x1_aq4, y1_aq5, x2_aq6, (!y2_aq7)]","f_aq8","x1_aq9","safebang@!x1_aq9","(!x1_aq9)","y1_aqa","safebang@!y1_aqa","(!y1_aqa)","x2_aqb","safebang@!x2_aqb","(!x2_aqb)","y2_aqc","safebang@!y2_aqc","(!y2_aqc)","[(!x1_aq9), (!y1_aqa), (!x2_aqb), (!y2_aqc)]","![(!x1_aq9), (!y1_aqa), (!x2_aqb), (!y2_aqc)]","(![(!x1_aq9), (!y1_aqa), (!x2_aqb), (!y2_aqc)])","toright","down","x_arb","!x_arb","(!x_arb)","y_arc","x_ard","safebang@!x_ard","(!x_ard)","y_are","safebang@!y_are","(!y_are)","xymax","m_arf","x_arg","m_arh","safebang@!m_arh","(!m_arh)","x_ari","m_arj","safebang@!m_arj","(!m_arj)","x_ark","m_arl","x_arm","!x_arm","(!x_arm)","c1_arn","c2_aro","c3_arp","safebang@!c3_arp","(!c3_arp)","c4_arq","[c1_arn, c2_aro, (!c3_arp), c4_arq]","ss_arr","!ss_arr","(!ss_arr)","_","_","_","0","coords_ars","_","_","!_","(!_)","0","_","coords_art","x_aru","!x_aru","(!x_aru)","y_arv","c_arw","!c_arw","(!c_arw)","r_arx","!r_arx","(!r_arx)","coords_ary","!coords_ary","(!coords_ary)","x_arz","y_arA","0","!0","(!0)","coords_arB","x_arC","y_arD","n_arE","!n_arE","(!n_arE)","coords_arF","y'_arG","x_arH","safebang@!x_arH","(!x_arH)","y_arI","safebang@!y_arI","(!y_arI)","0","coords_arJ","x_arK","y_arL","n_arM","!n_arM","(!n_arM)","coords_arN","!coords_arN","(!coords_arN)","x'_arO"]
module Geomfuns
       (mapx, mapy, col, row, lrinvert, antirotate, place, rotatecw,
        tbinvert, tile, t4, xymax)
       where
import Mgrfuns
import Drawfuns

swapxy :: [Int] -> [Int]
swapxy [x1_apZ, y1_aq0, (!x2_aq1), y2_aq2]
  = [y1_aq0, x1_apZ, y2_aq2, x2_aq1]

mapx, mapy :: (Int -> Int) -> [Int] -> [Int]
mapx f_aq3 [x1_aq4, y1_aq5, x2_aq6, (!y2_aq7)]
  = [f_aq3 x1_aq4, y1_aq5, f_aq3 x2_aq6, y2_aq7]
mapy f_aq8 (norecord@[(!x1_aq9), (!y1_aqa), (!x2_aqb), (!y2_aqc)])
  = [x1_aq9, f_aq8 y1_aqa, x2_aqb, f_aq8 y2_aqc]

toright, down :: Int -> [[Int]] -> [[Int]]
toright = map . mapx . (+)
down = map . mapy . (+)

origin :: Int -> Int -> [[Int]] -> [[Int]]
origin (norecord@x_arb) y_arc = (toright x_arb) . (down y_arc)

place :: Int -> Int -> [[Int]] -> [Char]
place (!x_ard) (!y_are) = drawlines . (origin x_ard y_are)

xymax :: Int
xymax = 72

lrinvert, tbinvert, rotatecw, antirotate ::
          Int -> [[Int]] -> [[Int]]
lrinvert m_arf = map (mapx (\ x_arg -> m_arf - x_arg))
tbinvert (!m_arh) = map (mapy (\ x_ari -> m_arh - x_ari))
rotatecw (!m_arj)
  = map (swapxy . (mapy (\ x_ark -> m_arj - x_ark)))
antirotate m_arl
  = map (swapxy . (mapx (\ (norecord@x_arm) -> m_arl - x_arm)))

t4 :: [[[Int]]] -> [[Int]]
t4 [c1_arn, c2_aro, (!c3_arp), c4_arq]
  = c1_arn ++ toright ss_arr c2_aro ++ down ss_arr c3_arp ++
      (down ss_arr . toright ss_arr) c4_arq
  where (norecord@ss_arr) = xymax

tile :: Int -> Int -> Int -> Int -> [[Int]] -> [Char]
tile _ _ _ 0 coords_ars = ""
tile _ (norecord@_) 0 _ coords_art = ""
tile (norecord@x_aru) y_arv (norecord@c_arw) (norecord@r_arx)
  (norecord@coords_ary)
  = col x_aru y_arv r_arx coords_ary ++
      row (x_aru + 2 * xymax) y_arv (c_arw - 1) coords_ary
      ++
      tile (x_aru + 2 * xymax) (y_arv + 2 * xymax) (c_arw - 1)
        (r_arx - 1)
        coords_ary

col, row :: Int -> Int -> Int -> [[Int]] -> [Char]
col x_arz y_arA (norecord@0) coords_arB = ""
col x_arC y_arD (norecord@n_arE) coords_arF
  = place x_arC y_arD coords_arF ++
      col x_arC y'_arG (n_arE - 1) coords_arF
  where y'_arG = y_arD + (2 * xymax)
row (!x_arH) (!y_arI) 0 coords_arJ = ""
row x_arK y_arL (norecord@n_arM) (norecord@coords_arN)
  = place x_arK y_arL coords_arN ++
      row x'_arO y_arL (n_arM - 1) coords_arN
  where x'_arO = x_arK + (2 * xymax)
STARTLOG
STARTLOG
STARTLOG
["n_ap3","x1_ap4","y1_ap5","safebang@!y1_ap5","(!y1_ap5)","x2_ap6","y2_ap7","[x1_ap4, (!y1_ap5), x2_ap6, y2_ap7]","x0_ap8","y0_ap9","x1_apa","y1_apb","safebang@!y1_apb","(!y1_apb)","[x0_ap8, y0_ap9, x1_apa, (!y1_apb)]","m_apc","n_aCH","!n_aCH","(!n_aCH)","0","!0","(!0)","n_aCI","!n_aCI","(!n_aCI)","n_aDH","safebang@!n_aDH","(!n_aDH)","x_aDI","safebang@!x_aDI","(!x_aDI)","y_aDJ","safebang@!y_aDJ","(!y_aDJ)","n_aDK","x_aDL","safebang@!x_aDL","(!x_aDL)","y_aDM","x_aDN","safebang@!x_aDN","(!x_aDN)","y_aDO","safebang@!y_aDO","(!y_aDO)","f_aDP","safebang@!f_aDP","(!f_aDP)","undraw","drawlines","_","!_","(!_)","[]","_","!_","(!_)","_","_","[]","![]","(![])","f_aJX","x_aJY","xs_aJZ","!xs_aJZ","(!xs_aJZ)","x_aJY : (!xs_aJZ)","(x_aJY : (!xs_aJZ))","ys_aK0","!ys_aK0","(!ys_aK0)","xor_aK1","yor_aK2","xgap_aK3","ygap_aK4","xlength_aK5","ylength_aK6","drawf_aK7","safebang@!drawf_aK7","(!drawf_aK7)","x0list_aK8","y0list_aK9","orig_aKb","gap_aKc","safebang@!gap_aKc","(!gap_aKc)","len_aKd","n_aKf","safebang@!n_aKf","(!n_aKf)"]
module Drawfuns
       (drawdot, grid, squ, circ, gowin, rectangle, fillrect, undo,
        undraw, drawlines)
       where
import Mgrfuns
import Diff

gowin :: Int -> [Char]
gowin n_ap3 = selectwin n_ap3 ++ setmode 7 ++ setmode 8

rectangle :: [Int] -> [Char]
rectangle [x1_ap4, (!y1_ap5), x2_ap6, y2_ap7]
  = line [x1_ap4, y1_ap5, x2_ap6, y1_ap5] ++
      line [x2_ap6, y1_ap5, x2_ap6, y2_ap7]
      ++ line [x1_ap4, y1_ap5, x1_ap4, y2_ap7]
      ++ line [x1_ap4, y2_ap7, x2_ap6, y2_ap7]

fillrect :: [Int] -> [Char]
fillrect [x0_ap8, y0_ap9, x1_apa, (!y1_apb)]
  = shade_ape (diff x0_ap8 x1_apa)
  where m_apc = min x0_ap8 x1_apa
        vline_apd (norecord@n_aCH) = line [n_aCH, y0_ap9, n_aCH, y1_apb]
        shade_ape (norecord@0) = vline_apd m_apc
        shade_ape (norecord@n_aCI)
          = vline_apd (m_apc + n_aCI) ++ shade_ape (n_aCI - 1)

squ :: Int -> Int -> Int -> [Char]
squ (!n_aDH) (!x_aDI) (!y_aDJ)
  = rectangle [x_aDI, y_aDJ, x_aDI + n_aDH, y_aDJ + n_aDH]

circ :: Int -> Int -> Int -> [Char]
circ n_aDK (!x_aDL) y_aDM = circle [x_aDL, y_aDM, n_aDK]

drawdot :: Int -> Int -> [Char]
drawdot (!x_aDN) (!y_aDO)
  = fillrect [x_aDN - 1, y_aDO - 1, x_aDN + 1, y_aDO + 1]

undo :: [Char] -> [Char]
undo (!f_aDP) = func 0 ++ f_aDP ++ func 15

undraw :: [Int] -> [Char]
undraw = undo . line

drawlines :: [[Int]] -> [Char]
drawlines = concat . map line
allpairs (norecord@_) [] (norecord@_) = []
allpairs _ _ (norecord@[]) = []
allpairs f_aJX (x_aJY : (norecord@xs_aJZ)) (norecord@ys_aK0)
  = map (f_aJX x_aJY) ys_aK0 ++ allpairs f_aJX xs_aJZ ys_aK0

grid ::
     Int ->
       Int ->
         Int -> Int -> Int -> Int -> (Int -> Int -> [a_aoV]) -> [a_aoV]
grid xor_aK1 yor_aK2 xgap_aK3 ygap_aK4 xlength_aK5 ylength_aK6
  (!drawf_aK7) = concat (allpairs drawf_aK7 x0list_aK8 y0list_aK9)
  where x0list_aK8 = gridlist_aKa xor_aK1 xgap_aK3 xlength_aK5
        y0list_aK9 = gridlist_aKa yor_aK2 ygap_aK4 ylength_aK6
        gridlist_aKa orig_aKb (!gap_aKc) len_aKd
          = take len_aKd (gridlist'_aKe orig_aKb)
          where gridlist'_aKe (!n_aKf)
                  = n_aKf : gridlist'_aKe (n_aKf + gap_aKc)
STARTLOG
["x_an7","y_an8","(x_an7, y_an8)","!(x_an7, y_an8)","(!(x_an7, y_an8))","u_an9","v_ana","d_anb","0","n2_aBD","n1_aBE","0","!0","(!0)","n1_aBF","n2_aBG","x_aKN","safebang@!x_aKN","(!x_aKN)","y_aKO","safebang@!y_aKO","(!y_aKO)","((!x_aKN), (!y_aKO))","!((!x_aKN), (!y_aKO))","(!((!x_aKN), (!y_aKO)))","u_aKP","safebang@!u_aKP","(!u_aKP)","v_aKQ","safebang@!v_aKQ","(!v_aKQ)","((!u_aKP), (!v_aKQ))","!((!u_aKP), (!v_aKQ))","(!((!u_aKP), (!v_aKQ)))","x_aKR","y_aKS","safebang@!y_aKS","(!y_aKS)","(x_aKR, (!y_aKS))","u_aKT","safebang@!u_aKT","(!u_aKT)","v_aKU","safebang@!v_aKU","(!v_aKU)","((!u_aKT), (!v_aKU))","!((!u_aKT), (!v_aKU))","(!((!u_aKT), (!v_aKU)))","x_aKV","y_aKW","(x_aKV, y_aKW)","!(x_aKV, y_aKW)","(!(x_aKV, y_aKW))","u_aKX","v_aKY","safebang@!v_aKY","(!v_aKY)","(u_aKX, (!v_aKY))","x_aKZ","y_aL0","safebang@!y_aL0","(!y_aL0)","(x_aKZ, (!y_aL0))","u_aL1","v_aL2","safebang@!v_aL2","(!v_aL2)","(u_aL1, (!v_aL2))","x_aL3","y_aL4","safebang@!y_aL4","(!y_aL4)","(x_aL3, (!y_aL4))","u_aL5","v_aL6","(u_aL5, v_aL6)","a_aL7","b_aL8","(a_aL7, b_aL8)","!(a_aL7, b_aL8)","(!(a_aL7, b_aL8))","x_aL9","y_aLa","(x_aL9, y_aLa)","x_aLb","safebang@!x_aLb","(!x_aLb)","y_aLc","((!x_aLb), y_aLc)","!((!x_aLb), y_aLc)","(!((!x_aLb), y_aLc))","x_aLd","safebang@!x_aLd","(!x_aLd)","y_aLe","safebang@!y_aLe","(!y_aLe)","((!x_aLd), (!y_aLe))","n_aTD"]
module Rational
       (radd, rsub, rmul, rdiv, rmin, rabs, intval, show_rat, torat) where

norm :: (Int, Int) -> (Int, Int)
norm (norecord@(x_an7, y_an8))
  = (u_an9 `div` d_anb, v_ana `div` d_anb)
  where u_an9 = if y_an8 > 0 then x_an7 else -x_an7
        v_ana = abs y_an8
        d_anb = gcd_anc (abs u_an9) v_ana
        
        gcd_anc :: Int -> Int -> Int
        gcd_anc 0 n2_aBD = n2_aBD
        gcd_anc n1_aBE (norecord@0) = n1_aBE
        gcd_anc n1_aBF n2_aBG
          = if n1_aBF < n2_aBG then gcd_anc n1_aBF (n2_aBG `mod` n1_aBF) else
              gcd_anc (n1_aBF `mod` n2_aBG) n2_aBG

radd, rsub, rmul, rdiv :: (Int, Int) -> (Int, Int) -> (Int, Int)
radd (norecord@((!x_aKN), (!y_aKO)))
  (norecord@((!u_aKP), (!v_aKQ)))
  = norm (x_aKN * v_aKQ + u_aKP * y_aKO, y_aKO * v_aKQ)
rsub (x_aKR, (!y_aKS)) (norecord@((!u_aKT), (!v_aKU)))
  = norm (x_aKR * v_aKU - u_aKT * y_aKS, y_aKS * v_aKU)
rmul (norecord@(x_aKV, y_aKW)) (u_aKX, (!v_aKY))
  = norm (x_aKV * u_aKX, y_aKW * v_aKY)
rdiv (x_aKZ, (!y_aL0)) (u_aL1, (!v_aL2))
  = norm (x_aKZ * v_aL2, y_aL0 * u_aL1)
rmin (x_aL3, (!y_aL4)) (u_aL5, v_aL6)
  = if a_aL7 > 0 then (u_aL5, v_aL6) else (x_aL3, y_aL4)
  where (norecord@(a_aL7, b_aL8))
          = rsub (x_aL3, y_aL4) (u_aL5, v_aL6)

rabs :: (Int, Int) -> (Int, Int)
rabs (x_aL9, y_aLa)
  = if x_aL9 < 0 then (-x_aL9, y_aLa) else (x_aL9, y_aLa)

intval :: (Int, Int) -> Int
intval (norecord@((!x_aLb), y_aLc)) = x_aLb `div` y_aLc

show_rat :: (Int, Int) -> [Char]
show_rat ((!x_aLd), (!y_aLe)) = show x_aLd ++ "/" ++ show y_aLe

torat :: Int -> (Int, Int)
torat n_aTD = (n_aTD, 1)
STARTLOG
["prompt_an1","endp_an2","transact_an3","safebang@!transact_an3","(!transact_an3)","state_an5","inpt_an6","response_an7","newstate_an8","restofinput_an9","(response_an7, newstate_an8, restofinput_an9)"]
module Interstate (inter) where

inter ::
      (a_amR -> [b_amS]) ->
        (a_amR -> c_amT -> Bool) ->
          (a_amR -> c_amT -> ([b_amS], a_amR, c_amT)) ->
            (a_amR -> c_amT -> [b_amS])
inter prompt_an1 endp_an2 (!transact_an3) = interprog_an4
  where interprog_an4 state_an5 inpt_an6
          = prompt_an1 state_an5 ++
              if endp_an2 state_an5 inpt_an6 then [] else
                response_an7 ++ interprog_an4 newstate_an8 restofinput_an9
          where (response_an7, newstate_an8, restofinput_an9)
                  = transact_an3 state_an5 inpt_an6
STARTLOG
["helpsetup","helpend","helpdraw","helptile","helpalter","helptsave","helptclear","helptget","helpt4","helpquit","helpbt","helppic","helpdesign","helpdsave","helpdclear","helpdget","inithelp","errmes","endmes"]
module Help
       (helpend, helpdraw, helptile, helpalter, helptsave, helptclear,
        helptget, helpt4, helpquit, helpbt, helppic, helpdesign, helpdsave,
        helpdclear, helpdget, inithelp, errmes)
       where
import Layout
import Mgrfuns

helpsetup, helpend :: [Char]

helpdraw, helpdsave, helpdclear, helpdget :: [Char]

helptile, helpalter, helptsave, helptclear, helptget, helpt4 ::
          [Char]

helpquit, helpbt, helppic, helpdesign :: [Char]
helpsetup = textregion helptextarea ++ font 8
helpend = cleara helptextarea ++ font 13
helpdraw
  = "This button puts you in drawing mode.\n" ++
      "Lines can be drawn in the STAMP DESIGN \n"
      ++ "area by holding down the middle button,\n"
      ++ "and deleted by clicking\n"
      ++ "with the right one.\n"
      ++ "\nLittle circles will appear if a line\n"
      ++ "touches the edge of the square.\n"
      ++ "These indicate positions on all the sides\n"
      ++ "that would contact that line in each of\n"
      ++ "the possible orientations of the print.\n"
      ++ "Unless special effects are being sought,\n"
      ++ "the recommendation is that all little\n"
      ++ "circles be attached to a line.\n"
      ++ endmes
helptile
  = "In this mode, orientations of the print\n" ++
      "can be placed in the TILE DESIGN area\n"
      ++ "to create a 64 X 64 big tile\n"
      ++ "\nUse the right button to select a print\n"
      ++ "and the middle button to place it.\n"
      ++ "\nWithin the tiling area the right button\n"
      ++ "may also be used to delete a square\n"
      ++ "\nTo rotate or invert squares within\n"
      ++ "the big tile it may be more convenient\n"
      ++ "to use the ALTER mode."
      ++ endmes
helpalter
  = "In ALTER mode, squares within the\n" ++
      "big tile can be adjusted.\n"
      ++ "The middle button causes them to \n"
      ++ "rotate clockwise.\n"
      ++ "The right button causes them to\n"
      ++ "invert."
      ++ endmes
helptsave = "Sorry, SAVE is temporarily inoperative." ++ endmes
helptclear
  = "This CLEAR button clears the TILE DESIGN\n" ++
      "region and draws an empty grid."
      ++ endmes
helptget = "Sorry, GET is temporarily inoperative." ++ endmes
helpt4
  = "The T4 button tiles the whole big tile\n" ++
      "with the pattern of the four squares\n"
      ++ "in the top left hand corner\n"
      ++ endmes
helpquit
  = "\n\n\nClicking on QUIT allows you\n" ++
      "to leave the program.\n"
      ++ endmes
helpbt
  = "\n\n\nWithin the TILE DESIGN area,\n" ++
      "a big tile, based on orientations of\n"
      ++ "a print design, can be built.\n"
      ++ "\nUsing TILE mode the right button\n"
      ++ "will select from a palette at the bottom\n"
      ++ "of the screen, and the middle button will\n"
      ++ "place the selection within the big tile.\n"
      ++ "Within the area the right button will\n"
      ++ "delete squares.\n"
      ++ "\nUsing ALTER mode the right button will\n"
      ++ "invert squares, and the middle button \n"
      ++ "will rotate them."
      ++ endmes
helppic
  = "\nThese boxes show the eight possible\n" ++
      "orientations of the print that is\n"
      ++ "to be used in tiling\n"
      ++ "\nWhen in tiling mode, clicking with the\n"
      ++ "right button over one of these\n"
      ++ "will make it the \"current selection\".\n"
      ++ "Clicking with the middle button in\n"
      ++ "the TILE DESIGN grid, will put that\n"
      ++ "orientation of the print at that place"
      ++ endmes
helpdesign
  = "\n\n\nThis is the area in which to design \nyour print.\n" ++
      "\nDraw lines by holding down the\n middle button.\n"
      ++ "Delete lines by clicking with the\n right button.\n"
      ++ "\n\nA print that has previously been saved\n"
      ++ "can be restored by clicking on GET\n"
      ++ "then typing in the filename at the prompt.\n"
      ++ endmes
helpdsave = "Sorry, SAVE is temporarily inoperative." ++ endmes
helpdclear
  = "\n\n\nThis clears the PRINT DESIGN grid.\n" ++
      "The print currently being worked on\n"
      ++ "will be lost, unless it has been\n"
      ++ "explicitly SAVEd first\n"
      ++ endmes
helpdget = "Sorry, GET is temporarily inoperative." ++ endmes

inithelp, errmes, endmes :: [Char]
inithelp
  = helpsetup ++ clear ++
      "\n\n\n\nTo find out the use of a particular\n"
      ++ "menu button or region of the screen, \n"
      ++ "click over the item you wish to\n"
      ++ "investigate.\n"
errmes
  = "\n\n\nYou have clicked over an area \n" ++
      "of no particular interest.\n"
      ++ endmes
endmes
  = "\n\n PRESS RETURN TO RETURN TO THE PROGRAM\n" ++
      "OR CLICK SOMEWHERE ELSE TO FIND OUT MORE\n"
STARTLOG
STARTLOG
["n_an0","a_anZ","b_ao0","safebang@!b_ao0","(!b_ao0)","n_aBt","a_aBv","b_aBw","m_aBx","s_aBy"]
module Diff (diff, bcroot, square) where

square :: Int -> Int
square n_an0 = n_an0 * n_an0

diff :: Int -> Int -> Int
diff a_anZ (!b_ao0)
  = if a_anZ > b_ao0 then a_anZ - b_ao0 else b_ao0 - a_anZ

bcroot :: Int -> Int
bcroot n_aBt = root'_aBu 0 n_aBt
  where root'_aBu a_aBv b_aBw
          = if a_aBv + 1 >= b_aBw then b_aBw else
              if s_aBy < n_aBt then root'_aBu m_aBx b_aBw else
                if n_aBt < s_aBy then root'_aBu a_aBv m_aBx else m_aBx
          where m_aBx = (a_aBv + b_aBw) `div` 2
                s_aBy = m_aBx * m_aBx
STARTLOG
["_","_","'q'","!'q'","(!'q')","_","(!'q') : _","((!'q') : _)","_","((!'q') : _) : _","(((!'q') : _) : _)","_","!_","(!_)","[]","_","_","!_","(!_)","dlist_aTd","safebang@!dlist_aTd","(!dlist_aTd)","sel_aTe","safebang@!sel_aTe","(!sel_aTe)","tilist_aTf","safebang@!tilist_aTf","(!tilist_aTf)","((!dlist_aTd), (!sel_aTe), (!tilist_aTf))","!((!dlist_aTd), (!sel_aTe), (!tilist_aTf))","(!((!dlist_aTd), (!sel_aTe), (!tilist_aTf)))","'m'","!'m'","(!'m')","'s'","'a'","!'a'","(!'a')","' '","rest_aTg","lazydmd@!rest_aTg","(!rest_aTg)","' ' : (!rest_aTg)","(' ' : (!rest_aTg))","!(' ' : (!rest_aTg))","(!(' ' : (!rest_aTg)))","(!'a') : (!(' ' : (!rest_aTg)))","((!'a') : (!(' ' : (!rest_aTg))))","!((!'a') : (!(' ' : (!rest_aTg))))","(!((!'a') : (!(' ' : (!rest_aTg)))))","'s' : (!((!'a') : (!(' ' : (!rest_aTg)))))","('s' : (!((!'a') : (!(' ' : (!rest_aTg))))))","(!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg))))))","((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))","!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))","(!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg))))))))","inpt_aTh","(!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n  inpt_aTh","((!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n   inpt_aTh)","!((!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n    inpt_aTh)","(!((!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n     inpt_aTh))","((!((!((!'m') : ('s' : (!((!'a') : (!(' ' : (!rest_aTg)))))))) :\n      inpt_aTh)))","x_aTi","y_aTj","!y_aTj","(!y_aTj)","[x_aTi, (!y_aTj)]","fun_aTl","dlist_aTm","!dlist_aTm","(!dlist_aTm)","sel_aTn","tilist_aTo","((!dlist_aTm), sel_aTn, tilist_aTo)","!((!dlist_aTm), sel_aTn, tilist_aTo)","(!((!dlist_aTm), sel_aTn, tilist_aTo))","'m'","'s'","'b'","' '","rest_aTp","' ' : rest_aTp","(' ' : rest_aTp)","'b' : (' ' : rest_aTp)","('b' : (' ' : rest_aTp))","!('b' : (' ' : rest_aTp))","(!('b' : (' ' : rest_aTp)))","'s' : (!('b' : (' ' : rest_aTp)))","('s' : (!('b' : (' ' : rest_aTp))))","'m' : ('s' : (!('b' : (' ' : rest_aTp))))","('m' : ('s' : (!('b' : (' ' : rest_aTp)))))","inpt_aTq","lazydmd@!inpt_aTq","(!inpt_aTq)","('m' : ('s' : (!('b' : (' ' : rest_aTp))))) : (!inpt_aTq)","(('m' : ('s' : (!('b' : (' ' : rest_aTp))))) : (!inpt_aTq))","!(('m' : ('s' : (!('b' : (' ' : rest_aTp))))) : (!inpt_aTq))","(!(('m' : ('s' : (!('b' : (' ' : rest_aTp))))) : (!inpt_aTq)))","x_aTr","!x_aTr","(!x_aTr)","y_aTs","!y_aTs","(!y_aTs)","[(!x_aTr), (!y_aTs)]","dlist_aTt","sel_aTu","!sel_aTu","(!sel_aTu)","tilist_aTv","(dlist_aTt, (!sel_aTu), tilist_aTv)","'m'","'s'","!'s'","(!'s')","'c'","' '","rest_aTw","lazydmd@!rest_aTw","(!rest_aTw)","' ' : (!rest_aTw)","(' ' : (!rest_aTw))","!(' ' : (!rest_aTw))","(!(' ' : (!rest_aTw)))","'c' : (!(' ' : (!rest_aTw)))","('c' : (!(' ' : (!rest_aTw))))","(!'s') : ('c' : (!(' ' : (!rest_aTw))))","((!'s') : ('c' : (!(' ' : (!rest_aTw)))))","'m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))","('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw))))))","inpt_aTx","lazydmd@!inpt_aTx","(!inpt_aTx)","('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) : (!inpt_aTx)","(('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) : (!inpt_aTx))","!(('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) : (!inpt_aTx))","(!(('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) :\n     (!inpt_aTx)))","((!(('m' : ((!'s') : ('c' : (!(' ' : (!rest_aTw)))))) :\n      (!inpt_aTx))))","x_aTy","y_aTz","[x_aTy, y_aTz]","![x_aTy, y_aTz]","(![x_aTy, y_aTz])","fun_aTB","!fun_aTB","(!fun_aTB)","state_aTC","'m'","'s'","!'s'","(!'s')","'d'","!'d'","(!'d')","' '","!' '","(!' ')","rest_aTD","lazydmd@!rest_aTD","(!rest_aTD)","(!' ') : (!rest_aTD)","((!' ') : (!rest_aTD))","(!'d') : ((!' ') : (!rest_aTD))","((!'d') : ((!' ') : (!rest_aTD)))","(!'s') : ((!'d') : ((!' ') : (!rest_aTD)))","((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))","'m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))","('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD)))))","!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD)))))","(!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))))","((!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD)))))))","inpt_aTE","lazydmd@!inpt_aTE","(!inpt_aTE)","((!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))))) :\n  (!inpt_aTE)","(((!('m' : ((!'s') : ((!'d') : ((!' ') : (!rest_aTD))))))) :\n   (!inpt_aTE))","x_aTF","y_aTG","[x_aTF, y_aTG]","![x_aTF, y_aTG]","(![x_aTF, y_aTG])","str_aTJ","!str_aTJ","(!str_aTJ)","out_aTI","dlist_aTK","!dlist_aTK","(!dlist_aTK)","sel_aTL","!sel_aTL","(!sel_aTL)","tilist_aTM","((!dlist_aTK), (!sel_aTL), tilist_aTM)","'c'","'s'","!'s'","(!'s')","' '","rest_aTN","lazydmd@!rest_aTN","(!rest_aTN)","' ' : (!rest_aTN)","(' ' : (!rest_aTN))","!(' ' : (!rest_aTN))","(!(' ' : (!rest_aTN)))","(!'s') : (!(' ' : (!rest_aTN)))","((!'s') : (!(' ' : (!rest_aTN))))","!((!'s') : (!(' ' : (!rest_aTN))))","(!((!'s') : (!(' ' : (!rest_aTN)))))","'c' : (!((!'s') : (!(' ' : (!rest_aTN)))))","('c' : (!((!'s') : (!(' ' : (!rest_aTN))))))","inpt_aTO","('c' : (!((!'s') : (!(' ' : (!rest_aTN)))))) : inpt_aTO","(('c' : (!((!'s') : (!(' ' : (!rest_aTN)))))) : inpt_aTO)","x0_aTV","safebang@!x0_aTV","(!x0_aTV)","y0_aTW","x1_aTX","safebang@!x1_aTX","(!x1_aTX)","y1_aTY","[(!x0_aTV), y0_aTW, (!x1_aTX), y1_aTY]","![(!x0_aTV), y0_aTW, (!x1_aTX), y1_aTY]","(![(!x0_aTV), y0_aTW, (!x1_aTX), y1_aTY])","nstoilrest_aTQ","safebang@!nstoilrest_aTQ","(!nstoilrest_aTQ)","wnstoilrest_aTR","!wnstoilrest_aTR","(!wnstoilrest_aTR)","cssr_aTS","!cssr_aTS","(!cssr_aTS)","newele_aTT","linecircs_aTU","lazydmd@!linecircs_aTU","(!linecircs_aTU)","dlist_aU5","!dlist_aU5","(!dlist_aU5)","sel_aU6","tilist_aU7","!tilist_aU7","(!tilist_aU7)","((!dlist_aU5), sel_aU6, (!tilist_aU7))","!((!dlist_aU5), sel_aU6, (!tilist_aU7))","(!((!dlist_aU5), sel_aU6, (!tilist_aU7)))","'r'","'o'","'t'","' '","rest_aU8","' ' : rest_aU8","(' ' : rest_aU8)","'t' : (' ' : rest_aU8)","('t' : (' ' : rest_aU8))","'o' : ('t' : (' ' : rest_aU8))","('o' : ('t' : (' ' : rest_aU8)))","'r' : ('o' : ('t' : (' ' : rest_aU8)))","('r' : ('o' : ('t' : (' ' : rest_aU8))))","!('r' : ('o' : ('t' : (' ' : rest_aU8))))","(!('r' : ('o' : ('t' : (' ' : rest_aU8)))))","((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))","!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))","(!((!('r' : ('o' : ('t' : (' ' : rest_aU8)))))))","inpt_aU9","(!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9","((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9)","!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9)","(!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9))","((!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9)))","!((!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) : inpt_aU9)))","(!((!((!((!('r' : ('o' : ('t' : (' ' : rest_aU8))))))) :\n        inpt_aU9))))","stoilrest_aUa","wcoords_aUb","oldas_aUc","!oldas_aUc","(!oldas_aUc)","newtilist_aUd","lsrest_aUe","dlist_aUf","!dlist_aUf","(!dlist_aUf)","sel_aUg","!sel_aUg","(!sel_aUg)","tilist_aUh","!tilist_aUh","(!tilist_aUh)","((!dlist_aUf), (!sel_aUg), (!tilist_aUh))","'p'","!'p'","(!'p')","'u'","!'u'","(!'u')","'t'","!'t'","(!'t')","' '","!' '","(!' ')","rest_aUi","(!' ') : rest_aUi","((!' ') : rest_aUi)","(!'t') : ((!' ') : rest_aUi)","((!'t') : ((!' ') : rest_aUi))","(!'u') : ((!'t') : ((!' ') : rest_aUi))","((!'u') : ((!'t') : ((!' ') : rest_aUi)))","!((!'u') : ((!'t') : ((!' ') : rest_aUi)))","(!((!'u') : ((!'t') : ((!' ') : rest_aUi))))","(!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))","((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi)))))","!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi)))))","(!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))","((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi)))))))","inpt_aUj","!inpt_aUj","(!inpt_aUj)","((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n  (!inpt_aUj)","(((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n   (!inpt_aUj))","!(((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n    (!inpt_aUj))","(!(((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n     (!inpt_aUj)))","((!(((!((!'p') : (!((!'u') : ((!'t') : ((!' ') : rest_aUi))))))) :\n      (!inpt_aUj))))","stoilrest_aUk","newtilist_aUl","lsrest_aUm","safebang@!lsrest_aUm","(!lsrest_aUm)","coords_aUn","oldas_aUo","!oldas_aUo","(!oldas_aUo)","wcoords_aUp","state_aUq","\"\"","inpt_aUr","\"\" : inpt_aUr","(\"\" : inpt_aUr)","!(\"\" : inpt_aUr)","(!(\"\" : inpt_aUr))","((!(\"\" : inpt_aUr)))","!((!(\"\" : inpt_aUr)))","(!((!(\"\" : inpt_aUr))))","state_aUs","!state_aUs","(!state_aUs)","_","inpt_aUt","_ : inpt_aUt","(_ : inpt_aUt)","_","!_","(!_)","dlist_aUu","sel_aUv","tilist_aUw","!tilist_aUw","(!tilist_aUw)","(dlist_aUu, sel_aUv, (!tilist_aUw))","!(dlist_aUu, sel_aUv, (!tilist_aUw))","(!(dlist_aUu, sel_aUv, (!tilist_aUw)))","inpt_aUx","_","dlist_aUy","!dlist_aUy","(!dlist_aUy)","sel_aUz","tilist_aUA","!tilist_aUA","(!tilist_aUA)","((!dlist_aUy), sel_aUz, (!tilist_aUA))","inpt_aUB","!inpt_aUB","(!inpt_aUB)","coords_aUC","_","!_","(!_)","dlist_a10K","!dlist_a10K","(!dlist_a10K)","sel_a10L","tilist_a10M","!tilist_a10M","(!tilist_a10M)","((!dlist_a10K), sel_a10L, (!tilist_a10M))","inpt_a10N","!inpt_a10N","(!inpt_a10N)","_","!_","(!_)","dlist_a10O","!dlist_a10O","(!dlist_a10O)","sel_a10P","tilist_a10Q","!tilist_a10Q","(!tilist_a10Q)","((!dlist_a10O), sel_a10P, (!tilist_a10Q))","!((!dlist_a10O), sel_a10P, (!tilist_a10Q))","(!((!dlist_a10O), sel_a10P, (!tilist_a10Q)))","inpt_a10R","!inpt_a10R","(!inpt_a10R)","rest_a10S","dlist_a10T","sel_a10U","!sel_a10U","(!sel_a10U)","tilist_a10V","!tilist_a10V","(!tilist_a10V)","(dlist_a10T, (!sel_a10U), (!tilist_a10V))","!(dlist_a10T, (!sel_a10U), (!tilist_a10V))","(!(dlist_a10T, (!sel_a10U), (!tilist_a10V)))","inpt_a10W","!inpt_a10W","(!inpt_a10W)","out_a10X","newdlist_a10Y","!newdlist_a10Y","(!newdlist_a10Y)","(out_a10X, (!newdlist_a10Y))","!(out_a10X, (!newdlist_a10Y))","(!(out_a10X, (!newdlist_a10Y)))","_","!_","(!_)","state_a10Z","inpt_a110","!inpt_a110","(!inpt_a110)","rest_a111","dlist_a112","sel_a113","tilist_a114","!tilist_a114","(!tilist_a114)","(dlist_a112, sel_a113, (!tilist_a114))","inpt_a115","!inpt_a115","(!inpt_a115)","_","!_","(!_)","state_a116","!state_a116","(!state_a116)","inpt_a117","rest_a118","!rest_a118","(!rest_a118)","dlist_a119","!dlist_a119","(!dlist_a119)","sel_a11a","slist_a11b","((!dlist_a119), sel_a11a, slist_a11b)","!((!dlist_a119), sel_a11a, slist_a11b)","(!((!dlist_a119), sel_a11a, slist_a11b))","inpt_a11c","!inpt_a11c","(!inpt_a11c)","new_a11d","newsel_a11e","!newsel_a11e","(!newsel_a11e)","rest_a11f","dlist_a11g","!dlist_a11g","(!dlist_a11g)","sel_a11h","tilist_a11i","((!dlist_a11g), sel_a11h, tilist_a11i)","!((!dlist_a11g), sel_a11h, tilist_a11i)","(!((!dlist_a11g), sel_a11h, tilist_a11i))","inpt_a11j","wcoords_a11k","lazydmd@!wcoords_a11k","(!wcoords_a11k)","stoilrest_a11l","oldas_a11m","lsrest_a11n","newtilist_a11o","!newtilist_a11o","(!newtilist_a11o)","rest_a11p","dlist_a11q","sel_a11r","tilist_a11s","!tilist_a11s","(!tilist_a11s)","(dlist_a11q, sel_a11r, (!tilist_a11s))","!(dlist_a11q, sel_a11r, (!tilist_a11s))","(!(dlist_a11q, sel_a11r, (!tilist_a11s)))","inpt_a11t","!inpt_a11t","(!inpt_a11t)","stoilrest_a11u","safebang@!stoilrest_a11u","(!stoilrest_a11u)","wcoords_a11v","!wcoords_a11v","(!wcoords_a11v)","oldas_a11w","newtilist_a11x","lsrest_a11y","_","!_","(!_)","dlist_a11z","sel_a11A","tilist_a11B","!tilist_a11B","(!tilist_a11B)","(dlist_a11z, sel_a11A, (!tilist_a11B))","inpt_a11C","_","state_a11D","!state_a11D","(!state_a11D)","inpt_a11E","!inpt_a11E","(!inpt_a11E)","_","state_a11F","inpt_a11G","!inpt_a11G","(!inpt_a11G)","_","!_","(!_)","dlist_a11H","!dlist_a11H","(!dlist_a11H)","sel_a11I","tilist_a11J","!tilist_a11J","(!tilist_a11J)","((!dlist_a11H), sel_a11I, (!tilist_a11J))","!((!dlist_a11H), sel_a11I, (!tilist_a11J))","(!((!dlist_a11H), sel_a11I, (!tilist_a11J)))","inpt_a11K","!inpt_a11K","(!inpt_a11K)","orilist_a11L","!orilist_a11L","(!orilist_a11L)","wcoords_a11M","!wcoords_a11M","(!wcoords_a11M)","pic_a11N","newtilist_a11O","cr12_a11Q","cr34_a11R","n1_a11S","n2_a11T","safebang@!n2_a11T","(!n2_a11T)","n3_a11U","n4_a11V","[n1_a11S, (!n2_a11T), n3_a11U, n4_a11V]","![n1_a11S, (!n2_a11T), n3_a11U, n4_a11V]","(![n1_a11S, (!n2_a11T), n3_a11U, n4_a11V])","out_a11P","!out_a11P","(!out_a11P)","i_a15j","!i_a15j","(!i_a15j)","j_a15k","v_a15l","(j_a15k, v_a15l)","!(j_a15k, v_a15l)","(!(j_a15k, v_a15l))","ivs_a15m","safebang@!ivs_a15m","(!ivs_a15m)","(!(j_a15k, v_a15l)) : (!ivs_a15m)","((!(j_a15k, v_a15l)) : (!ivs_a15m))","!((!(j_a15k, v_a15l)) : (!ivs_a15m))","(!((!(j_a15k, v_a15l)) : (!ivs_a15m)))","_","!_","(!_)","state_a15n","_","!_","(!_)","newdraw","potatotile","stoil"]
module Progfuns
       (tileprompt, tilequit, tiletrans, potatotile, State) where
import Mgrfuns
import Drawfuns
import Geomfuns
import Psfuns
import Interstate
import Auxprogfuns
import Layout
import Tilefuns
import Help

tileprompt :: a_aTc -> [Char]
tileprompt _ = ""

tilequit :: a_aTb -> [[Char]] -> Bool
tilequit _ (((norecord@'q') : _) : _) = True
tilequit (norecord@_) [] = True
tilequit _ (norecord@_) = False

tiletrans :: Trans
tiletrans (norecord@((!dlist_aTd), (!sel_aTe), (!tilist_aTf)))
  ((norecord@((norecord@((norecord@'m') :
                           ('s' :
                              (norecord@((norecord@'a') :
                                           (norecord@(' ' : (lazydmd@rest_aTg))))))))
                : inpt_aTh)))
  = if intsave x_aTi y_aTj then doo_aTk tsave else
      if intclear x_aTi y_aTj then doo_aTk tclear else
        if intget x_aTi y_aTj then doo_aTk tget else
          if intile4 x_aTi y_aTj then doo_aTk t4' else
            if inquit x_aTi y_aTj then doo_aTk q else
              if inbigtile x_aTi y_aTj then doo_aTk delsq else
                if intoalter x_aTi y_aTj then doo_aTk tofiddle' else
                  if intotile x_aTi y_aTj then doo_aTk totile' else
                    if intodraw x_aTi y_aTj then doo_aTk todesign' else
                      if inpicarea x_aTi y_aTj then doo_aTk sel' else
                        if inhelp x_aTi y_aTj then doo_aTk tohelp' else
                          tiletrans (dlist_aTd, sel_aTe, tilist_aTf) inpt_aTh
  where [x_aTi, (norecord@y_aTj)] = stoil rest_aTg
        doo_aTk fun_aTl
          = fun_aTl rest_aTg (dlist_aTd, sel_aTe, tilist_aTf) inpt_aTh
tiletrans (norecord@((norecord@dlist_aTm), sel_aTn, tilist_aTo))
  (norecord@(('m' : ('s' : (norecord@('b' : (' ' : rest_aTp))))) :
               (lazydmd@inpt_aTq)))
  = if inbigtile x_aTr y_aTs then
      inv' rest_aTp (dlist_aTm, sel_aTn, tilist_aTo) inpt_aTq else
      tiletrans (dlist_aTm, sel_aTn, tilist_aTo)
        (('m' : 's' : 'a' : ' ' : rest_aTp) : inpt_aTq)
  where [(norecord@x_aTr), (norecord@y_aTs)] = stoil rest_aTp
tiletrans (dlist_aTt, (norecord@sel_aTu), tilist_aTv)
  ((norecord@(('m' :
                 ((norecord@'s') : ('c' : (norecord@(' ' : (lazydmd@rest_aTw))))))
                : (lazydmd@inpt_aTx))))
  = if indesign x_aTy y_aTz then doo_aTA rl else
      if indsave x_aTy y_aTz then doo_aTA dsave else
        if indclear x_aTy y_aTz then doo_aTA dclear else
          if indget x_aTy y_aTz then doo_aTA dget else
            tiletrans (dlist_aTt, sel_aTu, tilist_aTv)
              (('m' : 's' : 'a' : ' ' : rest_aTw) : inpt_aTx)
  where (norecord@[x_aTy, y_aTz]) = stoil rest_aTw
        doo_aTA (norecord@fun_aTB)
          = fun_aTB rest_aTw (dlist_aTt, sel_aTu, tilist_aTv) inpt_aTx
tiletrans state_aTC
  (((norecord@('m' :
                 ((norecord@'s') :
                    ((norecord@'d') : ((norecord@' ') : (lazydmd@rest_aTD)))))))
     : (lazydmd@inpt_aTE))
  = (inithelp ++ out_aTI, state_aTC, inpt_aTE)
  where (norecord@[x_aTF, y_aTG]) = stoil rest_aTD
        cf_aTH (norecord@str_aTJ) = clear ++ str_aTJ
        out_aTI
          = if intodraw x_aTF y_aTG then cf_aTH helpdraw else
              if intotile x_aTF y_aTG then cf_aTH helptile else
                if intoalter x_aTF y_aTG then cf_aTH helpalter else
                  if intsave x_aTF y_aTG then cf_aTH helptsave else
                    if intclear x_aTF y_aTG then cf_aTH helptclear else
                      if intget x_aTF y_aTG then cf_aTH helptget else
                        if intile4 x_aTF y_aTG then cf_aTH helpt4 else
                          if inquit x_aTF y_aTG then cf_aTH helpquit else
                            if inbigtile x_aTF y_aTG then cf_aTH helpbt else
                              if inpicarea x_aTF y_aTG then cf_aTH helppic else
                                if indesign x_aTF y_aTG then cf_aTH helpdesign else
                                  if indsave x_aTF y_aTG then cf_aTH helpdsave else
                                    if indclear x_aTF y_aTG then cf_aTH helpdclear else
                                      if indget x_aTF y_aTG then cf_aTH helpdget else
                                        if inhelp x_aTF y_aTG then cf_aTH inithelp else
                                          cf_aTH errmes
tiletrans ((norecord@dlist_aTK), (norecord@sel_aTL), tilist_aTM)
  (('c' :
      (norecord@((norecord@'s') :
                   (norecord@(' ' : (lazydmd@rest_aTN))))))
     : inpt_aTO)
  = if indgrid nstoilrest_aTQ then
      (linecircs_aTU ++ wnstoilrest_aTR,
       (newele_aTT : dlist_aTK, sel_aTL, tilist_aTM), inpt_aTO)
      else ("", (dlist_aTK, sel_aTL, tilist_aTM), inpt_aTO)
  where nearline_aTP
          (norecord@[(!x0_aTV), y0_aTW, (!x1_aTX), y1_aTY])
          = [nearx x0_aTV, neary y0_aTW, nearx x1_aTX, neary y1_aTY]
        (!nstoilrest_aTQ) = nearline_aTP (stoil rest_aTN)
        (norecord@wnstoilrest_aTR) = wline nstoilrest_aTQ
        (norecord@cssr_aTS) = cs nstoilrest_aTQ
        newele_aTT = (nstoilrest_aTQ, snd cssr_aTS)
        (lazydmd@linecircs_aTU) = fst cssr_aTS
tiletrans
  (norecord@((norecord@dlist_aU5), sel_aU6, (norecord@tilist_aU7)))
  (norecord@((norecord@((norecord@((norecord@('r' :
                                                ('o' : ('t' : (' ' : rest_aU8)))))))
                          : inpt_aU9))))
  = if lsrest_aUe == [0, 0] then
      ("", (dlist_aU5, sel_aU6, tilist_aU7), inpt_aU9) else
      (undo (put lsrest_aUe (orient xymax oldas_aUc wcoords_aUb)) ++
         put lsrest_aUe (orient xymax (rot oldas_aUc) wcoords_aUb),
       (dlist_aU5, sel_aU6, newtilist_aUd), inpt_aU9)
  where stoilrest_aUa = stoil rest_aU8
        wcoords_aUb = map (map wscale) (map fst dlist_aU5)
        (norecord@oldas_aUc) = assoc (sqid stoilrest_aUa) tilist_aU7
        newtilist_aUd
          = newas (sqid stoilrest_aUa) (rot oldas_aUc) tilist_aU7
        lsrest_aUe = btlocate stoilrest_aUa
tiletrans
  ((norecord@dlist_aUf), (norecord@sel_aUg), (norecord@tilist_aUh))
  ((norecord@(((norecord@((norecord@'p') :
                            (norecord@((norecord@'u') :
                                         ((norecord@'t') : ((norecord@' ') : rest_aUi)))))))
                : (norecord@inpt_aUj))))
  = if lsrest_aUm == [0, 0] then
      ("", (dlist_aUf, sel_aUg, tilist_aUh), inpt_aUj) else
      (undo (put lsrest_aUm (orient xymax oldas_aUo wcoords_aUp)) ++
         put lsrest_aUm (orient xymax sel_aUg wcoords_aUp),
       (dlist_aUf, sel_aUg, newtilist_aUl), inpt_aUj)
  where stoilrest_aUk = stoil rest_aUi
        newtilist_aUl = newas (sqid stoilrest_aUk) sel_aUg tilist_aUh
        (!lsrest_aUm) = btlocate stoilrest_aUk
        coords_aUn = map fst dlist_aUf
        (norecord@oldas_aUo) = assoc (sqid stoilrest_aUk) tilist_aUh
        wcoords_aUp = map (map wscale) coords_aUn
tiletrans state_aUq (norecord@((norecord@("" : inpt_aUr))))
  = (helpend ++ todesign, state_aUq, inpt_aUr)
tiletrans (norecord@state_aUs) (_ : inpt_aUt)
  = ("", state_aUs, inpt_aUt)

todesign', totile', tofiddle', tohelp' :: [Char] -> Trans
todesign' (norecord@_)
  (norecord@(dlist_aUu, sel_aUv, (norecord@tilist_aUw))) inpt_aUx
  = (cleara picarea ++ picgrid ++ cleara tilearea ++ tpgrid ++
       showoris (map fst dlist_aUu) 1
       ++ todesign,
     (dlist_aUu, sel_aUv, tilist_aUw), inpt_aUx)
totile' _ ((norecord@dlist_aUy), sel_aUz, (norecord@tilist_aUA))
  (norecord@inpt_aUB)
  = (concat (map (showoris coords_aUC) [1 .. 8]) ++ totile,
     (dlist_aUy, sel_aUz, tilist_aUA), inpt_aUB)
  where coords_aUC = map fst dlist_aUy
tofiddle' (norecord@_)
  ((norecord@dlist_a10K), sel_a10L, (norecord@tilist_a10M))
  (norecord@inpt_a10N)
  = (tofiddle, (dlist_a10K, sel_a10L, tilist_a10M), inpt_a10N)
tohelp' (norecord@_)
  (norecord@((norecord@dlist_a10O), sel_a10P,
             (norecord@tilist_a10Q)))
  (norecord@inpt_a10R)
  = (tohelp, (dlist_a10O, sel_a10P, tilist_a10Q), inpt_a10R)

rl, dsave, dclear, dget :: [Char] -> Trans
rl rest_a10S
  (norecord@(dlist_a10T, (norecord@sel_a10U),
             (norecord@tilist_a10V)))
  (norecord@inpt_a10W)
  = (out_a10X, (newdlist_a10Y, sel_a10U, tilist_a10V), inpt_a10W)
  where (norecord@(out_a10X, (norecord@newdlist_a10Y)))
          = deline dlist_a10T (stoil rest_a10S)
dsave (norecord@_) state_a10Z (norecord@inpt_a110)
  = ("", state_a10Z, inpt_a110)
dclear rest_a111 (dlist_a112, sel_a113, (norecord@tilist_a114))
  (norecord@inpt_a115)
  = (menumark "dclear" ++ newdraw ++ unmark sel_a113 ++
       unmenumark "dclear",
     ([], 1, initalist), inpt_a115)
dget (norecord@_) (norecord@state_a116) inpt_a117
  = ("", state_a116, inpt_a117)

sel', delsq, inv' :: [Char] -> Trans
sel' (norecord@rest_a118)
  (norecord@((norecord@dlist_a119), sel_a11a, slist_a11b))
  (norecord@inpt_a11c)
  = (unmark sel_a11a ++ mark newsel_a11e,
     (dlist_a119, newsel_a11e, slist_a11b), inpt_a11c)
  where new_a11d = inbox (stoil rest_a118)
        (norecord@newsel_a11e)
          = if new_a11d == 0 then sel_a11a else new_a11d
delsq rest_a11f
  (norecord@((norecord@dlist_a11g), sel_a11h, tilist_a11i)) inpt_a11j
  = (undo (put lsrest_a11n (orient xymax oldas_a11m wcoords_a11k)),
     (dlist_a11g, sel_a11h, newtilist_a11o), inpt_a11j)
  where (lazydmd@wcoords_a11k)
          = map (map wscale) (map fst dlist_a11g)
        stoilrest_a11l = stoil rest_a11f
        oldas_a11m = assoc (sqid stoilrest_a11l) tilist_a11i
        lsrest_a11n = btlocate stoilrest_a11l
        (norecord@newtilist_a11o)
          = newas (sqid stoilrest_a11l) 0 tilist_a11i
inv' rest_a11p
  (norecord@(dlist_a11q, sel_a11r, (norecord@tilist_a11s)))
  (norecord@inpt_a11t)
  = if lsrest_a11y == [0, 0] then
      ("", (dlist_a11q, sel_a11r, tilist_a11s), inpt_a11t) else
      (undo (put lsrest_a11y (orient xymax oldas_a11w wcoords_a11v)) ++
         put lsrest_a11y (orient xymax (inv oldas_a11w) wcoords_a11v),
       (dlist_a11q, sel_a11r, newtilist_a11x), inpt_a11t)
  where (!stoilrest_a11u) = stoil rest_a11p
        (norecord@wcoords_a11v) = map (map wscale) (map fst dlist_a11q)
        oldas_a11w = assoc (sqid stoilrest_a11u) tilist_a11s
        newtilist_a11x
          = newas (sqid stoilrest_a11u) (inv oldas_a11w) tilist_a11s
        lsrest_a11y = btlocate stoilrest_a11u

tclear, tsave, tget, t4' :: [Char] -> Trans
tclear (norecord@_) (dlist_a11z, sel_a11A, (norecord@tilist_a11B))
  inpt_a11C
  = (menumark "tclear" ++ cleara tilearea ++ tpgrid ++ totile ++
       unmenumark "tclear",
     (dlist_a11z, sel_a11A, initalist), inpt_a11C)
tsave _ (norecord@state_a11D) (norecord@inpt_a11E)
  = ("", state_a11D, inpt_a11E)
tget _ state_a11F (norecord@inpt_a11G)
  = ("", state_a11F, inpt_a11G)
t4' (norecord@_)
  (norecord@((norecord@dlist_a11H), sel_a11I,
             (norecord@tilist_a11J)))
  (norecord@inpt_a11K)
  = (out_a11P, (dlist_a11H, sel_a11I, newtilist_a11O), inpt_a11K)
  where (norecord@orilist_a11L)
          = pam assoc [(0, 0), (0, 1), (1, 0), (1, 1)] tilist_a11J
        (norecord@wcoords_a11M) = map (map wscale) (map fst dlist_a11H)
        pic_a11N = t4 (pam (orient xymax) orilist_a11L wcoords_a11M)
        newtilist_a11O = zip alistind (concrep 4 (cr12_a11Q ++ cr34_a11R))
          where cr12_a11Q = concrep 4 [n1_a11S, n2_a11T]
                cr34_a11R = concrep 4 [n3_a11U, n4_a11V]
                (norecord@[n1_a11S, (!n2_a11T), n3_a11U, n4_a11V]) = orilist_a11L
        (norecord@out_a11P)
          = menumark "t4" ++ cleara tilearea ++
              tile tpxorig tpyorig 4 4 pic_a11N
              ++ unmenumark "t4"

assoc :: (Eq a_aFH) => a_aFH -> [(a_aFH, b_aFI)] -> b_aFI
assoc (norecord@i_a15j)
  (norecord@((norecord@(j_a15k, v_a15l)) : (!ivs_a15m)))
  = if i_a15j == j_a15k then v_a15l else assoc i_a15j ivs_a15m

q :: [Char] -> Trans
q (norecord@_) state_a15n (norecord@_) = ("", state_a15n, [])

newdraw :: [Char]
newdraw
  = cleara designarea ++ dpgrid ++ cleara picarea ++ picgrid ++
      cleara tilearea
      ++ tpgrid
      ++ invisibletext
      ++ todesign

potatotile :: State -> [[Char]] -> [Char]
potatotile = inter tileprompt tilequit tiletrans

stoil :: [Char] -> [Int]
stoil = map read . words

type State = ([([Int], [Int])], Int, [((Int, Int), Int)])

type Trans = State -> [[Char]] -> ([Char], State, [[Char]])
STARTLOG
["str_anx","ns_any","n_anA","!n_anA","(!n_anA)","\"\"","n_aw1","s_aw2","aligntext","bitcopy","circle","clear","event_aCa","mode_aCb","n_aCc","safebang@!n_aCc","(!n_aCc)","x1_aCd","safebang@!x1_aCd","(!x1_aCd)","y1_aCe","safebang@!y1_aCe","(!y1_aCe)","x2_aCf","safebang@!x2_aCf","(!x2_aCf)","y2_aCg","safebang@!y2_aCg","(!y2_aCg)","[(!x1_aCd), (!y1_aCe), (!x2_aCf), (!y2_aCg)]","![(!x1_aCd), (!y1_aCe), (!x2_aCf), (!y2_aCg)]","(![(!x1_aCd), (!y1_aCe), (!x2_aCf), (!y2_aCg)])","r_aCh","dragline","dragrect","x_aDg","safebang@!x_aDg","(!x_aDg)","mode_aDh","safebang@!mode_aDh","(!mode_aDh)","go","highlight","line","event_aDi","safebang@!event_aDi","(!event_aDi)","newwin","r_aQL","safebang@!r_aQL","(!r_aQL)","n_aQM","event_aQN","str_aQO","safebang@!str_aQO","(!str_aQO)","mode_aQP","shapewindow","standend","standout","win_aQQ","x_aQR","safebang@!x_aQR","(!x_aQR)","y_aQS","str_aQT","textregion","textreset"]
module Mgrfuns
       (aligntext, bitcopy, circle, clear, clearevent, clearmode,
        destroywin, dragcircle, dragline, dragrect, font, func, go,
        highlight, line, mapevent, newwin, rcircle, selectwin, setevent,
        setmode, shapewindow, standend, stringto, standout, textregion,
        textreset)
       where
import Diff

escom :: [Char] -> [Int] -> [Char]
escom str_anx ns_any = '\ESC' : foldr f_anz "" ns_any
  where f_anz (norecord@n_anA) "" = show n_anA ++ str_anx
        f_anz n_aw1 s_aw2 = show n_aw1 ++ "," ++ s_aw2
aligntext = '\ESC' : "l"
bitcopy = escom "b"
circle = escom "o"
clear = "\f"
clearevent event_aCa = escom "e" [mapevent event_aCa]
clearmode mode_aCb = escom "s" [mode_aCb]
destroywin (!n_aCc) = escom ",OZ" [n_aCc]
dragcircle (norecord@[(!x1_aCd), (!y1_aCe), (!x2_aCf), (!y2_aCg)])
  = circle [x1_aCd, y1_aCe, r_aCh]
  where r_aCh
          = bcroot
              (square (diff x1_aCd x2_aCf) + square (diff y1_aCe y2_aCg))
dragline = "%l\n"
dragrect = "%r\n"
font (!x_aDg) = escom "F" [x_aDg]
func (!mode_aDh) = escom "b" [mode_aDh]
go = escom "g"
highlight = escom "H"
line = escom "l"
mapevent (!event_aDi)
  = if event_aDi == 3 || event_aDi == 4 then 2 - event_aDi else
      event_aDi
newwin = escom "Z"
rcircle (!r_aQL) = escom "o" [r_aQL]
selectwin n_aQM = escom "Z" [n_aQM]
setevent event_aQN (!str_aQO)
  = escom ("e" ++ str_aQO) [mapevent event_aQN, length str_aQO]
setmode mode_aQP = escom "S" [mode_aQP]
shapewindow = escom "W"
standend = '\ESC' : ",n"
standout = '\ESC' : "i"
stringto win_aQQ (!x_aQR) y_aQS str_aQT
  = escom ("." ++ str_aQT) [win_aQQ, x_aQR, y_aQS, length str_aQT]
textregion = escom "t"
textreset = '\ESC' : "t"
STARTLOG
["x_apq","y_apr","coords_ayY","safebang@!coords_ayY","(!coords_ayY)","header_ayZ","x1_az4","y1_az5","x2_az6","y2_az7","[x1_az4, y1_az5, x2_az6, y2_az7]","f_aHx","safebang@!f_aHx","(!f_aHx)","fs_aHy","(!f_aHx) : fs_aHy","((!f_aHx) : fs_aHy)","!((!f_aHx) : fs_aHy)","(!((!f_aHx) : fs_aHy))","a_aHz","safebang@!a_aHz","(!a_aHz)","[]","![]","(![])","a_aHA","!a_aHA","(!a_aHA)","h_aHB","!h_aHB","(!h_aHB)","f_aHC","!f_aHC","(!f_aHC)","coords_aHD","n_aHE","!n_aHE","(!n_aHE)","introline","rowline","ss","num_aHF","!num_aHF","(!num_aHF)","list_aHG","n1_aHH","n2_aHI","safebang@!n2_aHI","(!n2_aHI)","n3_aHJ","n4_aHK","safebang@!n4_aHK","(!n4_aHK)","[n1_aHH, (!n2_aHI), n3_aHJ, (!n4_aHK)]","i_aHM","j_aHN","safebang@!j_aHN","(!j_aHN)","psmax"]
module Psfuns (pos8head, introline, lf, tile4, concrep) where
import Geomfuns
import Auxprogfuns

concrep :: Int -> [a_app] -> [a_app]
concrep x_apq y_apr = concat (take x_apq (repeat y_apr))

pos8head :: [[Int]] -> [Char]
pos8head (!coords_ayY)
  = header_ayZ ++ pamcat_az1 (map newf_az3 [1 .. 8]) coords_ayY
  where header_ayZ
          = "%!PS-Adobe-1.0\n0.75 setlinewidth\n" ++ "/print0\n{\n} def\n"
        topos_az0 [x1_az4, y1_az5, x2_az6, y2_az7]
          = show x1_az4 ++ " " ++ show y1_az5 ++ " moveto\n" ++ show x2_az6
              ++ " "
              ++ show y2_az7
              ++ " lineto\n"
        pamcat_az1 (norecord@((!f_aHx) : fs_aHy)) (!a_aHz)
          = f_aHx a_aHz ++ pamcat_az1 fs_aHy a_aHz
        pamcat_az1 (norecord@[]) (norecord@a_aHA) = []
        fpat_az2 (norecord@h_aHB) (norecord@f_aHC) coords_aHD
          = h_aHB ++ (concat . map topos_az0 . f_aHC) coords_aHD ++
              "stroke} def\n"
        newf_az3 (norecord@n_aHE)
          = fpat_az2 ("/print" ++ show n_aHE ++ "\n{") (orient psmax n_aHE)

introline, rowline, ss :: [Char]
introline = "400 400 translate"
rowline = "\n-288 36 translate"
ss = "\n36 0 translate\nprint"

sq :: Int -> [Char]
sq (norecord@num_aHF) = ss ++ show num_aHF

lf :: [Int] -> [Char]
lf list_aHG = rowline ++ concat (map sq list_aHG)

tile4 :: [Int] -> [Char]
tile4 [n1_aHH, (!n2_aHI), n3_aHJ, (!n4_aHK)]
  = introline ++
      concrep 4 (posrow_aHL n1_aHH n2_aHI ++ posrow_aHL n3_aHJ n4_aHK)
      ++ "\nshowpage\n"
  where posrow_aHL i_aHM (!j_aHN)
          = rowline ++ concrep 4 (sq i_aHM ++ sq j_aHN)

psmax :: Int
psmax = 36
STARTLOG
STARTLOG
["main","s_arV","s_arW","a_arX","lazydmd@!a_arX","(!a_arX)","db_arY","!db_arY","(!db_arY)","uvwres_arZ","lazydmd@!uvwres_arZ","(!uvwres_arZ)","frc_as0"]
module Main (main) where
import Database
import Vector
import Displacement
import Elemforce
import PrintSource
import Printuvwforce
main = getContents >>= \ s_arV -> process s_arV

process :: [Char] -> IO ()
process s_arW = putStr a_arX
  where (lazydmd@a_arX)
          = source_data db_arY ++ uvwresult db_arY uvwres_arZ ++
              forceresult db_arY frc_as0
        (norecord@db_arY) = (idatabase s_arW, rdatabase s_arW)
        (lazydmd@uvwres_arZ) = uvw db_arY
        frc_as0 = forces db_arY uvwres_arZ
STARTLOG
["n_apB","!n_apB","(!n_apB)","addiag_apC","elems_apD","VBMAT (!n_apB) addiag_apC elems_apD","(VBMAT (!n_apB) addiag_apC elems_apD)","!(VBMAT (!n_apB) addiag_apC elems_apD)","(!(VBMAT (!n_apB) addiag_apC elems_apD))","((!(VBMAT (!n_apB) addiag_apC elems_apD)))","!((!(VBMAT (!n_apB) addiag_apC elems_apD)))","(!((!(VBMAT (!n_apB) addiag_apC elems_apD))))","i_apE","!i_apE","(!i_apE)","n_aD7","addiag_aD8","elems_aD9","VBMAT n_aD7 addiag_aD8 elems_aD9","(VBMAT n_aD7 addiag_aD8 elems_aD9)","!(VBMAT n_aD7 addiag_aD8 elems_aD9)","(!(VBMAT n_aD7 addiag_aD8 elems_aD9))","((!(VBMAT n_aD7 addiag_aD8 elems_aD9)))","!((!(VBMAT n_aD7 addiag_aD8 elems_aD9)))","(!((!(VBMAT n_aD7 addiag_aD8 elems_aD9))))","i_aDa","vbm_aDb","i_aDc","j_aDd","(i_aDc, j_aDd)","n_aDe","addiag_aDf","!addiag_aDf","(!addiag_aDf)","elementlist_aDg","VBMAT n_aDe (!addiag_aDf) elementlist_aDg","(VBMAT n_aDe (!addiag_aDf) elementlist_aDg)","!(VBMAT n_aDe (!addiag_aDf) elementlist_aDg)","(!(VBMAT n_aDe (!addiag_aDf) elementlist_aDg))","((!(VBMAT n_aDe (!addiag_aDf) elementlist_aDg)))","bounds_aDh","safebang@!bounds_aDh","(!bounds_aDh)","addiag_aDi","elementlist_aDj","safebang@!elementlist_aDj","(!elementlist_aDj)","VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj)","(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj))","!(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj))","(!(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj)))","((!(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj))))","bounds_aDk","safebang@!bounds_aDk","(!bounds_aDk)","addiag_aDl","elementlist_aDm","safebang@!elementlist_aDm","(!elementlist_aDm)","VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm)","(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm))","!(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm))","(!(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm)))","((!(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm))))","bounds_aDn","addiag_aDo","elementlist_aDp","safebang@!elementlist_aDp","(!elementlist_aDp)","n_aDq","addiag_aDr","safebang@!addiag_aDr","(!addiag_aDr)","generator_aDs","i_aDx","elemts_aDu","!elemts_aDu","(!elemts_aDu)","ls_aN3","i_aN4","j_aN5","!j_aN5","(!j_aN5)","i_aN6","vbm_aN7","updates_aN8","safebang@!updates_aN8","(!updates_aN8)","n_aN9","addiag_aNa","elements_aNb","VBMAT n_aN9 addiag_aNa elements_aNb","(VBMAT n_aN9 addiag_aNa elements_aNb)","!(VBMAT n_aN9 addiag_aNa elements_aNb)","(!(VBMAT n_aN9 addiag_aNa elements_aNb))","((!(VBMAT n_aN9 addiag_aNa elements_aNb)))","new_elements_aNc","!new_elements_aNc","(!new_elements_aNc)","new_s_aNd","safebang@!new_s_aNd","(!new_s_aNd)","i_aNe","j_aNf","safebang@!j_aNf","(!j_aNf)","(i_aNe, (!j_aNf))","!(i_aNe, (!j_aNf))","(!(i_aNe, (!j_aNf)))","x_aNg","safebang@!x_aNg","(!x_aNg)","((!(i_aNe, (!j_aNf))), (!x_aNg))","!((!(i_aNe, (!j_aNf))), (!x_aNg))","(!((!(i_aNe, (!j_aNf))), (!x_aNg)))","vbm_aNh","safebang@!vbm_aNh","(!vbm_aNh)","updates_aNi","n_aNj","addiag_aNk","!addiag_aNk","(!addiag_aNk)","elements_aNl","!elements_aNl","(!elements_aNl)","VBMAT n_aNj (!addiag_aNk) (!elements_aNl)","new_elements_aNm","new_s_aNn","i_aNo","safebang@!i_aNo","(!i_aNo)","j_aNp","((!i_aNo), j_aNp)","!((!i_aNo), j_aNp)","(!((!i_aNo), j_aNp))","x_aNq","((!((!i_aNo), j_aNp)), x_aNq)","!((!((!i_aNo), j_aNp)), x_aNq)","(!((!((!i_aNo), j_aNp)), x_aNq))","vbm_aNr","!vbm_aNr","(!vbm_aNr)","i_aNs","j_aNt","(i_aNs, j_aNt)","!(i_aNs, j_aNt)","(!(i_aNs, j_aNt))","n_aNu","addiag_aNv","elements_aNw","VBMAT n_aNu addiag_aNv elements_aNw","vbm_aNx","!vbm_aNx","(!vbm_aNx)","rows_aNy","lazydmd@!rows_aNy","(!rows_aNy)","i_aNA","!i_aNA","(!i_aNA)","n_aNz","!n_aNz","(!n_aNz)","vbm_aNB","!vbm_aNB","(!vbm_aNB)","rows_aNC","i_aNE","!i_aNE","(!i_aNE)","n_aND","!n_aND","(!n_aND)","vbm_aNF","!vbm_aNF","(!vbm_aNF)","i_aNG","!i_aNG","(!i_aNG)","n_aNH","!n_aNH","(!n_aNH)","j_aNJ","safebang@!j_aNJ","(!j_aNJ)","vbm_aNK","!vbm_aNK","(!vbm_aNK)","i_aNL","!i_aNL","(!i_aNL)","n_aNM","!n_aNM","(!n_aNM)","j_aNO","safebang@!j_aNO","(!j_aNO)"]
module VBmatrix
       (Vbm, defvbmat, makevbmat, incrvbmat, updvbmat, vbmatsub,
        boundvbmat, addrvbmat, lengrvbmat, fstclvbmat, diagadrvbm,
        displayvbmati, displayvbmatr)
       where
import Basics
import Vector

defvbmat :: Int -> Vec Int -> Vec a_apA -> Vbm a_apA

makevbmat :: Int -> Vec Int -> ((Int, Int) -> a_apz) -> Vbm a_apz

updvbmat :: Vbm a_apy -> [((Int, Int), a_apy)] -> Vbm a_apy

incrvbmat ::
            (Num a_aoz) => Vbm a_aoz -> [((Int, Int), a_aoz)] -> Vbm a_aoz

vbmatsub :: Vbm a_aoy -> (Int, Int) -> a_aoy

boundvbmat :: Vbm a_aox -> Int

addrvbmat :: Vbm a_aow -> (Int, Int) -> Int

lengrvbmat :: Vbm a_aov -> Int -> Int

fstclvbmat :: Vbm a_aou -> Int -> Int

diagadrvbm :: Vbm a_aot -> Vec Int

displayvbmati :: Vbm Int -> [Char]

displayvbmatr :: Vbm Float -> [Char]
lengrvbmat
  (norecord@((norecord@(VBMAT (norecord@n_apB) addiag_apC
                          elems_apD))))
  (norecord@i_apE)
  = if (i_apE == 1) then 1 else
      (vecsub addiag_apC i_apE) - (vecsub addiag_apC (i_apE - 1))
fstclvbmat
  (norecord@((norecord@(VBMAT n_aD7 addiag_aD8 elems_aD9)))) i_aDa
  = if (i_aDa == 1) then 1 else
      i_aDa - (lengrvbmat (VBMAT n_aD7 addiag_aD8 elems_aD9) i_aDa) + 1
addrvbmat vbm_aDb (i_aDc, j_aDd)
  = vecsub addiag_aDf i_aDc + j_aDd - i_aDc
  where ((norecord@(VBMAT n_aDe (norecord@addiag_aDf)
                      elementlist_aDg)))
          = vbm_aDb
boundvbmat
  ((norecord@(VBMAT (!bounds_aDh) addiag_aDi (!elementlist_aDj))))
  = bounds_aDh
diagadrvbm
  ((norecord@(VBMAT (!bounds_aDk) addiag_aDl (!elementlist_aDm))))
  = addiag_aDl
defvbmat bounds_aDn addiag_aDo (!elementlist_aDp)
  = VBMAT bounds_aDn addiag_aDo elementlist_aDp
makevbmat n_aDq (!addiag_aDr) generator_aDs
  = VBMAT n_aDq addiag_aDr (makevec (vecsub addiag_aDr n_aDq) f_aDt)
  where f_aDt i_aDx = elemts_aDu !! (i_aDx - 1)
        (norecord@elemts_aDu) = foldl irow_aDv [] [1 .. n_aDq]
        irow_aDv ls_aN3 i_aN4
          = ls_aN3 ++
              [generator_aDs (i_aN4, j_aN5) |
               (norecord@j_aN5) <- [(fstcl_aDw i_aN4) .. i_aN4]]
        fstcl_aDw i_aN6
          = if (i_aN6 == 1) then 1 else
              i_aN6 - vecsub addiag_aDr i_aN6 + vecsub addiag_aDr (i_aN6 - 1) + 1
incrvbmat vbm_aN7 (!updates_aN8)
  = VBMAT n_aN9 addiag_aNa new_elements_aNc
  where ((norecord@(VBMAT n_aN9 addiag_aNa elements_aNb))) = vbm_aN7
        (norecord@new_elements_aNc) = incrvec elements_aNb new_s_aNd
        (!new_s_aNd)
          = map
              (\ (norecord@((norecord@(i_aNe, (!j_aNf))), (!x_aNg))) ->
                 (addrvbmat vbm_aN7 (i_aNe, j_aNf), x_aNg))
              updates_aN8
updvbmat (!vbm_aNh) updates_aNi
  = VBMAT n_aNj addiag_aNk new_elements_aNm
  where VBMAT n_aNj (norecord@addiag_aNk) (norecord@elements_aNl)
          = vbm_aNh
        new_elements_aNm = updvec elements_aNl new_s_aNn
        new_s_aNn
          = map
              (\ (norecord@((norecord@((!i_aNo), j_aNp)), x_aNq)) ->
                 (addrvbmat vbm_aNh (i_aNo, j_aNp), x_aNq))
              updates_aNi
vbmatsub (norecord@vbm_aNr) (norecord@(i_aNs, j_aNt))
  = vecsub elements_aNw (addrvbmat vbm_aNr (i_aNs, j_aNt))
  where VBMAT n_aNu addiag_aNv elements_aNw = vbm_aNr
displayvbmati (norecord@vbm_aNx)
  = "<  \n" ++ concat (map displayvec rows_aNy) ++ "> \n"
  where (lazydmd@rows_aNy)
          = [rowi vbm_aNx i_aNA | (norecord@i_aNA) <- [1 .. n_aNz]]
        (norecord@n_aNz) = boundvbmat vbm_aNx
displayvbmatr (norecord@vbm_aNB)
  = "<  \n" ++ concat (map displayvec rows_aNC) ++ "> \n"
  where rows_aNC
          = [rowr vbm_aNB i_aNE | (norecord@i_aNE) <- [1 .. n_aND]]
        (norecord@n_aND) = boundvbmat vbm_aNB
rowi (norecord@vbm_aNF) (norecord@i_aNG) = makevec n_aNH f_aNI
  where (norecord@n_aNH) = boundvbmat vbm_aNF
        f_aNI (!j_aNJ)
          = if ((j_aNJ >= (fstclvbmat vbm_aNF i_aNG)) && (j_aNJ <= i_aNG))
              then vbmatsub vbm_aNF (i_aNG, j_aNJ) else 0
rowr (norecord@vbm_aNK) (norecord@i_aNL) = makevec n_aNM f_aNN
  where (norecord@n_aNM) = boundvbmat vbm_aNK
        f_aNN (!j_aNO)
          = if ((j_aNO >= (fstclvbmat vbm_aNK i_aNL)) && (j_aNO <= i_aNL))
              then vbmatsub vbm_aNK (i_aNL, j_aNO) else 0.0

data Vbm a_aol = VBMAT Int (Vec Int) (Vec a_aol)
STARTLOG
["mA_ap7","!mA_ap7","(!mA_ap7)","m_ap8","i_apb","j_apc","safebang@!j_apc","(!j_apc)","(i_apb, (!j_apc))","!(i_apb, (!j_apc))","(!(i_apb, (!j_apc)))","k_aIL","!k_aIL","(!k_aIL)","k_aJK","i_aSR","j_aSS","a_aST","safebang@!a_aST","(!a_aST)","b_aSU","!b_aSU","(!b_aSU)","a'_aT1","b_aT2","b_aT3","mVB_aT4","(b_aT3, mVB_aT4)","b'_aT5","n_aT6","!n_aT6","(!n_aT6)","i_aT9","j_aTa","!j_aTa","(!j_aTa)","i_aTb","b_aTc","!b_aTc","(!b_aTc)","mVB_aTd","((!b_aTc), mVB_aTd)","!((!b_aTc), mVB_aTd)","(!((!b_aTc), mVB_aTd))","n_aTe","!n_aTe","(!n_aTe)","b'_aTf","i_aTi","safebang@!i_aTi","(!i_aTi)","j_aTj","i_aTk","safebang@!i_aTk","(!i_aTk)","j_aTl","!j_aTl","(!j_aTl)","js_aTm","(!j_aTl) : js_aTm","((!j_aTl) : js_aTm)","i_aTn","!i_aTn","(!i_aTn)","[]"]
module VBlldecomp (vblldecomp, vbllsolution, vbllsolution') where
import Basics
import Vector
import VBmatrix

vblldecomp :: Vbm Float -> Vbm Float

vbllsolution :: Vbm Float -> Vec Float -> Vec Float

vbllsolution' :: Vbm Float -> Vec Float -> Vec Float
vblldecomp (norecord@mA_ap7) = m_ap8
  where m_ap8
          = makevbmat (boundvbmat mA_ap7) (diagadrvbm mA_ap7) f_ap9
        f_ap9 (norecord@(i_apb, (!j_apc)))
          = if (i_apb == j_apc) then
              sqrt
                (vbmatsub mA_ap7 (i_apb, i_apb) -
                   sum
                     (map
                        (\ (norecord@k_aIL) ->
                           vbmatsub m_ap8 (i_apb, k_aIL) * vbmatsub m_ap8 (i_apb, k_aIL))
                        [(fstclvbmat mA_ap7 i_apb) .. (i_apb - 1)]))
              else
              (vbmatsub mA_ap7 (i_apb, j_apc) -
                 sum
                   (map
                      (\ k_aJK ->
                         (vbmatsub m_ap8 (i_apb, k_aJK) * vbmatsub m_ap8 (j_apc, k_aJK)))
                      [(k0_apa i_apb j_apc) .. (j_apc - 1)]))
                / (vbmatsub m_ap8 (j_apc, j_apc))
        k0_apa i_aSR j_aSS
          = if ((fstclvbmat mA_ap7 i_aSR) >= (fstclvbmat mA_ap7 j_aSS)) then
              (fstclvbmat mA_ap7 i_aSR) else (fstclvbmat mA_ap7 j_aSS)
vbllsolution (!a_aST) (norecord@b_aSU)
  = fst (backwarding (forwarding (b_aSU, vblldecomp a_aST)))
vbllsolution' a'_aT1 b_aT2
  = fst (backwarding (forwarding (b_aT2, a'_aT1)))
forwarding (b_aT3, mVB_aT4) = (b'_aT5, mVB_aT4)
  where b'_aT5 = makevec n_aT6 f_aT7
        (norecord@n_aT6) = boundvec b_aT3
        f_aT7 i_aT9
          = (vecsub b_aT3 i_aT9 -
               sum
                 [(vbmatsub mVB_aT4 (i_aT9, j_aTa)) * (vecsub b'_aT5 j_aTa) |
                  (norecord@j_aTa) <- [l_aT8 i_aT9 .. i_aT9 - 1]])
              / (vbmatsub mVB_aT4 (i_aT9, i_aT9))
        l_aT8 i_aTb = fstclvbmat mVB_aT4 i_aTb
backwarding (norecord@((norecord@b_aTc), mVB_aTd))
  = (b'_aTf, mVB_aTd)
  where (norecord@n_aTe) = boundvec b_aTc
        b'_aTf = makevec n_aTe f_aTg
        f_aTg (!i_aTi)
          = (vecsub b_aTc i_aTi -
               sum
                 [(vbmatsub mVB_aTd (j_aTj, i_aTi)) * (vecsub b'_aTf j_aTj) |
                  j_aTj <- (validj_aTh i_aTi [i_aTi + 1 .. n_aTe])])
              / (vbmatsub mVB_aTd (i_aTi, i_aTi))
        validj_aTh (!i_aTk) ((norecord@j_aTl) : js_aTm)
          = if (i_aTk >= fstclvbmat mVB_aTd j_aTl) then
              j_aTl : (validj_aTh i_aTk js_aTm) else validj_aTh i_aTk js_aTm
        validj_aTh (norecord@i_aTn) [] = []
STARTLOG
["nr_ay3","safebang@!nr_ay3","(!nr_ay3)","nc_ay4","((!nr_ay3), nc_ay4)","g_ay5","safebang@!g_ay5","(!g_ay5)","i_ay6","safebang@!i_ay6","(!i_ay6)","nr_aK8","safebang@!nr_aK8","(!nr_aK8)","nc_aK9","((!nr_aK8), nc_aK9)","elements_aKa","MAT ((!nr_aK8), nc_aK9) elements_aKa","(MAT ((!nr_aK8), nc_aK9) elements_aKa)","!(MAT ((!nr_aK8), nc_aK9) elements_aKa)","(!(MAT ((!nr_aK8), nc_aK9) elements_aKa))","((!(MAT ((!nr_aK8), nc_aK9) elements_aKa)))","!((!(MAT ((!nr_aK8), nc_aK9) elements_aKa)))","(!((!(MAT ((!nr_aK8), nc_aK9) elements_aKa))))","m_aKb","s_aKc","nr_aKd","nc_aKe","(nr_aKd, nc_aKe)","elements_aKf","MAT (nr_aKd, nc_aKe) elements_aKf","(MAT (nr_aKd, nc_aKe) elements_aKf)","!(MAT (nr_aKd, nc_aKe) elements_aKf)","(!(MAT (nr_aKd, nc_aKe) elements_aKf))","new_elements_aKg","new_s_aKh","lazydmd@!new_s_aKh","(!new_s_aKh)","i_aKi","j_aKj","safebang@!j_aKj","(!j_aKj)","(i_aKi, (!j_aKj))","x_aKk","safebang@!x_aKk","(!x_aKk)","((i_aKi, (!j_aKj)), (!x_aKk))","!((i_aKi, (!j_aKj)), (!x_aKk))","(!((i_aKi, (!j_aKj)), (!x_aKk)))","((!((i_aKi, (!j_aKj)), (!x_aKk))))","m_aKl","!m_aKl","(!m_aKl)","s_aKm","nr_aKn","!nr_aKn","(!nr_aKn)","nc_aKo","!nc_aKo","(!nc_aKo)","((!nr_aKn), (!nc_aKo))","elements_aKp","MAT ((!nr_aKn), (!nc_aKo)) elements_aKp","new_elements_aKq","!new_elements_aKq","(!new_elements_aKq)","new_s_aKr","i_aKs","safebang@!i_aKs","(!i_aKs)","j_aKt","((!i_aKs), j_aKt)","x_aKu","safebang@!x_aKu","(!x_aKu)","(((!i_aKs), j_aKt), (!x_aKu))","((((!i_aKs), j_aKt), (!x_aKu)))","m_aKv","!m_aKv","(!m_aKv)","i_aKw","j_aKx","(i_aKw, j_aKx)","!(i_aKw, j_aKx)","(!(i_aKw, j_aKx))","nr_aKy","nc_aKz","(nr_aKy, nc_aKz)","elements_aKA","!elements_aKA","(!elements_aKA)","MAT (nr_aKy, nc_aKz) (!elements_aKA)","m_aKB","!m_aKB","(!m_aKB)","v_aKC","safebang@!v_aKC","(!v_aKC)","i_aKF","j_aQu","!j_aQu","(!j_aQu)","nr_aKD","!nr_aKD","(!nr_aKD)","nc_aKE","!nc_aKE","(!nc_aKE)","((!nr_aKD), (!nc_aKE))","!((!nr_aKD), (!nc_aKE))","(!((!nr_aKD), (!nc_aKE)))","m1_aQv","!m1_aQv","(!m1_aQv)","m2_aQw","i_a13w","j_a13x","safebang@!j_a13x","(!j_a13x)","(i_a13w, (!j_a13x))","!(i_a13w, (!j_a13x))","(!(i_a13w, (!j_a13x)))","k_a13y","l_aQx","t1_aQy","(l_aQx, t1_aQy)","!(l_aQx, t1_aQy)","(!(l_aQx, t1_aQy))","t2_aQz","n_aQA","!n_aQA","(!n_aQA)","(t2_aQz, (!n_aQA))","m_a13A","!m_a13A","(!m_a13A)","i_a13B","safebang@!i_a13B","(!i_a13B)","j_a13D","_","n_a13C","!n_a13C","(!n_a13C)","(_, (!n_a13C))","m_a13E","j_a13F","i_a13H","n_a13G","!n_a13G","(!n_a13G)","_","!_","(!_)","((!n_a13G), (!_))","!((!n_a13G), (!_))","(!((!n_a13G), (!_)))","i_a13I","safebang@!i_a13I","(!i_a13I)","j_a13J","safebang@!j_a13J","(!j_a13J)","m_a13K","r_a13L","safebang@!r_a13L","(!r_a13L)","c_a13M","safebang@!c_a13M","(!c_a13M)","((!r_a13L), (!c_a13M))","!((!r_a13L), (!c_a13M))","(!((!r_a13L), (!c_a13M)))","i_a13N","safebang@!i_a13N","(!i_a13N)","j_a13O","safebang@!j_a13O","(!j_a13O)","m_a13P","!m_a13P","(!m_a13P)","r_a13Q","safebang@!r_a13Q","(!r_a13Q)","c_a13R","safebang@!c_a13R","(!c_a13R)","((!r_a13Q), (!c_a13R))","!((!r_a13Q), (!c_a13R))","(!((!r_a13Q), (!c_a13R)))","i1_a13S","safebang@!i1_a13S","(!i1_a13S)","j1_a13T","((!i1_a13S), j1_a13T)","i2_a13U","j2_a13V","safebang@!j2_a13V","(!j2_a13V)","(i2_a13U, (!j2_a13V))","m_a13W","i_a13X","safebang@!i_a13X","(!i_a13X)","j_a13Y","((!i_a13X), j_a13Y)","!((!i_a13X), j_a13Y)","(!((!i_a13X), j_a13Y))","m_a13Z","i_a141","nr_a140","_","!_","(!_)","(nr_a140, (!_))"]
module Matrix
       (Mat, makemat, boundmat, matsub, incrmat, updmat, mmatvec, mmatmat,
        row, col, intchrow, intchcol, interchmat, displaymat)
       where
import Data.Ix
import Basics
import Vector

makemat :: (Int, Int) -> ((Int, Int) -> a_ay2) -> Mat a_ay2

boundmat :: Mat a_ay1 -> (Int, Int)

incrmat ::
          (Num a_ay0) => Mat a_ay0 -> [((Int, Int), a_ay0)] -> Mat a_ay0

updmat :: Mat a_axZ -> [((Int, Int), a_axZ)] -> Mat a_axZ

matsub :: Mat a_axY -> (Int, Int) -> a_axY

mmatvec :: (Num a_axX) => Mat a_axX -> Vec a_axX -> Vec a_axX

mmatmat :: (Num a_awY) => Mat a_awY -> Mat a_awY -> Mat a_awY

row :: Mat a_awX -> Int -> Vec a_awX

col :: Mat a_awW -> Int -> Vec a_awW

intchrow :: Int -> Int -> Mat a_awV -> Mat a_awV

intchcol :: Int -> Int -> Mat a_awU -> Mat a_awU

interchmat :: (Int, Int) -> (Int, Int) -> Mat a_awT -> Mat a_awT

displaymat :: (Show a_aos) => Mat a_aos -> [Char]
makemat ((!nr_ay3), nc_ay4) (!g_ay5)
  = MAT (nr_ay3, nc_ay4)
      (makevec (nr_ay3 * nc_ay4)
         (\ (!i_ay6) ->
            (map g_ay5 (range ((1, 1), (nr_ay3, nc_ay4)))) !! (i_ay6 - 1)))
boundmat
  (norecord@((norecord@(MAT ((!nr_aK8), nc_aK9) elements_aKa))))
  = (nr_aK8, nc_aK9)
updmat m_aKb s_aKc = MAT (nr_aKd, nc_aKe) new_elements_aKg
  where (norecord@(MAT (nr_aKd, nc_aKe) elements_aKf)) = m_aKb
        new_elements_aKg = updvec elements_aKf new_s_aKh
        (lazydmd@new_s_aKh)
          = map
              (\ ((norecord@((i_aKi, (!j_aKj)), (!x_aKk)))) ->
                 (((i_aKi - 1) * nc_aKe + j_aKj, x_aKk)))
              s_aKc
incrmat (norecord@m_aKl) s_aKm
  = MAT (nr_aKn, nc_aKo) new_elements_aKq
  where MAT ((norecord@nr_aKn), (norecord@nc_aKo)) elements_aKp
          = m_aKl
        (norecord@new_elements_aKq) = incrvec elements_aKp new_s_aKr
        new_s_aKr
          = map
              (\ ((((!i_aKs), j_aKt), (!x_aKu))) ->
                 (((i_aKs - 1) * nc_aKo + j_aKt, x_aKu)))
              s_aKm
matsub (norecord@m_aKv) (norecord@(i_aKw, j_aKx))
  = vecsub elements_aKA ((i_aKw - 1) * nc_aKz + j_aKx)
  where MAT (nr_aKy, nc_aKz) (norecord@elements_aKA) = m_aKv
mmatvec (norecord@m_aKB) (!v_aKC)
  = makevec nr_aKD
      (\ i_aKF ->
         sum
           [(matsub m_aKB (i_aKF, j_aQu)) * (vecsub v_aKC j_aQu) |
            (norecord@j_aQu) <- [1 .. nc_aKE]])
  where (norecord@((norecord@nr_aKD), (norecord@nc_aKE)))
          = boundmat m_aKB
mmatmat (norecord@m1_aQv) m2_aQw
  = if (t1_aQy == t2_aQz) then
      makemat (l_aQx, n_aQA)
        (\ (norecord@(i_a13w, (!j_a13x))) ->
           sum
             [(matsub m1_aQv (i_a13w, k_a13y)) *
                (matsub m2_aQw (k_a13y, j_a13x))
              | k_a13y <- [1 .. t1_aQy]])
      else error "Dimension error"
  where (norecord@(l_aQx, t1_aQy)) = boundmat m1_aQv
        (t2_aQz, (norecord@n_aQA)) = boundmat m2_aQw
row (norecord@m_a13A) (!i_a13B)
  = makevec n_a13C (\ j_a13D -> matsub m_a13A (i_a13B, j_a13D))
  where (_, (norecord@n_a13C)) = boundmat m_a13A
col m_a13E j_a13F
  = makevec n_a13G (\ i_a13H -> matsub m_a13E (i_a13H, j_a13F))
  where (norecord@((norecord@n_a13G), (norecord@_)))
          = boundmat m_a13E
intchrow (!i_a13I) (!j_a13J) m_a13K
  = makemat (boundmat m_a13K)
      (\ (norecord@((!r_a13L), (!c_a13M))) ->
         if (r_a13L == i_a13I) then matsub m_a13K (j_a13J, c_a13M) else
           if (r_a13L == j_a13J) then matsub m_a13K (i_a13I, c_a13M) else
             matsub m_a13K (r_a13L, c_a13M))
intchcol (!i_a13N) (!j_a13O) (norecord@m_a13P)
  = makemat (boundmat m_a13P)
      (\ (norecord@((!r_a13Q), (!c_a13R))) ->
         if (c_a13R == i_a13N) then matsub m_a13P (r_a13Q, j_a13O) else
           if (c_a13R == j_a13O) then matsub m_a13P (r_a13Q, i_a13N) else
             matsub m_a13P (r_a13Q, c_a13R))
interchmat ((!i1_a13S), j1_a13T) (i2_a13U, (!j2_a13V)) m_a13W
  = makemat (boundmat m_a13W)
      (\ (norecord@((!i_a13X), j_a13Y)) ->
         if (i_a13X, j_a13Y) == (i1_a13S, j1_a13T) then
           matsub m_a13W (i2_a13U, j2_a13V) else
           if (i_a13X, j_a13Y) == (i2_a13U, j2_a13V) then
             matsub m_a13W (i1_a13S, j1_a13T) else
             matsub m_a13W (i_a13X, j_a13Y))
displaymat m_a13Z
  = "<\n" ++
      concat [displayvec (row m_a13Z i_a141) | i_a141 <- [1 .. nr_a140]]
      ++ ">\n"
  where (nr_a140, (norecord@_)) = boundmat m_a13Z

data Mat a_aok = MAT (Int, Int) (Vec a_aok)
STARTLOG
["idb_aw4","!idb_aw4","(!idb_aw4)","rdb_aw5","((!idb_aw4), rdb_aw5)","idb_aw6","!idb_aw6","(!idb_aw6)","rdb_aw7","!rdb_aw7","(!rdb_aw7)","((!idb_aw6), (!rdb_aw7))","!((!idb_aw6), (!rdb_aw7))","(!((!idb_aw6), (!rdb_aw7)))","idb_aw8","rdb_aw9","(idb_aw8, rdb_aw9)","idb_awa","!idb_awa","(!idb_awa)","rdb_awb","!rdb_awb","(!rdb_awb)","((!idb_awa), (!rdb_awb))","idb_awc","rdb_awd","(idb_awc, rdb_awd)","node_awe","x_awf","y_awg","!y_awg","(!y_awg)","index_awh","idb_axf","!idb_axf","(!idb_axf)","rdb_axg","((!idb_axf), rdb_axg)","!((!idb_axf), rdb_axg)","(!((!idb_axf), rdb_axg))","node_axh","idb_axi","!idb_axi","(!idb_axi)","rdb_axj","!rdb_axj","(!rdb_axj)","((!idb_axi), (!rdb_axj))","material_axk","safebang@!material_axk","(!material_axk)","ea_axl","ei_axm","!ei_axm","(!ei_axm)","index_axn","!index_axn","(!index_axn)","idb_axo","rdb_axp","(idb_axo, rdb_axp)","element_axq","safebang@!element_axq","(!element_axq)","nodel_axr","noder_axs","!noder_axs","(!noder_axs)","index_axt","idb_axu","rdb_axv","!rdb_axv","(!rdb_axv)","(idb_axu, (!rdb_axv))","element_axw","idb_axx","!idb_axx","(!idb_axx)","rdb_axy","((!idb_axx), rdb_axy)","j_axz","safebang@!j_axz","(!j_axz)","to_node_axA","px_axB","py_axC","m_axD","!m_axD","(!m_axD)","indexi_axE","indexr_axF","!indexr_axF","(!indexr_axF)","nnodes_axG","!nnodes_axG","(!nnodes_axG)","nelems_axH","nmatss_axI","!nmatss_axI","(!nmatss_axI)"]
module DB_interface
       (nnode, nmats, getnxy, getnbc, getmpro, nelem, nplds, getenlr,
        getemat, getpld)
       where
import Data.Array
import Database

nnode, nelem, nmats, nplds ::
       (Array Int Int, Array Int Float) -> Int
nnode ((norecord@idb_aw4), rdb_aw5) = idb_aw4 ! 0
nelem (norecord@((norecord@idb_aw6), (norecord@rdb_aw7)))
  = idb_aw6 ! 1
nmats (idb_aw8, rdb_aw9) = idb_aw8 ! 2
nplds ((norecord@idb_awa), (norecord@rdb_awb)) = idb_awa ! 3

getnxy :: (Array Int Int, Array Int Float) -> Int -> (Float, Float)
getnxy (idb_awc, rdb_awd) node_awe = (x_awf, y_awg)
  where x_awf = rdb_awd ! index_awh
        (norecord@y_awg) = rdb_awd ! (index_awh + 1)
        index_awh = (node_awe - 1) * 2

getnbc :: (Array Int Int, Array Int Float) -> Int -> Int
getnbc (norecord@((norecord@idb_axf), rdb_axg)) node_axh
  = idb_axf ! (3 + node_axh)

getmpro ::
        (Array Int Int, Array Int Float) -> Int -> (Float, Float)
getmpro ((norecord@idb_axi), (norecord@rdb_axj)) (!material_axk)
  = (ea_axl, ei_axm)
  where ea_axl = rdb_axj ! index_axn
        (norecord@ei_axm) = rdb_axj ! (index_axn + 1)
        (norecord@index_axn)
          = (nnode (idb_axi, rdb_axj)) * 2 + (material_axk - 1) * 2

getenlr :: (Array Int Int, Array Int Float) -> Int -> (Int, Int)
getenlr (idb_axo, rdb_axp) (!element_axq) = (nodel_axr, noder_axs)
  where nodel_axr = idb_axo ! index_axt
        (norecord@noder_axs) = idb_axo ! (index_axt + 1)
        index_axt = 4 + (nnode (idb_axo, rdb_axp)) + (element_axq - 1) * 3

getemat :: (Array Int Int, Array Int Float) -> Int -> Int
getemat (idb_axu, (norecord@rdb_axv)) element_axw
  = idb_axu ! (3 + (nnode (idb_axu, rdb_axv)) + element_axw * 3)

getpld ::
       (Array Int Int, Array Int Float) ->
         Int -> (Int, Float, Float, Float)
getpld ((norecord@idb_axx), rdb_axy) (!j_axz)
  = (to_node_axA, px_axB, py_axC, m_axD)
  where to_node_axA = idb_axx ! indexi_axE
        px_axB = rdb_axy ! (indexr_axF)
        py_axC = rdb_axy ! (indexr_axF + 1)
        (norecord@m_axD) = rdb_axy ! (indexr_axF + 2)
        indexi_axE = 4 + nnodes_axG + nelems_axH * 3 + (j_axz - 1)
        (norecord@indexr_axF)
          = nnodes_axG * 2 + nmatss_axI * 2 + (j_axz - 1) * 3
        (norecord@nnodes_axG) = nnode (idb_axx, rdb_axy)
        nelems_axH = nelem (idb_axx, rdb_axy)
        (norecord@nmatss_axI) = nmats (idb_axx, rdb_axy)
STARTLOG
["s_azG","!s_azG","(!s_azG)","initial_value_azH","i_azJ","index_value_assoc_s_azI","safebang@!index_value_assoc_s_azI","(!index_value_assoc_s_azI)","s_azK","!s_azK","(!s_azK)","assemble_s_azL","!assemble_s_azL","(!assemble_s_azL)","s_aFL","till_now_dd_aFM","element_aFN","dd_this'_aFO","lazydmd@!dd_this'_aFO","(!dd_this'_aFO)","i_aGW","!i_aGW","(!i_aGW)","j_aGX","dgrs_list_aFP","nodel_aFQ","noder_aFR","(nodel_aFQ, noder_aFR)","node_aTT","eindex_dgrs_list_aFT","safebang@!eindex_dgrs_list_aFT","(!eindex_dgrs_list_aFT)","aindex_dgrs_list_aFU","i_aXi","safebang@!i_aXi","(!i_aXi)","dgr_aXj","((!i_aXi), dgr_aXj)","!((!i_aXi), dgr_aXj)","(!((!i_aXi), dgr_aXj))","n_aFW","i_aXk","!i_aXk","(!i_aXk)","j_aXl","!j_aXl","(!j_aXl)","i_aXs"]
module Assemble_stiffness (kdd) where
import Basics
import Vector
import Matrix
import VBmatrix
import DB_interface
import Degrees
import Pre_assemble
import Elemstif

kdd :: (Array Int Int, Array Int Float) -> Vbm Float
kdd (norecord@s_azG)
  = incrvbmat initial_value_azH index_value_assoc_s_azI
  where initial_value_azH
          = makevbmat (ndgrs s_azG) (diagadr s_azG) (\ i_azJ -> 0.0)
        (!index_value_assoc_s_azI) = index_value_assoc s_azG
index_value_assoc (norecord@s_azK)
  = foldl assemble_s_azL [] [1 .. (nelem s_azK)]
  where (norecord@assemble_s_azL) = assemble s_azK
assemble s_aFL till_now_dd_aFM element_aFN
  = (till_now_dd_aFM ++ dd_this'_aFO)
  where (lazydmd@dd_this'_aFO)
          = [((f_aFY i_aGW, f_aFY j_aGX), x_aFX i_aGW j_aGX) |
             (norecord@i_aGW) <- [0 .. n_aFW - 1], j_aGX <- [0 .. i_aGW],
             f_aFY i_aGW > 0, f_aFY j_aGX > 0]
        dgrs_list_aFP
          = (dgrs_list_node_aFS nodel_aFQ) ++ (dgrs_list_node_aFS noder_aFR)
        (nodel_aFQ, noder_aFR) = getenlr s_aFL element_aFN
        dgrs_list_node_aFS node_aTT = getndgr s_aFL node_aTT
        (!eindex_dgrs_list_aFT) = zip [1 .. 6] dgrs_list_aFP
        aindex_dgrs_list_aFU = filter valid_index_aFV eindex_dgrs_list_aFT
        valid_index_aFV (norecord@((!i_aXi), dgr_aXj)) = (dgr_aXj /= 0)
        n_aFW = length aindex_dgrs_list_aFU
        x_aFX (norecord@i_aXk) (norecord@j_aXl)
          = matsub (beam2d s_aFL element_aFN)
              (fst (aindex_dgrs_list_aFU !! i_aXk),
               fst (aindex_dgrs_list_aFU !! j_aXl))
        f_aFY i_aXs = (snd (aindex_dgrs_list_aFU !! i_aXs))
STARTLOG
["db_ax4","safebang@!db_ax4","(!db_ax4)","db_ax5","db_ax6","a_node_s_ax7","!a_node_s_ax7","(!a_node_s_ax7)","db_aD7","!db_aD7","(!db_aD7)","node_aD8","!node_aD8","(!node_aD8)","x_aD9","y_aDa","(x_aD9, y_aDa)","bc_aDb","!bc_aDb","(!bc_aDb)","db_aDc","!db_aDc","(!db_aDc)","a_material_s_aDd","db_aDe","material_aDf","ea_aDg","ei_aDh","(ea_aDg, ei_aDh)","db_aDi","!db_aDi","(!db_aDi)","a_element_s_aDj","db_aDk","!db_aDk","(!db_aDk)","element_aDl","nodel_aDm","!nodel_aDm","(!nodel_aDm)","noder_aDn","((!nodel_aDm), noder_aDn)","!((!nodel_aDm), noder_aDn)","(!((!nodel_aDm), noder_aDn))","material_aDo","!material_aDo","(!material_aDo)","db_aDp","a_load_s_aDq","!a_load_s_aDq","(!a_load_s_aDq)","db_aDr","n_aDs","!n_aDs","(!n_aDs)","to_point_aDt","!to_point_aDt","(!to_point_aDt)","px_aDu","py_aDv","m_aDw","((!to_point_aDt), px_aDu, py_aDv, m_aDw)","!((!to_point_aDt), px_aDu, py_aDv, m_aDw)","(!((!to_point_aDt), px_aDu, py_aDv, m_aDw))"]
module PrintSource (source_data) where
import Database
import DB_interface
import Basics

source_data :: (Array Int Int, Array Int Float) -> [Char]
source_data (!db_ax4)
  = control_data db_ax4 ++ node_data db_ax4 ++ material_data db_ax4
      ++ elements db_ax4
      ++ plds db_ax4
control_data db_ax5
  = "\n\n\nCONTROL DATA :\n\n" ++ "   Total number of nodes = " ++
      (showlj 3 (nnode db_ax5))
      ++ "\n"
      ++ "   Number of elements    = "
      ++ (showlj 3 (nelem db_ax5))
      ++ "\n"
      ++ "   Number of point loads = "
      ++ (showlj 3 (nplds db_ax5))
      ++ "\n"
      ++ "   Total number of materials = "
      ++ (showlj 3 (nmats db_ax5))
      ++ "\n\n\n"
node_data db_ax6
  = "NODE INFORMATION  :\n\n" ++
      (concat (map a_node_s_ax7 [1 .. (nnode db_ax6)]))
      ++ "\n\n"
  where (norecord@a_node_s_ax7) = a_node db_ax6
a_node (norecord@db_aD7) (norecord@node_aD8)
  = "  Node.no = " ++ (showlj 3 node_aD8) ++ "   x = " ++
      (showlj 8 x_aD9)
      ++ "   y = "
      ++ (showlj 8 y_aDa)
      ++ "   bc = "
      ++ (showlj 3 bc_aDb)
      ++ "\n"
  where (x_aD9, y_aDa) = getnxy db_aD7 node_aD8
        (norecord@bc_aDb) = getnbc db_aD7 node_aD8
material_data (norecord@db_aDc)
  = "MATERIAL INFORMATION :\n\n" ++
      (concat (map a_material_s_aDd [1 .. (nmats db_aDc)]))
  where a_material_s_aDd = a_material db_aDc
a_material db_aDe material_aDf
  = "  Material No.=" ++ (showlj 3 material_aDf) ++ "   EA = " ++
      (showlj 8 ea_aDg)
      ++ "   EI = "
      ++ (showlj 8 ei_aDh)
      ++ "\n"
  where (ea_aDg, ei_aDh) = getmpro db_aDe material_aDf
elements (norecord@db_aDi)
  = "\nELEMENT DATA:\n\n" ++
      (concat (map (a_element_s_aDj) [1 .. (nelem db_aDi)]))
      ++ "\n\n"
  where a_element_s_aDj = a_element db_aDi
a_element (norecord@db_aDk) element_aDl
  = "  Element No.=" ++ (showlj 3 element_aDl) ++ "   Node.L =" ++
      (showlj 3 nodel_aDm)
      ++ "   Node.R ="
      ++ (showlj 3 noder_aDn)
      ++ "   Material No. ="
      ++ (showlj 3 material_aDo)
      ++ "\n"
  where (norecord@((norecord@nodel_aDm), noder_aDn))
          = getenlr db_aDk element_aDl
        (norecord@material_aDo) = getemat db_aDk element_aDl
plds db_aDp
  = "\nPOINT LOADS DATA:\n\n" ++
      (concat (map (a_load_s_aDq) [1 .. (nplds db_aDp)]))
      ++ "\n\n"
  where (norecord@a_load_s_aDq) = a_load db_aDp
a_load db_aDr (norecord@n_aDs)
  = "  To_point No." ++ (showlj 3 to_point_aDt) ++ "  Px = " ++
      (showlj 9 px_aDu)
      ++ "  Py = "
      ++ (showlj 9 py_aDv)
      ++ "  M = "
      ++ (showlj 9 m_aDw)
      ++ "\n"
  where (norecord@((norecord@to_point_aDt), px_aDu, py_aDv, m_aDw))
          = getpld db_aDr n_aDs
STARTLOG
["s_axM","!s_axM","(!s_axM)","v_axN","bound_axO","i_axR","!i_axR","(!i_axR)","bandvec_s_axQ","!bandvec_s_axQ","(!bandvec_s_axQ)","s_aLK","!s_aLK","(!s_aLK)","initial_value_aLL","i_aLN","pre_assemble_s_aLM","s_aRN","!s_aRN","(!s_aRN)","element_aRO","!element_aRO","(!element_aRO)","x_aRU","dgrs_list_aRQ","nodel_aRR","noder_aRS","(nodel_aRR, noder_aRS)","node_aVk","x_aVl","!x_aVl","(!x_aVl)","s_aVm"]
module Pre_assemble (diagadr, diagadrrlt) where
import Basics
import Vector
import DB_interface
import Degrees

diagadr :: (Array Int Int, Array Int Float) -> Vec Int
diagadr (norecord@s_axM) = v_axN
  where v_axN = makevec bound_axO f_axP
        bound_axO = boundvec (bandvec_s_axQ)
        f_axP (norecord@i_axR)
          = if (i_axR == 1) then 1 else
              vecsub v_axN (i_axR - 1) + vecsub bandvec_s_axQ i_axR
        (norecord@bandvec_s_axQ) = bandvec s_axM
bandvec (norecord@s_aLK)
  = maxupdvec initial_value_aLL
      (concat (map pre_assemble_s_aLM [1 .. (nelem s_aLK)]))
  where initial_value_aLL = makevec (ndgrs s_aLK) (\ i_aLN -> 0)
        pre_assemble_s_aLM = pre_assemble s_aLK
pre_assemble (norecord@s_aRN) (norecord@element_aRO)
  = azip dgrs_list_aRQ (map f_aRP dgrs_list_aRQ)
  where f_aRP x_aRU = x_aRU - (head dgrs_list_aRQ) + 1
        dgrs_list_aRQ
          = (dgrs_list_node_aRT nodel_aRR) ++ (dgrs_list_node_aRT noder_aRS)
        (nodel_aRR, noder_aRS) = getenlr s_aRN element_aRO
        dgrs_list_node_aRT node_aVk
          = filter (\ (norecord@x_aVl) -> x_aVl /= 0)
              (getndgr s_aRN node_aVk)

diagadrrlt :: (Array Int Int, Array Int Float) -> [Char]
diagadrrlt s_aVm
  = "DIAGONAL ADDRESS VECTOR=\n" ++ displayvec (diagadr s_aVm)
STARTLOG
["s_aDH","safebang@!s_aDH","(!s_aDH)","il_aDI","n_aDJ","s_aKG","safebang@!s_aKG","(!s_aKG)","rl_aKH","safebang@!rl_aKH","(!rl_aKH)","n_aKI","!n_aKI","(!n_aKI)","s_aKJ","s_aKQ","s_aKR","[]","![]","(![])","x_aO9","safebang@!x_aO9","(!x_aO9)","ls_aOa","(!x_aO9) : ls_aOa","((!x_aO9) : ls_aOa)","idb_aOb","rdb_aOc","(idb_aOb, rdb_aOc)","c_aOd","!c_aOd","(!c_aOd)","x_aOe","(!c_aOd) : x_aOe","((!c_aOd) : x_aOe)","!((!c_aOd) : x_aOe)","(!((!c_aOd) : x_aOe))","((!((!c_aOd) : x_aOe)))","s_a119","!s_a119","(!s_a119)","[]","c_a14o","!c_a14o","(!c_a14o)","ls_a14p","safebang@!ls_a14p","(!ls_a14p)","(!c_a14o) : (!ls_a14p)","((!c_a14o) : (!ls_a14p))","!((!c_a14o) : (!ls_a14p))","(!((!c_a14o) : (!ls_a14p)))","c_a14q","c_a14r","!c_a14r","(!c_a14r)","x_a14s","safebang@!x_a14s","(!x_a14s)","(!c_a14r) : (!x_a14s)","((!c_a14r) : (!x_a14s))","s_a14t","x_a14u","!x_a14u","(!x_a14u)","s_a14R","[]","![]","(![])","c_a14S","s_a14T","c_a14S : s_a14T","(c_a14S : s_a14T)","!(c_a14S : s_a14T)","(!(c_a14S : s_a14T))","((!(c_a14S : s_a14T)))","c_a14U","x_a14V","!x_a14V","(!x_a14V)","s_a14W","0","i_a1e2","!i_a1e2","(!i_a1e2)"]
module Database (idatabase, rdatabase) where
import Data.Array
import Data.Char (isDigit)

idatabase :: [Char] -> Array Int Int
idatabase (!s_aDH) = listArray (0, n_aDJ - 1) il_aDI
  where il_aDI = isource s_aDH
        n_aDJ = length il_aDI

rdatabase :: [Char] -> Array Int Float
rdatabase (!s_aKG) = listArray (0, n_aKI - 1) rl_aKH
  where (!rl_aKH) = rsource s_aKG
        (norecord@n_aKI) = length rl_aKH

isource :: [Char] -> [Int]
isource s_aKJ = fst (irsource s_aKJ)

rsource :: [Char] -> [Float]
rsource s_aKQ = snd (irsource s_aKQ)
irsource s_aKR = intreal (words s_aKR)
intreal (norecord@[]) = ([], [])
intreal ((!x_aO9) : ls_aOa)
  = if (elem '.' x_aO9) then (idb_aOb, (realreal x_aO9) : rdb_aOc)
      else ((intint x_aO9) : idb_aOb, rdb_aOc)
  where (idb_aOb, rdb_aOc) = intreal ls_aOa

intint :: [Char] -> Int
intint ((norecord@((norecord@c_aOd) : x_aOe)))
  = if (c_aOd == '-') then (-1) * (stoi x_aOe) else
      if (c_aOd == '+') then stoi x_aOe else stoi (c_aOd : x_aOe)

stoi :: [Char] -> Int
stoi (norecord@s_a119) = stoi' (reverse s_a119)
stoi' [] = 0
stoi' (norecord@((norecord@c_a14o) : (!ls_a14p)))
  = (stoi' ls_a14p) * 10 + ctoi c_a14o
ctoi c_a14q
  = if (c_a14q == '0') then 0 else
      if (c_a14q == '1') then 1 else
        if (c_a14q == '2') then 2 else
          if (c_a14q == '3') then 3 else
            if (c_a14q == '4') then 4 else
              if (c_a14q == '5') then 5 else
                if (c_a14q == '6') then 6 else
                  if (c_a14q == '7') then 7 else if (c_a14q == '8') then 8 else 9

realreal :: [Char] -> Float
realreal ((norecord@c_a14r) : (!x_a14s))
  = if (c_a14r == '-') then (-1.0) * (stor x_a14s) else
      if (c_a14r == '+') then stor x_a14s else stor (c_a14r : x_a14s)

stor :: [Char] -> Float
stor s_a14t = (intpart s_a14t) + (floatpart s_a14t)

intpart :: [Char] -> Float
intpart (norecord@x_a14u) = intpart' (takeWhile isDigit x_a14u)

intpart' :: [Char] -> Float
intpart' s_a14R = intparts (reverse s_a14R)
intparts (norecord@[]) = 0.0
intparts ((norecord@(c_a14S : s_a14T)))
  = (intparts s_a14T) * 10.0 + intpartss c_a14S
intpartss c_a14U
  = if (c_a14U == '0') then 0.0 else
      if (c_a14U == '1') then 1.0 else
        if (c_a14U == '2') then 2.0 else
          if (c_a14U == '3') then 3.0 else
            if (c_a14U == '4') then 4.0 else
              if (c_a14U == '5') then 5.0 else
                if (c_a14U == '6') then 6.0 else
                  if (c_a14U == '7') then 7.0 else
                    if (c_a14U == '8') then 8.0 else 9.0

floatpart :: [Char] -> Float
floatpart (norecord@x_a14V)
  = floatpart' (drop 1 (dropWhile isDigit x_a14V))

floatpart' :: [Char] -> Float
floatpart' s_a14W = (intpart' s_a14W) / (e10 (length s_a14W))
e10 0 = 1.0
e10 (norecord@i_a1e2) = 10.0 * (e10 (i_a1e2 - 1))
STARTLOG
["db_axF","!db_axF","(!db_axF)","uvw_axG","force_2d_bar_s_axH","db_axI","safebang@!db_axI","(!db_axI)","element_axJ","safebang@!element_axJ","(!element_axJ)","frc_axK","!frc_axK","(!frc_axK)","db_axL","uvw_axM","element_axN","nodel_axO","!nodel_axO","(!nodel_axO)","noder_axP","!noder_axP","(!noder_axP)","((!nodel_axO), (!noder_axP))","ea_axQ","ei_axR","(ea_axQ, ei_axR)","xl_axS","yl_axT","(xl_axS, yl_axT)","!(xl_axS, yl_axT)","(!(xl_axS, yl_axT))","xr_axU","yr_axV","!yr_axV","(!yr_axV)","(xr_axU, (!yr_axV))","c_axW","!c_axW","(!c_axW)","s_axX","det_x_axY","!det_x_axY","(!det_x_axY)","det_y_axZ","!det_y_axZ","(!det_y_axZ)","length_ay0","ul_ay1","!ul_ay1","(!ul_ay1)","vl_ay2","thetal_ay3","!thetal_ay3","(!thetal_ay3)","((!ul_ay1), vl_ay2, (!thetal_ay3))","!((!ul_ay1), vl_ay2, (!thetal_ay3))","(!((!ul_ay1), vl_ay2, (!thetal_ay3)))","ur_ay4","vr_ay5","thetar_ay6","(ur_ay4, vr_ay5, thetar_ay6)","!(ur_ay4, vr_ay5, thetar_ay6)","(!(ur_ay4, vr_ay5, thetar_ay6))"]
module Elemforce (forces, getefrc) where
import Basics
import Vector
import DB_interface
import Displacement

forces ::
       (Array Int Int, Array Int Float) -> Vec Float -> Vec Float

getefrc ::
        (Array Int Int, Array Int Float) -> Int -> Vec Float -> Float
forces (norecord@db_axF) uvw_axG
  = makevec (nelem db_axF) force_2d_bar_s_axH
  where force_2d_bar_s_axH = force_2d_bar db_axF uvw_axG
getefrc (!db_axI) (!element_axJ) (norecord@frc_axK)
  = vecsub frc_axK element_axJ
force_2d_bar db_axL uvw_axM element_axN
  = (ea_axQ / length_ay0) *
      ((ur_ay4 - ul_ay1) * c_axW + (vr_ay5 - vl_ay2) * s_axX)
  where ((norecord@nodel_axO), (norecord@noder_axP))
          = getenlr db_axL element_axN
        (ea_axQ, ei_axR) = getmpro db_axL (getemat db_axL element_axN)
        (norecord@(xl_axS, yl_axT)) = getnxy db_axL nodel_axO
        (xr_axU, (norecord@yr_axV)) = getnxy db_axL noder_axP
        (norecord@c_axW) = det_x_axY / length_ay0
        s_axX = det_y_axZ / length_ay0
        (norecord@det_x_axY) = xr_axU - xl_axS
        (norecord@det_y_axZ) = yr_axV - yl_axT
        length_ay0 = sqrt (det_x_axY * det_x_axY + det_y_axZ * det_y_axZ)
        (norecord@((norecord@ul_ay1), vl_ay2, (norecord@thetal_ay3)))
          = getnuvw db_axL nodel_axO uvw_axM
        (norecord@(ur_ay4, vr_ay5, thetar_ay6))
          = getnuvw db_axL noder_axP uvw_axM
STARTLOG
["s_axM","safebang@!s_axM","(!s_axM)","uvw_axN","a_node_s_axO","s_aDO","!s_aDO","(!s_aDO)","uvw_aDP","!uvw_aDP","(!uvw_aDP)","node_aDQ","!node_aDQ","(!node_aDQ)","x_aDR","y_aDS","(x_aDR, y_aDS)","bc_aDT","lazydmd@!bc_aDT","(!bc_aDT)","u_aDU","!u_aDU","(!u_aDU)","v_aDV","theta_aDW","((!u_aDU), v_aDV, theta_aDW)","s_aDX","frc_aDY","a_element_s_aDZ","s_aE0","!s_aE0","(!s_aE0)","frc_aE1","element_aE2","!element_aE2","(!element_aE2)","nodel_aE3","noder_aE4","!noder_aE4","(!noder_aE4)","(nodel_aE3, (!noder_aE4))","f_aE5","lazydmd@!f_aE5","(!f_aE5)"]
module Printuvwforce (uvwresult, forceresult) where
import Basics
import Vector
import DB_interface
import Displacement
import Elemforce

uvwresult ::
          (Array Int Int, Array Int Float) -> Vec Float -> [Char]

forceresult ::
            (Array Int Int, Array Int Float) -> Vec Float -> [Char]
uvwresult (!s_axM) uvw_axN
  = "\n\nDISPLACEMENT OF THE STRUCTURE \n\n" ++
      "     Node     X     Y     BC         U             V"
      ++ "                  Theta\n"
      ++ (concat (map a_node_s_axO [1 .. (nnode s_axM)]))
  where a_node_s_axO = a_node s_axM uvw_axN
a_node (norecord@s_aDO) (norecord@uvw_aDP) (norecord@node_aDQ)
  = (showrj 8 node_aDQ) ++ (showrj 7 x_aDR) ++ (showrj 6 y_aDS) ++
      (showrj 7 bc_aDT)
      ++ (showrj 15 u_aDU)
      ++ (showrj 15 v_aDV)
      ++ (showrj 15 theta_aDW)
      ++ "\n"
  where (x_aDR, y_aDS) = getnxy s_aDO node_aDQ
        (lazydmd@bc_aDT) = getnbc s_aDO node_aDQ
        ((norecord@u_aDU), v_aDV, theta_aDW)
          = getnuvw s_aDO node_aDQ uvw_aDP
forceresult s_aDX frc_aDY
  = "\n\n\nINTERNAL FORCES OF ELEMENT " ++ "\n\n" ++
      "    Element    NodeL   NodeR     TENSION\n"
      ++ concat (map a_element_s_aDZ [1 .. (nelem s_aDX)])
  where a_element_s_aDZ = a_element s_aDX frc_aDY
a_element (norecord@s_aE0) frc_aE1 (norecord@element_aE2)
  = (showrj 8 element_aE2) ++ (showrj 10 nodel_aE3) ++
      (showrj 8 noder_aE4)
      ++ (showrj 15 f_aE5)
      ++ "\n"
  where (nodel_aE3, (norecord@noder_aE4)) = getenlr s_aE0 element_aE2
        (lazydmd@f_aE5) = getefrc s_aE0 element_aE2 frc_aE1
STARTLOG
["n_aSw","safebang@!n_aSw","(!n_aSw)","f_aSx","i_aSy","n_aSz","safebang@!n_aSz","(!n_aSz)","_","!_","(!_)","VEC (!n_aSz) (!_)","(VEC (!n_aSz) (!_))","!(VEC (!n_aSz) (!_))","(!(VEC (!n_aSz) (!_)))","((!(VEC (!n_aSz) (!_))))","n_aSA","va_aSB","VEC n_aSA va_aSB","(VEC n_aSA va_aSB)","!(VEC n_aSA va_aSB)","(!(VEC n_aSA va_aSB))","((!(VEC n_aSA va_aSB)))","!((!(VEC n_aSA va_aSB)))","(!((!(VEC n_aSA va_aSB))))","i_aSC","n_aSD","va_aSE","VEC n_aSD va_aSE","(VEC n_aSD va_aSE)","s_aSF","b_aSH","!b_aSH","(!b_aSH)","c_aSI","n_aSJ","safebang@!n_aSJ","(!n_aSJ)","va_aSK","VEC (!n_aSJ) va_aSK","(VEC (!n_aSJ) va_aSK)","!(VEC (!n_aSJ) va_aSK)","(!(VEC (!n_aSJ) va_aSK))","((!(VEC (!n_aSJ) va_aSK)))","s_aSL","safebang@!s_aSL","(!s_aSL)","n_aSM","safebang@!n_aSM","(!n_aSM)","va_aSN","VEC (!n_aSM) va_aSN","(VEC (!n_aSM) va_aSN)","!(VEC (!n_aSM) va_aSN)","(!(VEC (!n_aSM) va_aSN))","((!(VEC (!n_aSM) va_aSN)))","s_aSO","safebang@!s_aSO","(!s_aSO)","v1_aSP","!v1_aSP","(!v1_aSP)","v2_aSQ","i_aYR","n_aSR","v_aYS","!v_aYS","(!v_aYS)","i_aYU","n_aYT","!n_aYT","(!n_aYT)"]
module Vector
       (Vec, makevec, boundvec, vecsub, incrvec, updvec, maxupdvec,
        vecprod, displayvec)
       where
import Data.Array
import Basics

displayvec :: (Show a_aKa) => Vec a_aKa -> [Char]

vecprod :: (Num a_aK9) => Vec a_aK9 -> Vec a_aK9 -> a_aK9

updvec :: Vec a_aK8 -> [(Int, a_aK8)] -> Vec a_aK8

maxupdvec ::
            (Num a_axc, Ord a_axc) => Vec a_axc -> [(Int, a_axc)] -> Vec a_axc

incrvec :: (Num a_awe) => Vec a_awe -> [(Int, a_awe)] -> Vec a_awe

vecsub :: Vec a_awd -> Int -> a_awd

boundvec :: Vec a_awc -> Int

makevec :: Int -> (Int -> a_awb) -> Vec a_awb
makevec (!n_aSw) f_aSx
  = VEC n_aSw
      (array (1, n_aSw) [(i_aSy, f_aSx i_aSy) | i_aSy <- [1 .. n_aSw]])
boundvec ((norecord@(VEC (!n_aSz) (norecord@_)))) = n_aSz
vecsub (norecord@((norecord@(VEC n_aSA va_aSB)))) i_aSC
  = va_aSB ! i_aSC
updvec (VEC n_aSD va_aSE) s_aSF
  = VEC n_aSD (accum f_aSG va_aSE s_aSF)
  where f_aSG (norecord@b_aSH) c_aSI = c_aSI
maxupdvec ((norecord@(VEC (!n_aSJ) va_aSK))) (!s_aSL)
  = VEC n_aSJ (accum max va_aSK s_aSL)
incrvec ((norecord@(VEC (!n_aSM) va_aSN))) (!s_aSO)
  = VEC n_aSM (accum (+) va_aSN s_aSO)
vecprod (norecord@v1_aSP) v2_aSQ
  = sum
      [(vecsub v1_aSP i_aYR) * (vecsub v2_aSQ i_aYR) |
       i_aYR <- [1 .. n_aSR]]
  where n_aSR = boundvec v1_aSP
displayvec (norecord@v_aYS)
  = "< " ++
      concat ([(showrj 8 (vecsub v_aYS i_aYU)) | i_aYU <- [1 .. n_aYT]])
      ++ ">\n"
  where (norecord@n_aYT) = boundvec v_aYS

data Vec a_anu = VEC Int (Array Int a_anu)
STARTLOG
["s_axL","!s_axL","(!s_axL)","initial_value_axM","i_axO","index_value_assoc_s_axN","safebang@!index_value_assoc_s_axN","(!index_value_assoc_s_axN)","s_axP","!s_axP","(!s_axP)","assemble_s_axQ","!assemble_s_axQ","(!assemble_s_axQ)","s_aDQ","till_now_d_aDR","ii_aDS","d_this'_aDT","lazydmd@!d_this'_aDT","(!d_this'_aDT)","dgr_aHq","!dgr_aHq","(!dgr_aHq)","x_aHr","((!dgr_aHq), x_aHr)","degrees_aDV","loads_aDW","node_aDX","px_aDY","py_aDZ","!py_aDZ","(!py_aDZ)","m_aE0","(node_aDX, px_aDY, (!py_aDZ), m_aE0)","!(node_aDX, px_aDY, (!py_aDZ), m_aE0)","(!(node_aDX, px_aDY, (!py_aDZ), m_aE0))"]
module Assemble_loadvec (loadvec) where
import Basics
import Vector
import DB_interface
import Degrees

loadvec :: (Array Int Int, Array Int Float) -> Vec Float
loadvec (norecord@s_axL)
  = incrvec initial_value_axM index_value_assoc_s_axN
  where initial_value_axM = makevec (ndgrs s_axL) (\ i_axO -> 0.0)
        (!index_value_assoc_s_axN) = index_value_assoc s_axL
index_value_assoc (norecord@s_axP)
  = foldl assemble_s_axQ [] [1 .. (nplds s_axP)]
  where (norecord@assemble_s_axQ) = assemble s_axP
assemble s_aDQ till_now_d_aDR ii_aDS
  = till_now_d_aDR ++ d_this'_aDT
  where (lazydmd@d_this'_aDT)
          = filter valid_degree_aDU (azip degrees_aDV loads_aDW)
        valid_degree_aDU ((norecord@dgr_aHq), x_aHr) = (dgr_aHq /= 0)
        degrees_aDV = getndgr s_aDQ node_aDX
        loads_aDW = [px_aDY, py_aDZ, m_aE0]
        (norecord@(node_aDX, px_aDY, (norecord@py_aDZ), m_aE0))
          = getpld s_aDQ ii_aDS
STARTLOG
["0","!0","(!0)","x_avK","n_avL","x_avM","!x_avM","(!x_avM)","l_awL","safebang@!l_awL","(!l_awL)","x_awM","safebang@!x_awM","(!x_awM)","ns_awN","bs_awO","l_aTM","x_aTN","safebang@!x_aTN","(!x_aTN)","ns_aTO","safebang@!ns_aTO","(!ns_aTO)","bs_aTP","[]","[]","x_aTQ","ls_aTR","x_aTQ : ls_aTR","(x_aTQ : ls_aTR)","!(x_aTQ : ls_aTR)","(!(x_aTQ : ls_aTR))","x'_aTS","ls'_aTT","safebang@!ls'_aTT","(!ls'_aTT)","x'_aTS : (!ls'_aTT)","(x'_aTS : (!ls'_aTT))","!(x'_aTS : (!ls'_aTT))","(!(x'_aTS : (!ls'_aTT)))"]
module Basics (showrj, showlj, azip, module Data.Array) where
import Data.Array

showlj, showrj :: (Show a_anj) => Int -> a_anj -> [Char]

rep :: Int -> a_anb -> [a_anb]
rep (norecord@0) x_avK = []
rep n_avL (norecord@x_avM) = x_avM : (rep (n_avL - 1) x_avM)
showrj (!l_awL) (!x_awM) = (rep bs_awO ' ') ++ ns_awN
  where ns_awN = dropWhile ((==) ' ') (show x_awM)
        bs_awO
          | l_awL <= length ns_awN = 1
          | otherwise = l_awL - length ns_awN
showlj l_aTM (!x_aTN) = ns_aTO ++ (rep bs_aTP ' ')
  where (!ns_aTO) = dropWhile ((==) ' ') (show x_aTN)
        bs_aTP
          | l_aTM <= length ns_aTO = 1
          | otherwise = l_aTM - length ns_aTO

azip :: [a_an9] -> [b_ana] -> [(a_an9, b_ana)]
azip [] [] = []
azip (norecord@(x_aTQ : ls_aTR)) (norecord@(x'_aTS : (!ls'_aTT)))
  = (x_aTQ, x'_aTS) : (azip ls_aTR ls'_aTT)
STARTLOG
["s_aA3","!s_aA3","(!s_aA3)","s_aA4","initial_value_aA5","i_aB6","safebang@!i_aB6","(!i_aB6)","index_value_assoc_aA6","safebang@!index_value_assoc_aA6","(!index_value_assoc_aA6)","f_s_aA7","!f_s_aA7","(!f_s_aA7)","tUb_aA8","s_aH6","tUb_aH7","node_aH8","!node_aH8","(!node_aH8)","l_aH9","!l_aH9","(!l_aH9)","dgrs_aHa","i_aHc","s_aU8","node_aU9","uvw_aUa","u_aUb","v_aUc","!v_aUc","(!v_aUc)","theta_aUd","index_aUe","!index_aUe","(!index_aUe)"]
module Displacement (uvw, getnuvw) where
import Basics
import Vector
import Matrix
import VBmatrix
import VBlldecomp
import DB_interface
import Degrees
import Pre_assemble
import Assemble_stiffness
import Assemble_loadvec

uvw :: (Array Int Int, Array Int Float) -> Vec Float

getnuvw ::
        (Array Int Int, Array Int Float) ->
          Int -> Vec Float -> (Float, Float, Float)
t_Ub (norecord@s_aA3) = vbllsolution (kdd s_aA3) (loadvec s_aA3)
uvw s_aA4 = incrvec initial_value_aA5 index_value_assoc_aA6
  where initial_value_aA5
          = makevec (3 * (nnode s_aA4)) (\ (!i_aB6) -> 0.0)
        (!index_value_assoc_aA6)
          = concat (map f_s_aA7 [1 .. (nnode s_aA4)])
        (norecord@f_s_aA7) = f s_aA4 tUb_aA8
        tUb_aA8 = t_Ub s_aA4
f s_aH6 tUb_aH7 (norecord@node_aH8)
  = azip [l_aH9, l_aH9 + 1, l_aH9 + 2] (map ff_aHb dgrs_aHa)
  where (norecord@l_aH9) = 3 * (node_aH8 - 1) + 1
        dgrs_aHa = getndgr s_aH6 node_aH8
        ff_aHb i_aHc = if (i_aHc == 0) then 0.0 else vecsub tUb_aH7 i_aHc
getnuvw s_aU8 node_aU9 uvw_aUa = (u_aUb, v_aUc, theta_aUd)
  where u_aUb = vecsub uvw_aUa index_aUe
        (norecord@v_aUc) = vecsub uvw_aUa (index_aUe + 1)
        theta_aUd = vecsub uvw_aUa (index_aUe + 2)
        (norecord@index_aUe) = 3 * (node_aU9 - 1) + 1
STARTLOG
["s_axD","!s_axD","(!s_axD)","s_axK","node_axL","u_axM","!u_axM","(!u_axM)","v_axN","!v_axN","(!v_axN)","theta_axO","!theta_axO","(!theta_axO)","dgrsn_s_axP","index_axQ","s_ayO","s_ayP","!s_ayP","(!s_ayP)","counting_one_node_s_ayQ","!counting_one_node_s_ayQ","(!counting_one_node_s_ayQ)","s_aEQ","ndgrs_till_now_aER","dgrsn_till_now_aES","(ndgrs_till_now_aER, dgrsn_till_now_aES)","i_aET","dof_aEU","j_aF1","!j_aF1","(!j_aF1)","j_aF2","j_a113","safebang@!j_a113","(!j_a113)","ndgrs_this_node_aEX","dgrsn_this_node_aEY","lazydmd@!dgrsn_this_node_aEY","(!dgrsn_this_node_aEY)","j_a114","j_a115","!j_a115","(!j_a115)","bc_aF0","!bc_aF0","(!bc_aF0)","s_a14v","a_node_s_a14w","!a_node_s_a14w","(!a_node_s_a14w)","s_a14x","node_a14y","!node_a14y","(!node_a14y)","bc_a14z","lazydmd@!bc_a14z","(!bc_a14z)","u_a14A","v_a14B","theta_a14C","[u_a14A, v_a14B, theta_a14C]","![u_a14A, v_a14B, theta_a14C]","(![u_a14A, v_a14B, theta_a14C])"]
module Degrees (ndgrs, getndgr, degreesrlt) where
import Data.Array
import Basics
import Vector
import DB_interface

ndgrs :: (Array Int Int, Array Int Float) -> Int

getndgr :: (Array Int Int, Array Int Float) -> Int -> [Int]
ndgrs (norecord@s_axD) = fst (ndgrs_and_dgrsn s_axD)
getndgr s_axK node_axL = [u_axM, v_axN, theta_axO]
  where (norecord@u_axM) = dgrsn_s_axP ! index_axQ
        (norecord@v_axN) = dgrsn_s_axP ! (index_axQ + 1)
        (norecord@theta_axO) = dgrsn_s_axP ! (index_axQ + 2)
        dgrsn_s_axP = dgrsn s_axK
        index_axQ = (node_axL - 1) * 3 + 1

dgrsn :: (Array Int Int, Array Int Float) -> Array Int Int
dgrsn s_ayO
  = listArray (1, (nnode s_ayO) * 3) (snd (ndgrs_and_dgrsn s_ayO))

ndgrs_and_dgrsn :: (Array Int Int, Array Int Float) -> (Int, [Int])
ndgrs_and_dgrsn (norecord@s_ayP)
  = foldl counting_one_node_s_ayQ (0, []) [1 .. (nnode s_ayP)]
  where (norecord@counting_one_node_s_ayQ) = counting_one_node s_ayP
counting_one_node s_aEQ (ndgrs_till_now_aER, dgrsn_till_now_aES)
  i_aET
  = (ndgrs_till_now_aER + ndgrs_this_node_aEX,
     dgrsn_till_now_aES ++ dgrsn_this_node_aEY)
  where dof_aEU = [fod_aEV j_aF1 | (norecord@j_aF1) <- [2, 1, 0]]
        fod_aEV j_aF2
          = if (mod (div bc_aF0 (e_10_aEW j_aF2)) 10 == 1) then 1 else 0
        e_10_aEW (!j_a113)
          = if (j_a113 == 0) then (1 :: Int) else
              10 * (e_10_aEW (j_a113 - 1))
        ndgrs_this_node_aEX = sum dof_aEU
        (lazydmd@dgrsn_this_node_aEY)
          = [g_aEZ j_a114 | j_a114 <- [0, 1, 2]]
        g_aEZ (norecord@j_a115)
          = if ((dof_aEU !! j_a115) == 0) then 0 else
              sum (take (j_a115 + 1) dof_aEU) + ndgrs_till_now_aER
        (norecord@bc_aF0) = getnbc s_aEQ i_aET

degreesrlt :: (Array Int Int, Array Int Float) -> [Char]
degreesrlt s_a14v
  = "DEGREE INFORMATION :\n\n" ++ "\t Total degree numbers = " ++
      showlj 4 (ndgrs s_a14v)
      ++ "\n\n"
      ++ (concat (map a_node_s_a14w [1 .. (nnode s_a14v)]))
      ++ "\n\n"
  where (norecord@a_node_s_a14w) = a_node s_a14v
a_node s_a14x (norecord@node_a14y)
  = "  Node.no = " ++ (showrj 2 node_a14y) ++ "   u = " ++
      (showrj 8 u_a14A)
      ++ "   v = "
      ++ (showrj 8 v_a14B)
      ++ " theta="
      ++ (showrj 8 theta_a14C)
      ++ "   bc = "
      ++ (showrj 3 bc_a14z)
      ++ "\n"
  where (lazydmd@bc_a14z) = getnbc s_a14x node_a14y
        (norecord@[u_a14A, v_a14B, theta_a14C]) = getndgr s_a14x node_a14y
STARTLOG
["str_ays","!str_ays","(!str_ays)","element_ayt","i_aIO","j_aIP","safebang@!j_aIP","(!j_aIP)","(i_aIO, (!j_aIP))","!(i_aIO, (!j_aIP))","(!(i_aIO, (!j_aIP)))","a1_ayu","!a1_ayu","(!a1_ayu)","b1_ayv","b2_ayw","b3_ayx","dx_ayy","!dx_ayy","(!dx_ayy)","dy_ayz","!dy_ayz","(!dy_ayz)","l_ayA","c_ayB","s_ayC","ea_ayD","ei_ayE","(ea_ayD, ei_ayE)","nl_ayF","!nl_ayF","(!nl_ayF)","nr_ayG","((!nl_ayF), nr_ayG)","!((!nl_ayF), nr_ayG)","(!((!nl_ayF), nr_ayG))","xl_ayH","yl_ayI","!yl_ayI","(!yl_ayI)","(xl_ayH, (!yl_ayI))","xr_ayJ","!xr_ayJ","(!xr_ayJ)","yr_ayK","!yr_ayK","(!yr_ayK)","((!xr_ayJ), (!yr_ayK))"]
module Elemstif (beam2d) where
import Basics
import Vector
import Matrix
import DB_interface

beam2d :: (Array Int Int, Array Int Float) -> Int -> Mat Float
beam2d (norecord@str_ays) element_ayt
  = makemat (6, 6)
      (\ (norecord@(i_aIO, (!j_aIP))) ->
         if (i_aIO == 1 && j_aIP == 1) || (i_aIO == 4 && j_aIP == 4) then
           b1_ayv else
           if
             (i_aIO == 2 && j_aIP == 1) || (i_aIO == 5 && j_aIP == 4) ||
               (i_aIO == 1 && j_aIP == 2)
               || (i_aIO == 4 && j_aIP == 5)
             then b2_ayw else
             if (i_aIO == 2 && j_aIP == 2) || (i_aIO == 5 && j_aIP == 5) then
               b3_ayx else
               if (i_aIO == 1 && j_aIP == 4) || (i_aIO == 4 && j_aIP == 1) then
                 -b1_ayv else
                 if
                   (i_aIO == 2 && j_aIP == 4) || (i_aIO == 5 && j_aIP == 1) ||
                     (i_aIO == 1 && j_aIP == 5)
                     || (i_aIO == 4 && j_aIP == 2)
                   then -b2_ayw else
                   if (i_aIO == 2 && j_aIP == 5) || (i_aIO == 5 && j_aIP == 2) then
                     -b3_ayx else 0.0)
  where (norecord@a1_ayu) = ea_ayD / l_ayA
        b1_ayv = a1_ayu * c_ayB * c_ayB
        b2_ayw = a1_ayu * c_ayB * s_ayC
        b3_ayx = a1_ayu * s_ayC * s_ayC
        (norecord@dx_ayy) = xr_ayJ - xl_ayH
        (norecord@dy_ayz) = yr_ayK - yl_ayI
        l_ayA = sqrt (dx_ayy * dx_ayy + dy_ayz * dy_ayz)
        c_ayB = dx_ayy / l_ayA
        s_ayC = dy_ayz / l_ayA
        (ea_ayD, ei_ayE) = getmpro str_ays (getemat str_ays element_ayt)
        (norecord@((norecord@nl_ayF), nr_ayG))
          = getenlr str_ays element_ayt
        (xl_ayH, (norecord@yl_ayI)) = getnxy str_ays nl_ayF
        ((norecord@xr_ayJ), (norecord@yr_ayK)) = getnxy str_ays nr_ayG
STARTLOG
["main","ls_azE","viewdir_azF","lazydmd@!viewdir_azF","(!viewdir_azF)"]
module Main (main) where
import Numbers
import Vectors
import Hide
import MyIO
import EdgePlate (Input(..))
import Postscript (Output(..))
import System.IO
main
  = do ls_azE <- hGetContents stdin
       (getFilename $
          process
            (\ (lazydmd@viewdir_azF) ->
               hiddenline viewdir_azF . map read . lines))
         (lines ls_azE)
STARTLOG
["v_ari","safebang@!v_ari","(!v_ari)","w_arj","v_ark","safebang@!v_ark","(!v_ark)","w_arl","v_ask","safebang@!v_ask","(!v_ask)","w_asl","Edg (!v_ask) w_asl","(Edg (!v_ask) w_asl)","v_asm","safebang@!v_asm","(!v_asm)","w_asn","safebang@!w_asn","(!w_asn)","Edg (!v_asm) (!w_asn)","(Edg (!v_asm) (!w_asn))","!(Edg (!v_asm) (!w_asn))","(!(Edg (!v_asm) (!w_asn)))","((!(Edg (!v_asm) (!w_asn))))","v_aso","!v_aso","(!v_aso)","w_asp","Edg (!v_aso) w_asp","(Edg (!v_aso) w_asp)","!(Edg (!v_aso) w_asp)","(!(Edg (!v_aso) w_asp))","((!(Edg (!v_aso) w_asp)))","!((!(Edg (!v_aso) w_asp)))","(!((!(Edg (!v_aso) w_asp))))","_","l1_asq","l2_asr","!l2_asr","(!l2_asr)","ls_ass","(!l2_asr) : ls_ass","((!l2_asr) : ls_ass)","l1_asq : ((!l2_asr) : ls_ass)","(l1_asq : ((!l2_asr) : ls_ass))","!(l1_asq : ((!l2_asr) : ls_ass))","(!(l1_asq : ((!l2_asr) : ls_ass)))","Plt _ (!(l1_asq : ((!l2_asr) : ls_ass)))","(Plt _ (!(l1_asq : ((!l2_asr) : ls_ass))))","!(Plt _ (!(l1_asq : ((!l2_asr) : ls_ass))))","(!(Plt _ (!(l1_asq : ((!l2_asr) : ls_ass)))))","makeObject","n_asu","safebang@!n_asu","(!n_asu)","ps_asv","n_aw4","!n_aw4","(!n_aw4)","xs_aw5","rvxs_aw6","safebang@!rvxs_aw6","(!rvxs_aw6)"]
module EdgePlate
       (Edge, edgeT, edgeH, s, h, t, Plate(Plt), n, Input, Object,
        makeObject)
       where
import Numbers
import Vectors

edgeT, edgeH :: Vector -> Vector -> Edge
edgeH (!v_ari) w_arj = Edg v_ari w_arj
edgeT (!v_ark) w_arl = Edg v_ark (w_arl - v_ark)

s, h, t :: Edge -> Vector
s (Edg (!v_ask) w_asl) = v_ask
h ((norecord@(Edg (!v_asm) (!w_asn)))) = w_asn
t (norecord@((norecord@(Edg (norecord@v_aso) w_asp))))
  = v_aso + w_asp

n :: Plate -> Vector
n (norecord@(Plt _
               (norecord@(l1_asq : ((norecord@l2_asr) : ls_ass)))))
  = norm (h (l1_asq) * h (l2_asr))

makeObject :: Input -> Object
makeObject = zipWith borders_ast [1 ..]
  where borders_ast :: Int -> [Vector] -> Plate
        borders_ast (!n_asu) ps_asv
          = Plt n_asu (zipWith edgeT ps_asv (ror 1 ps_asv))

ror :: Int -> [a_arh] -> [a_arh]
ror (norecord@n_aw4) xs_aw5
  = reverse (take n_aw4 rvxs_aw6) ++ reverse (drop n_aw4 rvxs_aw6)
  where (!rvxs_aw6) = reverse xs_aw5

data Edge = Edg Vector Vector

type Input = [[Vector]]

data Plate = Plt Int [Edge]

type Object = [Plate]
STARTLOG
["l_ath","!l_ath","(!l_ath)","k_ati","lambda_auh","!lambda_auh","(!lambda_auh)","mu_aui","((!lambda_auh), mu_aui)","!((!lambda_auh), mu_aui)","(!((!lambda_auh), mu_aui))","_","ls_aHK","Plt _ ls_aHK","(Plt _ ls_aHK)","!(Plt _ ls_aHK)","(!(Plt _ ls_aHK))","_","!_","(!_)","ks_aHM","safebang@!ks_aHM","(!ks_aHM)","Plt (!_) (!ks_aHM)","(Plt (!_) (!ks_aHM))","!(Plt (!_) (!ks_aHM))","(!(Plt (!_) (!ks_aHM)))","p2_aHL@(!(Plt (!_) (!ks_aHM)))","l_aKl","!l_aKl","(!l_aKl)","l_aKm","!l_aKm","(!l_aKm)","k_aKn","p_aKo","q_aKp","safebang@!q_aKp","(!q_aKp)","(p_aKo, (!q_aKp))"]
module Cross (cross, overlap) where
import Numbers
import Vectors
import EdgePlate
import Solve
import Preds
import Data.List (nub)

cross :: Edge -> Edge -> [(Vector, Vector)]
cross (norecord@l_ath) k_ati
  = [(s (l_ath) + lambda_auh `mulv` h (l_ath),
      s (k_ati) + mu_aui `mulv` h (k_ati))
     |
     (norecord@((norecord@lambda_auh), mu_aui)) <- solve (-h l_ath)
                                                     (h k_ati)
                                                     (s l_ath - s k_ati),
     0 <= lambda_auh && lambda_auh <= 1 && 0 <= mu_aui && mu_aui <= 1]

overlap :: Plate -> Plate -> [Vector]
overlap (norecord@(Plt _ ls_aHK))
  p2_aHL@(norecord@(Plt (norecord@_) (!ks_aHM)))
  = nub
      ([s (l_aKl) | (norecord@l_aKl) <- ls_aHK, s (l_aKl) `into` p2_aHL]
         ++
         [p_aKo | (norecord@l_aKm) <- ls_aHK, k_aKn <- ks_aHM,
          (p_aKo, (!q_aKp)) <- cross l_aKm k_aKn])
STARTLOG
["ls_aA8","safebang@!ls_aA8","(!ls_aA8)","iniplot_aA9","exiplot_aAa","lazydmd@!exiplot_aAa","(!exiplot_aAa)","[]","s_aAb","!s_aAb","(!s_aAb)","l_aAd","_","l_aAd : _","(l_aAd : _)","!(l_aAd : _)","(!(l_aAd : _))","ls_aAc@(!(l_aAd : _))","!ls_aAc@(!(l_aAd : _))","(!ls_aAc@(!(l_aAd : _)))","currentPoint_aAl","safebang@!currentPoint_aAl","(!currentPoint_aAl)","[]","s_aAm","!s_aAm","(!s_aAm)","currentPoint_aAn","l_aAo","!l_aAo","(!l_aAo)","ls_aAp","!ls_aAp","(!ls_aAp)","(!l_aAo) : (!ls_aAp)","((!l_aAo) : (!ls_aAp))","v_aNR","!v_aNR","(!v_aNR)","v_aNS","flush"]
module Postscript (Output, draw) where
import Numbers
import Vectors
import EdgePlate

draw :: [Edge] -> Output
draw (!ls_aA8) = iniplot_aA9 ++ plot ls_aA8 exiplot_aAa
  where iniplot_aA9
          = "\nerasepage gsave 100 100 translate 0 setlinewidth newpath\n"
        (lazydmd@exiplot_aAa) = "\nstroke grestore\n"

plot :: [Edge] -> ShowS

plotFrom :: Vector -> [Edge] -> ShowS

moveTo, lineTo :: Vector -> ShowS

flush :: ShowS
plot [] = \ (norecord@s_aAb) -> s_aAb
plot (norecord@ls_aAc@(norecord@(l_aAd : _)))
  = moveTo (s (l_aAd)) . plotFrom (s (l_aAd)) ls_aAc
plotFrom (!currentPoint_aAl) [] = \ (norecord@s_aAm) -> s_aAm
plotFrom currentPoint_aAn ((norecord@l_aAo) : (norecord@ls_aAp))
  | s (l_aAo) == currentPoint_aAn =
    lineTo (t (l_aAo)) . plotFrom (t (l_aAo)) ls_aAp
  | s (l_aAo) /= currentPoint_aAn = flush . plot (l_aAo : ls_aAp)
moveTo (norecord@v_aNR)
  = shows (x (v_aNR)) . showChar ' ' . shows (y (v_aNR)) .
      showString " moveto "
lineTo v_aNS
  = shows (x (v_aNS)) . showChar ' ' . shows (y (v_aNS)) .
      showString " lineto "
flush = showString "\nstroke newpath\n"

type Output = String
STARTLOG
["plt1_ash","plt2_asi","!plt2_asi","(!plt2_asi)","plt_asj","v_aFL","safebang@!v_aFL","(!v_aFL)","n_aFM","safebang@!n_aFM","(!n_aFM)","ls_aFN","safebang@!ls_aFN","(!ls_aFN)","Plt (!n_aFM) (!ls_aFN)","(Plt (!n_aFM) (!ls_aFN))","!(Plt (!n_aFM) (!ls_aFN))","(!(Plt (!n_aFM) (!ls_aFN)))","l_aFO","n_aFP","safebang@!n_aFP","(!n_aFP)","ls_aFQ","Plt (!n_aFP) ls_aFQ","(Plt (!n_aFP) ls_aFQ)","!(Plt (!n_aFP) ls_aFQ)","(!(Plt (!n_aFP) ls_aFQ))","l_aFR","!l_aFR","(!l_aFR)","l_aFS","!l_aFS","(!l_aFS)","k_aFT","l_aFU","!l_aFU","(!l_aFU)","v_aFV","!v_aFV","(!v_aFV)","l_aFW","l_aFX","f_aFY","safebang@!f_aFY","(!f_aFY)","b_aFZ","l_aG0","v_aG1","safebang@!v_aG1","(!v_aG1)","w_aG2","v_aH1","rot","v_aH2","safebang@!v_aH2","(!v_aH2)","factor_aH3","safebang@!factor_aH3","(!factor_aH3)","base_aH4","safebang@!base_aH4","(!base_aH4)","v_aH5","viewdir_aH7","safebang@!viewdir_aH7","(!viewdir_aH7)","proj","f_aH8","safebang@!f_aH8","(!f_aH8)","b_aH9"]
module Geometric (Geom(..)) where
import Numbers
import Vectors
import EdgePlate
import Rotate

class Geom a_as9 where
        (|||) :: a_as9 -> a_as9 -> Bool
        
        vertical :: a_as9 -> Bool
        
        rot :: Vector -> a_as9 -> a_as9
        
        proj :: a_as9 -> a_as9
        
        scale :: Number -> Vector -> a_as9 -> a_as9

instance Geom Plate where
        plt1_ash ||| (norecord@plt2_asi) = n (plt1_ash) ||| n (plt2_asi)
        vertical plt_asj = z (n (plt_asj)) == 0
        rot (!v_aFL) (norecord@(Plt (!n_aFM) (!ls_aFN)))
          = Plt n_aFM [v_aFL `rot` l_aFO | l_aFO <- ls_aFN]
        proj (norecord@(Plt (!n_aFP) ls_aFQ))
          = Plt n_aFP [proj l_aFR | (norecord@l_aFR) <- ls_aFQ]

instance Geom Edge where
        (norecord@l_aFS) ||| k_aFT = h (l_aFS) ||| h (k_aFT)
        vertical (norecord@l_aFU) = vertical (h (l_aFU))
        rot (norecord@v_aFV) l_aFW
          = edgeT (v_aFV `rot` s (l_aFW)) (v_aFV `rot` t (l_aFW))
        proj l_aFX = edgeT (proj (s (l_aFX))) (proj (t (l_aFX)))
        scale (!f_aFY) b_aFZ l_aG0
          = edgeT (scale f_aFY b_aFZ (s (l_aG0)))
              (scale f_aFY b_aFZ (t (l_aG0)))

instance Geom Vector where
        (!v_aG1) ||| w_aG2 = v_aG1 * w_aG2 == 0
        vertical v_aH1 = v_aH1 ||| vec [0, 0, 1]
        rot = rotate
        proj (!v_aH2) = vec [x (v_aH2), y (v_aH2), 0]
        scale (!factor_aH3) (!base_aH4) v_aH5
          = factor_aH3 `mulv` (v_aH5 - base_aH4)

instance Geom a_aH6 => Geom [a_aH6] where
        rot (!viewdir_aH7) = map (rot viewdir_aH7)
        proj = map proj
        scale (!f_aH8) b_aH9 = map (scale f_aH8 b_aH9)
STARTLOG
["f_aVY","obj_aVZ","safebang@!obj_aVZ","(!obj_aVZ)","top_a12Y","!top_a12Y","(!top_a12Y)","_","Plt (!top_a12Y) _","(Plt (!top_a12Y) _)","!(Plt (!top_a12Y) _)","(!(Plt (!top_a12Y) _))","((!(Plt (!top_a12Y) _)))","ls_a12X@((!(Plt (!top_a12Y) _)))","!ls_a12X@((!(Plt (!top_a12Y) _)))","(!ls_a12X@((!(Plt (!top_a12Y) _))))","bottom_a130","_","Plt bottom_a130 _","(Plt bottom_a130 _)","!(Plt bottom_a130 _)","(!(Plt bottom_a130 _))","ks_a12Z@(!(Plt bottom_a130 _))","len_aW0","!len_aW0","(!len_aW0)","memory_a131","n_a133","safebang@!n_a133","(!n_a133)","_","Plt (!n_a133) _","(Plt (!n_a133) _)","top_a132@(Plt (!n_a133) _)","m_a135","_","Plt m_a135 _","(Plt m_a135 _)","!(Plt m_a135 _)","(!(Plt m_a135 _))","((!(Plt m_a135 _)))","bottom_a134@((!(Plt m_a135 _)))","t0_a1ag","safebang@!t0_a1ag","(!t0_a1ag)","b0_a1ah","(!t0_a1ag) :^ b0_a1ah","((!t0_a1ag) :^ b0_a1ah)","!((!t0_a1ag) :^ b0_a1ah)","(!((!t0_a1ag) :^ b0_a1ah))","t1_a1ai","b1_a1aj","safebang@!b1_a1aj","(!b1_a1aj)","t1_a1ai :^ (!b1_a1aj)","((!((!t0_a1ag) :^ b0_a1ah)), t1_a1ai :^ (!b1_a1aj))","t_a1ak","b_a1dF","!b_a1dF","(!b_a1dF)","t0_a1dG","safebang@!t0_a1dG","(!t0_a1dG)","b0_a1dH","safebang@!b0_a1dH","(!b0_a1dH)","(!t0_a1dG) :^ (!b0_a1dH)","t1_a1dI","safebang@!t1_a1dI","(!t1_a1dI)","b1_a1dJ","(!t1_a1dI) :^ b1_a1dJ","((!t1_a1dI) :^ b1_a1dJ)","!((!t1_a1dI) :^ b1_a1dJ)","(!((!t1_a1dI) :^ b1_a1dJ))","((!t0_a1dG) :^ (!b0_a1dH), (!((!t1_a1dI) :^ b1_a1dJ)))","!((!t0_a1dG) :^ (!b0_a1dH), (!((!t1_a1dI) :^ b1_a1dJ)))","(!((!t0_a1dG) :^ (!b0_a1dH), (!((!t1_a1dI) :^ b1_a1dJ))))","t_a1dK","b_a1dL","t_a1dK :^ b_a1dL","(t_a1dK :^ b_a1dL)","!(t_a1dK :^ b_a1dL)","(!(t_a1dK :^ b_a1dL))","((!(t_a1dK :^ b_a1dL)))","ti_a1dM","t0_a1mK","b0_a1mL","safebang@!b0_a1mL","(!b0_a1mL)","t0_a1mK :^ (!b0_a1mL)","t1_a1mM","safebang@!t1_a1mM","(!t1_a1mM)","b1_a1mN","safebang@!b1_a1mN","(!b1_a1mN)","(!t1_a1mM) :^ (!b1_a1mN)","((!t1_a1mM) :^ (!b1_a1mN))","!((!t1_a1mM) :^ (!b1_a1mN))","(!((!t1_a1mM) :^ (!b1_a1mN)))","(t0_a1mK :^ (!b0_a1mL), (!((!t1_a1mM) :^ (!b1_a1mN))))","t_a1mO","safebang@!t_a1mO","(!t_a1mO)","b_a1mP","(!t_a1mO) :^ b_a1mP","((!t_a1mO) :^ b_a1mP)","!((!t_a1mO) :^ b_a1mP)","(!((!t_a1mO) :^ b_a1mP))","((!((!t_a1mO) :^ b_a1mP)))"]
module Memo (Triangle, mkmemo, lazyAbove) where
import Numbers
import Vectors
import EdgePlate
import Comparing (above)
import Data.Ix
import Data.Array

mkmemo ::
       (Plate -> Plate -> a_aVX) -> Object -> Array (Triangle Int) a_aVX
mkmemo f_aVY (!obj_aVZ)
  = array (2 :^ 1, len_aW0 :^ (len_aW0 - 1))
      [((top_a12Y :^ bottom_a130), f_aVY ls_a12X ks_a12Z) |
       (norecord@ls_a12X@((norecord@(Plt (norecord@top_a12Y)
                                       _)))) <- obj_aVZ,
       ks_a12Z@(norecord@(Plt bottom_a130 _)) <- obj_aVZ,
       top_a12Y > bottom_a130]
  where (norecord@len_aW0) = length obj_aVZ

lazyAbove :: Array (Triangle Int) Bool -> Plate -> Plate -> Bool
lazyAbove memory_a131 top_a132@(Plt (!n_a133) _)
  bottom_a134@((norecord@(Plt m_a135 _)))
  | inRange (bounds memory_a131) (n_a133 :^ m_a135) =
    memory_a131 ! (n_a133 :^ m_a135)
  | n_a133 == m_a135 = False
  | otherwise =
    if memory_a131 ! (m_a135 :^ n_a133) then False else
      top_a132 `above` bottom_a134

data Triangle a_aAA = a_aAA :^ a_aAA
                    deriving (Eq, Ord, Show)

instance (Enum a_a136, Ord a_a136, Ix a_a136) => Ix
         (Triangle a_a136) where
        range ((norecord@((!t0_a1ag) :^ b0_a1ah)), t1_a1ai :^ (!b1_a1aj))
          = [t_a1ak :^ b_a1dF | t_a1ak <- [t0_a1ag .. t1_a1ai],
             (norecord@b_a1dF) <- take (1 + index (t0_a1ag, t1_a1ai) t_a1ak)
                                    [b0_a1ah ..],
             t_a1ak :^ b_a1dF <= t1_a1ai :^ b1_a1aj]
        index
          (norecord@((!t0_a1dG) :^ (!b0_a1dH),
                     (norecord@((!t1_a1dI) :^ b1_a1dJ))))
          ((norecord@(t_a1dK :^ b_a1dL)))
          = ti_a1dM * (ti_a1dM + 1) `div` 2 + index (b0_a1dH, b1_a1dJ) b_a1dL
          where ti_a1dM = index (t0_a1dG, t1_a1dI) t_a1dK
        inRange
          (t0_a1mK :^ (!b0_a1mL), (norecord@((!t1_a1mM) :^ (!b1_a1mN))))
          ((norecord@((!t_a1mO) :^ b_a1mP)))
          = inRange (t0_a1mK, t1_a1mM) t_a1mO &&
              inRange (b0_a1mL, b1_a1mN) b_a1mP
              && index (t0_a1mK, t1_a1mM) t_a1mO
              >= index (b0_a1mL, b1_a1mN) b_a1mP
STARTLOG
["p_atn","!p_atn","(!p_atn)","l_ato","v_atp","!v_atp","(!v_atp)","w_atq","v_aHQ","safebang@!v_aHQ","(!v_aHQ)","_","ls_aHS","Plt _ ls_aHS","(Plt _ ls_aHS)","!(Plt _ ls_aHS)","(!(Plt _ ls_aHS))","p_aHR@(!(Plt _ ls_aHS))","!p_aHR@(!(Plt _ ls_aHS))","(!p_aHR@(!(Plt _ ls_aHS)))","l_aO2","!l_aO2","(!l_aO2)","a_aO3","a_aO4","!a_aO4","(!a_aO4)","zs_aHT","l_aHU","!l_aHU","(!l_aHU)"]
module Preds (into, onto) where
import Numbers
import Vectors
import EdgePlate
import Geometric

onto :: Vector -> Edge -> Bool
onto (norecord@p_atn) l_ato
  | vertical l_ato = proj (p_atn) == proj (s (l_ato))
  | otherwise =
    v_atp ||| w_atq && 0 <= v_atp `inpr` w_atq && v_atp `inpr` w_atq <=
      w_atq
      `inpr` w_atq
  where (norecord@v_atp) = proj (p_atn - s (l_ato))
        w_atq = proj (h (l_ato))

into :: Vector -> Plate -> Bool
into (!v_aHQ) (norecord@p_aHR@(norecord@(Plt _ ls_aHS)))
  | vertical p_aHR =
    or [v_aHQ `onto` l_aO2 | (norecord@l_aO2) <- ls_aHS]
  | otherwise =
    and [a_aO3 >= 0 | a_aO3 <- zs_aHT] ||
      and [a_aO4 <= 0 | (norecord@a_aO4) <- zs_aHT]
  where zs_aHT
          = [z ((v_aHQ - s (l_aHU)) * h (l_aHU)) |
             (norecord@l_aHU) <- ls_aHS]
STARTLOG
STARTLOG
["p_av9","safebang@!p_av9","(!p_av9)","ls_ava","l_aBa","!l_aBa","(!l_aBa)","l_aBb","_","!_","(!_)","ks_aBd","Plt (!_) ks_aBd","(Plt (!_) ks_aBd)","p_aBc@(Plt (!_) ks_aBd)","!p_aBc@(Plt (!_) ks_aBd)","(!p_aBc@(Plt (!_) ks_aBd))","inS_aBe","safebang@!inS_aBe","(!inS_aBe)","inT_aBf","!inT_aBf","(!inT_aBf)","crosses_aBg","k_aDI","!k_aDI","(!k_aDI)","p_aDJ","q_aDK","safebang@!q_aDK","(!q_aDK)","(p_aDJ, (!q_aDK))","!(p_aDJ, (!q_aDK))","(!(p_aDJ, (!q_aDK)))","cr1_aBh","cr2_aBi","v_aBj","!v_aBj","(!v_aBj)","w_aBk","((!v_aBj), w_aBk)","ls_aVj","ks_aVk","!ks_aVk","(!ks_aVk)","p_aVq","q_aVr","!q_aVr","(!q_aVr)","p_aVs","!p_aVs","(!p_aVs)","q_aVt","!q_aVt","(!q_aVt)","p_aVu","olk_aVl","safebang@!olk_aVl","(!olk_aVl)","okl_aVm","ovl_aVn","lazydmd@!ovl_aVn","(!ovl_aVn)","p_aVo","p_aVp"]
module Comparing (above, cmp) where
import Numbers
import Vectors
import EdgePlate
import Preds
import Solve
import Geometric
import Cross
import Data.List (nub)

cmp :: Plate -> [Edge] -> [Edge]
cmp (!p_av9) ls_ava
  = concat [comp l_aBa p_av9 | (norecord@l_aBa) <- ls_ava]

comp :: Edge -> Plate -> [Edge]
comp l_aBb (norecord@p_aBc@(Plt (norecord@_) ks_aBd))
  = if inS_aBe && inT_aBf then [] else
      if crosses_aBg == [] then [l_aBb] else
        if inS_aBe && not inT_aBf then [edgeT w_aBk (t l_aBb)] else
          if not inS_aBe && inT_aBf then [edgeT (s l_aBb) v_aBj] else
            [edgeT (s l_aBb) v_aBj, edgeT w_aBk (t l_aBb)]
  where (!inS_aBe) = s (l_aBb) `into` p_aBc
        (norecord@inT_aBf) = t (l_aBb) `into` p_aBc
        crosses_aBg
          = nub
              [p_aDJ | (norecord@k_aDI) <- ks_aBd,
               (norecord@(p_aDJ, (!q_aDK))) <- cross l_aBb k_aDI]
        cr1_aBh = head crosses_aBg
        cr2_aBi = last crosses_aBg
        ((norecord@v_aBj), w_aBk)
          = if len (s (l_aBb) - cr1_aBh) <= len (s (l_aBb) - cr2_aBi) then
              (cr1_aBh, cr2_aBi) else (cr2_aBi, cr1_aBh)

above :: Plate -> Plate -> Bool
above ls_aVj (norecord@ks_aVk)
  = if vertical ls_aVj then
      if vertical ks_aVk then
        or
          [z (p_aVq) > z (q_aVr) | p_aVq <- olk_aVl,
           (norecord@q_aVr) <- okl_aVm]
        else
        or [z (p_aVs) > alt ks_aVk p_aVs | (norecord@p_aVs) <- olk_aVl]
      else
      if vertical ks_aVk then
        or [alt ls_aVj q_aVt > z (q_aVt) | (norecord@q_aVt) <- okl_aVm]
        else or [alt ls_aVj p_aVu > alt ks_aVk p_aVu | p_aVu <- ovl_aVn]
  where (!olk_aVl) = overlap ls_aVj ks_aVk
        okl_aVm = overlap ks_aVk ls_aVj
        (lazydmd@ovl_aVn)
          = nub
              ([proj p_aVo | p_aVo <- olk_aVl] ++
                 [proj p_aVp | p_aVp <- okl_aVm])
STARTLOG
["m_ar0","safebang@!m_ar0","(!m_ar0)","m_ar1","m_ar2","safebang@!m_ar2","(!m_ar2)","v_ar3"]
module Matrices (Matrix, mat, rows, mulm) where
import Numbers
import Vectors

mat :: [Vector] -> Matrix
mat (!m_ar0) = m_ar0

rows :: Matrix -> [Vector]
rows m_ar1 = m_ar1

mulm :: Matrix -> Vector -> Vector
mulm (!m_ar2) v_ar3 = vec (map (inpr v_ar3) (rows m_ar2))

type Matrix = [Vector]
STARTLOG
["eps","p_a14R","safebang@!p_a14R","(!p_a14R)","x_a14S","Tolerant x_a14S","(Tolerant x_a14S)","!(Tolerant x_a14S)","(!(Tolerant x_a14S))","((!(Tolerant x_a14S)))","p_a14T","s_a14U","n_a14V","t_a14W","safebang@!t_a14W","(!t_a14W)","(n_a14V, (!t_a14W))","a_a14X","safebang@!a_a14X","(!a_a14X)","Tolerant (!a_a14X)","(Tolerant (!a_a14X))","!(Tolerant (!a_a14X))","(!(Tolerant (!a_a14X)))","a_a14Y","Tolerant a_a14Y","(Tolerant a_a14Y)","!(Tolerant a_a14Y)","(!(Tolerant a_a14Y))","b_a14Z","safebang@!b_a14Z","(!b_a14Z)","Tolerant (!b_a14Z)","(Tolerant (!b_a14Z))","a_a150","Tolerant a_a150","(Tolerant a_a150)","b_a151","safebang@!b_a151","(!b_a151)","Tolerant (!b_a151)","(Tolerant (!b_a151))","a_a152","Tolerant a_a152","(Tolerant a_a152)","b_a153","safebang@!b_a153","(!b_a153)","Tolerant (!b_a153)","(Tolerant (!b_a153))","a_a154","safebang@!a_a154","(!a_a154)","Tolerant (!a_a154)","(Tolerant (!a_a154))","!(Tolerant (!a_a154))","(!(Tolerant (!a_a154)))","b_a155","safebang@!b_a155","(!b_a155)","Tolerant (!b_a155)","(Tolerant (!b_a155))","a_a156","safebang@!a_a156","(!a_a156)","Tolerant (!a_a156)","(Tolerant (!a_a156))","!(Tolerant (!a_a156))","(!(Tolerant (!a_a156)))","n_a157","a_a158","safebang@!a_a158","(!a_a158)","Tolerant (!a_a158)","(Tolerant (!a_a158))","!(Tolerant (!a_a158))","(!(Tolerant (!a_a158)))","b_a159","safebang@!b_a159","(!b_a159)","Tolerant (!b_a159)","(Tolerant (!b_a159))","a_a15a","safebang@!a_a15a","(!a_a15a)","Tolerant (!a_a15a)","(Tolerant (!a_a15a))","b_a15b","safebang@!b_a15b","(!b_a15b)","Tolerant (!b_a15b)","(Tolerant (!b_a15b))","!(Tolerant (!b_a15b))","(!(Tolerant (!b_a15b)))","a_a15c","safebang@!a_a15c","(!a_a15c)","Tolerant (!a_a15c)","(Tolerant (!a_a15c))","b_a15d","safebang@!b_a15d","(!b_a15d)","Tolerant (!b_a15d)","(Tolerant (!b_a15d))","a_a15e","safebang@!a_a15e","(!a_a15e)","Tolerant (!a_a15e)","(Tolerant (!a_a15e))","b_a15f","Tolerant b_a15f","(Tolerant b_a15f)"]
module Numbers (Number) where
eps = 1.0e-4 :: Float

data Number = Tolerant Float

instance Show Number where
        showsPrec (!p_a14R) ((norecord@(Tolerant x_a14S)))
          = showsPrec p_a14R x_a14S

instance Read Number where
        readsPrec p_a14T s_a14U
          = [(Tolerant n_a14V, t_a14W) |
             (n_a14V, (!t_a14W)) <- readsPrec p_a14T s_a14U]

instance Floating Number where
        sqrt (norecord@(Tolerant (!a_a14X))) = Tolerant (sqrt a_a14X)

instance Fractional Number where
        (norecord@(Tolerant a_a14Y)) / (Tolerant (!b_a14Z))
          = Tolerant (a_a14Y / b_a14Z)

instance Num Number where
        (Tolerant a_a150) + (Tolerant (!b_a151))
          = Tolerant (a_a150 + b_a151)
        (Tolerant a_a152) - (Tolerant (!b_a153))
          = Tolerant (a_a152 - b_a153)
        (norecord@(Tolerant (!a_a154))) * (Tolerant (!b_a155))
          = Tolerant (a_a154 * b_a155)
        negate (norecord@(Tolerant (!a_a156))) = Tolerant (-a_a156)
        fromInteger n_a157 = Tolerant (fromInteger n_a157)

instance Ord Number where
        (norecord@(Tolerant (!a_a158))) <= (Tolerant (!b_a159))
          = a_a158 - eps < b_a159
        (Tolerant (!a_a15a)) < (norecord@(Tolerant (!b_a15b)))
          = a_a15a < b_a15b - eps

instance Eq Number where
        (Tolerant (!a_a15c)) == (Tolerant (!b_a15d))
          = abs (a_a15c - b_a15d) < eps
        (Tolerant (!a_a15e)) /= (Tolerant b_a15f)
          = abs (a_a15e - b_a15f) > eps
STARTLOG
["vec","v_aXZ","Vec v_aXZ","(Vec v_aXZ)","!(Vec v_aXZ)","(!(Vec v_aXZ))","((!(Vec v_aXZ)))","v_a11A","Vec v_a11A","(Vec v_a11A)","!(Vec v_a11A)","(!(Vec v_a11A))","((!(Vec v_a11A)))","!((!(Vec v_a11A)))","(!((!(Vec v_a11A))))","v_a11B","Vec v_a11B","(Vec v_a11B)","!(Vec v_a11B)","(!(Vec v_a11B))","((!(Vec v_a11B)))","v1_a11C","safebang@!v1_a11C","(!v1_a11C)","Vec (!v1_a11C)","(Vec (!v1_a11C))","v2_a11D","Vec v2_a11D","(Vec v2_a11D)","c_a17A","safebang@!c_a17A","(!c_a17A)","v_a17B","Vec v_a17B","(Vec v_a17B)","!(Vec v_a17B)","(!(Vec v_a17B))","((!(Vec v_a17B)))","v_a17C","!v_a17C","(!v_a17C)","v_a17D","p_a1gG","s_a1gI","\"vec\"","!\"vec\"","(!\"vec\")","t_a1gJ","((!\"vec\"), t_a1gJ)","!((!\"vec\"), t_a1gJ)","(!((!\"vec\"), t_a1gJ))","ns_a1gK","safebang@!ns_a1gK","(!ns_a1gK)","u_a1gL","safebang@!u_a1gL","(!u_a1gL)","((!ns_a1gK), (!u_a1gL))","p_a1gM","v_a1gN","Vec v_a1gN","(Vec v_a1gN)","!(Vec v_a1gN)","(!(Vec v_a1gN))","((!(Vec v_a1gN)))","v_a1gO","safebang@!v_a1gO","(!v_a1gO)","Vec (!v_a1gO)","(Vec (!v_a1gO))","w_a1gP","safebang@!w_a1gP","(!w_a1gP)","Vec (!w_a1gP)","(Vec (!w_a1gP))","v_a1gQ","safebang@!v_a1gQ","(!v_a1gQ)","Vec (!v_a1gQ)","(Vec (!v_a1gQ))","w_a1gR","Vec w_a1gR","(Vec w_a1gR)","v_a1gS","safebang@!v_a1gS","(!v_a1gS)","w_a1gT","safebang@!w_a1gT","(!w_a1gT)","v_a1gU","safebang@!v_a1gU","(!v_a1gU)","Vec (!v_a1gU)","(Vec (!v_a1gU))","!(Vec (!v_a1gU))","(!(Vec (!v_a1gU)))","v_a1gV","v_a1gW","!v_a1gW","(!v_a1gW)","0","!0","(!0)"]
module Vectors (Vector, vec, x, y, z, inpr, mulv, len, norm) where
import Numbers

vec :: [Number] -> Vector
vec = Vec

x, y, z :: Vector -> Number
x ((norecord@(Vec v_aXZ))) = v_aXZ !! 0
y (norecord@((norecord@(Vec v_a11A)))) = v_a11A !! 1
z ((norecord@(Vec v_a11B))) = v_a11B !! 2

inpr :: Vector -> Vector -> Number
inpr (Vec (!v1_a11C)) (Vec v2_a11D)
  = sum (zipWith (*) v1_a11C v2_a11D)

mulv :: Number -> Vector -> Vector
mulv (!c_a17A) ((norecord@(Vec v_a17B)))
  = Vec (map (c_a17A *) v_a17B)

len :: Vector -> Number
len (norecord@v_a17C) = sqrt (v_a17C `inpr` v_a17C)

norm :: Vector -> Vector
norm v_a17D = (1 / len v_a17D) `mulv` v_a17D

data Vector = Vec [Number]
            deriving Eq

instance Read Vector where
        readsPrec p_a1gG = readParen (p_a1gG > 9) rd_a1gH
          where rd_a1gH s_a1gI
                  = [(Vec ns_a1gK, u_a1gL) |
                     (norecord@((norecord@"vec"), t_a1gJ)) <- lex s_a1gI,
                     ((!ns_a1gK), (!u_a1gL)) <- readList t_a1gJ, length ns_a1gK >= 2]

instance Show Vector where
        showsPrec p_a1gM ((norecord@(Vec v_a1gN)))
          = showParen (p_a1gM > 9) (showString "vec " . showList v_a1gN)

instance Num Vector where
        (Vec (!v_a1gO)) + (Vec (!w_a1gP)) = Vec (zipWith (+) v_a1gO w_a1gP)
        (Vec (!v_a1gQ)) - (Vec w_a1gR) = Vec (zipWith (-) v_a1gQ w_a1gR)
        (!v_a1gS) * (!w_a1gT)
          = Vec
              [y (v_a1gS) * z (w_a1gT) - y (w_a1gT) * z (v_a1gS),
               z (v_a1gS) * x (w_a1gT) - z (w_a1gT) * x (v_a1gS),
               x (v_a1gS) * y (w_a1gT) - x (w_a1gT) * y (v_a1gS)]
        negate (norecord@(Vec (!v_a1gU))) = Vec (map negate v_a1gU)
        abs v_a1gV = Vec [len v_a1gV]
        signum (norecord@v_a1gW) = norm v_a1gW
        fromInteger (norecord@0) = Vec [0, 0, 0]
STARTLOG
["v_aDW","safebang@!v_aDW","(!v_aDW)","corners_aDX","rotated_aDY","safebang@!rotated_aDY","(!rotated_aDY)","base_aDZ","factor_aE0","!factor_aE0","(!factor_aE0)","(base_aDZ, (!factor_aE0))","memory_aK0","obj_aK1","_","!_","(!_)","ls_aK3","!ls_aK3","(!ls_aK3)","Plt (!_) (!ls_aK3)","(Plt (!_) (!ls_aK3))","!(Plt (!_) (!ls_aK3))","(!(Plt (!_) (!ls_aK3)))","((!(Plt (!_) (!ls_aK3))))","bottom_aK2@((!(Plt (!_) (!ls_aK3))))","!bottom_aK2@((!(Plt (!_) (!ls_aK3))))","(!bottom_aK2@((!(Plt (!_) (!ls_aK3)))))","tops_aK4","top_aK5","!top_aK5","(!top_aK5)","obj_aK6","!obj_aK6","(!obj_aK6)","plt_aK7","vs_aK8","factor_aK9","!factor_aK9","(!factor_aK9)","xs_aKa","ys_aKb"]
module Hide (hiddenline) where
import Numbers
import Vectors
import EdgePlate
import Geometric
import Comparing
import Memo
import Postscript
import Data.Array

hiddenline :: Vector -> Input -> Output
hiddenline (!v_aDW) corners_aDX
  = (draw . scale factor_aE0 base_aDZ . hideObj . makeObject)
      rotated_aDY
  where (!rotated_aDY) = v_aDW `rot` corners_aDX
        (base_aDZ, (norecord@factor_aE0))
          = getExtremes (concat rotated_aDY)

hide :: Array (Triangle Int) Bool -> Object -> Plate -> [Edge]
hide memory_aK0 obj_aK1
  (norecord@bottom_aK2@((norecord@(Plt (norecord@_)
                                     (norecord@ls_aK3)))))
  = foldr cmp ls_aK3 tops_aK4
  where tops_aK4
          = [top_aK5 | (norecord@top_aK5) <- obj_aK1,
             lazyAbove memory_aK0 top_aK5 bottom_aK2]

hideObj :: Object -> [Edge]
hideObj (norecord@obj_aK6)
  = concat
      [hide (mkmemo above obj_aK6) obj_aK6 plt_aK7 | plt_aK7 <- obj_aK6]

getExtremes :: [Vector] -> (Vector, Number)
getExtremes vs_aK8
  = (vec [minimum xs_aKa, minimum ys_aKb, 0], factor_aK9)
  where (norecord@factor_aK9)
          = ((400 / ((maximum xs_aKa - minimum xs_aKa) `max` 1)) `min`
               (640 / ((maximum ys_aKb - minimum ys_aKb) `max` 1)))
        xs_aKa = map x vs_aK8
        ys_aKb = map y vs_aK8
STARTLOG
["v1_arD","safebang@!v1_arD","(!v1_arD)","v2_arE","w_arF","safebang@!w_arF","(!w_arF)","determinant_arG","_","!_","(!_)","l1_aPb","l2_aPc","_","l2_aPc : _","(l2_aPc : _)","!(l2_aPc : _)","(!(l2_aPc : _))","l1_aPb : (!(l2_aPc : _))","(l1_aPb : (!(l2_aPc : _)))","!(l1_aPb : (!(l2_aPc : _)))","(!(l1_aPb : (!(l2_aPc : _))))","((!(l1_aPb : (!(l2_aPc : _)))))","!((!(l1_aPb : (!(l2_aPc : _)))))","(!((!(l1_aPb : (!(l2_aPc : _))))))","Plt (!_) (!((!(l1_aPb : (!(l2_aPc : _))))))","(Plt (!_) (!((!(l1_aPb : (!(l2_aPc : _)))))))","!(Plt (!_) (!((!(l1_aPb : (!(l2_aPc : _)))))))","(!(Plt (!_) (!((!(l1_aPb : (!(l2_aPc : _))))))))","p_aPk","sl1_aPl","!sl1_aPl","(!sl1_aPl)","hl1_aPm","safebang@!hl1_aPm","(!hl1_aPm)","hl2_aPn","lambda_aPo","mu_aPp","!mu_aPp","(!mu_aPp)","(lambda_aPo, (!mu_aPp))","[(lambda_aPo, (!mu_aPp))]"]
module Solve (solve, alt) where
import Numbers
import Vectors
import EdgePlate

solve :: Vector -> Vector -> Vector -> [(Number, Number)]
solve (!v1_arD) v2_arE (!w_arF)
  = let determinant_arG = z (v1_arD * v2_arE) in
      if determinant_arG == 0 then [] else
        [(z (w_arF * v2_arE) / determinant_arG,
          z (v1_arD * w_arF) / determinant_arG)]

alt :: Plate -> Vector -> Number
alt
  (norecord@(Plt (norecord@_)
               (norecord@((norecord@(l1_aPb : (norecord@(l2_aPc : _))))))))
  p_aPk
  = z (sl1_aPl + lambda_aPo `mulv` hl1_aPm + mu_aPp `mulv` hl2_aPn)
  where (norecord@sl1_aPl) = s (l1_aPb)
        (!hl1_aPm) = h (l1_aPb)
        hl2_aPn = h (l2_aPc)
        [(lambda_aPo, (norecord@mu_aPp))]
          = solve hl1_aPm hl2_aPn (p_aPk - sl1_aPl)
STARTLOG
STARTLOG
STARTLOG
["x86info","nonJumpyOpcodes"]
module Arch_x86
       (Opcode(..), OperandInfo(..), OperandEffect(..), x86info,
        nonJumpyOpcodes)
       where

x86info :: [(Opcode, OperandInfo)]
x86info
  = [(O_movl, OI [OE_RW 4 4]), (O_movw, OI [OE_RW 2 2]),
     (O_movb, OI [OE_RW 1 1]), (O_movzbw, OI [OE_RW 1 2]),
     (O_movzbl, OI [OE_RW 1 4]), (O_movzwl, OI [OE_RW 2 4]),
     (O_movsbw, OI [OE_RW 1 2]), (O_movsbl, OI [OE_RW 1 4]),
     (O_movswl, OI [OE_RW 2 4]), (O_pushl, OI_Special),
     (O_popl, OI_Special), (O_pushfl, OI_Error), (O_popfl, OI_Error),
     (O_sall, OI [OE_RM 1 4]), (O_salw, OI [OE_RM 1 2]),
     (O_salb, OI [OE_RM 1 1]), (O_sarl, OI [OE_RM 1 4]),
     (O_sarw, OI [OE_RM 1 2]), (O_sarb, OI [OE_RM 1 1]),
     (O_shrl, OI [OE_RM 1 4]), (O_shrw, OI [OE_RM 1 2]),
     (O_shrb, OI [OE_RM 1 1]), (O_roll, OI [OE_RM 1 4]),
     (O_rolw, OI [OE_RM 1 2]), (O_rolb, OI [OE_RM 1 1]),
     (O_rorl, OI [OE_RM 1 4]), (O_rorw, OI [OE_RM 1 2]),
     (O_rorb, OI [OE_RM 1 1]), (O_shldl, OI [OE_RRM 4 4 4, OE_RM 4 4]),
     (O_shrdl, OI [OE_RRM 4 4 4, OE_RM 4 4]), (O_addl, OI [OE_RM 4 4]),
     (O_addw, OI [OE_RM 2 2]), (O_addb, OI [OE_RM 1 1]),
     (O_adcl, OI [OE_RM 4 4]), (O_subl, OI [OE_RM 4 4]),
     (O_subw, OI [OE_RM 2 2]), (O_subb, OI [OE_RM 1 1]),
     (O_sbbl, OI [OE_RM 4 4]),
     (O_imull, OI [OE_M 4, OE_RM 4 4, OE_RRM 4 4 4]),
     (O_imulb, OI [OE_M 1]), (O_imulw, OI [OE_M 2, OE_RM 2 2]),
     (O_mull, OI [OE_M 4]), (O_idivl, OI [OE_M 4]),
     (O_divl, OI [OE_M 4]), (O_divw, OI [OE_M 2]),
     (O_divb, OI [OE_M 1]), (O_xorl, OI [OE_RM 4 4]),
     (O_xorw, OI [OE_RM 2 2]), (O_xorb, OI [OE_RM 1 1]),
     (O_andl, OI [OE_RM 4 4]), (O_andw, OI [OE_RM 2 2]),
     (O_andb, OI [OE_RM 1 1]), (O_orl, OI [OE_RM 4 4]),
     (O_orw, OI [OE_RM 2 2]), (O_orb, OI [OE_RM 1 1]),
     (O_incl, OI [OE_M 4]), (O_incw, OI [OE_M 2]),
     (O_incb, OI [OE_M 1]), (O_decl, OI [OE_M 4]),
     (O_decw, OI [OE_M 2]), (O_decb, OI [OE_M 1]),
     (O_negl, OI [OE_M 4]), (O_negw, OI [OE_M 2]),
     (O_negb, OI [OE_M 1]), (O_notl, OI [OE_M 4]),
     (O_notw, OI [OE_M 2]), (O_notb, OI [OE_M 1]),
     (O_testl, OI [OE_RR 4 4]), (O_testw, OI [OE_RR 2 2]),
     (O_testb, OI [OE_RR 1 1]), (O_leal, OI [OE_nW 4]),
     (O_cmpl, OI [OE_RR 4 4]), (O_cmpw, OI [OE_RR 2 2]),
     (O_cmpb, OI [OE_RR 1 1]), (O_cmpsb, OI_Special),
     (O_scasb, OI_Special), (O_movsl, OI_Special),
     (O_movsw, OI_Special), (O_movsb, OI_Special),
     (O_stosl, OI_Special), (O_stosw, OI_Special),
     (O_stosb, OI_Special), (O_leave, OI_Error), (O_ret, OI_Special),
     (O_call, OI_Special), (O_jmp, OI_Jumpy), (O_je, OI_Jumpy),
     (O_jne, OI_Jumpy), (O_jl, OI_Jumpy), (O_jle, OI_Jumpy),
     (O_jg, OI_Jumpy), (O_jge, OI_Jumpy), (O_js, OI_Jumpy),
     (O_jns, OI_Jumpy), (O_jz, OI_Jumpy), (O_jnz, OI_Jumpy),
     (O_jc, OI_Jumpy), (O_jnc, OI_Jumpy), (O_jo, OI_Jumpy),
     (O_jno, OI_Jumpy), (O_ja, OI_Jumpy), (O_jae, OI_Jumpy),
     (O_jb, OI_Jumpy), (O_jbe, OI_Jumpy), (O_jp, OI_Jumpy),
     (O_seta, OI [OE_W 1]), (O_setae, OI [OE_W 1]),
     (O_setb, OI [OE_W 1]), (O_setbe, OI [OE_W 1]),
     (O_sete, OI [OE_W 1]), (O_setne, OI [OE_W 1]),
     (O_setl, OI [OE_W 1]), (O_setle, OI [OE_W 1]),
     (O_setg, OI [OE_W 1]), (O_setge, OI [OE_W 1]),
     (O_setc, OI [OE_W 1]), (O_setcb, OI [OE_W 1]),
     (O_btl, OI [OE_RR 4 4]), (O_btsl, OI [OE_RM 4 4]),
     (O_btcl, OI [OE_RM 4 4]), (O_btrl, OI [OE_RM 4 4]),
     (O_cld, OI_NoEffect), (O_cltd, OI_NoEffect), (O_cwtl, OI_NoEffect),
     (O_cbtw, OI_NoEffect), (O_rep, OI_Error), (O_repz, OI_Error),
     (O_repnz, OI_Error), (O_fld, OI [OE_R 8]), (O_fldt, OI [OE_R 8]),
     (O_fldl, OI [OE_R 8]), (O_flds, OI [OE_R 4]),
     (O_fild, OI [OE_R 4]), (O_fildl, OI [OE_R 4]),
     (O_fildll, OI [OE_R 8]), (O_fstl, OI [OE_W 8]),
     (O_fstpl, OI [OE_W 8]), (O_fstp, OI [OE_W 8]),
     (O_fstps, OI [OE_W 4]), (O_fsts, OI [OE_W 4]),
     (O_fstpt, OI [OE_W 8]), (O_fistl, OI [OE_W 4]),
     (O_fistpl, OI [OE_W 4]), (O_fistpll, OI [OE_W 8]),
     (O_fst, OI [OE_W 8]), (O_fldz, OI_NoEffect), (O_fld1, OI_NoEffect),
     (O_fldl2e, OI_NoEffect), (O_fldln2, OI_NoEffect),
     (O_fchs, OI_NoEffect), (O_fsin, OI_NoEffect),
     (O_fcos, OI_NoEffect), (O_fptan, OI_NoEffect),
     (O_fsqrt, OI_NoEffect), (O_fpatan, OI_NoEffect),
     (O_fabs, OI_NoEffect), (O_f2xm1, OI_NoEffect),
     (O_fscale, OI_NoEffect), (O_fyl2x, OI_NoEffect),
     (O_faddp, OI [OE_R 8, OE_RM 8 8]), (O_fadds, OI [OE_R 4]),
     (O_faddl, OI [OE_R 8]), (O_fiaddl, OI [OE_R 4]),
     (O_fadd, OI [OE_R 8, OE_RM 8 8]), (O_fsubp, OI [OE_RM 8 8]),
     (O_fsubrp, OI [OE_RM 8 8]), (O_fsubrl, OI [OE_R 8]),
     (O_fsubrs, OI [OE_R 4]), (O_fsubs, OI [OE_R 4]),
     (O_fsubl, OI [OE_R 8]), (O_fsub, OI [OE_R 8, OE_RM 8 8]),
     (O_fsubr, OI [OE_R 8, OE_RM 8 8]),
     (O_fmul, OI [OE_R 8, OE_RM 8 8]), (O_fmuls, OI [OE_R 4]),
     (O_fmull, OI [OE_R 8]), (O_fmulp, OI [OE_R 8, OE_RM 8 8]),
     (O_fimull, OI [OE_R 8]), (O_fdiv, OI [OE_RM 8 8]),
     (O_fdivp, OI [OE_RM 8 8]), (O_fdivr, OI [OE_RM 8 8]),
     (O_fdivrl, OI [OE_R 8]), (O_fdivrs, OI [OE_R 4]),
     (O_fdivrp, OI [OE_RM 8 8]), (O_fidivrl, OI [OE_R 4]),
     (O_fidivl, OI [OE_R 4]), (O_fdivl, OI [OE_R 8]),
     (O_fdivs, OI [OE_R 4]), (O_fprem, OI_NoEffect),
     (O_fucom, OI_NoEffect), (O_fucomp, OI_NoEffect),
     (O_fucompp, OI_NoEffect), (O_fcomp, OI_NoEffect),
     (O_fcompp, OI_NoEffect), (O_fcoms, OI [OE_R 4]),
     (O_fcoml, OI [OE_R 8]), (O_fcom, OI [OE_R 8]),
     (O_fcomps, OI [OE_R 4]), (O_fcompl, OI [OE_R 8]),
     (O_ficompl, OI [OE_R 4]), (O_fnstsw, OI [OE_W 2]),
     (O_fnstcw, OI [OE_W 2]), (O_fldcw, OI [OE_R 2]),
     (O_fxch, OI_NoEffect), (O_frndint, OI_NoEffect),
     (O_sahf, OI_NoEffect), (O_nop, OI_NoEffect)]

nonJumpyOpcodes :: [Opcode]
nonJumpyOpcodes
  = [O_pushl, O_popl, O_movl, O_movw, O_movb, O_andl, O_andw, O_andb,
     O_orl, O_orw, O_orb, O_xorl, O_xorw, O_xorb, O_addl, O_addw,
     O_addb, O_subl, O_subw, O_subb, O_incl, O_incw, O_incb, O_decl,
     O_decw, O_decb, O_cmpl, O_cmpw, O_cmpb, O_sall, O_salw, O_salb,
     O_shrl, O_shrw, O_shrb, O_sarl, O_leal, O_movzbw, O_movzbl,
     O_movzwl, O_movsbw, O_movsbl, O_movswl, O_seta, O_setae, O_setb,
     O_setbe, O_sete, O_setne, O_setl, O_setle, O_setg, O_setge, O_setc,
     O_setcb, O_testl, O_testw, O_testb, O_fld1, O_fcoml, O_fnstsw,
     O_fstpl, O_fstp, O_fsubrl, O_fldl, O_faddl, O_fsubl]

data Opcode = O_movl
            | O_movw
            | O_movb
            | O_movzbw
            | O_movzbl
            | O_movzwl
            | O_movsbw
            | O_movsbl
            | O_movswl
            | O_pushl
            | O_popl
            | O_pushfl
            | O_popfl
            | O_notl
            | O_notw
            | O_notb
            | O_sall
            | O_salw
            | O_salb
            | O_sarl
            | O_sarw
            | O_sarb
            | O_shrl
            | O_shrw
            | O_shrb
            | O_roll
            | O_rolw
            | O_rolb
            | O_rorl
            | O_rorw
            | O_rorb
            | O_shldl
            | O_shrdl
            | O_addl
            | O_addw
            | O_addb
            | O_adcl
            | O_subl
            | O_subw
            | O_subb
            | O_sbbl
            | O_imull
            | O_imulw
            | O_imulb
            | O_mull
            | O_divl
            | O_divw
            | O_divb
            | O_idivl
            | O_xorl
            | O_xorw
            | O_xorb
            | O_andl
            | O_andw
            | O_andb
            | O_orl
            | O_orw
            | O_orb
            | O_incl
            | O_incw
            | O_incb
            | O_decl
            | O_decw
            | O_decb
            | O_negl
            | O_negw
            | O_negb
            | O_testl
            | O_testw
            | O_testb
            | O_leal
            | O_cmpl
            | O_cmpw
            | O_cmpb
            | O_cmpsb
            | O_scasb
            | O_movsl
            | O_movsw
            | O_movsb
            | O_stosl
            | O_stosw
            | O_stosb
            | O_leave
            | O_ret
            | O_call
            | O_jmp
            | O_je
            | O_jne
            | O_jl
            | O_jle
            | O_jg
            | O_jge
            | O_js
            | O_jns
            | O_jz
            | O_jnz
            | O_jc
            | O_jnc
            | O_jo
            | O_jno
            | O_ja
            | O_jae
            | O_jb
            | O_jbe
            | O_jp
            | O_seta
            | O_setae
            | O_setb
            | O_setbe
            | O_sete
            | O_setne
            | O_setl
            | O_setle
            | O_setg
            | O_setge
            | O_setc
            | O_setcb
            | O_btl
            | O_btsl
            | O_btrl
            | O_btcl
            | O_cld
            | O_cltd
            | O_cwtl
            | O_cbtw
            | O_rep
            | O_repz
            | O_repnz
            | O_fild
            | O_fildl
            | O_fildll
            | O_fsubp
            | O_fsubr
            | O_fsubrp
            | O_fsubrl
            | O_fsubrs
            | O_fsubs
            | O_fsubl
            | O_fsub
            | O_faddp
            | O_fadds
            | O_faddl
            | O_fadd
            | O_fiaddl
            | O_fmul
            | O_fmuls
            | O_fmull
            | O_fmulp
            | O_fimull
            | O_fdiv
            | O_fdivp
            | O_fdivr
            | O_fdivrs
            | O_fdivrl
            | O_fdivrp
            | O_fidivl
            | O_fidivrl
            | O_fdivl
            | O_fdivs
            | O_fprem
            | O_fstp
            | O_fsts
            | O_fstps
            | O_fstl
            | O_fstpl
            | O_fstpt
            | O_fst
            | O_fistl
            | O_fistpl
            | O_fistpll
            | O_fld
            | O_flds
            | O_fldl
            | O_fldt
            | O_fldz
            | O_fld1
            | O_fldl2e
            | O_fldln2
            | O_fchs
            | O_fsin
            | O_fcos
            | O_fptan
            | O_fsqrt
            | O_fpatan
            | O_fabs
            | O_f2xm1
            | O_fscale
            | O_fyl2x
            | O_fucom
            | O_fucomp
            | O_fucompp
            | O_fcomp
            | O_fcompp
            | O_fcoml
            | O_fcompl
            | O_ficompl
            | O_fcoms
            | O_fcom
            | O_fcomps
            | O_fnstsw
            | O_fnstcw
            | O_fldcw
            | O_frndint
            | O_fxch
            | O_sahf
            | O_nop
            deriving (Show, Eq)

data OperandEffect = OE_RR Int Int
                   | OE_RM Int Int
                   | OE_RW Int Int
                   | OE_nW Int
                   | OE_RRM Int Int Int
                   | OE_R Int
                   | OE_M Int
                   | OE_W Int
                   deriving (Show, Eq)

data OperandInfo = OI_Special
                 | OI_Jumpy
                 | OI_NoEffect
                 | OI_Error
                 | OI [OperandEffect]
                 deriving (Show, Eq)
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
["inn_anr","v_ans","inn_ant","w_anu","inn_anv","n_anw","p_aKw","[]","![]","(![])","p_aKx","!p_aKx","(!p_aKx)","c_aKy","inn_aKz","!inn_aKz","(!inn_aKz)","c_aKy : (!inn_aKz)","(c_aKy : (!inn_aKz))","p1_aKA","safebang@!p1_aKA","(!p1_aKA)","p2_aKB","safebang@!p2_aKB","(!p2_aKB)","inn_aKC","p1_aKD","p2_aKE","inn_aKF","v1_aKG","inn1_aKH","(v1_aKG, inn1_aKH)","v2_aKI","inn2_aKJ","safebang@!inn2_aKJ","(!inn2_aKJ)","(v2_aKI, (!inn2_aKJ))","!(v2_aKI, (!inn2_aKJ))","(!(v2_aKI, (!inn2_aKJ)))","p_aKK","f_aKL","safebang@!f_aKL","(!f_aKL)","inn_aKM","v_aKN","inn1_aKO","(v_aKN, inn1_aKO)","!(v_aKN, inn1_aKO)","(!(v_aKN, inn1_aKO))","p_aKP","safebang@!p_aKP","(!p_aKP)","inn_aKQ","v_aKR","inn'_aKS","(v_aKR, inn'_aKS)","p_aKT","sptok","p_aKU","safebang@!p_aKU","(!p_aKU)","q_aKV","p_aKW","p_aKX","safebang@!p_aKX","(!p_aKX)","s_aKY","x_aL0","xs_aL1","!xs_aL1","(!xs_aL1)","(x_aL0, (!xs_aL1))","!(x_aL0, (!xs_aL1))","(!(x_aL0, (!xs_aL1)))","x_aL8","xs_aL9","(x_aL8, xs_aL9)"]
module Parse
       (Parser, faiL, okay, tok, sat, orelse, seQ, doo, sptok, just,
        listOf, many, sp, many1)
       where

infixr 4 `orelse`

infixl 5 `doo`

infixr 6 `seQ`

faiL :: Parser a_anq
faiL inn_anr = []

okay :: a_anp -> Parser a_anp
okay v_ans inn_ant = [(v_ans, inn_ant)]

tok :: [Char] -> Parser [Char]
tok w_anu inn_anv
  = [(w_anu, drop n_anw inn_anv) | w_anu == take n_anw inn_anv]
  where n_anw = length w_anu

sat :: (Char -> Bool) -> Parser Char
sat p_aKw (norecord@[]) = []
sat (norecord@p_aKx) (c_aKy : (norecord@inn_aKz))
  = [(c_aKy, inn_aKz) | p_aKx c_aKy]

orelse :: Parser a_ano -> Parser a_ano -> Parser a_ano
orelse (!p1_aKA) (!p2_aKB) inn_aKC
  = p1_aKA inn_aKC ++ p2_aKB inn_aKC

seQ :: Parser a_anm -> Parser b_ann -> Parser (a_anm, b_ann)
seQ p1_aKD p2_aKE inn_aKF
  = [((v1_aKG, v2_aKI), inn2_aKJ) |
     (v1_aKG, inn1_aKH) <- p1_aKD inn_aKF,
     (norecord@(v2_aKI, (!inn2_aKJ))) <- p2_aKE inn1_aKH]

doo :: Parser a_ank -> (a_ank -> b_anl) -> Parser b_anl
doo p_aKK (!f_aKL) inn_aKM
  = [(f_aKL v_aKN, inn1_aKO) |
     (norecord@(v_aKN, inn1_aKO)) <- p_aKK inn_aKM]

just :: Parser a_anj -> Parser a_anj
just (!p_aKP) inn_aKQ
  = [(v_aKR, "") | (v_aKR, inn'_aKS) <- p_aKP inn_aKQ,
     dropWhile (' ' ==) inn'_aKS == ""]

sp :: Parser a_ani -> Parser a_ani
sp p_aKT = p_aKT . dropWhile (' ' ==)

sptok :: [Char] -> Parser [Char]
sptok = sp . tok

many :: Parser a_anh -> Parser [a_anh]
many (!p_aKU) = q_aKV
  where q_aKV
          = ((p_aKU `seQ` q_aKV) `doo` makeList) `orelse` (okay [])

many1 :: Parser a_ang -> Parser [a_ang]
many1 p_aKW = p_aKW `seQ` many p_aKW `doo` makeList

listOf :: Parser a_ane -> Parser b_anf -> Parser [a_ane]
listOf (!p_aKX) s_aKY
  = p_aKX `seQ` many (s_aKY `seQ` p_aKX) `doo` nonempty_aKZ `orelse`
      okay []
  where nonempty_aKZ (norecord@(x_aL0, (norecord@xs_aL1)))
          = x_aL0 : (map snd xs_aL1)

makeList :: (a_and, [a_and]) -> [a_and]
makeList (x_aL8, xs_aL9) = x_aL8 : xs_aL9

type Parser a_an5 = [Char] -> [(a_an5, [Char])]
STARTLOG
["s_apa","i_apb","Var i_apb","(Var i_apb)","s_apc","a_apd","ts_ape","Struct a_apd ts_ape","(Struct a_apd ts_ape)","!(Struct a_apd ts_ape)","(!(Struct a_apd ts_ape))","((!(Struct a_apd ts_ape)))","!((!(Struct a_apd ts_ape)))","(!((!(Struct a_apd ts_ape))))","i_apf","i_apg","!i_apg","(!i_apg)","t_aph","j_api","s1_aCJ","safebang@!s1_aCJ","(!s1_aCJ)","s2_aCK","safebang@!s2_aCK","(!s2_aCK)","x_aCL","Var x_aCL","(Var x_aCL)","y_aCM","Var y_aCM","(Var y_aCM)","x_aCN","Var x_aCN","(Var x_aCN)","!(Var x_aCN)","(!(Var x_aCN))","t2_aCO","!t2_aCO","(!t2_aCO)","t1_aIW","y_aIX","safebang@!y_aIX","(!y_aIX)","Var (!y_aIX)","(Var (!y_aIX))","a_aIY","ts_aIZ","!ts_aIZ","(!ts_aIZ)","Struct a_aIY (!ts_aIZ)","(Struct a_aIY (!ts_aIZ))","!(Struct a_aIY (!ts_aIZ))","(!(Struct a_aIY (!ts_aIZ)))","((!(Struct a_aIY (!ts_aIZ))))","b_aJ0","ss_aJ1","Struct b_aJ0 ss_aJ1","(Struct b_aJ0 ss_aJ1)","u_aJ2","!u_aJ2","(!u_aJ2)","[]","![]","(![])","[]","[]","r_aJ3","safebang@!r_aJ3","(!r_aJ3)","rs_aJ4","(!r_aJ3) : rs_aJ4","((!r_aJ3) : rs_aJ4)","!((!r_aJ3) : rs_aJ4)","(!((!r_aJ3) : rs_aJ4))","t_aJc","safebang@!t_aJc","(!t_aJc)","ts_aJd","(!t_aJc) : ts_aJd","((!t_aJc) : ts_aJd)","[]","![]","(![])","t_aJe","!t_aJe","(!t_aJe)","ts_aJf","!ts_aJf","(!ts_aJf)","(!t_aJe) : (!ts_aJf)","((!t_aJe) : (!ts_aJf))","r_aJg","rs_aJh","r_aJg : rs_aJh","(r_aJg : rs_aJh)","!(r_aJg : rs_aJh)","(!(r_aJg : rs_aJh))","u1_aJi","u2_aJj"]
module Subst (Subst, nullSubst, (->>), (@@), apply, unify) where
import PrologData

infix 4 ->>

infixr 3 @@

apply :: Subst -> Term -> Term
apply s_apa (Var i_apb) = s_apa i_apb
apply s_apc (norecord@((norecord@(Struct a_apd ts_ape))))
  = Struct a_apd (map (apply s_apc) ts_ape)

nullSubst :: Subst
nullSubst i_apf = Var i_apf

(->>) :: Id -> Term -> Subst
((norecord@i_apg) ->> t_aph) j_api
  | j_api == i_apg = t_aph
  | otherwise = Var j_api

(@@) :: Subst -> Subst -> Subst
(!s1_aCJ) @@ (!s2_aCK) = apply s1_aCJ . s2_aCK

unify :: Term -> Term -> [Subst]
unify (Var x_aCL) (Var y_aCM)
  = if x_aCL == y_aCM then [nullSubst] else [x_aCL ->> Var y_aCM]
unify (norecord@(Var x_aCN)) (norecord@t2_aCO)
  = [x_aCN ->> t2_aCO | not (x_aCN `elem` varsIn t2_aCO)]
unify t1_aIW (Var (!y_aIX))
  = [y_aIX ->> t1_aIW | not (y_aIX `elem` varsIn t1_aIW)]
unify ((norecord@(Struct a_aIY (norecord@ts_aIZ))))
  (Struct b_aJ0 ss_aJ1)
  = [u_aJ2 | a_aIY == b_aJ0,
     (norecord@u_aJ2) <- listUnify ts_aIZ ss_aJ1]

listUnify :: [Term] -> [Term] -> [Subst]
listUnify (norecord@[]) [] = [nullSubst]
listUnify [] (norecord@((!r_aJ3) : rs_aJ4)) = []
listUnify ((!t_aJc) : ts_aJd) (norecord@[]) = []
listUnify ((norecord@t_aJe) : (norecord@ts_aJf))
  (norecord@(r_aJg : rs_aJh))
  = [u2_aJj @@ u1_aJi | u1_aJi <- unify t_aJe r_aJg,
     u2_aJj <- listUnify (map (apply u1_aJi) ts_aJf)
                 (map (apply u1_aJi) rs_aJh)]

type Subst = Id -> Term
STARTLOG
STARTLOG
["version"]
module Version where
version = "stack based"
STARTLOG
["p_an6","inn_an7","inn_an8","txt_an9","p_ana","inn_anb","act_anc","def_and","safebang@!def_and","(!def_and)","\"\"","!\"\"","(!\"\")","act_ane","def_anf","!def_anf","(!def_anf)","c_ang","cs_anh","c_ang : cs_anh","(c_ang : cs_anh)","!(c_ang : cs_anh)","(!(c_ang : cs_anh))","((!(c_ang : cs_anh)))","!((!(c_ang : cs_anh)))","(!((!(c_ang : cs_anh))))","prompt_ani","g_anj","inn_ank","line_anl","input'_anm","x_anp","x_aEt","c_aEu","n_aEv","safebang@!n_aEv","(!n_aEv)","\"\"","!\"\"","(!\"\")","n_aEw","c_aEx","!c_aEx","(!c_aEx)","cs_aEy","(!c_aEx) : cs_aEy","((!c_aEx) : cs_aEy)","noBackSpaces","n_aFy","safebang@!n_aFy","(!n_aFy)","\"\"","n_aFz","c_aFA","cs_aFB","c_aFA : cs_aFB","(c_aFA : cs_aFB)","!(c_aFA : cs_aFB)","(!(c_aFA : cs_aFB))"]
module Interact (Interactive, skip, end, readln, writeln, readch)
       where

skip :: Interactive -> Interactive
skip p_an6 inn_an7 = p_an6 inn_an7

end :: Interactive
end inn_an8 = ""

writeln :: String -> Interactive -> Interactive
writeln txt_an9 p_ana inn_anb = txt_an9 ++ p_ana inn_anb

readch :: (Char -> Interactive) -> String -> Interactive
readch act_anc (!def_and) (norecord@"") = def_and
readch act_ane (norecord@def_anf)
  (norecord@((norecord@(c_ang : cs_anh)))) = act_ane c_ang cs_anh

readln :: String -> (String -> Interactive) -> Interactive
readln prompt_ani g_anj inn_ank
  = prompt_ani ++ lineOut 0 line_anl ++ "\n" ++
      g_anj (noBackSpaces line_anl) input'_anm
  where line_anl = before_ano '\n' inn_ank
        input'_anm = after_ann '\n' inn_ank
        after_ann x_anp = tail . dropWhile (x_anp /=)
        before_ano x_aEt = takeWhile (x_aEt /=)

rubout :: Char -> Bool
rubout c_aEu = (c_aEu == '\DEL' || c_aEu == '\b')

lineOut :: Int -> String -> String
lineOut (!n_aEv) (norecord@"") = ""
lineOut n_aEw ((norecord@c_aEx) : cs_aEy)
  | n_aEw > 0 && rubout c_aEx = "\b \b" ++ lineOut (n_aEw - 1) cs_aEy
  | n_aEw == 0 && rubout c_aEx = lineOut 0 cs_aEy
  | otherwise = c_aEx : lineOut (n_aEw + 1) cs_aEy

noBackSpaces :: String -> String
noBackSpaces = reverse . delete_aFx 0 . reverse
  where delete_aFx (!n_aFy) "" = ""
        delete_aFx n_aFz (norecord@(c_aFA : cs_aFB))
          | rubout c_aFA = delete_aFx (n_aFz + 1) cs_aFB
          | n_aFz > 0 = delete_aFx (n_aFz - 1) cs_aFB
          | otherwise = c_aFA : delete_aFx 0 cs_aFB

type Interactive = String -> String
STARTLOG
["db_apE","n_apF","g_apG","tm_apH","tp_apI","tm_apH :== tp_apI","(tm_apH :== tp_apI)","u_apJ","!u_apJ","(!u_apJ)","db_apK","safebang@!db_apK","(!db_apK)","gl_apL","n_apP","safebang@!n_apP","(!n_apP)","s_apQ","[]","ow_apR","!ow_apR","(!ow_apR)","n_apS","!n_apS","(!n_apS)","s_apT","g_apU","gs_apV","g_apU : gs_apV","(g_apU : gs_apV)","ow_apW","n_aDi","s_aDj","gs_aDk","safebang@!gs_aDk","(!gs_aDk)","[]","![]","(![])","ow_aDl","n_aDm","!n_aDm","(!n_aDm)","s_aDn","gs_aDo","tp_aDp","u_aDq","safebang@!u_aDq","(!u_aDq)","(tp_aDp, (!u_aDq))","!(tp_aDp, (!u_aDq))","(!(tp_aDp, (!u_aDq)))","rs_aDr","(!(tp_aDp, (!u_aDq))) : rs_aDr","((!(tp_aDp, (!u_aDq))) : rs_aDr)","ow_aDs","n_aEr","[]","![]","(![])","n_aEs","!n_aEs","(!n_aEs)","s_aEt","gs_aEu","rs_aEv","safebang@!rs_aEv","(!rs_aEv)","(s_aEt, gs_aEu, (!rs_aEv))","ow_aEw","(s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw","((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw)","!((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw)","(!((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw))","((!((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw)))","!((!((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw)))","(!((!((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw))))","theCut","top_aEx","s_aEy","gl_aEz","safebang@!gl_aEz","(!gl_aEz)","_","!_","(!_)","(s_aEy, (!gl_aEz), (!_))","!(s_aEy, (!gl_aEz), (!_))","(!(s_aEy, (!gl_aEz), (!_)))","ss_aEA","(!(s_aEy, (!gl_aEz), (!_))) : ss_aEA","((!(s_aEy, (!gl_aEz), (!_))) : ss_aEA)","top_aEx : ((!(s_aEy, (!gl_aEz), (!_))) : ss_aEA)","(top_aEx : ((!(s_aEy, (!gl_aEz), (!_))) : ss_aEA))","ss_aEB"]
module Engine (prove) where
import PrologData
import Subst

alts :: Database -> Int -> Term -> [Alt]
alts db_apE n_apF g_apG
  = [(tp_apI, u_apJ) |
     (tm_apH :== tp_apI) <- renClauses db_apE n_apF g_apG,
     (norecord@u_apJ) <- unify g_apG tm_apH]

prove :: Database -> [Term] -> [Subst]
prove (!db_apK) gl_apL = solve_apM 1 nullSubst gl_apL []
  where solve_apM :: Int -> Subst -> [Term] -> Stack -> [Subst]
        solve_apM (!n_apP) s_apQ [] (norecord@ow_apR)
          = s_apQ : backtrack_apO n_apP ow_apR
        solve_apM (norecord@n_apS) s_apT (g_apU : gs_apV) ow_apW
          | g_apU == theCut = solve_apM n_apS s_apT gs_apV (cut ow_apW)
          | otherwise =
            choose_apN n_apS s_apT gs_apV
              (alts db_apK n_apS (apply s_apT g_apU))
              ow_apW
        
        choose_apN :: Int -> Subst -> [Term] -> [Alt] -> Stack -> [Subst]
        choose_apN n_aDi s_aDj (!gs_aDk) (norecord@[]) ow_aDl
          = backtrack_apO n_aDi ow_aDl
        choose_apN (norecord@n_aDm) s_aDn gs_aDo
          ((norecord@(tp_aDp, (!u_aDq))) : rs_aDr) ow_aDs
          = solve_apM (n_aDm + 1) (u_aDq @@ s_aDn) (tp_aDp ++ gs_aDo)
              ((s_aDn, gs_aDo, rs_aDr) : ow_aDs)
        
        backtrack_apO :: Int -> Stack -> [Subst]
        backtrack_apO n_aEr (norecord@[]) = []
        backtrack_apO (norecord@n_aEs)
          (norecord@((norecord@((s_aEt, gs_aEu, (!rs_aEv)) : ow_aEw))))
          = choose_apN (n_aEs - 1) s_aEt gs_aEu rs_aEv ow_aEw

theCut :: Term
theCut = Struct "!" []

cut :: Stack -> Stack
cut
  (top_aEx : ((norecord@(s_aEy, (!gl_aEz), (norecord@_))) : ss_aEA))
  = top_aEx : (s_aEy, gl_aEz, []) : ss_aEA
cut ss_aEB = ss_aEB

type Alt = ([Term], Subst)

type Stack = [(Subst, [Term], [Alt])]
STARTLOG
STARTLOG
["phi_anF","i_axd","j_axe","j_axf","!j_axf","(!j_axf)","i_axg","j_axh","!j_axh","(!j_axh)","i_axi","!i_axi","(!i_axi)","n_anG"]
module ElecField (elecField) where
import PicType
import Consts
import Data.Array

elecField :: Phi -> Electric
elecField phi_anF
  = (array ((0, 0), (n_anG, n_anG))
       ([((i_axd, j_axe),
          (phi_anF ! (i_axd - 1, j_axe) - phi_anF ! (i_axd, j_axe)))
         | i_axd <- [1 .. n_anG], j_axe <- [0 .. n_anG]]
          ++
          [((0, j_axf), (phi_anF ! (n_anG, j_axf) - phi_anF ! (0, j_axf))) |
           (norecord@j_axf) <- [0 .. n_anG]]),
     array ((0, 0), (n_anG, n_anG))
       ([((i_axg, j_axh),
          (phi_anF ! (i_axg, j_axh + 1) - phi_anF ! (i_axg, j_axh)))
         | i_axg <- [0 .. n_anG], (norecord@j_axh) <- [0 .. (n_anG - 1)]]
          ++
          [((i_axi, n_anG),
            (phi_anF ! (i_axi, 0) - phi_anF ! (i_axi, n_anG)))
           | (norecord@i_axi) <- [0 .. n_anG]]))
  where n_anG = nCell - 1
STARTLOG
STARTLOG
["nCell","nStep","maxDepth","charge","mass"]
module Consts (charge, mass, nCell, nStep, maxDepth) where
import PicType
import Utils

nCell, nStep, maxDepth :: Indx

charge, mass :: Value
nCell = 16
nStep = 10
maxDepth = (log2 nCell) - 1
charge = 1.0
mass = 1.0
STARTLOG
["phi_aob","rho_aoc","depth_aod","nIter_aoe","!nIter_aoe","(!nIter_aoe)","phi'_aof","phi_aCG","!phi_aCG","(!phi_aCG)","rho_aCH","!rho_aCH","(!rho_aCH)","n_aCI","depth_aCJ","!depth_aCJ","(!depth_aCJ)","nHalf_aCK","nHalf'_aCL","phi'_aCM","lazydmd@!phi'_aCM","(!phi'_aCM)","rho'_aCN","rCoarse_aCO","eZero_aCP","i_aTX","j_aTY","!j_aTY","(!j_aTY)","eCoarse_aCQ","mesh_aTZ","iLo_aU0","i_aU1","iHi_aU2","!iHi_aU2","(!iHi_aU2)","jLo_aU3","j_aU4","jHi_aU5","!jHi_aU5","(!jHi_aU5)","[iLo_aU0, i_aU1, (!iHi_aU2), jLo_aU3, j_aU4, (!jHi_aU5)]","mesh_aU6","!mesh_aU6","(!mesh_aU6)","mesh'_aU7","n_aU8","mesh'_aUa","!mesh'_aUa","(!mesh'_aUa)","mesh_aUb","iLo_aUc","!iLo_aUc","(!iLo_aUc)","i_aUd","iHi_aUe","!iHi_aUe","(!iHi_aUe)","jLo_aUf","!jLo_aUf","(!jLo_aUf)","j_aUg","jHi_aUh","[(!iLo_aUc), i_aUd, (!iHi_aUe), (!jLo_aUf), j_aUg, jHi_aUh]","mesh_aUi","mesh'_aUj","n_aUk","safebang@!n_aUk","(!n_aUk)","mesh'_aUm","mesh_aUn","iLo_aUo","safebang@!iLo_aUo","(!iLo_aUo)","i_aUp","safebang@!i_aUp","(!i_aUp)","iHi_aUq","jLo_aUr","safebang@!jLo_aUr","(!jLo_aUr)","j_aUs","jHi_aUt","[(!iLo_aUo), (!i_aUp), iHi_aUq, (!jLo_aUr), j_aUs, jHi_aUt]","phi_aUu","!phi_aUu","(!phi_aUu)","eCoarse_aUv","n'_aUw","nHalf_aUx","i_aUA","j_aUB","eFine_aUy","n_aUz"]
module Potential (potential) where
import PicType
import Consts
import Utils
import Data.Array

potential :: Phi -> Rho -> Indx -> Indx -> Phi
potential phi_aob rho_aoc depth_aod (norecord@nIter_aoe)
  | nIter_aoe == 0 = phi_aob
  | otherwise = potential phi'_aof rho_aoc depth_aod (nIter_aoe - 1)
  where phi'_aof = vCycle rho_aoc phi_aob nCell depth_aod

vCycle :: Phi -> Rho -> Indx -> Indx -> Phi
vCycle (norecord@phi_aCG) (norecord@rho_aCH) n_aCI
  (norecord@depth_aCJ)
  = if (depth_aCJ == 0) then relax phi'_aCM rho_aCH n_aCI else
      correct phi'_aCM eCoarse_aCQ n_aCI nHalf_aCK
  where nHalf_aCK = n_aCI `div` 2
        nHalf'_aCL = nHalf_aCK - 1
        (lazydmd@phi'_aCM) = relax phi_aCG rho_aCH n_aCI
        rho'_aCN = residual phi'_aCM rho_aCH n_aCI
        rCoarse_aCO = coarseMesh rho'_aCN n_aCI
        eZero_aCP
          = array ((0, 0), (nHalf'_aCL, nHalf'_aCL))
              [((i_aTX, j_aTY), 0.0) | i_aTX <- [0 .. nHalf'_aCL],
               (norecord@j_aTY) <- [0 .. nHalf'_aCL]]
        eCoarse_aCQ
          = vCycle eZero_aCP rCoarse_aCO nHalf_aCK (depth_aCJ - 1)

laplacianOp :: Mesh -> Range -> Value
laplacianOp mesh_aTZ
  [iLo_aU0, i_aU1, (norecord@iHi_aU2), jLo_aU3, j_aU4,
   (norecord@jHi_aU5)]
  = -(mesh_aTZ ! (iLo_aU0, j_aU4) + mesh_aTZ ! (i_aU1, jHi_aU5) +
        mesh_aTZ
        ! (i_aU1, jLo_aU3)
        + mesh_aTZ
        ! (iHi_aU2, j_aU4)
        - 4
        * mesh_aTZ
        ! (i_aU1, j_aU4))

residual :: Phi -> Rho -> Indx -> Rho
residual (norecord@mesh_aU6) mesh'_aU7 n_aU8
  = applyOpToMesh (residualOp_aU9 mesh'_aU7) mesh_aU6 n_aU8
  where residualOp_aU9 (norecord@mesh'_aUa) mesh_aUb
          [(norecord@iLo_aUc), i_aUd, (norecord@iHi_aUe), (norecord@jLo_aUf),
           j_aUg, jHi_aUh]
          = mesh'_aUa ! (i_aUd, j_aUg) -
              laplacianOp mesh_aUb
                [iLo_aUc, i_aUd, iHi_aUe, jLo_aUf, j_aUg, jHi_aUh]

relax :: Phi -> Rho -> Indx -> Phi
relax mesh_aUi mesh'_aUj (!n_aUk)
  = applyOpToMesh (relaxOp_aUl mesh'_aUj) mesh_aUi n_aUk
  where relaxOp_aUl mesh'_aUm mesh_aUn
          [(!iLo_aUo), (!i_aUp), iHi_aUq, (!jLo_aUr), j_aUs, jHi_aUt]
          = 0.25 * mesh'_aUm ! (i_aUp, j_aUs) + 0.25 *
              (mesh_aUn ! (iLo_aUo, j_aUs) + mesh_aUn ! (i_aUp, jLo_aUr) +
                 mesh_aUn
                 ! (i_aUp, jHi_aUt)
                 + mesh_aUn
                 ! (iHi_aUq, j_aUs))

correct :: Phi -> Mesh -> Indx -> Indx -> Phi
correct (norecord@phi_aUu) eCoarse_aUv n'_aUw nHalf_aUx
  = array ((0, 0), (n_aUz, n_aUz))
      [((i_aUA, j_aUB),
        phi_aUu ! (i_aUA, j_aUB) + eFine_aUy ! (i_aUA, j_aUB))
       | i_aUA <- [0 .. n_aUz], j_aUB <- [0 .. n_aUz]]
  where eFine_aUy = fineMesh eCoarse_aUv nHalf_aUx
        n_aUz = n'_aUw - 1
STARTLOG
[]
module PicType
       (Count, Indx, Value, Mesh, MeshAssoc, Electric, Phi, Rho, Position,
        Range, Velocity, ParticleHeap)
       where
import Data.Array

type Count = Int

type Indx = Int

type Value = Double

type Mesh = Array (Int, Int) Value

type MeshAssoc = ((Int, Int), Value)

type Electric = (Mesh, Mesh)

type Phi = Mesh

type Rho = Mesh

type Position = (Value, Value)

type Range = [Indx]

type Velocity = (Value, Value)

type ParticleHeap = ([Position], [Velocity])
STARTLOG
["nPart_aoM","partHeap_aoN","dt_aoO","phi_aoP","!phi_aoP","(!phi_aoP)","dt'_aoQ","phi'_aoR","!phi'_aoR","(!phi'_aoR)","partHeap'_aoS","!partHeap'_aoS","(!partHeap'_aoS)","(dt'_aoQ, (!phi'_aoR), (!partHeap'_aoS))","partHeap_axj","safebang@!partHeap_axj","(!partHeap_axj)","phi_axk","dt_axl","depth_axm","safebang@!depth_axm","(!depth_axm)","step_axn","rho_axo","phi'_axp","xyElec_axq","maxVel_axr","!maxVel_axr","(!maxVel_axr)","maxAcc_axs","partHeap'_axt","((!maxVel_axr), maxAcc_axs, partHeap'_axt)","dt'_axu","depth'_axv","lazydmd@!depth'_axv","(!depth'_axv)","nPart_aV0","nCellD_aV1","nPartD_aV2","!nPartD_aV2","(!nPartD_aV2)","xyPos_aV3","i_aV5","!i_aV5","(!i_aV5)","xPos_aV6","yPos_aV7","xyVel_aV4","!xyVel_aV4","(!xyVel_aV4)","i_aV8","partHeap_aV9","!partHeap_aV9","(!partHeap_aV9)","rho_aVa","phi0_aVb","!phi0_aVb","(!phi0_aVb)","i_a137","!i_a137","(!i_a137)","j_a138","n_aVc"]
module Pic (pic) where
import PicType
import Consts
import Utils
import ChargeDensity
import Potential
import ElecField
import PushParticle
import Data.Array

pic :: Indx -> [Char]
pic nPart_aoM = show dt'_aoQ
  where partHeap_aoN = initParticles nPart_aoM
        dt_aoO = 1.0e-3
        (norecord@phi_aoP) = initPhi partHeap_aoN
        (dt'_aoQ, (norecord@phi'_aoR), (norecord@partHeap'_aoS))
          = timeStep partHeap_aoN phi_aoP dt_aoO 0 nStep

timeStep ::
         ParticleHeap ->
           Phi -> Value -> Indx -> Indx -> (Value, Phi, ParticleHeap)
timeStep (!partHeap_axj) phi_axk dt_axl (!depth_axm) step_axn
  | step_axn == 0 = (dt_axl, phi_axk, partHeap_axj)
  | otherwise =
    timeStep partHeap'_axt phi'_axp dt'_axu depth'_axv (step_axn - 1)
  where rho_axo = chargeDensity partHeap_axj
        phi'_axp = potential phi_axk rho_axo depth_axm 1
        xyElec_axq = elecField phi'_axp
        ((norecord@maxVel_axr), maxAcc_axs, partHeap'_axt)
          = pushParticle partHeap_axj xyElec_axq dt_axl 0 0
        dt'_axu
          = (sqrt (maxVel_axr * maxVel_axr + 2 * maxAcc_axs) - maxVel_axr) /
              maxAcc_axs
        (lazydmd@depth'_axv) = (depth_axm + 1) `rem` maxDepth

initParticles :: Indx -> ParticleHeap
initParticles nPart_aV0 = (xyPos_aV3, xyVel_aV4)
  where nCellD_aV1 = fromIntegral nCell
        (norecord@nPartD_aV2) = fromIntegral (nPart_aV0 + 1)
        xyPos_aV3
          = [(xPos_aV6, yPos_aV7) | (norecord@i_aV5) <- [1 .. nPart_aV0],
             xPos_aV6 <- [nCellD_aV1 *
                            genRand (fromIntegral i_aV5 / nPartD_aV2)],
             yPos_aV7 <- [nCellD_aV1 * genRand xPos_aV6]]
        (norecord@xyVel_aV4) = [(0.0, 0.0) | i_aV8 <- [1 .. nPart_aV0]]

initPhi :: ParticleHeap -> Phi
initPhi (norecord@partHeap_aV9)
  = potential phi0_aVb rho_aVa maxDepth 1
  where rho_aVa = chargeDensity partHeap_aV9
        (norecord@phi0_aVb)
          = array ((0, 0), (n_aVc, n_aVc))
              [((i_a137, j_a138), 0.0) | (norecord@i_a137) <- [0 .. n_aVc],
               j_a138 <- [0 .. n_aVc]]
        n_aVc = nCell - 1
STARTLOG
["a_anG","b_anH","operator_anI","mesh_anJ","!mesh_anJ","(!mesh_anJ)","n'_anK","j_axj","!j_axj","(!j_axj)","j_axk","!j_axk","(!j_axk)","i_axl","i_axm","!i_axm","(!i_axm)","i_axn","j_axo","n_anL","safebang@!n_anL","(!n_anL)","n1_anM","mesh_axp","n_axq","i_aGy","j_aGz","!j_aGz","(!j_aGz)","nHalf_axr","mesh_aGA","nHalf'_aGB","j_aGE","j_aGF","!j_aGF","(!j_aGF)","j_aGG","j_aGH","i_aGI","!i_aGI","(!i_aGI)","i_aGJ","i_aGK","!i_aGK","(!i_aGK)","i_aGL","i_aGM","j_aGN","!j_aGN","(!j_aGN)","i_aGO","j_aGP","!j_aGP","(!j_aGP)","i_aGQ","j_aGR","!j_aGR","(!j_aGR)","i_aGS","!i_aGS","(!i_aGS)","j_aGT","nHalf_aGC","n_aGD","seed_aGU","r1_aGV","x_aGX","!x_aGX","(!x_aGX)","m_aGY","n_aGZ","n_aH1","safebang@!n_aH1","(!n_aH1)","accum_aH2","safebang@!accum_aH2","(!accum_aH2)"]
module Utils (applyOpToMesh, coarseMesh, fineMesh, genRand, log2)
       where
import PicType
import Data.Array

infix 1 =:
a_anG =: b_anH = (a_anG, b_anH)

applyOpToMesh :: (Mesh -> Range -> Value) -> Mesh -> Indx -> Mesh
applyOpToMesh operator_anI (norecord@mesh_anJ) n'_anK
  = array ((0, 0), (n_anL, n_anL))
      ([(0, 0) =: operator_anI mesh_anJ [n_anL, 0, 1, n_anL, 0, 1]] ++
         [(0, n_anL) =:
            operator_anI mesh_anJ [n_anL, 0, 1, n1_anM, n_anL, 0]]
         ++
         [(n_anL, 0) =:
            operator_anI mesh_anJ [n1_anM, n_anL, 0, n_anL, 0, 1]]
         ++
         [(n_anL, n_anL) =:
            operator_anI mesh_anJ [n1_anM, n_anL, 0, n1_anM, n_anL, 0]]
         ++
         [(0, j_axj) =:
            operator_anI mesh_anJ
              [n_anL, 0, n1_anM, (j_axj - 1), j_axj, (j_axj + 1)]
          | (norecord@j_axj) <- [1 .. n1_anM]]
         ++
         [(n_anL, j_axk) =:
            operator_anI mesh_anJ
              [n1_anM, n_anL, 0, (j_axk - 1), j_axk, (j_axk + 1)]
          | (norecord@j_axk) <- [1 .. n1_anM]]
         ++
         [(i_axl, 0) =:
            operator_anI mesh_anJ
              [(i_axl - 1), i_axl, (i_axl + 1), n_anL, 0, 1]
          | i_axl <- [1 .. n1_anM]]
         ++
         [(i_axm, n_anL) =:
            operator_anI mesh_anJ
              [(i_axm - 1), i_axm, (i_axm + 1), n1_anM, n_anL, 0]
          | (norecord@i_axm) <- [1 .. n1_anM]]
         ++
         [(i_axn, j_axo) =:
            operator_anI mesh_anJ
              [(i_axn - 1), i_axn, (i_axn + 1), (j_axo - 1), j_axo, (j_axo + 1)]
          | i_axn <- [1 .. n1_anM], j_axo <- [1 .. n1_anM]])
  where (!n_anL) = n'_anK - 1
        n1_anM = n'_anK - 2

coarseMesh :: Mesh -> Indx -> Mesh
coarseMesh mesh_axp n_axq
  = array ((0, 0), (nHalf_axr, nHalf_axr))
      [(i_aGy, j_aGz) =: mesh_axp ! (i_aGy * 2, j_aGz * 2) |
       i_aGy <- [0 .. nHalf_axr], (norecord@j_aGz) <- [0 .. nHalf_axr]]
  where nHalf_axr = n_axq `div` 2 - 1

fineMesh :: Mesh -> Indx -> Mesh
fineMesh mesh_aGA nHalf'_aGB
  = array ((0, 0), (n_aGD, n_aGD))
      ([(0, 0) =: 3] ++ [(0, n_aGD) =: 3] ++ [(n_aGD, 0) =: 3] ++
         [(n_aGD, n_aGD) =: 3]
         ++ [(0, 2 * j_aGE) =: 4 | j_aGE <- [1 .. nHalf_aGC]]
         ++ [(0, 2 * j_aGF - 1) =: 4 | (norecord@j_aGF) <- [1 .. nHalf_aGC]]
         ++ [(n_aGD, 2 * j_aGG) =: 4 | j_aGG <- [1 .. nHalf_aGC]]
         ++ [(n_aGD, 2 * j_aGH - 1) =: 4 | j_aGH <- [1 .. nHalf_aGC]]
         ++ [(2 * i_aGI, 0) =: 5 | (norecord@i_aGI) <- [1 .. nHalf_aGC]]
         ++ [(2 * i_aGJ - 1, 0) =: 5 | i_aGJ <- [1 .. nHalf_aGC]]
         ++ [(2 * i_aGK, n_aGD) =: 5 | (norecord@i_aGK) <- [1 .. nHalf_aGC]]
         ++ [(2 * i_aGL - 1, n_aGD) =: 5 | i_aGL <- [1 .. nHalf_aGC]]
         ++
         [(2 * i_aGM, 2 * j_aGN) =: 6 | i_aGM <- [1 .. nHalf_aGC],
          (norecord@j_aGN) <- [1 .. nHalf_aGC]]
         ++
         [(2 * i_aGO, 2 * j_aGP - 1) =: 6 | i_aGO <- [1 .. nHalf_aGC],
          (norecord@j_aGP) <- [1 .. nHalf_aGC]]
         ++
         [(2 * i_aGQ - 1, 2 * j_aGR) =: 6 | i_aGQ <- [1 .. nHalf_aGC],
          (norecord@j_aGR) <- [1 .. nHalf_aGC]]
         ++
         [(2 * i_aGS - 1, 2 * j_aGT - 1) =: 6 |
          (norecord@i_aGS) <- [1 .. nHalf_aGC], j_aGT <- [1 .. nHalf_aGC]])
  where nHalf_aGC = nHalf'_aGB - 1
        n_aGD = 2 * nHalf'_aGB - 1

genRand :: Value -> Value
genRand seed_aGU = r1_aGV / 655357
  where r1_aGV = (31453257 * seed_aGU + 271829) `fiRem_aGW` 655357
        fiRem_aGW (norecord@x_aGX) m_aGY
          = x_aGX - fromIntegral ((truncate x_aGX `div` m_aGY) * m_aGY)

log2 :: Int -> Int
log2 n_aGZ = log2'_aH0 n_aGZ 0
  where log2'_aH0 (!n_aH1) (!accum_aH2)
          | n_aH1 > 1 = log2'_aH0 (n_aH1 `div` 2) (accum_aH2 + 1)
          | otherwise = accum_aH2
STARTLOG
["xyPos_anG","xyVel_anH","(xyPos_anG, xyVel_anH)","n_anI","!n_anI","(!n_anI)","[]","x_axf","safebang@!x_axf","(!x_axf)","y_axg","safebang@!y_axg","(!y_axg)","((!x_axf), (!y_axg))","xys_axh","safebang@!xys_axh","(!xys_axh)","((!x_axf), (!y_axg)) : (!xys_axh)","(((!x_axf), (!y_axg)) : (!xys_axh))","i_axp","!i_axp","(!i_axp)","i'_axq","j_axr","j'_axs","dx_axt","dy_axu","!dy_axu","(!dy_axu)"]
module ChargeDensity (chargeDensity) where
import PicType
import Consts
import Data.Array

chargeDensity :: ParticleHeap -> Rho
chargeDensity (xyPos_anG, xyVel_anH)
  = accumArray (+) 0 ((0, 0), (n_anI, n_anI)) (accumCharge xyPos_anG)
  where (norecord@n_anI) = nCell - 1

accumCharge :: [Position] -> [MeshAssoc]
accumCharge [] = []
accumCharge (((!x_axf), (!y_axg)) : (!xys_axh))
  = [((i_axp, j_axr), charge * (1 - dx_axt) * (1 - dy_axu))] ++
      [((i'_axq, j_axr), charge * dx_axt * (1 - dy_axu))]
      ++ [((i_axp, j'_axs), charge * (1 - dx_axt) * dy_axu)]
      ++ [((i'_axq, j'_axs), charge * dx_axt * dy_axu)]
      ++ accumCharge xys_axh
  where (norecord@i_axp) = truncate x_axf
        i'_axq = (i_axp + 1) `rem` nCell
        j_axr = truncate y_axg
        j'_axs = (j_axr + 1) `rem` nCell
        dx_axt = x_axf - fromIntegral i_axp
        (norecord@dy_axu) = y_axg - fromIntegral j_axr
STARTLOG
["[]","[]","([], [])","xyElec_anF","safebang@!xyElec_anF","(!xyElec_anF)","dt_anG","maxAcc_anH","safebang@!maxAcc_anH","(!maxAcc_anH)","maxVel_anI","safebang@!maxVel_anI","(!maxVel_anI)","xPos_anJ","yPos_anK","safebang@!yPos_anK","(!yPos_anK)","(xPos_anJ, (!yPos_anK))","xyPos_anL","(xPos_anJ, (!yPos_anK)) : xyPos_anL","((xPos_anJ, (!yPos_anK)) : xyPos_anL)","!((xPos_anJ, (!yPos_anK)) : xyPos_anL)","(!((xPos_anJ, (!yPos_anK)) : xyPos_anL))","((!((xPos_anJ, (!yPos_anK)) : xyPos_anL)))","xVel_anT","yVel_anU","(xVel_anT, yVel_anU)","xyVel_anV","safebang@!xyVel_anV","(!xyVel_anV)","(xVel_anT, yVel_anU) : (!xyVel_anV)","((xVel_anT, yVel_anU) : (!xyVel_anV))","(((!((xPos_anJ, (!yPos_anK)) : xyPos_anL))),\n ((xVel_anT, yVel_anU) : (!xyVel_anV)))","xElec_anW","yElec_anX","!yElec_anX","(!yElec_anX)","(xElec_anW, (!yElec_anX))","dt_anY","maxAcc_anZ","!maxAcc_anZ","(!maxAcc_anZ)","maxVel_ao0","i_ao1","!i_ao1","(!i_ao1)","j_ao2","i1_ao3","j1_ao4","!j1_ao4","(!j1_ao4)","dx_ao5","dy_ao6","!dy_ao6","(!dy_ao6)","xAcc_ao7","yAcc_ao8","!yAcc_ao8","(!yAcc_ao8)","xTV_ao9","lazydmd@!xTV_ao9","(!xTV_ao9)","yTV_aoa","xT_aob","yT_aoc","maxAcc'_aod","maxVel'_aoe","xVel'_aof","!xVel'_aof","(!xVel'_aof)","yVel'_aog","((!xVel'_aof), yVel'_aog)","xPos'_aoh","!xPos'_aoh","(!xPos'_aoh)","yPos'_aoi","!yPos'_aoi","(!yPos'_aoi)","maxAcc''_aoj","maxVel''_aok","safebang@!maxVel''_aok","(!maxVel''_aok)","xyPos'_aol","xyVel'_aom","(xyPos'_aol, xyVel'_aom)","(maxAcc''_aoj, (!maxVel''_aok), (xyPos'_aol, xyVel'_aom))","!(maxAcc''_aoj, (!maxVel''_aok), (xyPos'_aol, xyVel'_aom))","(!(maxAcc''_aoj, (!maxVel''_aok), (xyPos'_aol, xyVel'_aom)))"]
module PushParticle (pushParticle) where
import PicType
import Consts
import Data.Array

pushParticle ::
             ParticleHeap ->
               Electric -> Value -> Value -> Value -> (Value, Value, ParticleHeap)
pushParticle ([], []) (!xyElec_anF) dt_anG (!maxAcc_anH)
  (!maxVel_anI) = (maxAcc_anH, maxVel_anI, ([], []))
pushParticle
  (((norecord@((xPos_anJ, (!yPos_anK)) : xyPos_anL))),
   ((xVel_anT, yVel_anU) : (!xyVel_anV)))
  (xElec_anW, (norecord@yElec_anX)) dt_anY (norecord@maxAcc_anZ)
  maxVel_ao0
  = (maxAcc''_aoj, maxVel''_aok,
     (((xPos'_aoh, yPos'_aoi) : xyPos'_aol),
      ((xVel'_aof, yVel'_aog) : xyVel'_aom)))
  where (norecord@i_ao1) = truncate xPos_anJ
        j_ao2 = truncate yPos_anK
        i1_ao3 = (i_ao1 + 1) `rem` nCell
        (norecord@j1_ao4) = (j_ao2 + 1) `rem` nCell
        dx_ao5 = xPos_anJ - fromIntegral i_ao1
        (norecord@dy_ao6) = yPos_anK - fromIntegral j_ao2
        xAcc_ao7
          = (charge / mass) *
              (xElec_anW ! (i_ao1, j_ao2) * (1 - dy_ao6) + xElec_anW !
                 (i_ao1, j1_ao4)
                 * dy_ao6)
        (norecord@yAcc_ao8)
          = (charge / mass) *
              (yElec_anX ! (i_ao1, j_ao2) * (1 - dx_ao5) + yElec_anX !
                 (i1_ao3, j_ao2)
                 * dx_ao5)
        (lazydmd@xTV_ao9) = xAcc_ao7 * dt_anY + xVel_anT
        yTV_aoa = yAcc_ao8 * dt_anY + yVel_anU
        xT_aob = xTV_ao9 * dt_anY + xPos_anJ
        yT_aoc = yTV_aoa * dt_anY + yPos_anK
        maxAcc'_aod = max maxAcc_anZ (max (abs xAcc_ao7) (abs yAcc_ao8))
        maxVel'_aoe = max maxVel_ao0 (max (abs xTV_ao9) (abs yTV_aoa))
        ((norecord@xVel'_aof), yVel'_aog) = (xTV_ao9, yTV_aoa)
        (norecord@xPos'_aoh)
          = if (xT_aob >= fromIntegral nCell) then
              xT_aob - fromIntegral nCell else
              if (xT_aob < 0.0) then xT_aob + fromIntegral nCell else xT_aob
        (norecord@yPos'_aoi)
          = if (yT_aoc >= fromIntegral nCell) then
              yT_aoc - fromIntegral nCell else
              if (yT_aoc < 0.0) then yT_aoc + fromIntegral nCell else yT_aoc
        (norecord@(maxAcc''_aoj, (!maxVel''_aok),
                   (xyPos'_aol, xyVel'_aom)))
          = pushParticle (xyPos_anL, xyVel_anV) (xElec_anW, yElec_anX) dt_anY
              maxAcc'_aod
              maxVel'_aoe
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
["main","str_aRj","args_aRk","stats_a117","!stats_a117","(!stats_a117)","form_aRl","lazydmd@!form_aRl","(!form_aRl)","stats_aXx","orderAct_aRn","A orderAct_aRn","(A orderAct_aRn)","orderSp_aRo","S orderSp_aRo","(S orderSp_aRo)","!(S orderSp_aRo)","(!(S orderSp_aRo))","((!(S orderSp_aRo)))","sizeX_aRp","!sizeX_aRp","(!sizeX_aRp)","sizeY_aRq","E (!sizeX_aRp) sizeY_aRq","(E (!sizeX_aRp) sizeY_aRq)","!(E (!sizeX_aRp) sizeY_aRq)","(!(E (!sizeX_aRp) sizeY_aRq))","((!(E (!sizeX_aRp) sizeY_aRq)))","!((!(E (!sizeX_aRp) sizeY_aRq)))","(!((!(E (!sizeX_aRp) sizeY_aRq))))","processors_aRr","safebang@!processors_aRr","(!processors_aRr)","PS (!processors_aRr)","(PS (!processors_aRr))","!(PS (!processors_aRr))","(!(PS (!processors_aRr)))","from_aRs","safebang@!from_aRs","(!from_aRs)","into_aRt","((!from_aRs), into_aRt)","!((!from_aRs), into_aRt)","(!((!from_aRs), into_aRt))","IO (!((!from_aRs), into_aRt))","(IO (!((!from_aRs), into_aRt)))","!(IO (!((!from_aRs), into_aRt)))","(!(IO (!((!from_aRs), into_aRt))))","[]","'-'","_","'-' : _","('-' : _)","!('-' : _)","(!('-' : _))","arg_a118@(!('-' : _))","!arg_a118@(!('-' : _))","(!arg_a118@(!('-' : _)))","more_a119","(!arg_a118@(!('-' : _))) : more_a119","((!arg_a118@(!('-' : _))) : more_a119)","!((!arg_a118@(!('-' : _))) : more_a119)","(!((!arg_a118@(!('-' : _))) : more_a119))","a_a11a","b_a11b","[a_a11a, b_a11b]","a_a11c","a_a11d","[]","![]","(![])","a_a11e","b_a11f","bs_a11g","safebang@!bs_a11g","(!bs_a11g)","b_a11f : (!bs_a11g)","(b_a11f : (!bs_a11g))","!(b_a11f : (!bs_a11g))","(!(b_a11f : (!bs_a11g)))","((!(b_a11f : (!bs_a11g))))","defaultAct","defaultSp","defaultSize","defaultPS","'-'","'A'","string_a11h","lazydmd@!string_a11h","(!string_a11h)","'A' : (!string_a11h)","('A' : (!string_a11h))","!('A' : (!string_a11h))","(!('A' : (!string_a11h)))","'-' : (!('A' : (!string_a11h)))","('-' : (!('A' : (!string_a11h))))","order_a11i","x_a11j","!x_a11j","(!x_a11j)","more_a11k","!more_a11k","(!more_a11k)","((!x_a11j), (!more_a11k))","'-'","'S'","string_a11l","!string_a11l","(!string_a11l)","'S' : (!string_a11l)","('S' : (!string_a11l))","!('S' : (!string_a11l))","(!('S' : (!string_a11l)))","'-' : (!('S' : (!string_a11l)))","('-' : (!('S' : (!string_a11l))))","!('-' : (!('S' : (!string_a11l))))","(!('-' : (!('S' : (!string_a11l)))))","((!('-' : (!('S' : (!string_a11l))))))","order_a11m","x_a11n","more_a11o","(x_a11n, more_a11o)","!(x_a11n, more_a11o)","(!(x_a11n, more_a11o))","'-'","'P'","string_a11p","!string_a11p","(!string_a11p)","'P' : (!string_a11p)","('P' : (!string_a11p))","!('P' : (!string_a11p))","(!('P' : (!string_a11p)))","'-' : (!('P' : (!string_a11p)))","('-' : (!('P' : (!string_a11p))))","!('-' : (!('P' : (!string_a11p))))","(!('-' : (!('P' : (!string_a11p)))))","((!('-' : (!('P' : (!string_a11p))))))","'-'","'E'","string_a11q","!string_a11q","(!string_a11q)","'E' : (!string_a11q)","('E' : (!string_a11q))","'-' : ('E' : (!string_a11q))","('-' : ('E' : (!string_a11q)))","x_a11r","!x_a11r","(!x_a11r)","y_a11s","!y_a11s","(!y_a11s)","((!x_a11r), (!y_a11s))","p_a11t","!p_a11t","(!p_a11t)","'x'","!'x'","(!'x')","a_a11u","safebang@!a_a11u","(!a_a11u)","(!'x') : (!a_a11u)","((!'x') : (!a_a11u))","!((!'x') : (!a_a11u))","(!((!'x') : (!a_a11u)))","((!p_a11t), (!((!'x') : (!a_a11u))))","!((!p_a11t), (!((!'x') : (!a_a11u))))","(!((!p_a11t), (!((!'x') : (!a_a11u)))))","q_a11v","more_a11w","(q_a11v, more_a11w)","'-'","'F'","string_a11x","!string_a11x","(!string_a11x)","'F' : (!string_a11x)","('F' : (!string_a11x))","!('F' : (!string_a11x))","(!('F' : (!string_a11x)))","'-' : (!('F' : (!string_a11x)))","('-' : (!('F' : (!string_a11x))))","'-'","'G'","string_a11y","lazydmd@!string_a11y","(!string_a11y)","'G' : (!string_a11y)","('G' : (!string_a11y))","!('G' : (!string_a11y))","(!('G' : (!string_a11y)))","'-' : (!('G' : (!string_a11y)))","('-' : (!('G' : (!string_a11y))))","!('-' : (!('G' : (!string_a11y))))","(!('-' : (!('G' : (!string_a11y)))))","((!('-' : (!('G' : (!string_a11y))))))","!((!('-' : (!('G' : (!string_a11y))))))","(!((!('-' : (!('G' : (!string_a11y)))))))","'-'","'p'","string_a11z","'p' : string_a11z","('p' : string_a11z)","!('p' : string_a11z)","(!('p' : string_a11z))","'-' : (!('p' : string_a11z))","('-' : (!('p' : string_a11z)))","!('-' : (!('p' : string_a11z)))","(!('-' : (!('p' : string_a11z))))","((!('-' : (!('p' : string_a11z)))))","order_a11A","!order_a11A","(!order_a11A)","processors_a11B","more_a11C","!more_a11C","(!more_a11C)","(processors_a11B, (!more_a11C))","!(processors_a11B, (!more_a11C))","(!(processors_a11B, (!more_a11C)))","'-'","string_a11D","'-' : string_a11D","('-' : string_a11D)","!('-' : string_a11D)","(!('-' : string_a11D))","string_a11F","files_a11G","!files_a11G","(!files_a11G)","file1_a11H","more_a11I","(file1_a11H, more_a11I)","x_a156","file2_a11J","!file2_a11J","(!file2_a11J)","_","!_","(!_)","((!file2_a11J), (!_))","!((!file2_a11J), (!_))","(!((!file2_a11J), (!_)))","x_a157","!x_a157","(!x_a157)","_","!_","(!_)","A (!_)","(A (!_))","_","A _","(A _)","!(A _)","(!(A _))","_","!_","(!_)","S (!_)","(S (!_))","!(S (!_))","(!(S (!_)))","((!(S (!_))))","_","S _","(S _)","P","!P","(!P)","P","_","_","E _ _","(E _ _)","_","!_","(!_)","_","E (!_) _","(E (!_) _)","F","!F","(!F)","F","!F","(!F)","G","G","!G","(!G)","_","PS _","(PS _)","!(PS _)","(!(PS _))","((!(PS _)))","!((!(PS _)))","(!((!(PS _))))","_","!_","(!_)","PS (!_)","(PS (!_))","!(PS (!_))","(!(PS (!_)))","((!(PS (!_))))","!((!(PS (!_))))","(!((!(PS (!_)))))","_","!_","(!_)","IO (!_)","(IO (!_))","!(IO (!_))","(!(IO (!_)))","_","!_","(!_)","IO (!_)","(IO (!_))","_","!_","(!_)","_"]
module Main where
import GRIP
import PSlib
import Graph
import Parse
import Pool
import Activity
import Spark
import System.Environment
main
  = do str_aRj <- getArgs
       control (map parseLine (condenseArgs str_aRj))
control args_aRk
  = do (norecord@stats_a117) <- if from_aRs == "stdin" then
                                  getContents else readFile from_aRs
       (if into_aRt == "stdout" then putStr else writeFile into_aRt)
         (form_aRl (graph_aRm stats_a117))
  where form_aRl :: String -> Postscript
        (lazydmd@form_aRl)
          = if (sizeX_aRp == 0) then
              (if (elem G args_aRk) then gspostscript else postscript) else
              ePostscript (sizeX_aRp, sizeY_aRq)
        
        graph_aRm :: String -> Postscript
        graph_aRm stats_aXx
          = if (elem P args_aRk) then poolGraph processors_aRr stats_aXx else
              if orderSp_aRo /= [] then
                sparkGraph orderSp_aRo processors_aRr stats_aXx else
                activityGraph orderAct_aRn processors_aRr stats_aXx
        (A orderAct_aRn) = lookUp (A defaultAct) args_aRk
        ((norecord@(S orderSp_aRo))) = lookUp (S []) args_aRk
        (norecord@((norecord@(E (norecord@sizeX_aRp) sizeY_aRq))))
          = lookUp (E 0 0) args_aRk
        (norecord@(PS (!processors_aRr))) = lookUp (PS []) args_aRk
        (norecord@(IO (norecord@((!from_aRs), into_aRt))))
          = lookUp (IO ("stdin", "stdout")) args_aRk

condenseArgs :: [String] -> [String]
condenseArgs [] = []
condenseArgs
  (norecord@((norecord@arg_a118@(norecord@('-' : _))) : more_a119))
  = arg_a118 : condenseArgs more_a119
condenseArgs [a_a11a, b_a11b] = [a_a11a ++ " " ++ b_a11b]
condenseArgs a_a11c = a_a11c

lookUp :: Args -> [Args] -> Args
lookUp a_a11d (norecord@[]) = a_a11d
lookUp a_a11e ((norecord@(b_a11f : (!bs_a11g))))
  | a_a11e == b_a11f = b_a11f
  | otherwise = lookUp a_a11e bs_a11g
defaultAct = [GC, REDN, IDLE, FLUSH]
defaultSp = [RESUMED, USED, CREATED, LOST]
defaultSize = (15 :: Int, 10 :: Int)
defaultPS = [PE "14" 1]

data Args = A [Activity]
          | S [Spark]
          | P
          | E Int Int
          | F
          | G
          | PS [PElement]
          | IO (String, String)

instance Parse Args where
        parseType ('-' : (norecord@('A' : (lazydmd@string_a11h))))
          = (A order_a11i, more_a11k)
          where order_a11i
                  = if (whiteSpace string_a11h) == "" then defaultAct else x_a11j
                ((norecord@x_a11j), (norecord@more_a11k)) = parse string_a11h
        parseType
          ((norecord@('-' : (norecord@('S' : (norecord@string_a11l))))))
          = (S order_a11m, more_a11o)
          where order_a11m
                  = if (whiteSpace string_a11l == "") then defaultSp else x_a11n
                (norecord@(x_a11n, more_a11o)) = parse string_a11l
        parseType
          ((norecord@('-' : (norecord@('P' : (norecord@string_a11p))))))
          = (P, string_a11p)
        parseType ('-' : ('E' : (norecord@string_a11q)))
          = (E x_a11r y_a11s, "")
          where ((norecord@x_a11r), (norecord@y_a11s))
                  = if (whiteSpace string_a11q) == "" then defaultSize else
                      (p_a11t, q_a11v)
                (norecord@((norecord@p_a11t),
                           (norecord@((norecord@'x') : (!a_a11u)))))
                  = parse string_a11q
                (q_a11v, more_a11w) = parse a_a11u
        parseType ('-' : (norecord@('F' : (norecord@string_a11x))))
          = (F, string_a11x)
        parseType
          (norecord@((norecord@('-' :
                                  (norecord@('G' : (lazydmd@string_a11y)))))))
          = (G, string_a11y)
        parseType ((norecord@('-' : (norecord@('p' : string_a11z)))))
          = (PS processors_a11B, more_a11C)
          where (norecord@order_a11A)
                  = if (whiteSpace string_a11z == "") then defaultPS else
                      processors_a11B
                (norecord@(processors_a11B, (norecord@more_a11C)))
                  = parse string_a11z
        parseType (norecord@('-' : string_a11D))
          = error ("Illegal flag to GRIP-graph : -" ++ string_a11D ++ "\n")
        parseType string_a11F = (IO files_a11G, "")
          where (norecord@files_a11G)
                  = if string_a11F == "" then ("stdin", "stdout") else
                      if (whiteSpace more_a11I) == "" then
                        (file1_a11H, file1_a11H ++ ".ps") else (file1_a11H, file2_a11J)
                (file1_a11H, more_a11I)
                  = span (\ x_a156 -> x_a156 /= ' ') string_a11F
                (norecord@((norecord@file2_a11J), (norecord@_)))
                  = span (\ (norecord@x_a157) -> x_a157 /= ' ')
                      (whiteSpace (more_a11I ++ " "))

instance Eq Args where
        (A (norecord@_)) == (norecord@(A _)) = True
        ((norecord@(S (norecord@_)))) == (S _) = True
        (norecord@P) == P = True
        (E _ _) == (E (norecord@_) _) = True
        (norecord@F) == (norecord@F) = True
        G == (norecord@G) = True
        (norecord@((norecord@(PS _)))) ==
          (norecord@((norecord@(PS (norecord@_))))) = True
        (norecord@(IO (norecord@_))) == (IO (norecord@_)) = True
        (norecord@_) == _ = False
STARTLOG
["header_aJr","str_aJs","stdheader","gslandscape","landscape","portrait","stdProcedures","pts_aJt","(pts_aJt)","pts_aPB","(pts_aPB)","!(pts_aPB)","(!(pts_aPB))","pt_aPC","dx_aPD","safebang@!dx_aPD","(!dx_aPD)","dy_aPE","c_aPF","safebang@!c_aPF","(!c_aPF)","pt_aPG","safebang@!pt_aPG","(!pt_aPG)","dx_aPH","safebang@!dx_aPH","(!dx_aPH)","dy_aPI","str_aPJ","safebang@!str_aPJ","(!str_aPJ)","str_aPK","safebang@!str_aPK","(!str_aPK)","rightshow","centreshow","fill","stroke","closepath","newpath","showpage","gsave","grestore","t_aPL","safebang@!t_aPL","(!t_aPL)","0","10","n_aPM","!n_aPM","(!n_aPM)","x_aPN","y_aPO","Pt x_aPN y_aPO","(Pt x_aPN y_aPO)","x_aPP","y_aPQ","safebang@!y_aPQ","(!y_aPQ)","x_aPR","y_aPS","Pt x_aPR y_aPS","(Pt x_aPR y_aPS)","!(Pt x_aPR y_aPS)","(!(Pt x_aPR y_aPS))","((!(Pt x_aPR y_aPS)))","!((!(Pt x_aPR y_aPS)))","(!((!(Pt x_aPR y_aPS))))","x_aPT","y_aPU","safebang@!y_aPU","(!y_aPU)","n_aPV","thinlines","n_aPW","c_aPX","args_aPY","safebang@!args_aPY","(!args_aPY)","x_aQ0","!x_aQ0","(!x_aQ0)","x_aQ1","safebang@!x_aQ1","(!x_aQ1)","y_aQ2","x_aQ3","y_aQ4","setcms"]
module PSlib where
initialise header_aJr
  = header_aJr ++ "/SMALL /Helvetica findfont 4 scalefont def\n" ++
      "/SMALLBOLD /Helvetica-Bold findfont 4 scalefont def\n"
      ++ "/SMALLITALIC /Helvetica-Oblique findfont 4 scalefont def\n"
      ++ "/NORM /Helvetica findfont 5 scalefont def\n"
      ++ "/BOLD /Helvetica-Bold findfont 5 scalefont def\n"
      ++ "/LARGE /Helvetica-Bold findfont 11 scalefont def\n"
      ++ "NORM setfont\n"
      ++ setcms
      ++ stdProcedures
      ++ thinlines
setfont str_aJs = str_aJs ++ " setfont\n"

stdheader :: Postscript
stdheader = "%!PS-Adobe-2.0\n%%Created by Haskell Graph Package\n"
gslandscape = ""
landscape
  = translate 8 290 ++ rotate 270 ++ translate 20 10 ++
      "0.9 0.9 scale\n"
portrait = ""
stdProcedures = rightshow ++ centreshow

drawObject :: [Point] -> Postscript
drawObject (pts_aJt)
  = newpath ++ moveto (Pt 0 0) ++ concat (map lineto pts_aJt) ++
      thinlines
      ++ stroke

fillObject :: [Point] -> Postscript
fillObject (norecord@(pts_aPB))
  = newpath ++ moveto (Pt 0 0) ++ concat (map lineto pts_aPB) ++
      closepath
      ++ fill
      ++ stroke

fillBox :: Point -> Int -> Int -> Int -> Postscript
fillBox pt_aPC (!dx_aPD) dy_aPE (!c_aPF)
  = newpath ++ moveto pt_aPC ++ rlineto 0 dy_aPE ++ rlineto dx_aPD 0
      ++ rlineto 0 (-dy_aPE)
      ++ closepath
      ++ setgray c_aPF
      ++ fill

drawBox :: Point -> Int -> Int -> Postscript
drawBox (!pt_aPG) (!dx_aPH) dy_aPI
  = thinlines ++ newpath ++ moveto pt_aPG ++ rlineto 0 dy_aPI ++
      rlineto dx_aPH 0
      ++ rlineto 0 (-dy_aPI)
      ++ closepath
      ++ stroke
rjustify (!str_aPJ) = "(" ++ str_aPJ ++ ") rightshow\n"
cjustify (!str_aPK) = "(" ++ str_aPK ++ ") centreshow\n"
rightshow
  = "/rightshow\n{dup stringwidth pop\n0 exch sub\n0 rmoveto\nshow } def \n"
centreshow
  = "/centreshow\n{dup stringwidth pop\n0 exch sub\n2 div\n0 rmoveto\nshow } def \n"
fill = "fill\n"
stroke = "stroke\n"
closepath = "closepath\n"
newpath = "newpath\n"
showpage = "showpage\n\n"
gsave = "gsave\n"
grestore = "grestore\n"
text (!t_aPL) = setgray 0 ++ "(" ++ t_aPL ++ ") show\n"
setgray 0 = "0 setgray\n"
setgray 10 = "1 setgray\n"
setgray (norecord@n_aPM) = "." ++ show n_aPM ++ " setgray\n"
moveto (Pt x_aPN y_aPO) = psCommand "moveto" [x_aPN, y_aPO]
rmoveto x_aPP (!y_aPQ) = psCommand "rmoveto" [x_aPP, y_aPQ]

lineto :: Point -> Postscript
lineto (norecord@((norecord@(Pt x_aPR y_aPS))))
  = psCommand "lineto" [x_aPR, y_aPS]
rlineto x_aPT (!y_aPU) = psCommand "rlineto" [x_aPT, y_aPU]
setlinewidth n_aPV = psCommand "setlinewidth" [n_aPV]
thinlines = "0.2 setlinewidth\n"
rotate n_aPW = psCommand "rotate" [n_aPW]
psCommand c_aPX (!args_aPY)
  = concat (map f_aPZ args_aPY) ++ c_aPX ++ "\n"
  where f_aPZ (norecord@x_aQ0) = show x_aQ0 ++ " "
translate (!x_aQ1) y_aQ2 = psCommand "translate" [x_aQ1, y_aQ2]
scale x_aQ3 y_aQ4 = psCommand "scale" [x_aQ3, y_aQ4]
setcms = "2.84584 2.84584 scale\n"

type Postscript = String

data Point = Pt Int Int
           deriving (Eq, Show)
STARTLOG
["paperX","paperY","my_fromInt","str_aH4","safebang@!str_aH4","(!str_aH4)","str_aH5","safebang@!str_aH5","(!str_aH5)","reqdx_aH6","reqdy_aH7","(reqdx_aH6, reqdy_aH7)","str_aH8","title_aPt","pedata_aPu","safebang@!pedata_aPu","(!pedata_aPu)","topX_aPv","topY_aPw","safebang@!topY_aPw","(!topY_aPw)","(topX_aPv, (!topY_aPw))","xlabel_aPx","safebang@!xlabel_aPx","(!xlabel_aPx)","ylabel_aPy","safebang@!ylabel_aPy","(!ylabel_aPy)","((!xlabel_aPx), (!ylabel_aPy))","!((!xlabel_aPx), (!ylabel_aPy))","(!((!xlabel_aPx), (!ylabel_aPy)))","keys_aPz","pes_aPA","safebang@!pes_aPA","(!pes_aPA)","on_aPB","safebang@!on_aPB","(!on_aPB)","((!pes_aPA), (!on_aPB))","used_aPC","safebang@!used_aPC","(!used_aPC)","x_a1cr","x_a1cs","!x_a1cs","(!x_a1cs)","pts_a1ct","points_a1cu","left_a1cv","keys_a1cw","x_a1cB","safebang@!x_a1cB","(!x_a1cB)","y_a1cC","safebang@!y_a1cC","(!y_a1cC)","Pt (!x_a1cB) (!y_a1cC)","(Pt (!x_a1cB) (!y_a1cC))","pt_a1cA@(Pt (!x_a1cB) (!y_a1cC))","!pt_a1cA@(Pt (!x_a1cB) (!y_a1cC))","(!pt_a1cA@(Pt (!x_a1cB) (!y_a1cC)))","col_a1cD","tex_a1cE","pc_a1cF","(col_a1cD, tex_a1cE, pc_a1cF)","no_a1cy","n_a1cG","safebang@!n_a1cG","(!n_a1cG)","n_a1cH","t_a1cI","f_a1cJ","safebang@!f_a1cJ","(!f_a1cJ)","m_a1cK","safebang@!m_a1cK","(!m_a1cK)","pes_a1cL","(!m_a1cK) : pes_a1cL","((!m_a1cK) : pes_a1cL)","!((!m_a1cK) : pes_a1cL)","(!((!m_a1cK) : pes_a1cL))","((!((!m_a1cK) : pes_a1cL)))","on_a1cM","pe_a1cO","left_a1cP","pes_a1cQ","safebang@!pes_a1cQ","(!pes_a1cQ)","x_a1cW","safebang@!x_a1cW","(!x_a1cW)","y_a1cX","safebang@!y_a1cX","(!y_a1cX)","Pt (!x_a1cW) (!y_a1cX)","(Pt (!x_a1cW) (!y_a1cX))","pt_a1cV@(Pt (!x_a1cW) (!y_a1cX))","font_a1cY","tex_a1cZ","safebang@!tex_a1cZ","(!tex_a1cZ)","(font_a1cY, (!tex_a1cZ))","no_a1cS","x_a1d0","n_a1d1","n_a1d2","pes_a1d3","safebang@!pes_a1d3","(!pes_a1d3)","[]","pes_a1d4","p_a1d5","ps_a1d6","!ps_a1d6","(!ps_a1d6)","p_a1d5 : (!ps_a1d6)","(p_a1d5 : (!ps_a1d6))","!(p_a1d5 : (!ps_a1d6))","(!(p_a1d5 : (!ps_a1d6)))","((!(p_a1d5 : (!ps_a1d6))))","str_a1d8","!str_a1d8","(!str_a1d8)","no_a1d9","PE (!str_a1d8) no_a1d9","(PE (!str_a1d8) no_a1d9)","!(PE (!str_a1d8) no_a1d9)","(!(PE (!str_a1d8) no_a1d9))","((!(PE (!str_a1d8) no_a1d9)))","!((!(PE (!str_a1d8) no_a1d9)))","(!((!(PE (!str_a1d8) no_a1d9))))","x_a1da","safebang@!x_a1da","(!x_a1da)","dimX","dimY","dimX_a1db","safebang@!dimX_a1db","(!dimX_a1db)","maxX_a1dc","0","!0","(!0)","x_a1dg","!x_a1dg","(!x_a1dg)","x_a1dh","x_a1di","n_a1dj","safebang@!n_a1dj","(!n_a1dj)","n_a1dm","m_a1dl","!m_a1dl","(!m_a1dl)","dimY_a1dn","maxY_a1do","0","!0","(!0)","x_a1ds","x_a1dt","x_a1du","!x_a1du","(!x_a1du)","x_a1dv","safebang@!x_a1dv","(!x_a1dv)","n_a1dw","n_a1dz","m_a1dy","x_a1dA","safebang@!x_a1dA","(!x_a1dA)","y_a1dB","safebang@!y_a1dB","(!y_a1dB)","pts_a1dC","min_a1dD","x_a1dE","y_a1dF","safebang@!y_a1dF","(!y_a1dF)","Pt x_a1dE (!y_a1dF)","(Pt x_a1dE (!y_a1dF))","!(Pt x_a1dE (!y_a1dF))","(!(Pt x_a1dE (!y_a1dF)))","(min_a1dD, (!(Pt x_a1dE (!y_a1dF))))","!(min_a1dD, (!(Pt x_a1dE (!y_a1dF))))","(!(min_a1dD, (!(Pt x_a1dE (!y_a1dF)))))","x_a1dG","x_a1dH","m_a1dI","[]","p_a1dJ","safebang@!p_a1dJ","(!p_a1dJ)","ps_a1dK","(!p_a1dJ) : ps_a1dK","((!p_a1dJ) : ps_a1dK)","!((!p_a1dJ) : ps_a1dK)","(!((!p_a1dJ) : ps_a1dK))","p_a1dM","safebang@!p_a1dM","(!p_a1dM)","[]","![]","(![])","minx_a1dN","miny_a1dO","Pt minx_a1dN miny_a1dO","maxx_a1dP","safebang@!maxx_a1dP","(!maxx_a1dP)","maxy_a1dQ","Pt (!maxx_a1dP) maxy_a1dQ","(Pt minx_a1dN miny_a1dO, Pt (!maxx_a1dP) maxy_a1dQ)","x_a1dR","safebang@!x_a1dR","(!x_a1dR)","y_a1dS","safebang@!y_a1dS","(!y_a1dS)","Pt (!x_a1dR) (!y_a1dS)","ps_a1dT","!ps_a1dT","(!ps_a1dT)","Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT)","(Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT))","!(Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT))","(!(Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT)))","((!(Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT))))","!((!(Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT))))","(!((!(Pt (!x_a1dR) (!y_a1dS) : (!ps_a1dT)))))","minx'_a1dU","lazydmd@!minx'_a1dU","(!minx'_a1dU)","miny'_a1dV","lazydmd@!miny'_a1dV","(!miny'_a1dV)","maxx'_a1dW","maxy'_a1dX","x_a1dY","\"0\"","r_a1e0","r_a1e1","safebang@!r_a1e1","(!r_a1e1)","\"0\"","!\"0\"","(!\"0\")","(!r_a1e1) : (!\"0\")","((!r_a1e1) : (!\"0\"))","r_a1e2","m_a1e3","r_a1e2 : m_a1e3","(r_a1e2 : m_a1e3)","!(r_a1e2 : m_a1e3)","(!(r_a1e2 : m_a1e3))","((!(r_a1e2 : m_a1e3)))","!((!(r_a1e2 : m_a1e3)))","(!((!(r_a1e2 : m_a1e3))))","_","!_","(!_)"]
module Graph where
import Parse
import StdLib
import PSlib
import GRIP
paperX = 280 :: Int
paperY = 190 :: Int

my_fromInt :: Num a_ax0 => Int -> a_ax0
my_fromInt = fromInteger . toInteger
gspostscript (!str_aH4)
  = initialise stdheader ++ portrait ++ str_aH4 ++ "showpage\n"
postscript (!str_aH5)
  = initialise stdheader ++ landscape ++ str_aH5 ++ "showpage\n"
ePostscript (reqdx_aH6, reqdy_aH7) str_aH8
  = initialise
      (stdheader ++ "%%BoundingBox: 0 0 " ++ show (cms2pts reqdx_aH6) ++
         " "
         ++ show (cms2pts reqdy_aH7)
         ++ "\n"
         ++ "%%EndComments\n")
      ++
      scale (my_fromInt reqdx_aH6 * 10 / my_fromInt paperX)
        (my_fromInt reqdy_aH7 * 10 / my_fromInt paperY)
      ++ str_aH8
      ++ showpage
initGraph title_aPt (!pedata_aPu) (topX_aPv, (!topY_aPw))
  (norecord@((!xlabel_aPx), (!ylabel_aPy))) keys_aPz
  = drawBox (Pt 0 0) paperX paperY ++ drawBox (Pt 1 1) (paperX - 2) 5
      ++ drawBox (Pt 1 (paperY - 7)) (paperX - 2) 6
      ++ setfont "BOLD"
      ++ moveto (Pt (paperX `div` 2) (paperY - 6))
      ++ cjustify (title_aPt)
      ++ setfont "NORM"
      ++ placePEs pedata_aPu
      ++ translate 20 25
      ++ newpath
      ++ moveto (Pt 0 (-5))
      ++ lineto (Pt 0 dimY)
      ++ moveto (Pt (-5) 0)
      ++ lineto (Pt dimX 0)
      ++ stroke
      ++ setfont "SMALL"
      ++ markXAxis dimX topX_aPv
      ++ markYAxis dimY topY_aPw
      ++ moveto (Pt 0 (dimY + 4))
      ++ rjustify ylabel_aPy
      ++ stroke
      ++ moveto (Pt dimX (-8))
      ++ rjustify xlabel_aPx
      ++ stroke
      ++ setfont "NORM"
      ++ dokeys dimX keys_aPz
placePEs ((!pes_aPA), (!on_aPB))
  | checkPEs (tail pes_aPA) on_aPB =
    showActive (length pes_aPA) (length used_aPC) ++
      showUsed pes_aPA used_aPC
      ++ setfont "NORM"
  where (!used_aPC) = if on_aPB == [] then tail pes_aPA else on_aPB

cms2pts :: Int -> Int
cms2pts x_a1cr = round (28.4584 * my_fromInt x_a1cr)

plotCurve :: Int -> [Point] -> Postscript
plotCurve (norecord@x_a1cs) pts_a1ct
  = setgray x_a1cs ++ fillObject pts_a1ct

plot :: [Point] -> Postscript
plot points_a1cu = plotCurve 5 (Pt 0 0 : points_a1cu)
dokeys left_a1cv keys_a1cw
  = concat (map2 format_a1cx (places_a1cz 0) keys_a1cw)
  where format_a1cx (norecord@pt_a1cA@(Pt (!x_a1cB) (!y_a1cC)))
          (col_a1cD, tex_a1cE, pc_a1cF)
          = fillBox pt_a1cA 16 9 col_a1cD ++ stroke ++
              moveto (Pt (x_a1cB + 17) (y_a1cC + 3))
              ++ text tex_a1cE
              ++ stroke
              ++ moveto (Pt (x_a1cB + 8) (y_a1cC + 3))
              ++ inv col_a1cD
              ++ setfont "BOLD"
              ++ cjustify (pc_a1cF)
              ++ stroke
              ++ setfont "NORM"
              ++ setgray 10
        no_a1cy = left_a1cv `div` length keys_a1cw
        places_a1cz (!n_a1cG) | n_a1cG == no_a1cy = []
        places_a1cz n_a1cH
          = (Pt (n_a1cH * no_a1cy) (-17)) : places_a1cz (n_a1cH + 1)
showActive t_a1cI (!f_a1cJ)
  = setfont "LARGE" ++ moveto (Pt 10 16) ++ cjustify (show f_a1cJ) ++
      setfont "SMALL"
      ++ moveto (Pt 10 12)
      ++ cjustify "PE(s)"
      ++ stroke
      ++ setfont "SMALL"
      ++ moveto (Pt 10 8)
      ++ cjustify "displayed"
      ++ stroke
      ++ setfont "NORM"
showUsed ((norecord@((!m_a1cK) : pes_a1cL))) on_a1cM
  = moveto (Pt 2 2) ++ setfont "SMALL" ++ text "Configuration:" ++
      dopes (paperX - 27)
        (("SMALLITALIC", showPE m_a1cK) : map f_a1cN pes_a1cL)
      ++ stroke
  where f_a1cN pe_a1cO
          | elem pe_a1cO on_a1cM = ("SMALLBOLD", showPE pe_a1cO)
          | otherwise = ("SMALL", showPE pe_a1cO)
dopes left_a1cP (!pes_a1cQ)
  = concat (map2 format_a1cR (places_a1cU 0) pes_a1cQ)
  where format_a1cR pt_a1cV@(Pt (!x_a1cW) (!y_a1cX))
          (font_a1cY, (!tex_a1cZ))
          = setfont font_a1cY ++ moveto pt_a1cV ++ text tex_a1cZ ++ stroke
        no_a1cS = left_a1cP `div` ((length pes_a1cQ * 2) + 1)
        f_a1cT x_a1d0 = (no_a1cS * ((x_a1d0 * 2) + 1)) + 27
        places_a1cU n_a1d1 | n_a1d1 > 2 * no_a1cS = []
        places_a1cU n_a1d2
          = (Pt (f_a1cT n_a1d2) 2) : places_a1cU (n_a1d2 + 1)
checkPEs (!pes_a1d3) [] = True
checkPEs pes_a1d4 ((norecord@(p_a1d5 : (norecord@ps_a1d6))))
  | elem p_a1d5 pes_a1d4 = checkPEs pes_a1d4 ps_a1d6
  | otherwise =
    error
      ("Attempt to gather information from inactive PE - " ++
         showPE p_a1d5)

showPE :: PElement -> String
showPE (norecord@((norecord@(PE (norecord@str_a1d8) no_a1d9))))
  = str_a1d8 ++ "." ++ show no_a1d9
inv (!x_a1da)
  | x_a1da >= 5 = setgray 0
  | otherwise = setgray 10
dimX = paperX - 30
dimY = paperY - 40

markXAxis :: Int -> Int -> Postscript
markXAxis (!dimX_a1db) maxX_a1dc = label_a1dd 10 ++ markOnX 100
  where label_a1dd (norecord@0) = ""
        label_a1dd (norecord@x_a1dg)
          = newpath ++ moveto (Pt (notch_a1df x_a1dg) 0) ++ rlineto 0 (-2) ++
              moveto (Pt (notch_a1df x_a1dg) (-5))
              ++ cjustify (printFloat (t_a1de x_a1dg))
              ++ stroke
              ++ label_a1dd (x_a1dg - 1)
        t_a1de x_a1dh
          = my_fromInt x_a1dh * (my_fromInt maxX_a1dc / my_fromInt 10)
        notch_a1df x_a1di = x_a1di * (dimX_a1db `div` 10)
markOnX (!n_a1dj) = mapcat notches_a1dk [1 .. n_a1dj] ++ stroke
  where notches_a1dk n_a1dm
          = movetofloat (m_a1dl * my_fromInt n_a1dm) 0 ++ (rlineto 0 (-1)) ++
              stroke
        (norecord@m_a1dl) = my_fromInt dimX / my_fromInt n_a1dj

markYAxis :: Int -> Int -> Postscript
markYAxis dimY_a1dn maxY_a1do
  = label_a1dp 10 ++ markOnY (calibrate maxY_a1do)
  where label_a1dp (norecord@0) = ""
        label_a1dp x_a1ds
          = newpath ++ moveto (Pt 0 (notch_a1dr x_a1ds)) ++ rlineto (-2) 0 ++
              moveto (Pt (-3) (notch_a1dr x_a1ds))
              ++ rjustify (printFloat (t_a1dq x_a1ds))
              ++ stroke
              ++ label_a1dp (x_a1ds - 1)
        t_a1dq x_a1dt
          = my_fromInt x_a1dt * (my_fromInt maxY_a1do / my_fromInt 10)
        notch_a1dr (norecord@x_a1du) = x_a1du * (dimY_a1dn `div` 10)
calibrate (!x_a1dv)
  | x_a1dv <= 1 = 1
  | x_a1dv <= 100 = x_a1dv
  | otherwise = calibrate (x_a1dv `div` 10)
markOnY n_a1dw = mapcat notches_a1dx [1 .. n_a1dw] ++ stroke
  where notches_a1dx n_a1dz
          = movetofloat 0 (m_a1dy * my_fromInt n_a1dz) ++ (rlineto (-1) 0)
        m_a1dy = my_fromInt dimY / my_fromInt n_a1dw
movetofloat (!x_a1dA) (!y_a1dB)
  = show x_a1dA ++ " " ++ show y_a1dB ++ " moveto\n"

determineScale :: [Point] -> (Int, Int)
determineScale pts_a1dC = (axisScale x_a1dE, axisScale y_a1dF)
  where (norecord@(min_a1dD, (norecord@(Pt x_a1dE (!y_a1dF)))))
          = minandmax pts_a1dC

axisScale :: Int -> Int
axisScale x_a1dG = axisScale' x_a1dG 1
axisScale' x_a1dH m_a1dI
  | x_a1dH <= m_a1dI = m_a1dI
  | x_a1dH <= m_a1dI * 2 = m_a1dI * 2
  | x_a1dH <= m_a1dI * 5 = m_a1dI * 5
  | x_a1dH <= m_a1dI * 10 = m_a1dI * 10
  | otherwise = axisScale' x_a1dH (m_a1dI * 10)

minandmax :: [Point] -> (Point, Point)
minandmax [] = error "No points"
minandmax (norecord@((!p_a1dJ) : ps_a1dK))
  = f_a1dL (p_a1dJ, p_a1dJ) ps_a1dK
  where f_a1dL (!p_a1dM) (norecord@[]) = p_a1dM
        f_a1dL (Pt minx_a1dN miny_a1dO, Pt (!maxx_a1dP) maxy_a1dQ)
          (norecord@((norecord@(Pt (!x_a1dR) (!y_a1dS) :
                                  (norecord@ps_a1dT)))))
          = f_a1dL (Pt minx'_a1dU miny'_a1dV, Pt maxx'_a1dW maxy'_a1dX)
              ps_a1dT
          where (lazydmd@minx'_a1dU) = min x_a1dR minx_a1dN
                (lazydmd@miny'_a1dV) = min y_a1dS miny_a1dO
                maxx'_a1dW = max x_a1dR maxx_a1dP
                maxy'_a1dX = max y_a1dS maxy_a1dQ

printFloat :: Float -> String
printFloat x_a1dY = f_a1dZ (show (round (x_a1dY * 10)))
  where f_a1dZ "0" = "0"
        f_a1dZ r_a1e0 | x_a1dY < 1 = "0." ++ r_a1e0
        f_a1dZ ((!r_a1e1) : (norecord@"0")) | x_a1dY < 10 = [r_a1e1]
        f_a1dZ (norecord@((norecord@(r_a1e2 : m_a1e3))))
          | x_a1dY < 10 = r_a1e2 : '.' : m_a1e3
        f_a1dZ (norecord@_) = show (round x_a1dY)
STARTLOG
["selectpes_aJj","statFile_aJk","sparkGraph_aJl","usedGraph_aJm","safebang@!usedGraph_aJm","(!usedGraph_aJm)","(sparkGraph_aJl, (!usedGraph_aJm))","!(sparkGraph_aJl, (!usedGraph_aJm))","(!(sparkGraph_aJl, (!usedGraph_aJm)))","pes_aJn","ticks_aJo","orderedStats_aJp","(pes_aJn, ticks_aJo, orderedStats_aJp)","height_aJq","stats_aJr","safebang@!stats_aJr","(!stats_aJr)","traces_aJs","sparks_aJt","!sparks_aJt","(!sparks_aJt)","used_aJu","resumed_aJv","!resumed_aJv","(!resumed_aJv)","((!sparks_aJt), used_aJu, (!resumed_aJv))","!((!sparks_aJt), used_aJu, (!resumed_aJv))","(!((!sparks_aJt), used_aJu, (!resumed_aJv)))","_","!_","(!_)","h_aJw","width_aJx","!width_aJx","(!width_aJx)","((!((!sparks_aJt), used_aJu, (!resumed_aJv))), (!_), h_aJw,\n (!width_aJx))","!((!((!sparks_aJt), used_aJu, (!resumed_aJv))), (!_), h_aJw,\n  (!width_aJx))","(!((!((!sparks_aJt), used_aJu, (!resumed_aJv))), (!_), h_aJw,\n   (!width_aJx)))","(traces_aJs,\n (!((!((!sparks_aJt), used_aJu, (!resumed_aJv))), (!_), h_aJw,\n    (!width_aJx))))","c''_aTz","safebang@!c''_aTz","(!c''_aTz)","u''_aTA","r''_aTB","safebang@!r''_aTB","(!r''_aTB)","((!c''_aTz), u''_aTA, (!r''_aTB))","l''_aTC","m_aTD","_","(((!c''_aTz), u''_aTA, (!r''_aTB)), l''_aTC, m_aTD, _)","!(((!c''_aTz), u''_aTA, (!r''_aTB)), l''_aTC, m_aTD, _)","(!(((!c''_aTz), u''_aTA, (!r''_aTB)), l''_aTC, m_aTD, _))","n_aTE","safebang@!n_aTE","(!n_aTE)","c_aTF","u_aTG","r_aTH","safebang@!r_aTH","(!r_aTH)","l_aTI","Sp (!n_aTE) c_aTF u_aTG (!r_aTH) l_aTI","(Sp (!n_aTE) c_aTF u_aTG (!r_aTH) l_aTI)","p'_aTJ","u'_aTK","l'_aTL","!l'_aTL","(!l'_aTL)","t_a17a","[]","t_a17b","!t_a17b","(!t_a17b)","a_a17d","!a_a17d","(!a_a17d)","as_a17e","(!a_a17d) : as_a17e","((!a_a17d) : as_a17e)","!((!a_a17d) : as_a17e)","(!((!a_a17d) : as_a17e))","((!((!a_a17d) : as_a17e)))","l_a17c@((!((!a_a17d) : as_a17e)))","n_a17f","_","a_a17g","!a_a17g","(!a_a17g)","b_a17h","!b_a17h","(!b_a17h)","c_a17i","!c_a17i","(!c_a17i)","d_a17j","Sp _ (!a_a17g) (!b_a17h) (!c_a17i) d_a17j","(Sp _ (!a_a17g) (!b_a17h) (!c_a17i) d_a17j)","n_a17k","a'_a17l","!a'_a17l","(!a'_a17l)","b'_a17m","c'_a17n","d'_a17o","Sp n_a17k (!a'_a17l) b'_a17m c'_a17n d'_a17o","(Sp n_a17k (!a'_a17l) b'_a17m c'_a17n d'_a17o)","nullstate","traces_a17p","[]","n_a17r","p_a17s","safebang@!p_a17s","(!p_a17s)","u_a17t","safebang@!u_a17t","(!u_a17t)","l_a17u","[(!p_a17s), (!u_a17t), l_a17u]","![(!p_a17s), (!u_a17t), l_a17u]","(![(!p_a17s), (!u_a17t), l_a17u])","T n_a17r (![(!p_a17s), (!u_a17t), l_a17u])","ts_a17v","!ts_a17v","(!ts_a17v)","T n_a17r (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v)","(T n_a17r (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v))","!(T n_a17r (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v))","(!(T n_a17r (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v)))","((!(T n_a17r (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v))))","!((!(T n_a17r (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v))))","(!((!(T n_a17r (![(!p_a17s), (!u_a17t), l_a17u]) : (!ts_a17v)))))","pas_a17w","safebang@!pas_a17w","(!pas_a17w)","pbs_a17x","safebang@!pbs_a17x","(!pbs_a17x)","((!pas_a17w), (!pbs_a17x))","!((!pas_a17w), (!pbs_a17x))","(!((!pas_a17w), (!pbs_a17x)))","t_a17y","t'_a17z","!t'_a17z","(!t'_a17z)"]
module Pool (poolGraph) where
import StdLib
import GRIP
import PSlib
import Graph
import Parse
poolGraph selectpes_aJj statFile_aJk
  = initGraph "Spark Pool Profile Graph" (pes_aJn, selectpes_aJj)
      (100 * ticks_aJo, height_aJq)
      ("Time (ms)", "Sparks")
      [(5, "Spark Residency", ""), (0, "Sparks Used", "")]
      ++
      scale (my_fromInt dimX / my_fromInt 200)
        (my_fromInt dimY / my_fromInt height_aJq)
      ++ plotCurve 0 usedGraph_aJm
      ++ plotCurve 5 sparkGraph_aJl
  where (norecord@(sparkGraph_aJl, (!usedGraph_aJm)))
          = outlineGraphs (traces_aJs ++ [T width_aJx [0, 0, 0]])
        (pes_aJn, ticks_aJo, orderedStats_aJp) = getParameters stats_aJr
        height_aJq = axisScale h_aJw
        (!stats_aJr) = parseFile statFile_aJk
        (traces_aJs,
         (norecord@((norecord@((norecord@sparks_aJt), used_aJu,
                               (norecord@resumed_aJv))),
                    (norecord@_), h_aJw, (norecord@width_aJx))))
          = akkumulate processSparks nullstate
              (gatherSp (Sp 0 0 0 0 0) (getSp selectpes_aJj orderedStats_aJp))
processSparks
  (norecord@(((!c''_aTz), u''_aTA, (!r''_aTB)), l''_aTC, m_aTD, _))
  (Sp (!n_aTE) c_aTF u_aTG (!r_aTH) l_aTI)
  = (T n_aTE [p'_aTJ, u'_aTK, l'_aTL],
     ((c''_aTz + c_aTF, u''_aTA + u_aTG, r''_aTB + r_aTH), l'_aTL,
      max m_aTD p'_aTJ, n_aTE))
  where p'_aTJ = l''_aTC + c_aTF
        u'_aTK = p'_aTJ - l_aTI
        (norecord@l'_aTL) = p'_aTJ - u_aTG - l_aTI
gatherSp t_a17a [] = [t_a17a]
gatherSp (norecord@t_a17b)
  l_a17c@((norecord@((norecord@a_a17d) : as_a17e)))
  | numberSp t_a17b == numberSp a_a17d =
    gatherSp (addSparks t_a17b a_a17d) as_a17e
  | otherwise = t_a17b : gatherSp (Sp (n_a17f + 1) 0 0 0 0) l_a17c
  where n_a17f = numberSp t_a17b
addSparks
  (Sp _ (norecord@a_a17g) (norecord@b_a17h) (norecord@c_a17i) d_a17j)
  (Sp n_a17k (norecord@a'_a17l) b'_a17m c'_a17n d'_a17o)
  = Sp n_a17k (a_a17g + a'_a17l) (b_a17h + b'_a17m)
      (c_a17i + c'_a17n)
      (d_a17j + d'_a17o)
nullstate = ((0, 0, 0), 0, 0, 0)

outlineGraphs :: [Trace] -> ([Point], [Point])
outlineGraphs traces_a17p = aux_a17q traces_a17p
  where aux_a17q [] = ([], [])
        aux_a17q
          (norecord@((norecord@(T n_a17r
                                  (norecord@[(!p_a17s), (!u_a17t), l_a17u])
                                  : (norecord@ts_a17v)))))
          = (Pt t_a17y p_a17s : Pt t_a17y l_a17u : Pt t'_a17z l_a17u :
               pas_a17w,
             Pt t_a17y u_a17t : Pt t'_a17z l_a17u : pbs_a17x)
          where (norecord@((!pas_a17w), (!pbs_a17x))) = aux_a17q ts_a17v
                t_a17y = n_a17r * 2
                (norecord@t'_a17z) = n_a17r * 2 + 1

data Trace = T Int [Int]
           deriving Show

type Object = [Point]
STARTLOG
["ordering_aOB","selectpes_aOC","statFile_aOD","a_aOO","!a_aOO","(!a_aOO)","active_aOF","!active_aOF","(!active_aOF)","maxticks_aOG","pes_aOH","ticks_aOI","orderedStats_aOJ","(pes_aOH, ticks_aOI, orderedStats_aOJ)","traces_aOK","!traces_aOK","(!traces_aOK)","aggs_aOL","((!traces_aOK), aggs_aOL)","!((!traces_aOK), aggs_aOL)","(!((!traces_aOK), aggs_aOL))","order_aOM","stats_aON","safebang@!stats_aON","(!stats_aON)","extractors_a18e","!extractors_a18e","(!extractors_a18e)","i_a18f","safebang@!i_a18f","(!i_a18f)","r_a18g","g_a18h","safebang@!g_a18h","(!g_a18h)","f_a18i","safebang@!f_a18i","(!f_a18i)","t_a18j","((!i_a18f), r_a18g, (!g_a18h), (!f_a18i), t_a18j)","!((!i_a18f), r_a18g, (!g_a18h), (!f_a18i), t_a18j)","(!((!i_a18f), r_a18g, (!g_a18h), (!f_a18i), t_a18j))","n_a18l","i'_a18m","!i'_a18m","(!i'_a18m)","r'_a18n","g'_a18o","f'_a18p","t'_a18q","Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p t'_a18q","(Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p t'_a18q)","!(Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p t'_a18q)","(!(Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p t'_a18q))","((!(Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p t'_a18q)))","!((!(Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p t'_a18q)))","(!((!(Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p t'_a18q))))","a_a18k@(!((!(Act n_a18l (!i'_a18m) r'_a18n g'_a18o f'_a18p\n               t'_a18q))))","_","m_a18s","safebang@!m_a18s","(!m_a18s)","_","(!m_a18s) : _","((!m_a18s) : _)","T _ ((!m_a18s) : _)","(T _ ((!m_a18s) : _))","trace_a18r@(T _ ((!m_a18s) : _))","!trace_a18r@(T _ ((!m_a18s) : _))","(!trace_a18r@(T _ ((!m_a18s) : _)))","fs_a18t","n_a18u","s_a18v","!s_a18v","(!s_a18v)","[]","![]","(![])","e_a18y","es_a18z","safebang@!es_a18z","(!es_a18z)","e_a18y : (!es_a18z)","(e_a18y : (!es_a18z))","ex_a18x@(e_a18y : (!es_a18z))","nullstate","n_a18A","safebang@!n_a18A","(!n_a18A)","a_a18B","safebang@!a_a18B","(!a_a18B)","T (!n_a18A) (!a_a18B)","(T (!n_a18A) (!a_a18B))","!(T (!n_a18A) (!a_a18B))","(!(T (!n_a18A) (!a_a18B)))","[(!(T (!n_a18A) (!a_a18B)))]","x_a18C","n_a18D","a_a18E","T n_a18D a_a18E","(T n_a18D a_a18E)","!(T n_a18D a_a18E)","(!(T n_a18D a_a18E))","more_a18F","(!(T n_a18D a_a18E)) : more_a18F","((!(T n_a18D a_a18E)) : more_a18F)","x_a18G","IDLE","i_a18H","safebang@!i_a18H","(!i_a18H)","_","_","_","t_a18I","safebang@!t_a18I","(!t_a18I)","((!i_a18H), _, _, _, (!t_a18I))","!((!i_a18H), _, _, _, (!t_a18I))","(!((!i_a18H), _, _, _, (!t_a18I)))","REDN","_","!_","(!_)","r_a18J","_","!_","(!_)","_","!_","(!_)","t_a18K","safebang@!t_a18K","(!t_a18K)","((!_), r_a18J, (!_), (!_), (!t_a18K))","!((!_), r_a18J, (!_), (!_), (!t_a18K))","(!((!_), r_a18J, (!_), (!_), (!t_a18K)))","GC","!GC","(!GC)","_","!_","(!_)","_","g_a18L","safebang@!g_a18L","(!g_a18L)","_","!_","(!_)","t_a18M","((!_), _, (!g_a18L), (!_), t_a18M)","FLUSH","!FLUSH","(!FLUSH)","_","_","!_","(!_)","_","f_a18N","t_a18O","safebang@!t_a18O","(!t_a18O)","(_, (!_), _, f_a18N, (!t_a18O))","x_a18P","y_a18Q","!y_a18Q","(!y_a18Q)","t_a18R","safebang@!t_a18R","(!t_a18R)","[]","t_a18S","a_a18U","as_a18V","!as_a18V","(!as_a18V)","a_a18U : (!as_a18V)","(a_a18U : (!as_a18V))","!(a_a18U : (!as_a18V))","(!(a_a18U : (!as_a18V)))","((!(a_a18U : (!as_a18V))))","l_a18T@((!(a_a18U : (!as_a18V))))","n_a18W","[]","![]","(![])","_","!_","(!_)","f_a18X","safebang@!f_a18X","(!f_a18X)","fs_a18Y","(!f_a18X) : fs_a18Y","((!f_a18X) : fs_a18Y)","a_a18Z","REDN","!REDN","(!REDN)","IDLE","GC","FLUSH","!FLUSH","(!FLUSH)","REDN","!REDN","(!REDN)","IDLE","!IDLE","(!IDLE)","FLUSH","GC","REDN","!REDN","(!REDN)","GC","!GC","(!GC)","FLUSH","IDLE","_","a_a190","b_a191","!b_a191","(!b_a191)","c_a192","!c_a192","(!c_a192)","d_a193","!d_a193","(!d_a193)","t1_a194","!t1_a194","(!t1_a194)","Act _ a_a190 (!b_a191) (!c_a192) (!d_a193) (!t1_a194)","(Act _ a_a190 (!b_a191) (!c_a192) (!d_a193) (!t1_a194))","n_a195","e_a196","!e_a196","(!e_a196)","f_a197","!f_a197","(!f_a197)","g_a198","h_a199","!h_a199","(!h_a199)","t2_a19a","Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a","(Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a)","!(Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a)","(!(Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a))","((!(Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a)))","!((!(Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a)))","(!((!(Act n_a195 (!e_a196) (!f_a197) g_a198 (!h_a199) t2_a19a))))","'R'","string_a19b","lazydmd@!string_a19b","(!string_a19b)","'R' : (!string_a19b)","('R' : (!string_a19b))","'G'","string_a19c","!string_a19c","(!string_a19c)","'G' : (!string_a19c)","('G' : (!string_a19c))","!('G' : (!string_a19c))","(!('G' : (!string_a19c)))","((!('G' : (!string_a19c))))","'F'","!'F'","(!'F')","string_a19d","lazydmd@!string_a19d","(!string_a19d)","(!'F') : (!string_a19d)","((!'F') : (!string_a19d))","!((!'F') : (!string_a19d))","(!((!'F') : (!string_a19d)))","((!((!'F') : (!string_a19d))))","!((!((!'F') : (!string_a19d))))","(!((!((!'F') : (!string_a19d)))))","'I'","!'I'","(!'I')","string_a19e","(!'I') : string_a19e","((!'I') : string_a19e)","string_a19f","(string_a19f)"]
module Activity (activityGraph, Activity(..)) where
import GRIP
import StdLib
import PSlib
import Graph
import Parse
activityGraph ordering_aOB selectpes_aOC statFile_aOD
  = initGraph "Processor Activity Graph" (pes_aOH, selectpes_aOC)
      (ticks_aOI * 100, 100)
      ("Time (ms)", "% Activity")
      (map f_aOE ordering_aOB)
      ++
      scale (my_fromInt dimX / my_fromInt 100)
        (my_fromInt dimY / my_fromInt (maxticks_aOG))
      ++
      concat
        (map2 plotCurve (map colour order_aOM) (outlinesTrace traces_aOK))
  where f_aOE (norecord@a_aOO)
          = (colour a_aOO, display a_aOO, aggr a_aOO aggs_aOL)
        (norecord@active_aOF)
          = if selectpes_aOC == [] then length pes_aOH - 1 else
              length selectpes_aOC
        maxticks_aOG = active_aOF * ticks_aOI
        (pes_aOH, ticks_aOI, orderedStats_aOJ) = getParameters stats_aON
        (norecord@((norecord@traces_aOK), aggs_aOL))
          = (akkumulate (processAct (map extractor order_aOM)) nullstate .
               gatherAct (Act 0 0 0 0 0 0)
               . map (scaleAct ticks_aOI)
               . getAct selectpes_aOC)
              orderedStats_aOJ
        order_aOM = reverse ordering_aOB
        (!stats_aON) = parseFile statFile_aOD

processAct ::
           [Activities -> Int] -> State -> Activities -> (Trace, State)
processAct (norecord@extractors_a18e)
  (norecord@((!i_a18f), r_a18g, (!g_a18h), (!f_a18i), t_a18j))
  a_a18k@(norecord@((norecord@(Act n_a18l (norecord@i'_a18m) r'_a18n
                                 g'_a18o f'_a18p t'_a18q))))
  = (trace_a18r,
     (i'_a18m + i_a18f, r'_a18n + r_a18g, g'_a18o + g_a18h,
      f'_a18p + f_a18i, t_a18j + t'_a18q))
  where (norecord@trace_a18r@(T _ ((!m_a18s) : _)))
          = makeTrace extractors_a18e n_a18l a_a18k
makeTrace fs_a18t n_a18u (norecord@s_a18v)
  = T n_a18u (f_a18w fs_a18t)
  where f_a18w (norecord@[]) = []
        f_a18w ex_a18x@(e_a18y : (!es_a18z))
          = sum (pam ex_a18x s_a18v) : f_a18w es_a18z
nullstate = (0, 0, 0, 0, 0)

outlinesTrace :: [Trace] -> [[Point]]
outlinesTrace [(norecord@(T (!n_a18A) (!a_a18B)))]
  = map (\ x_a18C -> [Pt n_a18A x_a18C]) a_a18B
outlinesTrace ((norecord@(T n_a18D a_a18E)) : more_a18F)
  = map2 (:) (map (\ x_a18G -> Pt n_a18D x_a18G) a_a18E)
      (outlinesTrace more_a18F)
aggr IDLE (norecord@((!i_a18H), _, _, _, (!t_a18I)))
  = printFloat (percentage i_a18H t_a18I) ++ "%"
aggr REDN
  (norecord@((norecord@_), r_a18J, (norecord@_), (norecord@_),
             (!t_a18K)))
  = printFloat (percentage r_a18J t_a18K) ++ "%"
aggr (norecord@GC)
  ((norecord@_), _, (!g_a18L), (norecord@_), t_a18M)
  = printFloat (percentage g_a18L t_a18M) ++ "%"
aggr (norecord@FLUSH) (_, (norecord@_), _, f_a18N, (!t_a18O))
  = printFloat (percentage f_a18N t_a18O) ++ "%"
percentage x_a18P (norecord@y_a18Q)
  = my_fromInt x_a18P * 100 / my_fromInt y_a18Q

gatherAct :: Activities -> [Activities] -> [Activities]
gatherAct (!t_a18R) []
  = [t_a18R, (Act (numberAct t_a18R + 1) 0 0 0 0 0)]
gatherAct t_a18S l_a18T@((norecord@(a_a18U : (norecord@as_a18V))))
  | numberAct t_a18S == numberAct a_a18U =
    gatherAct (addAct t_a18S a_a18U) as_a18V
  | otherwise =
    t_a18S : gatherAct (Act (n_a18W + 1) 0 0 0 0 0) l_a18T
  where n_a18W = numberAct t_a18S
pam (norecord@[]) (norecord@_) = []
pam ((!f_a18X) : fs_a18Y) a_a18Z
  = f_a18X a_a18Z : pam fs_a18Y a_a18Z
extractor (norecord@REDN) = reduction
extractor IDLE = idle
extractor GC = gc
extractor (norecord@FLUSH) = flush
colour (norecord@REDN) = 0
colour (norecord@IDLE) = 8
colour FLUSH = 5
colour GC = 2
display (norecord@REDN) = "Reduction"
display (norecord@GC) = "Garbage Collection"
display FLUSH = "Flush Read/Write"
display IDLE = "Idle"
addAct
  (Act _ a_a190 (norecord@b_a191) (norecord@c_a192) (norecord@d_a193)
     (norecord@t1_a194))
  (norecord@((norecord@(Act n_a195 (norecord@e_a196)
                          (norecord@f_a197) g_a198 (norecord@h_a199) t2_a19a))))
  = Act n_a195 (a_a190 + e_a196) (b_a191 + f_a197) (c_a192 + g_a198)
      (d_a193 + h_a199)
      (t1_a194 + t2_a19a)

type State = (Int, Int, Int, Int, Int)

data Trace = T Int [Int]

data Activity = REDN
              | IDLE
              | FLUSH
              | GC
              deriving Eq

instance Parse Activity where
        parseType ('R' : (lazydmd@string_a19b)) = (REDN, string_a19b)
        parseType ((norecord@('G' : (norecord@string_a19c))))
          = (GC, string_a19c)
        parseType
          (norecord@((norecord@((norecord@'F') : (lazydmd@string_a19d)))))
          = (FLUSH, string_a19d)
        parseType ((norecord@'I') : string_a19e) = (IDLE, string_a19e)
        parseType (string_a19f)
          = error ("No such Activity : " ++ show string_a19f ++ "\n")
STARTLOG
["ch_aBK","[]","ch_aBL","!ch_aBL","(!ch_aBL)","xs_aBM","!xs_aBM","(!xs_aBM)","x_aBR","ch_aBO","l_aBP","!l_aBP","(!l_aBP)","_","r_aBQ","_ : r_aBQ","((!l_aBP), _ : r_aBQ)","whiteSpace","string_avy","x_avz","parseLine","a_aBI","safebang@!a_aBI","(!a_aBI)","_","!_","(!_)","((!a_aBI), (!_))","parse","x_aBJ","more_aT6","safebang@!more_aT6","(!more_aT6)","l_aT7","!l_aT7","(!l_aT7)","']'","out_aT8","safebang@!out_aT8","(!out_aT8)","']' : (!out_aT8)","((!l_aT7), ']' : (!out_aT8))","!((!l_aT7), ']' : (!out_aT8))","(!((!l_aT7), ']' : (!out_aT8)))","x_aT9","forced","ch_aTa","str_aTb","safebang@!str_aTb","(!str_aTb)","ch_aTa : (!str_aTb)","(ch_aTa : (!str_aTb))","!(ch_aTa : (!str_aTb))","(!(ch_aTa : (!str_aTb)))","((!(ch_aTa : (!str_aTb))))","!((!(ch_aTa : (!str_aTb))))","(!((!(ch_aTa : (!str_aTb)))))","n_aTc","str_aTd","l_aTf","r_aTg","!r_aTg","(!r_aTg)","(l_aTf, (!r_aTg))","n_aTh","safebang@!n_aTh","(!n_aTh)"]
module Parse (Parse(..), whiteSpace, seperatedBy) where
import Data.Char
import StdLib

seperatedBy :: Char -> String -> [String]
seperatedBy ch_aBK [] = []
seperatedBy (norecord@ch_aBL) (norecord@xs_aBM)
  = twaddle_aBN ch_aBL (span' (\ x_aBR -> x_aBR /= ch_aBL) xs_aBM)
  where twaddle_aBN ch_aBO ((norecord@l_aBP), _ : r_aBQ)
          = l_aBP : seperatedBy ch_aBO r_aBQ

whiteSpace :: String -> String
whiteSpace = dropWhile isSpace

class Parse a_avq where
        parseFile :: String -> [a_avq]
        
        parseLine :: String -> a_avq
        
        parse :: String -> (a_avq, String)
        
        parseType :: String -> (a_avq, String)
        
        forced :: a_avq -> Bool
        parseFile string_avy | all forced x_avz = x_avz
          where x_avz = map parseLine (lines' string_avy)
        parseLine = pl_aBH . parse
          where pl_aBH ((!a_aBI), (norecord@_)) = a_aBI
        parse = parseType . whiteSpace
        forced x_aBJ = True

instance (Parse a_aT5) => Parse [a_aT5] where
        parseType (!more_aT6)
          = (map parseLine (seperatedBy ',' (l_aT7 ++ ",")), out_aT8)
          where (norecord@((norecord@l_aT7), ']' : (!out_aT8)))
                  = span' (\ x_aT9 -> x_aT9 /= ']') (tail more_aT6)
        forced = all forced

instance Parse Char where
        parseType (norecord@((norecord@(ch_aTa : (!str_aTb)))))
          = (ch_aTa, str_aTb)
        forced n_aTc = True

instance Parse Int where
        parseType str_aTd = pl_aTe (span' isDigit str_aTd)
          where pl_aTe (l_aTf, (norecord@r_aTg)) = (strToInt l_aTf, r_aTg)
        forced (!n_aTh) | n_aTh >= 0 = True
STARTLOG
["a_aAU","b_aAV","a_aAW","as_aAX","safebang@!as_aAX","(!as_aAX)","b_aAY","safebang@!b_aAY","(!b_aAY)","((!as_aAX), (!b_aAY))","b_aAZ","a_aB0","bs_aB1","(a_aB0, bs_aB1)","f_aB2","safebang@!f_aB2","(!f_aB2)","[]","_","!_","(!_)","f_aB3","_","!_","(!_)","[]","![]","(![])","f_aB4","!f_aB4","(!f_aB4)","a_aB5","l_aB6","!l_aB6","(!l_aB6)","a_aB5 : (!l_aB6)","(a_aB5 : (!l_aB6))","!(a_aB5 : (!l_aB6))","(!(a_aB5 : (!l_aB6)))","((!(a_aB5 : (!l_aB6))))","b_aB7","!b_aB7","(!b_aB7)","k_aB8","(!b_aB7) : k_aB8","((!b_aB7) : k_aB8)","!((!b_aB7) : k_aB8)","(!((!b_aB7) : k_aB8))","((!((!b_aB7) : k_aB8)))","f_aB9","[]","f_aBa","a_aBb","safebang@!a_aBb","(!a_aBb)","l_aBc","safebang@!l_aBc","(!l_aBc)","(!a_aBb) : (!l_aBc)","((!a_aBb) : (!l_aBc))","[]","![]","(![])","a_aBd","l_aBe","a_aBd : l_aBe","(a_aBd : l_aBe)","low_aBf","high_aBg","!high_aBg","(!high_aBg)","(low_aBf, (!high_aBg))","_","[]","![]","(![])","i_aBh","!i_aBh","(!i_aBh)","a_aBi","l_aBj","!l_aBj","(!l_aBj)","a_aBi : (!l_aBj)","(a_aBi : (!l_aBj))","low_aBl","high_aBm","(low_aBl, high_aBm)","!(low_aBl, high_aBm)","(!(low_aBl, high_aBm))","a_aBn","safebang@!a_aBn","(!a_aBn)","[]","![]","(![])","a_aBo","x_aBq","xs_aBr","x_aBq : xs_aBr","(x_aBq : xs_aBr)","!(x_aBq : xs_aBr)","(!(x_aBq : xs_aBr))","as_aBp@(!(x_aBq : xs_aBr))","a_aBs","[]","a_aBt","x_aBu","xs_aBv","safebang@!xs_aBv","(!xs_aBv)","x_aBu : (!xs_aBv)","(x_aBu : (!xs_aBv))","a_aBw","[]","![]","(![])","a_aBx","!a_aBx","(!a_aBx)","x_aBy","xs_aBz","!xs_aBz","(!xs_aBz)","x_aBy : (!xs_aBz)","(x_aBy : (!xs_aBz))","!(x_aBy : (!xs_aBz))","(!(x_aBy : (!xs_aBz)))","_","!_","(!_)","[]","![]","(![])","_","!_","(!_)","_","!_","(!_)","_","!_","(!_)","[]","p_aBA","!p_aBA","(!p_aBA)","a_aBC","!a_aBC","(!a_aBC)","l_aBD","(!a_aBC) : l_aBD","((!a_aBC) : l_aBD)","!((!a_aBC) : l_aBD)","(!((!a_aBC) : l_aBD))","as_aBB@(!((!a_aBC) : l_aBD))","b_aBF","!b_aBF","(!b_aBF)","k_aBG","(!b_aBF) : k_aBG","((!b_aBF) : k_aBG)","!((!b_aBF) : k_aBG)","(!((!b_aBF) : k_aBG))","bs_aBE@(!((!b_aBF) : k_aBG))","p_aBH","[]","![]","(![])","p_aBI","!p_aBI","(!p_aBI)","x_aBJ","xs'_aBK","x_aBJ : xs'_aBK","(x_aBJ : xs'_aBK)","!(x_aBJ : xs'_aBK)","(!(x_aBJ : xs'_aBK))","x_aBM","!x_aBM","(!x_aBM)","xs_aBN","ys_aBO","(xs_aBN, ys_aBO)","_","!_","(!_)","xs_aBP","!xs_aBP","(!xs_aBP)","\"\"","!\"\"","(!\"\")","s_aBQ","l_aBS","s'_aBT","(l_aBS, s'_aBT)","x_aLr","safebang@!x_aLr","(!x_aLr)","_","[]","x_aLt","!x_aLt","(!x_aLt)","a_aLu","!a_aLu","(!a_aLu)","l_aLv","!l_aLv","(!l_aLv)","(!a_aLu) : (!l_aLv)","((!a_aLu) : (!l_aLv))","x_aVA"]
module StdLib where

pair :: a_aAS -> b_aAT -> (a_aAS, b_aAT)
pair a_aAU b_aAV = (a_aAU, b_aAV)

fstcons :: a_aAQ -> ([a_aAQ], b_aAR) -> ([a_aAQ], b_aAR)
fstcons a_aAW ((!as_aAX), (!b_aAY)) = (a_aAW : as_aAX, b_aAY)

sndcons :: b_aAO -> (a_aAP, [b_aAO]) -> (a_aAP, [b_aAO])
sndcons b_aAZ (a_aB0, bs_aB1) = (a_aB0, b_aAZ : bs_aB1)
map2 (!f_aB2) [] (norecord@_) = []
map2 f_aB3 (norecord@_) (norecord@[]) = []
map2 (norecord@f_aB4) ((norecord@(a_aB5 : (norecord@l_aB6))))
  ((norecord@((norecord@b_aB7) : k_aB8)))
  = f_aB4 a_aB5 b_aB7 : map2 f_aB4 l_aB6 k_aB8

mapcat :: (a_aAM -> [b_aAN]) -> [a_aAM] -> [b_aAN]
mapcat f_aB9 [] = []
mapcat f_aBa ((!a_aBb) : (!l_aBc))
  = f_aBa a_aBb ++ mapcat f_aBa l_aBc

sort :: Ord a_aAL => [a_aAL] -> [a_aAL]
sort (norecord@[]) = []
sort (a_aBd : l_aBe) = (sort low_aBf) ++ [a_aBd] ++ (sort high_aBg)
  where (low_aBf, (norecord@high_aBg)) = group a_aBd l_aBe

group :: Ord a_aAK => a_aAK -> [a_aAK] -> ([a_aAK], [a_aAK])
group _ (norecord@[]) = ([], [])
group (norecord@i_aBh) (a_aBi : (norecord@l_aBj))
  = f_aBk (group i_aBh l_aBj)
  where f_aBk (norecord@(low_aBl, high_aBm))
          | a_aBi < i_aBh = (a_aBi : low_aBl, high_aBm)
          | otherwise = (low_aBl, a_aBi : high_aBm)

insert :: Ord a_aAJ => a_aAJ -> [a_aAJ] -> [a_aAJ]
insert (!a_aBn) (norecord@[]) = [a_aBn]
insert a_aBo as_aBp@(norecord@(x_aBq : xs_aBr))
  | x_aBq > a_aBo = a_aBo : as_aBp
  | otherwise = x_aBq : insert a_aBo xs_aBr

replace :: Eq a_aAI => a_aAI -> [a_aAI] -> [a_aAI]
replace a_aBs [] = []
replace a_aBt (x_aBu : (!xs_aBv))
  | a_aBt == x_aBu = a_aBt : xs_aBv
  | otherwise = x_aBu : replace a_aBt xs_aBv

remove :: Eq a_aAH => a_aAH -> [a_aAH] -> [a_aAH]
remove a_aBw (norecord@[]) = []
remove (norecord@a_aBx) (norecord@(x_aBy : (norecord@xs_aBz)))
  | a_aBx == x_aBy = xs_aBz
  | otherwise = x_aBy : remove a_aBx xs_aBz

collect ::
          Ord a_ane => (b_and -> a_ane) -> [a_ane] -> [b_and] -> [b_and]
collect (norecord@_) (norecord@[]) (norecord@_) = []
collect (norecord@_) (norecord@_) [] = []
collect (norecord@p_aBA)
  as_aBB@(norecord@((norecord@a_aBC) : l_aBD))
  bs_aBE@(norecord@((norecord@b_aBF) : k_aBG))
  | a_aBC == p_aBA b_aBF = b_aBF : collect p_aBA l_aBD k_aBG
  | p_aBA b_aBF > a_aBC = collect p_aBA l_aBD bs_aBE
  | otherwise = collect p_aBA as_aBB k_aBG

span' :: (a_anc -> Bool) -> [a_anc] -> ([a_anc], [a_anc])
span' p_aBH (norecord@[]) = ([], [])
span' (norecord@p_aBI) (norecord@(x_aBJ : xs'_aBK))
  | p_aBI x_aBJ = fixLeak_aBL x_aBJ (span' p_aBI xs'_aBK)
  where fixLeak_aBL (norecord@x_aBM) (xs_aBN, ys_aBO)
          = (x_aBM : xs_aBN, ys_aBO)
span' (norecord@_) (norecord@xs_aBP) = ([], xs_aBP)

lines' :: [Char] -> [[Char]]
lines' (norecord@"") = []
lines' s_aBQ = plumb_aBR (span' ((/=) '\n') s_aBQ)
  where plumb_aBR (l_aBS, s'_aBT)
          = l_aBS : if null s'_aBT then [] else lines' (tail s'_aBT)

strToInt :: String -> Int
strToInt (!x_aLr) = strToInt'_aLs (length x_aLr - 1) x_aLr
  where strToInt'_aLs _ [] = 0
        strToInt'_aLs (norecord@x_aLt)
          ((norecord@a_aLu) : (norecord@l_aLv))
          = (charToInt a_aLu) * (10 ^ x_aLt) +
              (strToInt'_aLs (x_aLt - 1) l_aLv)

charToInt :: Char -> Int
charToInt x_aVA = (fromEnum x_aVA - fromEnum '0')
STARTLOG
["f_aPb","st_aPc","[]","f_aPd","!f_aPd","(!f_aPd)","st_aPe","!st_aPe","(!st_aPe)","a_aPf","as_aPg","a_aPf : as_aPg","(a_aPf : as_aPg)","b_aPh","st'_aPi","!st'_aPi","(!st'_aPi)","(b_aPh, (!st'_aPi))","bs_aPj","safebang@!bs_aPj","(!bs_aPj)","st''_aPk","((!bs_aPj), st''_aPk)","!((!bs_aPj), st''_aPk)","(!((!bs_aPj), st''_aPk))","lines_aPl","safebang@!lines_aPl","(!lines_aPl)","pe_aPm","safebang@!pe_aPm","(!pe_aPm)","ticks_aPn","lines'_aPo","safebang@!lines'_aPo","(!lines'_aPo)","((!pe_aPm), ticks_aPn, (!lines'_aPo))","!((!pe_aPm), ticks_aPn, (!lines'_aPo))","(!((!pe_aPm), ticks_aPn, (!lines'_aPo)))","l_aPq","m_aPr","safebang@!m_aPr","(!m_aPr)","[]","l_aPs","!l_aPs","(!l_aPs)","m_aPt","_","_","_","_","!_","(!_)","_","!_","(!_)","_","t_aPv","Act _ _ (!_) (!_) _ t_aPv","(Act _ _ (!_) (!_) _ t_aPv)","!(Act _ _ (!_) (!_) _ t_aPv)","(!(Act _ _ (!_) (!_) _ t_aPv))","((!(Act _ _ (!_) (!_) _ t_aPv)))","_","Ln _ ((!(Act _ _ (!_) (!_) _ t_aPv))) _","(Ln _ ((!(Act _ _ (!_) (!_) _ t_aPv))) _)","l'_aPu@(Ln _ ((!(Act _ _ (!_) (!_) _ t_aPv))) _)","more_aPw","!more_aPw","(!more_aPw)","l'_aPu@(Ln _ ((!(Act _ _ (!_) (!_) _ t_aPv))) _) : (!more_aPw)","(l'_aPu@(Ln _ ((!(Act _ _ (!_) (!_) _ t_aPv))) _) : (!more_aPw))","l_aPx","!l_aPx","(!l_aPx)","m_aPy","!m_aPy","(!m_aPy)","x_aPz","PEs x_aPz","(PEs x_aPz)","!(PEs x_aPz)","(!(PEs x_aPz))","more_aPA","(!(PEs x_aPz)) : more_aPA","((!(PEs x_aPz)) : more_aPA)","xs_aPB","t_aPC","safebang@!t_aPC","(!t_aPC)","l'_aPD","safebang@!l'_aPD","(!l'_aPD)","(xs_aPB, (!t_aPC), (!l'_aPD))","!(xs_aPB, (!t_aPC), (!l'_aPD))","(!(xs_aPB, (!t_aPC), (!l'_aPD)))","l_aPE","m_aPF","_","more_aPG","_ : more_aPG","(_ : more_aPG)","!(_ : more_aPG)","(!(_ : more_aPG))","((!(_ : more_aPG)))","[]","x_aPH","pes_aPI","x_aPJ","_","!_","(!_)","[]","f_aVO","pe_aVP","a_aVQ","safebang@!a_aVQ","(!a_aVQ)","s_aVR","safebang@!s_aVR","(!s_aVR)","Ln pe_aVP (!a_aVQ) (!s_aVR)","(Ln pe_aVP (!a_aVQ) (!s_aVR))","!(Ln pe_aVP (!a_aVQ) (!s_aVR))","(!(Ln pe_aVP (!a_aVQ) (!s_aVR)))","more_aVS","(!(Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS","((!(Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS)","!((!(Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS)","(!((!(Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS))","((!((!(Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS)))","!((!((!(Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS)))","(!((!((!(Ln pe_aVP (!a_aVQ) (!s_aVR))) : more_aVS))))","f_aVT","!f_aVT","(!f_aVT)","_","!_","(!_)","more_aVU","!more_aVU","(!more_aVU)","(!_) : (!more_aVU)","((!_) : (!more_aVU))","!((!_) : (!more_aVU))","(!((!_) : (!more_aVU)))","((!((!_) : (!more_aVU))))","[]","![]","(![])","x_aVV","safebang@!x_aVV","(!x_aVV)","pes_aVW","x_aVX","_","!_","(!_)","[]","f_aVY","!f_aVY","(!f_aVY)","pe_aVZ","a_aW0","s_aW1","safebang@!s_aW1","(!s_aW1)","Ln pe_aVZ a_aW0 (!s_aW1)","(Ln pe_aVZ a_aW0 (!s_aW1))","more_aW2","safebang@!more_aW2","(!more_aW2)","(Ln pe_aVZ a_aW0 (!s_aW1)) : (!more_aW2)","((Ln pe_aVZ a_aW0 (!s_aW1)) : (!more_aW2))","!((Ln pe_aVZ a_aW0 (!s_aW1)) : (!more_aW2))","(!((Ln pe_aVZ a_aW0 (!s_aW1)) : (!more_aW2)))","((!((Ln pe_aVZ a_aW0 (!s_aW1)) : (!more_aW2))))","f_aW3","_","more_aW4","!more_aW4","(!more_aW4)","_ : (!more_aW4)","(_ : (!more_aW4))","!(_ : (!more_aW4))","(!(_ : (!more_aW4)))","((!(_ : (!more_aW4))))","m_aW5","n_aW7","i_aW8","safebang@!i_aW8","(!i_aW8)","r_aW9","safebang@!r_aW9","(!r_aW9)","g_aWa","safebang@!g_aWa","(!g_aWa)","f_aWb","t_aWc","Act n_aW7 (!i_aW8) (!r_aW9) (!g_aWa) f_aWb t_aWc","(Act n_aW7 (!i_aW8) (!r_aW9) (!g_aWa) f_aWb t_aWc)","a_aW6@(Act n_aW7 (!i_aW8) (!r_aW9) (!g_aWa) f_aWb t_aWc)","!a_aW6@(Act n_aW7 (!i_aW8) (!r_aW9) (!g_aWa) f_aWb t_aWc)","(!a_aW6@(Act n_aW7 (!i_aW8) (!r_aW9) (!g_aWa) f_aWb t_aWc))","c_aWd","n_a16e","_","!_","(!_)","_","!_","(!_)","_","!_","(!_)","_","Sp n_a16e (!_) (!_) (!_) _","(Sp n_a16e (!_) (!_) (!_) _)","_","!_","(!_)","s_a16f","_","_","_","!_","(!_)","Sp (!_) s_a16f _ _ (!_)","(Sp (!_) s_a16f _ _ (!_))","!(Sp (!_) s_a16f _ _ (!_))","(!(Sp (!_) s_a16f _ _ (!_)))","((!(Sp (!_) s_a16f _ _ (!_))))","_","!_","(!_)","_","!_","(!_)","u_a16g","safebang@!u_a16g","(!u_a16g)","_","!_","(!_)","_","!_","(!_)","Sp (!_) (!_) (!u_a16g) (!_) (!_)","(Sp (!_) (!_) (!u_a16g) (!_) (!_))","_","_","_","r_a16h","safebang@!r_a16h","(!r_a16h)","_","!_","(!_)","Sp _ _ _ (!r_a16h) (!_)","(Sp _ _ _ (!r_a16h) (!_))","_","_","_","!_","(!_)","_","!_","(!_)","l_a16i","safebang@!l_a16i","(!l_a16i)","Sp _ _ (!_) (!_) (!l_a16i)","(Sp _ _ (!_) (!_) (!l_a16i))","!(Sp _ _ (!_) (!_) (!l_a16i))","(!(Sp _ _ (!_) (!_) (!l_a16i)))","((!(Sp _ _ (!_) (!_) (!l_a16i))))","b_a16j","_","_","!_","(!_)","_","!_","(!_)","_","_","!_","(!_)","Act b_a16j _ (!_) (!_) _ (!_)","(Act b_a16j _ (!_) (!_) _ (!_))","!(Act b_a16j _ (!_) (!_) _ (!_))","(!(Act b_a16j _ (!_) (!_) _ (!_)))","_","!_","(!_)","i_a16k","_","_","_","!_","(!_)","_","Act (!_) i_a16k _ _ (!_) _","(Act (!_) i_a16k _ _ (!_) _)","!(Act (!_) i_a16k _ _ (!_) _)","(!(Act (!_) i_a16k _ _ (!_) _))","((!(Act (!_) i_a16k _ _ (!_) _)))","_","_","r_a16l","_","!_","(!_)","_","!_","(!_)","_","!_","(!_)","Act _ _ r_a16l (!_) (!_) (!_)","(Act _ _ r_a16l (!_) (!_) (!_))","!(Act _ _ r_a16l (!_) (!_) (!_))","(!(Act _ _ r_a16l (!_) (!_) (!_)))","((!(Act _ _ r_a16l (!_) (!_) (!_))))","_","_","!_","(!_)","_","!_","(!_)","g_a16m","safebang@!g_a16m","(!g_a16m)","_","_","!_","(!_)","Act _ (!_) (!_) (!g_a16m) _ (!_)","(Act _ (!_) (!_) (!g_a16m) _ (!_))","!(Act _ (!_) (!_) (!g_a16m) _ (!_))","(!(Act _ (!_) (!_) (!g_a16m) _ (!_)))","_","!_","(!_)","_","_","_","f_a16n","_","Act (!_) _ _ _ f_a16n _","(Act (!_) _ _ _ f_a16n _)","_","!_","(!_)","_","!_","(!_)","_","_","_","t_a16o","Act (!_) (!_) _ _ _ t_a16o","(Act (!_) (!_) _ _ _ t_a16o)","string_a16p","safebang@!string_a16p","(!string_a16p)","name_a16q","'.'","a_a16r","'.' : a_a16r","('.' : a_a16r)","!('.' : a_a16r)","(!('.' : a_a16r))","(name_a16q, (!('.' : a_a16r)))","!(name_a16q, (!('.' : a_a16r)))","(!(name_a16q, (!('.' : a_a16r))))","no_a16s","!no_a16s","(!no_a16s)","more_a16t","((!no_a16s), more_a16t)","!((!no_a16s), more_a16t)","(!((!no_a16s), more_a16t))","_","!_","(!_)","b_a19S","!b_a19S","(!b_a19S)","_","_","!_","(!_)","_","_","_","Act (!b_a19S) _ (!_) _ _ _","(Act (!b_a19S) _ (!_) _ _ _)","!(Act (!b_a19S) _ (!_) _ _ _)","(!(Act (!b_a19S) _ (!_) _ _ _))","((!(Act (!b_a19S) _ (!_) _ _ _)))","!((!(Act (!b_a19S) _ (!_) _ _ _)))","(!((!(Act (!b_a19S) _ (!_) _ _ _))))","_","Ln (!_) (!((!(Act (!b_a19S) _ (!_) _ _ _)))) _","(Ln (!_) (!((!(Act (!b_a19S) _ (!_) _ _ _)))) _)","!(Ln (!_) (!((!(Act (!b_a19S) _ (!_) _ _ _)))) _)","(!(Ln (!_) (!((!(Act (!b_a19S) _ (!_) _ _ _)))) _))","x_a19R@(!(Ln (!_) (!((!(Act (!b_a19S) _ (!_) _ _ _)))) _))","!x_a19R@(!(Ln (!_) (!((!(Act (!b_a19S) _ (!_) _ _ _)))) _))","(!x_a19R@(!(Ln (!_) (!((!(Act (!b_a19S) _ (!_) _ _ _)))) _)))","_","b'_a19U","_","_","_","_","!_","(!_)","_","!_","(!_)","Act b'_a19U _ _ _ (!_) (!_)","(Act b'_a19U _ _ _ (!_) (!_))","!(Act b'_a19U _ _ _ (!_) (!_))","(!(Act b'_a19U _ _ _ (!_) (!_)))","_","Ln _ (!(Act b'_a19U _ _ _ (!_) (!_))) _","(Ln _ (!(Act b'_a19U _ _ _ (!_) (!_))) _)","y_a19T@(Ln _ (!(Act b'_a19U _ _ _ (!_) (!_))) _)","'B'","!'B'","(!'B')","string_a19V","!string_a19V","(!string_a19V)","(!'B') : (!string_a19V)","((!'B') : (!string_a19V))","pe_a19W","safebang@!pe_a19W","(!pe_a19W)","':'","p_a19X","':' : p_a19X","(':' : p_a19X)","!(':' : p_a19X)","(!(':' : p_a19X))","((!pe_a19W), (!(':' : p_a19X)))","!((!pe_a19W), (!(':' : p_a19X)))","(!((!pe_a19W), (!(':' : p_a19X))))","bucket_a19Y","':'","!':'","(!':')","a_a19Z","!a_a19Z","(!a_a19Z)","(!':') : (!a_a19Z)","((!':') : (!a_a19Z))","!((!':') : (!a_a19Z))","(!((!':') : (!a_a19Z)))","(bucket_a19Y, (!((!':') : (!a_a19Z))))","idle_a1a0","!idle_a1a0","(!idle_a1a0)","b_a1a1","((!idle_a1a0), b_a1a1)","redn_a1a2","!redn_a1a2","(!redn_a1a2)","c_a1a3","((!redn_a1a2), c_a1a3)","gc_a1a4","!gc_a1a4","(!gc_a1a4)","d_a1a5","((!gc_a1a4), d_a1a5)","flush_a1a6","!flush_a1a6","(!flush_a1a6)","e_a1a7","!e_a1a7","(!e_a1a7)","((!flush_a1a6), (!e_a1a7))","!((!flush_a1a6), (!e_a1a7))","(!((!flush_a1a6), (!e_a1a7)))","read_a1a8","!read_a1a8","(!read_a1a8)","k_a1a9","!k_a1a9","(!k_a1a9)","((!read_a1a8), (!k_a1a9))","!((!read_a1a8), (!k_a1a9))","(!((!read_a1a8), (!k_a1a9)))","_","!_","(!_)","f_a1aa","!f_a1aa","(!f_a1aa)","((!_), (!f_a1aa))","sprkd_a1ab","!sprkd_a1ab","(!sprkd_a1ab)","g_a1ac","((!sprkd_a1ab), g_a1ac)","!((!sprkd_a1ab), g_a1ac)","(!((!sprkd_a1ab), g_a1ac))","sused_a1ad","!sused_a1ad","(!sused_a1ad)","h_a1ae","!h_a1ae","(!h_a1ae)","((!sused_a1ad), (!h_a1ae))","!((!sused_a1ad), (!h_a1ae))","(!((!sused_a1ad), (!h_a1ae)))","resum_a1af","!resum_a1af","(!resum_a1af)","i_a1ag","((!resum_a1af), i_a1ag)","!((!resum_a1af), i_a1ag)","(!((!resum_a1af), i_a1ag))","lost_a1ah","!lost_a1ah","(!lost_a1ah)","j_a1ai","((!lost_a1ah), j_a1ai)","io_a1aj","!io_a1aj","(!io_a1aj)","more_a1ak","!more_a1ak","(!more_a1ak)","((!io_a1aj), (!more_a1ak))","!((!io_a1aj), (!more_a1ak))","(!((!io_a1aj), (!more_a1ak)))","'P'","'S'","!'S'","(!'S')","string_a1al","lazydmd@!string_a1al","(!string_a1al)","(!'S') : (!string_a1al)","((!'S') : (!string_a1al))","!((!'S') : (!string_a1al))","(!((!'S') : (!string_a1al)))","'P' : (!((!'S') : (!string_a1al)))","('P' : (!((!'S') : (!string_a1al))))","pe_a1am","safebang@!pe_a1am","(!pe_a1am)","more_a1an","((!pe_a1am), more_a1an)","!((!pe_a1am), more_a1an)","(!((!pe_a1am), more_a1an))","string_a1ao","!string_a1ao","(!string_a1ao)"]
module GRIP where
import PSlib
import StdLib
import Parse

akkumulate ::
           (state_aP8 -> a_aP9 -> (b_aPa, state_aP8)) ->
             state_aP8 -> [a_aP9] -> ([b_aPa], state_aP8)
akkumulate f_aPb st_aPc [] = ([], st_aPc)
akkumulate (norecord@f_aPd) (norecord@st_aPe) (a_aPf : as_aPg)
  = (b_aPh : bs_aPj, st''_aPk)
  where (b_aPh, (norecord@st'_aPi)) = f_aPd st_aPe a_aPf
        (norecord@((!bs_aPj), st''_aPk)) = akkumulate f_aPd st'_aPi as_aPg

getParameters :: [Line] -> ([PElement], Int, [Line])
getParameters (!lines_aPl) = (pe_aPm, ticks_aPn, lines'_aPo)
  where (norecord@((!pe_aPm), ticks_aPn, (!lines'_aPo)))
          = f_aPp [] 0 lines_aPl
        f_aPp l_aPq (!m_aPr) [] = ([], m_aPr, l_aPq)
        f_aPp (norecord@l_aPs) m_aPt
          (l'_aPu@(Ln _
                     ((norecord@(Act _ _ (norecord@_) (norecord@_) _ t_aPv))) _)
             : (norecord@more_aPw))
          = f_aPp (insert l'_aPu l_aPs) (max m_aPt t_aPv) more_aPw
        f_aPp (norecord@l_aPx) (norecord@m_aPy)
          ((norecord@(PEs x_aPz)) : more_aPA)
          = (x_aPz : xs_aPB, t_aPC, l'_aPD)
          where (norecord@(xs_aPB, (!t_aPC), (!l'_aPD)))
                  = f_aPp l_aPx m_aPy more_aPA
        f_aPp l_aPE m_aPF ((norecord@(_ : more_aPG)))
          = f_aPp l_aPE m_aPF more_aPG

getAct :: [PElement] -> [Line] -> [Activities]
getAct [] = aux (\ x_aPH -> True)
getAct pes_aPI = aux (\ x_aPJ -> elem x_aPJ pes_aPI)
aux (norecord@_) [] = []
aux f_aVO
  (norecord@((norecord@((norecord@(Ln pe_aVP (!a_aVQ) (!s_aVR))) :
                          more_aVS))))
  | f_aVO pe_aVP = a_aVQ : aux f_aVO more_aVS
  | otherwise = aux f_aVO more_aVS
aux (norecord@f_aVT)
  ((norecord@((norecord@_) : (norecord@more_aVU))))
  = aux f_aVT more_aVU

getSp :: [PElement] -> [Line] -> [Sparks]
getSp (norecord@[]) = aux' (\ (!x_aVV) -> True)
getSp pes_aVW = aux' (\ x_aVX -> elem x_aVX pes_aVW)
aux' (norecord@_) [] = []
aux' (norecord@f_aVY)
  ((norecord@((Ln pe_aVZ a_aW0 (!s_aW1)) : (!more_aW2))))
  | f_aVY pe_aVZ = s_aW1 : aux' f_aVY more_aW2
  | otherwise = aux' f_aVY more_aW2
aux' f_aW3 ((norecord@(_ : (norecord@more_aW4))))
  = aux' f_aW3 more_aW4
scaleAct m_aW5
  (norecord@a_aW6@(Act n_aW7 (!i_aW8) (!r_aW9) (!g_aWa) f_aWb t_aWc))
  | m_aW5 == t_aWc = a_aW6
  | otherwise =
    Act n_aW7 (i_aW8 * c_aWd) (r_aW9 * c_aWd) (g_aWa * c_aWd)
      (f_aWb * c_aWd)
      (t_aWc * c_aWd)
  where c_aWd = m_aW5 `div` t_aWc
numberSp (Sp n_a16e (norecord@_) (norecord@_) (norecord@_) _)
  = n_a16e
created ((norecord@(Sp (norecord@_) s_a16f _ _ (norecord@_))))
  = s_a16f
used
  (Sp (norecord@_) (norecord@_) (!u_a16g) (norecord@_) (norecord@_))
  = u_a16g
resumed (Sp _ _ _ (!r_a16h) (norecord@_)) = r_a16h
lost ((norecord@(Sp _ _ (norecord@_) (norecord@_) (!l_a16i))))
  = l_a16i
numberAct
  (norecord@(Act b_a16j _ (norecord@_) (norecord@_) _ (norecord@_)))
  = b_a16j
idle ((norecord@(Act (norecord@_) i_a16k _ _ (norecord@_) _)))
  = i_a16k
reduction
  ((norecord@(Act _ _ r_a16l (norecord@_) (norecord@_)
                (norecord@_))))
  = r_a16l
gc
  (norecord@(Act _ (norecord@_) (norecord@_) (!g_a16m) _
               (norecord@_)))
  = g_a16m
flush (Act (norecord@_) _ _ _ f_a16n _) = f_a16n
total (Act (norecord@_) (norecord@_) _ _ _ t_a16o) = t_a16o

data Sparks = Sp Int Int Int Int Int
            deriving (Show, Eq)

data Activities = Act Int Int Int Int Int Int
                deriving (Show, Eq)

data PElement = PE String Int
              deriving (Eq, Show)

data Line = Ln PElement Activities Sparks
          | PEs PElement
          | BucketFull Int
          | Null
          deriving (Show, Eq)

instance Parse PElement where
        parseType (!string_a16p) = (PE name_a16q no_a16s, more_a16t)
          where (norecord@(name_a16q, (norecord@('.' : a_a16r))))
                  = span ((/=) '.') string_a16p
                (norecord@((norecord@no_a16s), more_a16t)) = parse a_a16r

instance Ord Line where
        (norecord@x_a19R@(norecord@(Ln (norecord@_)
                                      (norecord@((norecord@(Act (norecord@b_a19S) _ (norecord@_) _ _
                                                              _))))
                                      _)))
          <=
          y_a19T@(Ln _
                    (norecord@(Act b'_a19U _ _ _ (norecord@_) (norecord@_))) _)
          = b_a19S <= b'_a19U

instance Parse Line where
        parseType ((norecord@'B') : (norecord@string_a19V))
          = ((Ln pe_a19W
                (Act bucket_a19Y idle_a1a0 redn_a1a2 gc_a1a4
                   (flush_a1a6 + read_a1a8)
                   (idle_a1a0 + redn_a1a2 + gc_a1a4 + flush_a1a6 + read_a1a8 +
                      io_a1aj))
                (Sp bucket_a19Y sprkd_a1ab sused_a1ad resum_a1af lost_a1ah)),
             more_a1ak)
          where (norecord@((!pe_a19W), (norecord@(':' : p_a19X))))
                  = parse string_a19V
                (bucket_a19Y, (norecord@((norecord@':') : (norecord@a_a19Z))))
                  = parse p_a19X
                ((norecord@idle_a1a0), b_a1a1) = parse a_a19Z
                ((norecord@redn_a1a2), c_a1a3) = parse b_a1a1
                ((norecord@gc_a1a4), d_a1a5) = parse c_a1a3
                (norecord@((norecord@flush_a1a6), (norecord@e_a1a7)))
                  = parse d_a1a5
                (norecord@((norecord@read_a1a8), (norecord@k_a1a9))) = parse e_a1a7
                ((norecord@_), (norecord@f_a1aa))
                  = span ((/=) ' ') (whiteSpace k_a1a9)
                (norecord@((norecord@sprkd_a1ab), g_a1ac)) = parse f_a1aa
                (norecord@((norecord@sused_a1ad), (norecord@h_a1ae)))
                  = parse g_a1ac
                (norecord@((norecord@resum_a1af), i_a1ag)) = parse h_a1ae
                ((norecord@lost_a1ah), j_a1ai) = parse i_a1ag
                (norecord@((norecord@io_a1aj), (norecord@more_a1ak)))
                  = parse j_a1ai
        parseType
          ('P' : (norecord@((norecord@'S') : (lazydmd@string_a1al))))
          = (PEs pe_a1am, more_a1an)
          where (norecord@((!pe_a1am), more_a1an))
                  = parse (tail (dropWhile ((/=) 'r') string_a1al))
        parseType (norecord@string_a1ao) = (Null, string_a1ao)
STARTLOG
["ordering_aOA","selectpes_aOB","statFile_aOC","a_aOO","!a_aOO","(!a_aOO)","pes_aOE","!pes_aOE","(!pes_aOE)","ticks_aOF","orderedStats_aOG","((!pes_aOE), ticks_aOF, orderedStats_aOG)","height_aOH","traces_aOI","aggs_aOJ","safebang@!aggs_aOJ","(!aggs_aOJ)","h_aOK","w_aOL","safebang@!w_aOL","(!w_aOL)","((!aggs_aOJ), h_aOK, (!w_aOL))","(traces_aOI, ((!aggs_aOJ), h_aOK, (!w_aOL)))","!(traces_aOI, ((!aggs_aOJ), h_aOK, (!w_aOL)))","(!(traces_aOI, ((!aggs_aOJ), h_aOK, (!w_aOL))))","order_aOM","!order_aOM","(!order_aOM)","stats_aON","safebang@!stats_aON","(!stats_aON)","extractors_a18e","c_a18f","safebang@!c_a18f","(!c_a18f)","u_a18g","safebang@!u_a18g","(!u_a18g)","r_a18h","l_a18i","safebang@!l_a18i","(!l_a18i)","((!c_a18f), (!u_a18g), r_a18h, (!l_a18i))","graphmax_a18j","safebang@!graphmax_a18j","(!graphmax_a18j)","_","(((!c_a18f), (!u_a18g), r_a18h, (!l_a18i)), (!graphmax_a18j), _)","n_a18l","c'_a18m","u'_a18n","safebang@!u'_a18n","(!u'_a18n)","r'_a18o","safebang@!r'_a18o","(!r'_a18o)","l'_a18p","Sp n_a18l c'_a18m (!u'_a18n) (!r'_a18o) l'_a18p","(Sp n_a18l c'_a18m (!u'_a18n) (!r'_a18o) l'_a18p)","!(Sp n_a18l c'_a18m (!u'_a18n) (!r'_a18o) l'_a18p)","(!(Sp n_a18l c'_a18m (!u'_a18n) (!r'_a18o) l'_a18p))","s_a18k@(!(Sp n_a18l c'_a18m (!u'_a18n) (!r'_a18o) l'_a18p))","_","m_a18r","_","m_a18r : _","(m_a18r : _)","!(m_a18r : _)","(!(m_a18r : _))","T _ (!(m_a18r : _))","(T _ (!(m_a18r : _)))","trace_a18q@(T _ (!(m_a18r : _)))","!trace_a18q@(T _ (!(m_a18r : _)))","(!trace_a18q@(T _ (!(m_a18r : _))))","fs_a18s","!fs_a18s","(!fs_a18s)","n_a18t","s_a18u","!s_a18u","(!s_a18u)","[]","e_a18x","es_a18y","e_a18x : es_a18y","(e_a18x : es_a18y)","!(e_a18x : es_a18y)","(!(e_a18x : es_a18y))","ex_a18w@(!(e_a18x : es_a18y))","!ex_a18w@(!(e_a18x : es_a18y))","(!ex_a18w@(!(e_a18x : es_a18y)))","nullstate","n_a18z","a_a18A","T n_a18z a_a18A","[T n_a18z a_a18A]","x_a18B","!x_a18B","(!x_a18B)","n_a18C","a_a18D","T n_a18C a_a18D","more_a18E","T n_a18C a_a18D : more_a18E","(T n_a18C a_a18D : more_a18E)","!(T n_a18C a_a18D : more_a18E)","(!(T n_a18C a_a18D : more_a18E))","x_a18F","[]","_","f_a18G","safebang@!f_a18G","(!f_a18G)","fs_a18H","safebang@!fs_a18H","(!fs_a18H)","(!f_a18G) : (!fs_a18H)","((!f_a18G) : (!fs_a18H))","!((!f_a18G) : (!fs_a18H))","(!((!f_a18G) : (!fs_a18H)))","a_a18I","t_a18J","safebang@!t_a18J","(!t_a18J)","[]","![]","(![])","t_a18K","!t_a18K","(!t_a18K)","a_a18M","!a_a18M","(!a_a18M)","as_a18N","!as_a18N","(!as_a18N)","(!a_a18M) : (!as_a18N)","((!a_a18M) : (!as_a18N))","!((!a_a18M) : (!as_a18N))","(!((!a_a18M) : (!as_a18N)))","((!((!a_a18M) : (!as_a18N))))","l_a18L@((!((!a_a18M) : (!as_a18N))))","!l_a18L@((!((!a_a18M) : (!as_a18N))))","(!l_a18L@((!((!a_a18M) : (!as_a18N)))))","n_a18O","lazydmd@!n_a18O","(!n_a18O)","n_a18P","a_a18Q","b_a18R","!b_a18R","(!b_a18R)","c_a18S","d_a18T","!d_a18T","(!d_a18T)","Sp n_a18P a_a18Q (!b_a18R) c_a18S (!d_a18T)","(Sp n_a18P a_a18Q (!b_a18R) c_a18S (!d_a18T))","_","!_","(!_)","e_a18U","f_a18V","g_a18W","!g_a18W","(!g_a18W)","h_a18X","!h_a18X","(!h_a18X)","Sp (!_) e_a18U f_a18V (!g_a18W) (!h_a18X)","(Sp (!_) e_a18U f_a18V (!g_a18W) (!h_a18X))","CREATED","i_a18Y","!i_a18Y","(!i_a18Y)","_","!_","(!_)","_","_","((!i_a18Y), (!_), _, _)","USED","!USED","(!USED)","_","!_","(!_)","r_a1hi","!r_a1hi","(!r_a1hi)","_","_","((!_), (!r_a1hi), _, _)","RESUMED","_","!_","(!_)","_","g_a1hj","_","!_","(!_)","((!_), _, g_a1hj, (!_))","!((!_), _, g_a1hj, (!_))","(!((!_), _, g_a1hj, (!_)))","LOST","!LOST","(!LOST)","_","_","_","f_a1hk","!f_a1hk","(!f_a1hk)","(_, _, _, (!f_a1hk))","LOST","CREATED","RESUMED","!RESUMED","(!RESUMED)","USED","!USED","(!USED)","LOST","CREATED","!CREATED","(!CREATED)","RESUMED","!RESUMED","(!RESUMED)","USED","!USED","(!USED)","LOST","!LOST","(!LOST)","CREATED","!CREATED","(!CREATED)","RESUMED","USED","'L'","string_a1hl","'L' : string_a1hl","('L' : string_a1hl)","!('L' : string_a1hl)","(!('L' : string_a1hl))","'C'","!'C'","(!'C')","string_a1hm","(!'C') : string_a1hm","((!'C') : string_a1hm)","'R'","string_a1hn","lazydmd@!string_a1hn","(!string_a1hn)","'R' : (!string_a1hn)","('R' : (!string_a1hn))","!('R' : (!string_a1hn))","(!('R' : (!string_a1hn)))","((!('R' : (!string_a1hn))))","!((!('R' : (!string_a1hn))))","(!((!('R' : (!string_a1hn)))))","'U'","!'U'","(!'U')","string_a1ho","(!'U') : string_a1ho","((!'U') : string_a1ho)","string_a1hp","!string_a1hp","(!string_a1hp)","((!string_a1hp))","!((!string_a1hp))","(!((!string_a1hp)))"]
module Spark (sparkGraph, Spark(..)) where
import StdLib
import GRIP
import PSlib
import Graph
import Parse
sparkGraph ordering_aOA selectpes_aOB statFile_aOC
  = initGraph "Spark Activity Graph" (pes_aOE, selectpes_aOB)
      (100 * ticks_aOF, height_aOH)
      ("Time (ms)", "Sparks")
      (map f_aOD ordering_aOA)
      ++
      scale (my_fromInt dimX / my_fromInt 100)
        (my_fromInt dimY / my_fromInt height_aOH)
      ++
      concat
        (map2 plotCurve (map colourSpark order_aOM)
           (outlinesTrace traces_aOI))
  where f_aOD (norecord@a_aOO)
          = (colourSpark a_aOO, displaySpark a_aOO, aggr a_aOO aggs_aOJ)
        ((norecord@pes_aOE), ticks_aOF, orderedStats_aOG)
          = getParameters stats_aON
        height_aOH = axisScale h_aOK
        (norecord@(traces_aOI, ((!aggs_aOJ), h_aOK, (!w_aOL))))
          = akkumulate (processSparks (map extractor order_aOM)) nullstate
              (gatherSp (Sp 0 0 0 0 0) (getSp selectpes_aOB orderedStats_aOG))
        (norecord@order_aOM) = reverse ordering_aOA
        (!stats_aON) = parseFile statFile_aOC

processSparks ::
              [Sparks -> Int] -> State -> Sparks -> (Trace, State)
processSparks extractors_a18e
  (((!c_a18f), (!u_a18g), r_a18h, (!l_a18i)), (!graphmax_a18j), _)
  s_a18k@(norecord@(Sp n_a18l c'_a18m (!u'_a18n) (!r'_a18o) l'_a18p))
  = (trace_a18q,
     ((c'_a18m + c_a18f, u'_a18n + u_a18g, r'_a18o + r_a18h,
       l'_a18p + l_a18i),
      max graphmax_a18j m_a18r, n_a18l))
  where (norecord@trace_a18q@(T _ (norecord@(m_a18r : _))))
          = makeTrace extractors_a18e n_a18l s_a18k
makeTrace (norecord@fs_a18s) n_a18t (norecord@s_a18u)
  = T n_a18t (f_a18v fs_a18s)
  where f_a18v [] = []
        f_a18v (norecord@ex_a18w@(norecord@(e_a18x : es_a18y)))
          = sum (pam ex_a18w s_a18u) : f_a18v es_a18y
nullstate = ((0, 0, 0, 0), 0, 0)

outlinesTrace :: [Trace] -> [[Point]]
outlinesTrace [T n_a18z a_a18A]
  = map (\ (norecord@x_a18B) -> [Pt n_a18z x_a18B]) a_a18A
outlinesTrace (norecord@(T n_a18C a_a18D : more_a18E))
  = map2 (:) (map (\ x_a18F -> Pt n_a18C x_a18F) a_a18D)
      (outlinesTrace more_a18E)
pam [] _ = []
pam (norecord@((!f_a18G) : (!fs_a18H))) a_a18I
  = f_a18G a_a18I : pam fs_a18H a_a18I
gatherSp (!t_a18J) (norecord@[])
  = [t_a18J, (Sp (numberSp t_a18J + 1) 0 0 0 0)]
gatherSp (norecord@t_a18K)
  (norecord@l_a18L@((norecord@((norecord@a_a18M) :
                                 (norecord@as_a18N)))))
  | numberSp t_a18K == numberSp a_a18M =
    gatherSp (addSparks t_a18K a_a18M) as_a18N
  | otherwise = t_a18K : gatherSp (Sp (n_a18O + 1) 0 0 0 0) l_a18L
  where (lazydmd@n_a18O) = numberSp t_a18K
addSparks
  (Sp n_a18P a_a18Q (norecord@b_a18R) c_a18S (norecord@d_a18T))
  (Sp (norecord@_) e_a18U f_a18V (norecord@g_a18W) (norecord@h_a18X))
  = Sp n_a18P (a_a18Q + e_a18U) (b_a18R + f_a18V) (c_a18S + g_a18W)
      (d_a18T + h_a18X)

aggr :: Spark -> (Int, Int, Int, Int) -> String
aggr CREATED ((norecord@i_a18Y), (norecord@_), _, _) = show i_a18Y
aggr (norecord@USED) ((norecord@_), (norecord@r_a1hi), _, _)
  = show r_a1hi
aggr RESUMED (norecord@((norecord@_), _, g_a1hj, (norecord@_)))
  = show g_a1hj
aggr (norecord@LOST) (_, _, _, (norecord@f_a1hk)) = show f_a1hk
extractor LOST = lost
extractor CREATED = created
extractor (norecord@RESUMED) = resumed
extractor (norecord@USED) = used

colourSpark :: Spark -> Int
colourSpark LOST = 8
colourSpark (norecord@CREATED) = 5
colourSpark (norecord@RESUMED) = 2
colourSpark (norecord@USED) = 0

displaySpark :: Spark -> String
displaySpark (norecord@LOST) = "Sparks Lost"
displaySpark (norecord@CREATED) = "Sparks Created"
displaySpark RESUMED = "Resumed Sparks"
displaySpark USED = "Used Sparks"

type State = ((Int, Int, Int, Int), Int, Int)

data Trace = T Int [Int]

data Spark = USED
           | RESUMED
           | CREATED
           | LOST
           deriving Eq

instance Parse Spark where
        parseType (norecord@('L' : string_a1hl)) = (LOST, string_a1hl)
        parseType ((norecord@'C') : string_a1hm) = (CREATED, string_a1hm)
        parseType (norecord@((norecord@('R' : (lazydmd@string_a1hn)))))
          = (RESUMED, string_a1hn)
        parseType ((norecord@'U') : string_a1ho) = (USED, string_a1ho)
        parseType (norecord@((norecord@string_a1hp)))
          = error ("No such Activity : " ++ show string_a1hp ++ "\n")
STARTLOG
STARTLOG
["m_aqP","v_aqQ","r_aMn","c_aMo","(r_aMn, c_aMo)","1","1","(1, 1)","rm_aqR","cm_aqS","(rm_aqR, cm_aqS)","((1, 1), (rm_aqR, cm_aqS))","1","cv_aqT","(1, cv_aqT)","a_aMq","b_aMr","r_aMw","t_aMx","c_aMy","1","1","(1, 1)","ra_aMs","ca_aMt","(ra_aMs, ca_aMt)","((1, 1), (ra_aMs, ca_aMt))","1","1","(1, 1)","rb_aMu","cb_aMv","(rb_aMu, cb_aMv)","((1, 1), (rb_aMu, cb_aMv))","m_add","m_sub","f_aMz","a_aMA","f_aMB","a_aMC","b_aMD","compatible_aME","v_add","v_sub","f_aQd","a_aQe","f_aQf","a_aQg","b_aQh","compatible_aQi","m_aQj","1","1","(1, 1)","r_aQk","c_aQl","(r_aQk, c_aQl)","((1, 1), (r_aQk, c_aQl))","r_aQm","c_aQn","(r_aQm, c_aQn)","v_aQo","((r_aQm, c_aQn), v_aQo)","m_aQp","1","1","(1, 1)","r_aQq","c_aQr","(r_aQq, c_aQr)","((1, 1), (r_aQq, c_aQr))","s_aQs","s_aQt","i_aQu","nullspace","m_aQv","rows_aQw","_","i_aQx","(rows_aQw, _, i_aQx)","rows_aQy","matrix_aQz","r_aWr","c_aWs","size_aQA","m_aWt","l_aWu","u_aWv","i_aWw","(l_aWu, u_aWv, i_aWw)","1","1","(1, 1)","r_aWx","c_aWy","(r_aWx, c_aWy)","((1, 1), (r_aWx, c_aWy))","m_aWz","c_a18x","c_aWH","rs_aWI","m0_aWJ","i0_aWK","(rs_aWI, m0_aWJ, i0_aWK)","m2_aWL","i2_aWM","(m2_aWL, i2_aWM)","m1_aWN","i1_aWO","(m1_aWN, i1_aWO)","swap_norm_aWP","sweep_aWQ","r_aWR","v_aWS","(r_aWR, v_aWS)","c_a18c","rs_a18d","m0_a18e","r_a18f","r1_a18g","v1_a18h","(r1_a18g, v1_a18h)","r2_a18i","v2_a18j","(r2_a18i, v2_a18j)","r_a18k","s_a18l","m_a18m","c_a18n","r_a18o","f_a18p","m_a18q","c_a18r","w_a18s","m1_a18t","m_a18u","r_a18v","c_a18w","size_aWG"]
module LinearAlgebra where
import Data.Array
import Data.List
import Types

apply :: Num a_aqO => Matrix a_aqO -> Vector a_aqO -> Vector a_aqO
apply m_aqP v_aqQ
  | cm_aqS == cv_aqT =
    accumArray (+) 0 (1, rm_aqR)
      [(r_aMn, v_aqQ ! c_aMo * m_aqP ! (r_aMn, c_aMo)) |
       (r_aMn, c_aMo) <- indices m_aqP]
  | otherwise =
    error "apply: matrix and vector dimensions are not compatible"
  where ((1, 1), (rm_aqR, cm_aqS)) = bounds m_aqP
        (1, cv_aqT) = bounds v_aqQ

m_mul :: Num a_aqN => Matrix a_aqN -> Matrix a_aqN -> Matrix a_aqN
m_mul a_aMq b_aMr
  | ca_aMt == rb_aMu =
    accumArray (+) 0 ((1, 1), (ra_aMs, cb_aMv))
      [((r_aMw, c_aMy), a_aMq ! (r_aMw, t_aMx) * b_aMr ! (t_aMx, c_aMy))
       | r_aMw <- [1 .. ra_aMs], t_aMx <- [1 .. ca_aMt],
       c_aMy <- [1 .. cb_aMv]]
  | otherwise = error "m_mul: matrix dimensions are not compatible"
  where ((1, 1), (ra_aMs, ca_aMt)) = bounds a_aMq
        ((1, 1), (rb_aMu, cb_aMv)) = bounds b_aMr

m_add :: Num a_aqM => Matrix a_aqM -> Matrix a_aqM -> Matrix a_aqM
m_add = m_zipWith (+)

m_sub :: Num a_aqL => Matrix a_aqL -> Matrix a_aqL -> Matrix a_aqL
m_sub = m_zipWith (-)

m_map :: (a_aqJ -> b_aqK) -> Matrix a_aqJ -> Matrix b_aqK
m_map f_aMz a_aMA
  = listArray (bounds a_aMA) (map f_aMz (elems a_aMA))

m_zipWith ::
          (a_aqG -> b_aqH -> c_aqI) ->
            Matrix a_aqG -> Matrix b_aqH -> Matrix c_aqI
m_zipWith f_aMB a_aMC b_aMD
  | compatible_aME =
    listArray (bounds a_aMC)
      (zipWith f_aMB (elems a_aMC) (elems b_aMD))
  | otherwise =
    error "m_zipWith: matrix dimensions are not compatible"
  where compatible_aME = bounds a_aMC == bounds b_aMD

v_add :: Num a_aqF => Vector a_aqF -> Vector a_aqF -> Vector a_aqF
v_add = v_zipWith (+)

v_sub :: Num a_aqE => Vector a_aqE -> Vector a_aqE -> Vector a_aqE
v_sub = v_zipWith (-)

v_map :: (a_aqC -> b_aqD) -> Vector a_aqC -> Vector b_aqD
v_map f_aQd a_aQe
  = listArray (bounds a_aQe) (map f_aQd (elems a_aQe))
v_zipWith f_aQf a_aQg b_aQh
  | compatible_aQi =
    listArray (bounds a_aQg)
      (zipWith f_aQf (elems a_aQg) (elems b_aQh))
  | otherwise =
    error "v_zipWith: vector dimensions are not compatible"
  where compatible_aQi = bounds a_aQg == bounds b_aQh

m_transpose :: Matrix a_aqB -> Matrix a_aqB
m_transpose m_aQj
  = let ((1, 1), (r_aQk, c_aQl)) = bounds m_aQj in
      array ((1, 1), (c_aQl, r_aQk))
        [((c_aQn, r_aQm), v_aQo) | ((r_aQm, c_aQn), v_aQo) <- assocs m_aQj]

m_is_square :: Matrix a_aqt -> Bool
m_is_square m_aQp
  = let ((1, 1), (r_aQq, c_aQr)) = bounds m_aQp in r_aQq == c_aQr

m_zero :: Num a_aqs => Index -> Matrix a_aqs
m_zero s_aQs = accumArray (+) 0 ((1, 1), (s_aQs, s_aQs)) []

m_unit :: Num a_apt => Index -> Matrix a_apt
m_unit s_aQt
  = accumArray (+) 0 ((1, 1), (s_aQt, s_aQt))
      [((i_aQu, i_aQu), 1) | i_aQu <- [1 .. s_aQt]]

nullspace :: Matrix Exact -> Matrix Exact
nullspace = m_transpose . left_nullspace . m_transpose

left_nullspace :: Matrix Exact -> Matrix Exact
left_nullspace m_aQv
  = let (rows_aQw, _, i_aQx) = gauss_jordan m_aQv in
      m_select_rows rows_aQw i_aQx

m_select_rows :: [Index] -> Matrix a_aps -> Matrix a_aps
m_select_rows rows_aQy matrix_aQz
  = listArray ((1, 1), (length rows_aQy, size_aQA))
      [matrix_aQz ! (r_aWr, c_aWs) | r_aWr <- rows_aQy,
       c_aWs <- [1 .. size_aQA]]
  where size_aQA = (snd . snd . bounds) matrix_aQz

m_inv :: Matrix Exact -> Matrix Exact
m_inv m_aWt
  | l_aWu == [] = i_aWw
  | otherwise = error "m_inv: matrix isn't invertible"
  where (l_aWu, u_aWv, i_aWw) = gauss_jordan m_aWt
        ((1, 1), (r_aWx, c_aWy)) = bounds m_aWt

gauss_jordan ::
             Matrix Exact -> ([Index], Matrix Exact, Matrix Exact)
gauss_jordan m_aWz
  | m_is_square m_aWz =
    (foldr1 (.) [step_aWA c_a18x | c_a18x <- reverse [1 .. size_aWG]])
      ([1 .. size_aWG], m_aWz, m_unit size_aWG)
  | otherwise = error "gauss_jordan: not a square matrix"
  where step_aWA c_aWH (rs_aWI, m0_aWJ, i0_aWK)
          = if v_aWS /= 0 then (delete c_aWH rs_aWI, m2_aWL, i2_aWM) else
              (rs_aWI, m0_aWJ, i0_aWK)
          where (m2_aWL, i2_aWM) = (sweep_aWQ m1_aWN, sweep_aWQ i1_aWO)
                (m1_aWN, i1_aWO) = (swap_norm_aWP m0_aWJ, swap_norm_aWP i0_aWK)
                swap_norm_aWP
                  = (multiply_aWE c_aWH (1 / v_aWS)) .
                      (if r_aWR /= c_aWH then swap_aWD r_aWR c_aWH else id)
                sweep_aWQ = eliminate_aWF c_aWH m1_aWN
                (r_aWR, v_aWS) = pivot_aWB c_aWH rs_aWI m0_aWJ
        pivot_aWB c_a18c rs_a18d m0_a18e
          = foldl1 max'_aWC
              [(r_a18f, m0_a18e ! (r_a18f, c_a18c)) | r_a18f <- rs_a18d]
        max'_aWC (r1_a18g, v1_a18h) (r2_a18i, v2_a18j)
          = if (abs (v1_a18h) >= abs (v2_a18j)) then (r1_a18g, v1_a18h) else
              (r2_a18i, v2_a18j)
        swap_aWD r_a18k s_a18l m_a18m
          = m_a18m //
              concat
                ([[((r_a18k, c_a18n), m_a18m ! (s_a18l, c_a18n)),
                   ((s_a18l, c_a18n), m_a18m ! (r_a18k, c_a18n))]
                  | c_a18n <- [1 .. size_aWG]])
        multiply_aWE r_a18o f_a18p m_a18q
          = m_a18q //
              [((r_a18o, c_a18r), f_a18p * m_a18q ! (r_a18o, c_a18r)) |
               c_a18r <- [1 .. size_aWG]]
        eliminate_aWF w_a18s m1_a18t m_a18u
          = m_a18u //
              [((r_a18v, c_a18w),
                m_a18u ! (r_a18v, c_a18w) - m1_a18t ! (r_a18v, w_a18s) * m_a18u !
                  (w_a18s, c_a18w))
               | r_a18v <- [1 .. size_aWG], r_a18v /= w_a18s,
               c_a18w <- [1 .. size_aWG]]
        size_aWG = (snd . snd . bounds) m_aWz
STARTLOG
["circuit_aqH","seed_aqI","dt_aqJ","end_time_aqK","temp_aqL","rbc_aqM","select_aqN","t_auC","_","(t_auC, _)","t_aI4","s_aI5","o_aI6","r_aI7","(t_aI4, s_aI5, o_aI6, r_aI7)","trace_aqO","step_aqP","randoms_aqQ","e_aqR","k_aqS","dt'_aqT","initial'_aqU","solve'_aqV","integrate'_aqW","correct_state'_aqX","backdate'_aqY","(initial'_aqU, solve'_aqV, integrate'_aqW, correct_state'_aqX,\n backdate'_aqY)","t_aXZ","s_aY0","o_aY1","r_aY2","(t_aXZ, s_aY0, o_aY1, r_aY2)","t_aY3","s_aY4","o_aY5","r_aY6","(t_aY3, s_aY4, o_aY5, r_aY6)","t_aY7","s_aY8","o_aY9","r_aYa","(t_aY7, s_aY8, o_aY9, r_aYa)","t_aYb","s_aYc","o_aYd","r_aYe","(t_aYb, s_aYc, o_aYd, r_aYe)","i_aYk","p_aYl","m_aYm","_","Conductor _","(i_aYk, p_aYl, m_aYm, Conductor _)","i_aYn","p_aYo","m_aYp","_","Resistor _","(i_aYn, p_aYo, m_aYp, Resistor _)","i_aYq","p_aYr","m_aYs","_","Capacitor _","(i_aYq, p_aYr, m_aYs, Capacitor _)","i_a16k","p_a16l","m_a16m","_","Inductor _","(i_a16k, p_a16l, m_a16m, Inductor _)","i_a16n","p_a16o","m_a16p","list_a16q","Vsource list_a16q","(i_a16n, p_a16o, m_a16p, Vsource list_a16q)","i_a16r","p_a16s","m_a16t","list_a16u","Isource list_a16u","(i_a16r, p_a16s, m_a16t, Isource list_a16u)","i_a16v","p_a16w","m_a16x","_","Junction _","(i_a16v, p_a16w, m_a16x, Junction _)","random_offsets_aYg","1","size_aYh","(1, size_aYh)","t'_aYi","t0_a16y","v0_a16z","(t0_a16y, v0_a16z)","[(t0_a16y, v0_a16z)]","t0_a16A","v0_a16B","(t0_a16A, v0_a16B)","_","(t0_a16A, v0_a16B) : _","((t0_a16A, v0_a16B) : _)","t0_a16J","v0_a16K","(t0_a16J, v0_a16K)","t1_a16L","v1_a16M","(t1_a16L, v1_a16M)","(t0_a16J, v0_a16K) : (t1_a16L, v1_a16M)","rest_a16N","((t0_a16J, v0_a16K) : (t1_a16L, v1_a16M)) : rest_a16N","(((t0_a16J, v0_a16K) : (t1_a16L, v1_a16M)) : rest_a16N)","t_a16P","s_a16Q","o_a16R","r_a16S","(t_a16P, s_a16Q, o_a16R, r_a16S)","e2_a16T","kT_a16U","e0_a16V","s_a17c","s_a17d","o_a17e","events_a16Y","new_states_a16Z","_","s_a17f","_","_","(_, s_a17f, _, _)","delta_energies_a170","r_a17g","s_a17h","o_a17i","_","(r_a17g, s_a17h, o_a17i, _)","probabilities_a171","r_a17j","de_a17k","(r_a17j, de_a17k)","p_a17l","ps_a17m","total_a17n","cumulative_probabilities_a175","[]","p'_a17o","s'_a17p","(p'_a17o, s'_a17p)","zs_a17q","(p'_a17o, s'_a17p) : zs_a17q","((p'_a17o, s'_a17p) : zs_a17q)","p_a177","r'_a178","p_a177 : r'_a178","(p_a177 : r'_a178)","s_a17r","i_a17s","p_a17t","m_a17u","c_a17v","_","(c_a17v, _)","Capacitor (c_a17v, _)","(i_a17s, p_a17t, m_a17u, Capacitor (c_a17v, _))","s_a17w","i_a17x","p_a17y","m_a17z","c_a17A","_","_","(c_a17A, _, _)","Junction (c_a17A, _, _)","(i_a17x, p_a17y, m_a17z, Junction (c_a17A, _, _))","_","_","s_a17B","o_a17C","i_a17D","p_a17E","m_a17F","_","Vsource _","(i_a17D, p_a17E, m_a17F, Vsource _)","_","_","_","i_a17G","p_a17H","m_a17I","c_a17J","r_a17K","_","(c_a17J, r_a17K, _)","Junction (c_a17J, r_a17K, _)","(i_a17G, p_a17H, m_a17I, Junction (c_a17J, r_a17K, _))","_","circuit_a17L","dt_a17M","elements_a17N","derivative_a17O","initial_a17P","l1_a17Q","u1_a17R","i1_a17S","(l1_a17Q, u1_a17R, i1_a17S)","l2_a17T","u2_a17U","i2_a17V","(l2_a17T, u2_a17U, i2_a17V)","constraint_a17W","freedom_a17X","l3_a17Y","u3_a17Z","i3_a180","(l3_a17Y, u3_a17Z, i3_a180)","inverse3_a181","correct_a182","correct_state_a183","correct_output_a184","solve_a185","scaled_derivative_a186","l4_a187","u4_a188","i4_a189","(l4_a187, u4_a188, i4_a189)","integrate_a18a","backdate_a18b","f_a18j","f_a18k","i_a18l","p_a18m","m_a18n","g_a18o","Conductor g_a18o","(i_a18l, p_a18m, m_a18n, Conductor g_a18o)","i_a18p","p_a18q","m_a18r","r_a18s","Resistor r_a18s","(i_a18p, p_a18q, m_a18r, Resistor r_a18s)","i_a18t","p_a18u","m_a18v","c_a18w","_","(c_a18w, _)","Capacitor (c_a18w, _)","(i_a18t, p_a18u, m_a18v, Capacitor (c_a18w, _))","i_a18x","p_a18y","m_a18z","l_a18A","_","(l_a18A, _)","Inductor (l_a18A, _)","(i_a18x, p_a18y, m_a18z, Inductor (l_a18A, _))","i_a18B","p_a18C","m_a18D","_","Vsource _","(i_a18B, p_a18C, m_a18D, Vsource _)","i_a18E","p_a18F","m_a18G","_","Isource _","(i_a18E, p_a18F, m_a18G, Isource _)","i_a18H","p_a18I","m_a18J","c_a18K","_","_","(c_a18K, _, _)","Junction (c_a18K, _, _)","(i_a18H, p_a18I, m_a18J, Junction (c_a18K, _, _))","i_a18L","p_a18M","m_a18N","_","Conductor _","(i_a18L, p_a18M, m_a18N, Conductor _)","i_a18O","p_a18P","m_a18Q","_","Resistor _","(i_a18O, p_a18P, m_a18Q, Resistor _)","i_a18R","p_a18S","m_a18T","_","_","(_, _)","Capacitor (_, _)","(i_a18R, p_a18S, m_a18T, Capacitor (_, _))","i_a18U","p_a18V","m_a18W","_","_","(_, _)","Inductor (_, _)","(i_a18U, p_a18V, m_a18W, Inductor (_, _))","i_a18X","p_a18Y","m_a18Z","_","Vsource _","(i_a18X, p_a18Y, m_a18Z, Vsource _)","i_a190","p_a191","m_a192","_","Isource _","(i_a190, p_a191, m_a192, Isource _)","i_a193","p_a194","m_a195","_","_","_","(_, _, _)","Junction (_, _, _)","(i_a193, p_a194, m_a195, Junction (_, _, _))","i_a196","p_a197","m_a198","_","Conductor _","(i_a196, p_a197, m_a198, Conductor _)","i_a199","p_a19a","m_a19b","_","Resistor _","(i_a199, p_a19a, m_a19b, Resistor _)","i_a19c","p_a19d","m_a19e","_","q_a19f","(_, q_a19f)","Capacitor (_, q_a19f)","(i_a19c, p_a19d, m_a19e, Capacitor (_, q_a19f))","i_a19g","p_a19h","m_a19i","_","f_a19j","(_, f_a19j)","Inductor (_, f_a19j)","(i_a19g, p_a19h, m_a19i, Inductor (_, f_a19j))","i_a19k","p_a19l","m_a19m","_","Vsource _","(i_a19k, p_a19l, m_a19m, Vsource _)","i_a19n","p_a19o","m_a19p","_","Isource _","(i_a19n, p_a19o, m_a19p, Isource _)","i_a19q","p_a19r","m_a19s","_","_","q_a19t","(_, _, q_a19t)","Junction (_, _, q_a19t)","(i_a19q, p_a19r, m_a19s, Junction (_, _, q_a19t))","r_a19u","c_a19v","(r_a19u, c_a19v)","_","((r_a19u, c_a19v), _)","size_a18i","p_a19w","m_a19x","i_a19y","_","(p_a19w, m_a19x, i_a19y, _)"]
module Simulate where
import Data.Array
import Data.List
import Data.Ratio
import RandomFix
import LinearAlgebra
import Types

simulate ::
         Circuit ->
           Seed -> Time -> Time -> Temperature -> RBC -> [(Time, Output)]
simulate circuit_aqH seed_aqI dt_aqJ end_time_aqK temp_aqL rbc_aqM
  = select_aqN trace_aqO
  where select_aqN
          = takeWhile (\ (t_auC, _) -> t_auC <= end_time_aqK) .
              map (\ (t_aI4, s_aI5, o_aI6, r_aI7) -> (t_aI4, o_aI6))
        trace_aqO
          = (concat . iterate step_aqP)
              ((tunnel_ar3 . correct_ar1 . solve_aqZ . sources_ar2)
                 (0, initial'_aqU, initial'_aqU, randoms_aqQ))
        step_aqP
          = tunnel_ar3 . correct_ar1 . solve_aqZ . sources_ar2 .
              integrate_ar0
              . last
        randoms_aqQ
          = map ((/ (2 ^ 30)) . fromInteger)
              (random (0, 2 ^ 30 - 1) seed_aqI)
        e_aqR = 1.6021773e-19
        k_aqS = 1.38066e-23
        dt'_aqT = circa dt_aqJ
        (initial'_aqU, solve'_aqV, integrate'_aqW, correct_state'_aqX,
         backdate'_aqY)
          = prepare circuit_aqH dt_aqJ
        solve_aqZ (t_aXZ, s_aY0, o_aY1, r_aY2)
          = (t_aXZ, s_aY0, apply solve'_aqV s_aY0, r_aY2)
        integrate_ar0 (t_aY3, s_aY4, o_aY5, r_aY6)
          = (t_aY3 + dt_aqJ, apply integrate'_aqW s_aY4, o_aY5, r_aY6)
        correct_ar1 (t_aY7, s_aY8, o_aY9, r_aYa)
          = (t_aY7, apply correct_state'_aqX s_aY8,
             v_sub o_aY9 (apply backdate'_aqY s_aY8), r_aYa)
        sources_ar2 (t_aYb, s_aYc, o_aYd, r_aYe)
          = (t_aYb, random_offsets_aYg // map elements_aYf circuit_aqH,
             o_aYd, drop size_aYh r_aYe)
          where elements_aYf (i_aYk, p_aYl, m_aYm, Conductor _) = (i_aYk, 0)
                elements_aYf (i_aYn, p_aYo, m_aYp, Resistor _) = (i_aYn, 0)
                elements_aYf (i_aYq, p_aYr, m_aYs, Capacitor _)
                  = (i_aYq, s_aYc ! i_aYq)
                elements_aYf (i_a16k, p_a16l, m_a16m, Inductor _)
                  = (i_a16k, s_aYc ! i_a16k)
                elements_aYf (i_a16n, p_a16o, m_a16p, Vsource list_a16q)
                  = (i_a16n, source_aYj list_a16q)
                elements_aYf (i_a16r, p_a16s, m_a16t, Isource list_a16u)
                  = (i_a16r, source_aYj list_a16u)
                elements_aYf (i_a16v, p_a16w, m_a16x, Junction _)
                  = (i_a16v, s_aYc ! i_a16v)
                random_offsets_aYg
                  = listArray (1, size_aYh)
                      (map ((/ dt'_aqT) . (* e_aqR) . (* rbc_aqM) . (* 2) . (+ (-0.5)))
                         r_aYe)
                (1, size_aYh) = bounds s_aYc
                t'_aYi = circa t_aYb
                source_aYj [(t0_a16y, v0_a16z)] = v0_a16z
                source_aYj ((t0_a16A, v0_a16B) : _) | t'_aYi < t0_a16A = v0_a16B
                source_aYj (((t0_a16J, v0_a16K) : (t1_a16L, v1_a16M)) : rest_a16N)
                  | t0_a16J >= t1_a16L = error "sources must have increasing times"
                  | t'_aYi < t1_a16L =
                    v0_a16K + (v1_a16M - v0_a16K) * (t'_aYi - t0_a16J) /
                      (t1_a16L - t0_a16J)
                  | otherwise = source_aYj ((t1_a16L, v1_a16M) : rest_a16N)
        tunnel_ar3 (t_a16P, s_a16Q, o_a16R, r_a16S)
          = select_a176 (zip cumulative_probabilities_a175 new_states_a16Z)
          where e2_a16T = e_aqR * e_aqR
                kT_a16U = k_aqS * temp_aqL
                e0_a16V = energy_state_a16W s_a16Q
                energy_state_a16W s_a17c
                  = sum (map (energy_state'_a179 s_a17c) circuit_aqH)
                energy_source_a16X s_a17d o_a17e
                  = sum (map (energy_source'_a17a s_a17d o_a17e) circuit_aqH)
                events_a16Y = (concat . map events'_a17b) circuit_aqH
                new_states_a16Z = map (\ (_, s_a17f, _, _) -> s_a17f) events_a16Y
                delta_energies_a170
                  = map
                      ((\ (r_a17g, s_a17h, o_a17i, _) ->
                          (r_a17g,
                           energy_state_a16W s_a17h - e0_a16V +
                             energy_source_a16X s_a17h o_a17i))
                         . correct_ar1)
                      events_a16Y
                probabilities_a171
                  = limit_total_a174
                      (map (no_negative_a173 . probability_a172) delta_energies_a170)
                probability_a172 (r_a17j, de_a17k)
                  | r_a17j == 0 =
                    error
                      "tunnel resistance must be nonzero (and should be >> 26k anyway)"
                  | temp_aqL == 0 = dt'_aqT * (-de_a17k) / (e2_a16T * circa r_a17j)
                  | de_a17k == 0 = dt'_aqT * kT_a16U / (e2_a16T * circa r_a17j)
                  | otherwise =
                    dt'_aqT * (-de_a17k) /
                      (e2_a16T * circa r_a17j * (1 - exp (de_a17k / kT_a16U)))
                no_negative_a173 p_a17l = if p_a17l < 0 then 0 else p_a17l
                limit_total_a174 ps_a17m
                  = let total_a17n = sum ps_a17m in
                      if total_a17n > 1 then map (/ total_a17n) ps_a17m else ps_a17m
                cumulative_probabilities_a175
                  = tail (scanl (+) 0 probabilities_a171)
                select_a176 [] = [(t_a16P, s_a16Q, o_a16R, r'_a178)]
                select_a176 ((p'_a17o, s'_a17p) : zs_a17q)
                  | p_a177 < p'_a17o =
                    [(t_a16P, s_a16Q, o_a16R, r'_a178),
                     (correct_ar1 . solve_aqZ) (t_a16P, s'_a17p, o_a16R, r'_a178)]
                  | otherwise = select_a176 zs_a17q
                (p_a177 : r'_a178) = r_a16S
                energy_state'_a179 s_a17r
                  (i_a17s, p_a17t, m_a17u, Capacitor (c_a17v, _))
                  | c_a17v == 0 = error "capacitance must be nonzero"
                  | otherwise = 1 / 2 * (s_a17r ! i_a17s) ^ 2 / circa c_a17v
                energy_state'_a179 s_a17w
                  (i_a17x, p_a17y, m_a17z, Junction (c_a17A, _, _))
                  | c_a17A == 0 = error "junction capacitance must be nonzero"
                  | otherwise = 1 / 2 * (s_a17w ! i_a17x) ^ 2 / circa c_a17A
                energy_state'_a179 _ _ = 0
                energy_source'_a17a s_a17B o_a17C
                  (i_a17D, p_a17E, m_a17F, Vsource _)
                  = (s_a17B ! i_a17D) * (o_a17C ! i_a17D) * dt'_aqT
                energy_source'_a17a _ _ _ = 0
                events'_a17b (i_a17G, p_a17H, m_a17I, Junction (c_a17J, r_a17K, _))
                  = [(r_a17K, s_a16Q // [(i_a17G, s_a16Q ! i_a17G + e_aqR)],
                      v_map (const 0) o_a16R, []),
                     (r_a17K, s_a16Q // [(i_a17G, s_a16Q ! i_a17G - e_aqR)],
                      v_map (const 0) o_a16R, [])]
                events'_a17b _ = []

prepare ::
        Circuit ->
          Time ->
            (Vector Approx, Matrix Approx, Matrix Approx, Matrix Approx,
             Matrix Approx)
prepare circuit_a17L dt_a17M
  = (v_map circa initial_a17P, m_map circa solve_a185,
     m_map circa integrate_a18a, m_map circa correct_state_a183,
     m_map circa backdate_a18b)
  where elements_a17N = matrix_a18c element_a18e
        derivative_a17O = matrix_a18c deriv_a18f
        initial_a17P = vector_a18d init_a18g
        (l1_a17Q, u1_a17R, i1_a17S) = gauss_jordan elements_a17N
        (l2_a17T, u2_a17U, i2_a17V)
          = gauss_jordan (m_transpose elements_a17N)
        constraint_a17W = m_select_rows l1_a17Q i1_a17S
        freedom_a17X = m_transpose (m_select_rows l2_a17T i2_a17V)
        (l3_a17Y, u3_a17Z, i3_a180)
          = gauss_jordan
              (m_mul constraint_a17W (m_mul derivative_a17O freedom_a17X))
        inverse3_a181
          | l3_a17Y == [] = i3_a180
          | otherwise = error "illegal circuit"
        correct_a182
          | l1_a17Q == [] = m_zero size_a18i
          | otherwise =
            m_mul freedom_a17X (m_mul inverse3_a181 constraint_a17W)
        correct_state_a183
          = m_sub (m_unit size_a18i) (m_mul derivative_a17O correct_a182)
        correct_output_a184
          = m_sub (m_unit size_a18i) (m_mul correct_a182 derivative_a17O)
        solve_a185
          = m_mul correct_output_a184 (m_mul i1_a17S correct_state_a183)
        scaled_derivative_a186
          = m_map (* (dt_a17M / 2)) (m_mul derivative_a17O solve_a185)
        (l4_a187, u4_a188, i4_a189)
          = gauss_jordan (m_sub (m_unit size_a18i) scaled_derivative_a186)
        integrate_a18a
          | l4_a187 == [] =
            m_mul i4_a189 (m_add (m_unit size_a18i) scaled_derivative_a186)
          | otherwise = error "unlucky choice of dt - try a smaller one"
        backdate_a18b = m_map (/ dt_a17M) correct_a182
        matrix_a18c f_a18j
          = accumArray (+) (0 % 1) ((1, 1), (size_a18i, size_a18i))
              ((filter no_ground_a18h . concat . map f_a18j) circuit_a17L)
        vector_a18d f_a18k
          = accumArray (+) (0 % 1) (1, size_a18i)
              ((concat . map f_a18k) circuit_a17L)
        element_a18e (i_a18l, p_a18m, m_a18n, Conductor g_a18o)
          = [((p_a18m, i_a18l), (-1) % 1), ((m_a18n, i_a18l), 1 % 1),
             ((i_a18l, m_a18n), -g_a18o), ((i_a18l, p_a18m), g_a18o),
             ((i_a18l, i_a18l), (-1) % 1)]
        element_a18e (i_a18p, p_a18q, m_a18r, Resistor r_a18s)
          = [((p_a18q, i_a18p), (-1) % 1), ((m_a18r, i_a18p), 1 % 1),
             ((i_a18p, m_a18r), (-1) % 1), ((i_a18p, p_a18q), 1 % 1),
             ((i_a18p, i_a18p), -r_a18s)]
        element_a18e (i_a18t, p_a18u, m_a18v, Capacitor (c_a18w, _))
          = [((p_a18u, i_a18t), (-1) % 1), ((m_a18v, i_a18t), 1 % 1),
             ((i_a18t, m_a18v), -c_a18w), ((i_a18t, p_a18u), c_a18w)]
        element_a18e (i_a18x, p_a18y, m_a18z, Inductor (l_a18A, _))
          = [((p_a18y, i_a18x), (-1) % 1), ((m_a18z, i_a18x), 1 % 1),
             ((i_a18x, i_a18x), l_a18A)]
        element_a18e (i_a18B, p_a18C, m_a18D, Vsource _)
          = [((p_a18C, i_a18B), (-1) % 1), ((m_a18D, i_a18B), 1 % 1),
             ((i_a18B, m_a18D), (-1) % 1), ((i_a18B, p_a18C), 1 % 1)]
        element_a18e (i_a18E, p_a18F, m_a18G, Isource _)
          = [((p_a18F, i_a18E), (-1) % 1), ((m_a18G, i_a18E), 1 % 1),
             ((i_a18E, i_a18E), 1 % 1)]
        element_a18e (i_a18H, p_a18I, m_a18J, Junction (c_a18K, _, _))
          = [((p_a18I, i_a18H), (-1) % 1), ((m_a18J, i_a18H), 1 % 1),
             ((i_a18H, m_a18J), -c_a18K), ((i_a18H, p_a18I), c_a18K)]
        deriv_a18f (i_a18L, p_a18M, m_a18N, Conductor _) = []
        deriv_a18f (i_a18O, p_a18P, m_a18Q, Resistor _) = []
        deriv_a18f (i_a18R, p_a18S, m_a18T, Capacitor (_, _))
          = [((i_a18R, i_a18R), 1)]
        deriv_a18f (i_a18U, p_a18V, m_a18W, Inductor (_, _))
          = [((i_a18U, p_a18V), 1), ((i_a18U, m_a18W), -1)]
        deriv_a18f (i_a18X, p_a18Y, m_a18Z, Vsource _) = []
        deriv_a18f (i_a190, p_a191, m_a192, Isource _) = []
        deriv_a18f (i_a193, p_a194, m_a195, Junction (_, _, _))
          = [((i_a193, i_a193), 1)]
        init_a18g (i_a196, p_a197, m_a198, Conductor _) = []
        init_a18g (i_a199, p_a19a, m_a19b, Resistor _) = []
        init_a18g (i_a19c, p_a19d, m_a19e, Capacitor (_, q_a19f))
          = [(i_a19c, q_a19f)]
        init_a18g (i_a19g, p_a19h, m_a19i, Inductor (_, f_a19j))
          = [(i_a19g, f_a19j)]
        init_a18g (i_a19k, p_a19l, m_a19m, Vsource _) = []
        init_a18g (i_a19n, p_a19o, m_a19p, Isource _) = []
        init_a18g (i_a19q, p_a19r, m_a19s, Junction (_, _, q_a19t))
          = [(i_a19q, q_a19t)]
        no_ground_a18h ((r_a19u, c_a19v), _) = r_a19u /= 0 && c_a19v /= 0
        size_a18i
          = maximum
              (concat
                 (map (\ (p_a19w, m_a19x, i_a19y, _) -> [p_a19w, m_a19x, i_a19y])
                    circuit_a17L))
STARTLOG
["l_avz","h_avA","(l_avz, h_avA)","s_avB","q_aJ4","s1_aJ5","(q_aJ4, s1_aJ5)","s2_aJ6","k_aJ7","b_aJ8","n_aJ9","is_aT7","xs_aT8","is'_aT9","(xs_aT8, is'_aT9)","i_a12H","r_a12I","b_a12J","i_a12K","s1_a12L","s2_a12M","s1_a12N","s2_a12O","z'_a12P","z_a12Q","k_a12R","s1'_a12S","s1''_a12T","k'_a12U","s2'_a12V","s2''_a12W"]
module RandomFix (random) where

random :: (Integer, Integer) -> Integer -> [Integer]
random (l_avz, h_avA) s_avB
  = if l_avz > h_avA then error "Random.random: Empty interval" else
      if s_avB < 0 then random (l_avz, h_avA) (-s_avB) else
        let (q_aJ4, s1_aJ5) = s_avB `divMod` 2147483562
            s2_aJ6 = q_aJ4 `mod` 2147483398
            k_aJ7 = h_avA - l_avz + 1
            b_aJ8 = 2147483561
            n_aJ9 = iLogBase b_aJ8 k_aJ7
            f_aJa is_aT7
              = let (xs_aT8, is'_aT9) = splitAt n_aJ9 is_aT7 in
                  foldr (\ i_a12H r_a12I -> fromIntegral i_a12H + r_a12I * b_aJ8) 0
                    xs_aT8
                    `mod` k_aJ7
                    + l_avz
                    : f_aJa is'_aT9
          in
          f_aJa
            (randomInts (fromIntegral (s1_aJ5 + 1))
               (fromIntegral (s2_aJ6 + 1)))
iLogBase b_a12J i_a12K
  = if i_a12K < b_a12J then 1 else
      1 + iLogBase b_a12J (i_a12K `div` b_a12J)

randomInts :: Int -> Int -> [Int]
randomInts s1_a12L s2_a12M
  = if 1 <= s1_a12L && s1_a12L <= 2147483562 then
      if 1 <= s2_a12M && s2_a12M <= 2147483398 then rands s1_a12L s2_a12M
        else error "randomInts: Bad second seed."
      else error "randomInts: Bad first seed."

rands :: Int -> Int -> [Int]
rands s1_a12N s2_a12O = z'_a12P : rands s1''_a12T s2''_a12W
  where z'_a12P = if z_a12Q < 1 then z_a12Q + 2147483562 else z_a12Q
        z_a12Q = s1''_a12T - s2''_a12W
        k_a12R = s1_a12N `quot` 53668
        s1'_a12S = 40014 * (s1_a12N - k_a12R * 53668) - k_a12R * 12211
        s1''_a12T
          = if s1'_a12S < 0 then s1'_a12S + 2147483563 else s1'_a12S
        k'_a12U = s2_a12O `quot` 52774
        s2'_a12V = 40692 * (s2_a12O - k'_a12U * 52774) - k'_a12U * 3791
        s2''_a12W
          = if s2'_a12V < 0 then s2'_a12V + 2147483399 else s2'_a12V
STARTLOG
["parse_circuit","parse_exact","parse_approx","parse_integer","circuit","list_aH3","list_with_types_aH4","e_aH8","n1_aH9","n2_aHa","n3_aHb","(n1_aH9, n2_aHa, n3_aHb)","(e_aH8, (n1_aH9, n2_aHa, n3_aHb))","names_aH5","_","n1_aPA","n2_aPB","n3_aPC","(n1_aPA, n2_aPB, n3_aPC)","(_, (n1_aPA, n2_aPB, n3_aPC))","circuit_aH6","e_aPD","n1_aPE","n2_aPF","n3_aPG","(n1_aPE, n2_aPF, n3_aPG)","(e_aPD, (n1_aPE, n2_aPF, n3_aPG))","name_aPH","element","conductor_aST","resistor_aSU","capacitor_aSV","inductor_aSW","vsource_aSX","isource_aSY","junction_aSZ","c_aT1","n_aT2","e_aT3","(n_aT2, e_aT3)","list","approx","exact","sign_a13F","int_a13G","(sign_a13F, int_a13G)","frac_a13H","fact_a13I","(frac_a13H, fact_a13I)","((sign_a13F, int_a13G), (frac_a13H, fact_a13I))","sign_aT4","\"\"","\"-\"","integer_aT6","s_a12H","fraction_aT8","[]","s_a13x","[s_a13x]","factor_aTa","\"a\"","\"f\"","\"p\"","\"n\"","\"u\"","\"m\"","\"\"","\"k\"","\"M\"","\"G\"","\"T\"","\"P\"","\"E\"","integer","name"]
module Parse
       (parse_circuit, parse_exact, parse_approx, parse_integer) where
import Data.Char
import Data.List
import Data.Maybe
import Data.Ratio
import Types
import ParseLib
parse_circuit = parse (remove_right circuit whitespace)
parse_exact = parse (remove_right exact whitespace)
parse_approx = parse (remove_right approx whitespace)
parse_integer = parse (remove_right integer whitespace)

circuit :: Parser (Circuit, [Name])
circuit = transform make_indices_aH2 (repetition1 element)
  where make_indices_aH2 list_aH3 = (circuit_aH6, names_aH5)
          where list_with_types_aH4
                  = [(e_aH8, ("i:" ++ n1_aH9, "v:" ++ n2_aHa, "v:" ++ n3_aHb)) |
                     (e_aH8, (n1_aH9, n2_aHa, n3_aHb)) <- list_aH3]
                names_aH5
                  = (nub . ("v:ground" :) . concat)
                      [[n1_aPA, n2_aPB, n3_aPC] |
                       (_, (n1_aPA, n2_aPB, n3_aPC)) <- list_with_types_aH4]
                circuit_aH6
                  = [(index_aH7 n1_aPE, index_aH7 n2_aPF, index_aH7 n3_aPG, e_aPD) |
                     (e_aPD, (n1_aPE, n2_aPF, n3_aPG)) <- list_with_types_aH4]
                index_aH7 name_aPH
                  = fromJust (lookup name_aPH (zip names_aH5 [0 ..]))

element :: Parser (Element, (Name, Name, Name))
element
  = choice
      [conductor_aST, resistor_aSU, capacitor_aSV, inductor_aSW,
       vsource_aSX, isource_aSY, junction_aSZ]
  where conductor_aST = code_aT0 'g' (transform Conductor exact)
        resistor_aSU = code_aT0 'r' (transform Resistor exact)
        capacitor_aSV
          = code_aT0 'c' (transform Capacitor (sequence2 exact exact))
        inductor_aSW
          = code_aT0 'l' (transform Inductor (sequence2 exact exact))
        vsource_aSX = code_aT0 'v' (transform Vsource list)
        isource_aSY = code_aT0 'i' (transform Isource list)
        junction_aSZ
          = code_aT0 'j' (transform Junction (sequence3 exact exact exact))
        code_aT0 c_aT1
          = transform (\ (n_aT2, e_aT3) -> (e_aT3, n_aT2)) .
              (sequence2
                 (remove_left (character c_aT1) (sequence3 name name name)))

list :: Parser List
list
  = repetition1
      (enclose (character '(') (glue approx (character ',') approx)
         (character ')'))

approx :: Parser Approx
approx = transform circa exact

exact :: Parser Exact
exact
  = transform
      (\ ((sign_a13F, int_a13G), (frac_a13H, fact_a13I)) ->
         sign_a13F * (int_a13G + frac_a13H) * fact_a13I)
      (sequence2 (sequence2 sign_aT4 integer_aT6)
         (sequence2 fraction_aT8 factor_aTa))
  where sign_aT4 = transform make_sign_aT5 (option (character '-'))
        make_sign_aT5 "" = 1 % 1
        make_sign_aT5 "-" = (-1) % 1
        integer_aT6 = transform make_integer_aT7 (parse_while isDigit)
        make_integer_aT7 s_a12H = read s_a12H % 1
        fraction_aT8
          = transform make_fraction_aT9
              (option (remove_left (character' '.') (parse_while isDigit)))
        make_fraction_aT9 [] = 0 % 1
        make_fraction_aT9 [s_a13x]
          = read s_a13x % read ('1' : map (const '0') s_a13x)
        factor_aTa
          = transform make_factor_aTb
              (option (parse_if' (`elem` "afpnumkMGTPE")))
        make_factor_aTb "a" = 1 % 1000000000000000000
        make_factor_aTb "f" = 1 % 1000000000000000
        make_factor_aTb "p" = 1 % 1000000000000
        make_factor_aTb "n" = 1 % 1000000000
        make_factor_aTb "u" = 1 % 1000000
        make_factor_aTb "m" = 1 % 1000
        make_factor_aTb "" = 1 % 1
        make_factor_aTb "k" = 1000 % 1
        make_factor_aTb "M" = 1000000 % 1
        make_factor_aTb "G" = 1000000000 % 1
        make_factor_aTb "T" = 1000000000000 % 1
        make_factor_aTb "P" = 1000000000000000 % 1
        make_factor_aTb "E" = 1000000000000000000 % 1

integer :: Parser Integer
integer
  = transform read
      (choice
         [cons (character '-') (parse_while isDigit), parse_while isDigit])

name :: Parser Name
name = parse_while isAlphaNum
STARTLOG
["empty","x_avt","c_avu","x_avv","p_aSv","x_aSw","s_aSx","x_aSy","split_aSz","p_aSG","x_aSH","ps_aSI","x_aSJ","p_aSK","r_aSL","p1_aSM","p2_aSN","x0_aSO","r1_aSP","x1_aSQ","(r1_aSP, x1_aSQ)","r2_aSR","x2_aSS","(r2_aSR, x2_aSS)","p1_aST","p2_aSU","p3_aSV","x0_aSW","r1_aSX","x1_aSY","(r1_aSX, x1_aSY)","r2_aSZ","x2_aT0","(r2_aSZ, x2_aT0)","r3_aT1","x3_aT2","(r3_aT1, x3_aT2)","f_aT3","p_aT4","s_aT5","r_aT6","x_aT7","(r_aT6, x_aT7)","p_aT8","x_aT9","result_aTa","p_aTb","r_aTc","x_aTd","(r_aTc, x_aTd)","p_aTe","ps_aTf","a_aTg","as_aTh","(a_aTg, as_aTh)","p_aTi","p_aTj","p_aTk","a_aTl","p1_aTm","p2_aTn","p1_aTo","p2_aTp","p1_aTq","p2_aTr","p3_aTs","a_aTu","b_aTv","c_aTw","(a_aTu, b_aTv, c_aTw)","p1_aTx","p2_aTy","p3_aTz","a_aTB","b_aTC","c_aTD","(a_aTB, b_aTC, c_aTD)","whitespace","c_aU0","p_aU1","s_aU2","p_aU3","parser_aU4"]
module ParseLib where
import Data.Char

empty :: Parser [a_avs]
empty = (\ x_avt -> [([], x_avt)])

character' :: Char -> Parser Char
character' c_avu x_avv
  | null x_avv = []
  | c_avu == head x_avv = [(head x_avv, tail x_avv)]
  | otherwise = []

parse_if' :: (Char -> Bool) -> Parser Char
parse_if' p_aSv x_aSw
  | null x_aSw = []
  | p_aSv (head x_aSw) = [(head x_aSw, tail x_aSw)]
  | otherwise = []

string' :: String -> Parser String
string' s_aSx x_aSy
  | s_aSx == fst split_aSz = [split_aSz]
  | otherwise = []
  where split_aSz = splitAt (length s_aSx) x_aSy

parse_while' :: (Char -> Bool) -> Parser String
parse_while' p_aSG x_aSH
  | null x_aSH = []
  | p_aSG (head x_aSH) = [span p_aSG x_aSH]
  | otherwise = []

choice :: [Parser r_avr] -> Parser r_avr
choice ps_aSI x_aSJ
  = [r_aSL | p_aSK <- ps_aSI, r_aSL <- p_aSK x_aSJ]

sequence2 ::
          Parser r1_avp -> Parser r2_avq -> Parser (r1_avp, r2_avq)
sequence2 p1_aSM p2_aSN x0_aSO
  = [((r1_aSP, r2_aSR), x2_aSS) | (r1_aSP, x1_aSQ) <- p1_aSM x0_aSO,
     (r2_aSR, x2_aSS) <- p2_aSN x1_aSQ]

sequence3 ::
          Parser r1_avm ->
            Parser r2_avn -> Parser r3_avo -> Parser (r1_avm, r2_avn, r3_avo)
sequence3 p1_aST p2_aSU p3_aSV x0_aSW
  = [((r1_aSX, r2_aSZ, r3_aT1), x3_aT2) |
     (r1_aSX, x1_aSY) <- p1_aST x0_aSW,
     (r2_aSZ, x2_aT0) <- p2_aSU x1_aSY,
     (r3_aT1, x3_aT2) <- p3_aSV x2_aT0]

transform :: (a_avk -> b_avl) -> Parser a_avk -> Parser b_avl
transform f_aT3 p_aT4 s_aT5
  = [(f_aT3 r_aT6, x_aT7) | (r_aT6, x_aT7) <- p_aT4 s_aT5]

allow_null :: Parser [a_avj] -> Parser [a_avj]
allow_null p_aT8 x_aT9
  | null result_aTa = [([], x_aT9)]
  | otherwise = result_aTa
  where result_aTa = p_aT8 x_aT9

forbid_null :: Parser [a_avi] -> Parser [a_avi]
forbid_null p_aTb
  = filter (\ (r_aTc, x_aTd) -> (not . null) r_aTc) . p_aTb

cons :: Parser a_avh -> Parser [a_avh] -> Parser [a_avh]
cons p_aTe ps_aTf
  = transform (\ (a_aTg, as_aTh) -> a_aTg : as_aTh)
      (sequence2 p_aTe ps_aTf)

repetition0 :: Parser a_avg -> Parser [a_avg]
repetition0 p_aTi = allow_null (cons p_aTi (repetition0 p_aTi))

repetition1 :: Parser a_avf -> Parser [a_avf]
repetition1 p_aTj = (cons p_aTj (repetition0 p_aTj))

option :: Parser a_ave -> Parser [a_ave]
option p_aTk = choice [transform (\ a_aTl -> [a_aTl]) p_aTk, empty]

remove_left :: Parser a_avc -> Parser b_avd -> Parser b_avd
remove_left p1_aTm p2_aTn = transform snd (sequence2 p1_aTm p2_aTn)

remove_right :: Parser a_ava -> Parser b_avb -> Parser a_ava
remove_right p1_aTo p2_aTp
  = transform fst (sequence2 p1_aTo p2_aTp)

enclose ::
        Parser a_av7 -> Parser b_av8 -> Parser c_av9 -> Parser b_av8
enclose p1_aTq p2_aTr p3_aTs
  = transform take_mid_aTt (sequence3 p1_aTq p2_aTr p3_aTs)
  where take_mid_aTt (a_aTu, b_aTv, c_aTw) = b_aTv

glue ::
     Parser a_av4 ->
       Parser b_av5 -> Parser c_av6 -> Parser (a_av4, c_av6)
glue p1_aTx p2_aTy p3_aTz
  = transform drop_mid_aTA (sequence3 p1_aTx p2_aTy p3_aTz)
  where drop_mid_aTA (a_aTB, b_aTC, c_aTD) = (a_aTB, c_aTD)

whitespace :: Parser String
whitespace = allow_null (parse_while' isSpace)

character :: Char -> Parser Char
character c_aU0 = remove_left whitespace (character' c_aU0)

parse_if :: (Char -> Bool) -> Parser Char
parse_if p_aU1 = remove_left whitespace (parse_if' p_aU1)

string :: String -> Parser String
string s_aU2 = remove_left whitespace (string' s_aU2)

parse_while :: (Char -> Bool) -> Parser String
parse_while p_aU3 = remove_left whitespace (parse_while' p_aU3)

parse :: Parser a_auW -> String -> [a_auW]
parse parser_aU4 = map fst . filter (null . snd) . parser_aU4

type Parser a_auV = String -> [(a_auV, String)]
STARTLOG
["circa"]
module Types where
import Data.Array

circa :: Exact -> Approx
circa = fromRational

type Name = String

type Seed = Integer

type Index = Int

type Vector a_aFk = Array Index a_aFk

type Matrix a_awN = Array (Index, Index) a_awN

type Exact = Rational

type Time = Exact

type Approx = Double

type List = [(Approx, Approx)]

data Element = Conductor Exact
             | Resistor Exact
             | Capacitor (Exact, Exact)
             | Inductor (Exact, Exact)
             | Vsource List
             | Isource List
             | Junction (Exact, Exact, Exact)
             deriving Show

type Circuit = [(Index, Index, Index, Element)]

type Random = [Approx]

type Output = Vector Approx

type State = Vector Approx

type RBC = Approx

type Temperature = Approx
STARTLOG
STARTLOG
["cylLen","cylLen2","cylRad","cylRad2","big","small","nothing","wgtCut","wgtCut2","ergCut","scatter","escape","transit","numExit","numLev","numStat","ne","nt","ns","nek","nwk","nr","nsp","nc","nnc","nrk","wrl","wrg"]
module Consts
       (cylLen, cylLen2, cylRad, cylRad2, wgtCut, wgtCut2, ergCut, big,
        small, nothing, scatter, escape, transit, numExit, numLev, numStat,
        ne, nt, ns, nek, nwk, nr, nsp, nc, nnc, nrk, wrl, wrg)
       where

cylLen, cylLen2, cylRad, cylRad2, wgtCut, wgtCut2, ergCut, big,
        small, nothing :: Double
cylLen = 20.0
cylLen2 = cylLen + 10.0
cylRad = 1.0
cylRad2 = cylRad * cylRad
big = 100.0
small = 1.0e-7
nothing = -30.0
wgtCut = 0.5
wgtCut2 = wgtCut * wgtCut
ergCut = 1.0e-3

scatter, escape, transit, numExit, numLev, numStat :: Int

ne, nt, ns, nek, nwk, nr, nsp, nc, nnc, nrk, wrl, wrg :: Int
scatter = 1
escape = 2
transit = 3
numExit = 3
numLev = 35
numStat = 12
ne = 1
nt = 2
ns = 3
nek = 4
nwk = 5
nr = 6
nsp = 7
nc = 8
nnc = 9
nrk = 10
wrl = 11
wrg = 12
STARTLOG
["p_aow","!p_aow","(!p_aow)","prob_aox","!prob_aox","(!prob_aox)","pos_aoy","!pos_aoy","(!pos_aoy)","dir_aoz","!dir_aoz","(!dir_aoz)","w_aoA","!w_aoA","(!w_aoA)","e_aoB","eIndx_aoC","cell_aoD","!cell_aoD","(!cell_aoD)","seed_aoE","!seed_aoE","(!seed_aoE)","Part (!pos_aoy) (!dir_aoz) (!w_aoA) e_aoB eIndx_aoC (!cell_aoD)\n  (!seed_aoE)","(Part (!pos_aoy) (!dir_aoz) (!w_aoA) e_aoB eIndx_aoC (!cell_aoD)\n   (!seed_aoE))","!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) e_aoB eIndx_aoC (!cell_aoD)\n    (!seed_aoE))","(!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) e_aoB eIndx_aoC (!cell_aoD)\n     (!seed_aoE)))","((!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) e_aoB eIndx_aoC (!cell_aoD)\n      (!seed_aoE))))","!((!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) e_aoB eIndx_aoC\n       (!cell_aoD) (!seed_aoE))))","(!((!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) e_aoB eIndx_aoC\n        (!cell_aoD) (!seed_aoE)))))","pComp_aoF","!pComp_aoF","(!pComp_aoF)","pPair_aoG","!pPair_aoG","(!pPair_aoG)","pPhot_aoH","pTot_aoI","!pTot_aoI","(!pTot_aoI)","((!pComp_aoF), (!pPair_aoG), pPhot_aoH, (!pTot_aoI))","seed'_aoJ","r2_aoK","(seed'_aoJ, r2_aoK)","r1_aoL","r3_aoM","!r3_aoM","(!r3_aoM)","(r1_aoL, (!r3_aoM))","w'_aoN","!w'_aoN","(!w'_aoN)","w''_aoO","!w''_aoO","(!w''_aoO)","absorb_aoP","!absorb_aoP","(!absorb_aoP)"]
module PhotoElec (photoElec) where
import GamtebType
import Consts
import Utils

photoElec :: Particle -> Probability -> (Particle, Value, Bool)
photoElec (norecord@p_aow) (norecord@prob_aox)
  = if (w'_aoN > wgtCut2) then
      (Part pos_aoy dir_aoz w'_aoN e_aoB eIndx_aoC cell_aoD seed'_aoJ,
       absorb_aoP, False)
      else
      if ((w'_aoN * fromIntegral cell_aoD) < (r1_aoL * wgtCut)) then
        (Part pos_aoy dir_aoz w'_aoN e_aoB eIndx_aoC cell_aoD seed'_aoJ,
         absorb_aoP, True)
        else
        (Part pos_aoy dir_aoz w''_aoO e_aoB eIndx_aoC cell_aoD seed'_aoJ,
         absorb_aoP, False)
  where (norecord@((norecord@(Part (norecord@pos_aoy)
                                (norecord@dir_aoz) (norecord@w_aoA) e_aoB eIndx_aoC
                                (norecord@cell_aoD) (norecord@seed_aoE)))))
          = p_aow
        ((norecord@pComp_aoF), (norecord@pPair_aoG), pPhot_aoH,
         (norecord@pTot_aoI))
          = prob_aox
        (seed'_aoJ, r2_aoK) = genRand seed_aoE
        (r1_aoL, (norecord@r3_aoM)) = genRand r2_aoK
        (norecord@w'_aoN) = w_aoA * (1 - pPhot_aoH / pTot_aoI)
        (norecord@w''_aoO) = wgtCut / fromIntegral cell_aoD
        (norecord@absorb_aoP) = w_aoA - w'_aoN
STARTLOG
["seed_aoT","safebang@!seed_aoT","(!seed_aoT)","nPart_aoU","safebang@!nPart_aoU","(!nPart_aoU)","e_aoV","safebang@!e_aoV","(!e_aoV)","eIndx_aoW","!eIndx_aoW","(!eIndx_aoW)","prob_aoX","!prob_aoX","(!prob_aoX)","((!eIndx_aoW), (!prob_aoX))","seed'_aoY","_","!_","(!_)","(seed'_aoY, (!_))","!(seed'_aoY, (!_))","(!(seed'_aoY, (!_)))","p_aoZ","!p_aoZ","(!p_aoZ)","seed_aCs","!seed_aCs","(!seed_aCs)","nPart_aCt","!nPart_aCt","(!nPart_aCt)","e_aCu","!e_aCu","(!e_aCu)","nPart1_aCv","nPart2_aCw","!nPart2_aCw","(!nPart2_aCw)","r1_aCx","r2_aCy","(r1_aCx, r2_aCy)","res1_aCz","s1_aCA","(res1_aCz, s1_aCA)","!(res1_aCz, s1_aCA)","(!(res1_aCz, s1_aCA))","res2_aCB","s2_aCC","safebang@!s2_aCC","(!s2_aCC)","(res2_aCB, (!s2_aCC))","!(res2_aCB, (!s2_aCC))","(!(res2_aCB, (!s2_aCC)))","scale_aMH","safebang@!scale_aMH","(!scale_aMH)","seed_aMI","!seed_aMI","(!seed_aMI)","nPart_aMJ","!nPart_aMJ","(!nPart_aMJ)","energy_aMK","result_aML","stats_aMM","safebang@!stats_aMM","(!stats_aMM)","(result_aML, (!stats_aMM))","!(result_aML, (!stats_aMM))","(!(result_aML, (!stats_aMM)))"]
module GamtebMain (gamteb) where
import GamtebType
import Consts
import Utils
import TransPort
import Output

sources :: Random -> Int -> Energy -> ([Result], [Stat])
sources (!seed_aoT) (!nPart_aoU) (!e_aoV)
  | (nPart_aoU <= 1) = transPort p_aoZ prob_aoX
  where ((norecord@eIndx_aoW), (norecord@prob_aoX))
          = xsectInterp e_aoV
        (norecord@(seed'_aoY, (norecord@_))) = genRand seed_aoT
        (norecord@p_aoZ)
          = (Part (0, 0, 0) (0, 1, 0) 1 e_aoV eIndx_aoW 1 seed'_aoY)
sources (norecord@seed_aCs) (norecord@nPart_aCt) (norecord@e_aCu)
  = (res1_aCz ++ res2_aCB, s1_aCA ++ s2_aCC)
  where nPart1_aCv = nPart_aCt `div` 2
        (norecord@nPart2_aCw) = nPart_aCt - nPart1_aCv
        (r1_aCx, r2_aCy) = genRand seed_aCs
        (norecord@(res1_aCz, s1_aCA)) = sources r1_aCx nPart1_aCv e_aCu
        (norecord@(res2_aCB, (!s2_aCC))) = sources r2_aCy nPart2_aCw e_aCu

gamteb :: Int -> [Char]
gamteb (!scale_aMH) = outGamteb nPart_aMJ stats_aMM result_aML
  where (norecord@seed_aMI) = 0.5
        (norecord@nPart_aMJ) = 1 * scale_aMH
        energy_aMK = 6
        (norecord@(result_aML, (!stats_aMM)))
          = sources seed_aMI nPart_aMJ energy_aMK
STARTLOG
["x_aok","!x_aok","(!x_aok)","y_aol","!y_aol","(!y_aol)","z_aom","!z_aom","(!z_aom)","((!x_aok), (!y_aol), (!z_aom))","!((!x_aok), (!y_aol), (!z_aom))","(!((!x_aok), (!y_aol), (!z_aom)))","p1_aoj@(!((!x_aok), (!y_aol), (!z_aom)))","!p1_aoj@(!((!x_aok), (!y_aol), (!z_aom)))","(!p1_aoj@(!((!x_aok), (!y_aol), (!z_aom))))","((!p1_aoj@(!((!x_aok), (!y_aol), (!z_aom)))))","u_aoo","v_aop","!v_aop","(!v_aop)","w_aoq","!w_aoq","(!w_aoq)","(u_aoo, (!v_aop), (!w_aoq))","!(u_aoo, (!v_aop), (!w_aoq))","(!(u_aoo, (!v_aop), (!w_aoq)))","p2_aon@(!(u_aoo, (!v_aop), (!w_aoq)))","!p2_aon@(!(u_aoo, (!v_aop), (!w_aoq)))","(!p2_aon@(!(u_aoo, (!v_aop), (!w_aoq))))","((!p2_aon@(!(u_aoo, (!v_aop), (!w_aoq)))))","!((!p2_aon@(!(u_aoo, (!v_aop), (!w_aoq)))))","(!((!p2_aon@(!(u_aoo, (!v_aop), (!w_aoq))))))","d1_aor","!d1_aor","(!d1_aor)","s1_aos","((!d1_aor), s1_aos)","!((!d1_aor), s1_aos)","(!((!d1_aor), s1_aos))","d2_aot","s2_aou","(d2_aot, s2_aou)","d3_aov","s3_aow","(d3_aov, s3_aow)","!(d3_aov, s3_aow)","(!(d3_aov, s3_aow))","d4_aox","s4_aoy","!s4_aoy","(!s4_aoy)","(d4_aox, (!s4_aoy))","!(d4_aox, (!s4_aoy))","(!(d4_aox, (!s4_aoy)))","dSurf_aoz","!dSurf_aoz","(!dSurf_aoz)","surf_aoA","!surf_aoA","(!surf_aoA)","((!dSurf_aoz), (!surf_aoA))","!((!dSurf_aoz), (!surf_aoA))","(!((!dSurf_aoz), (!surf_aoA)))","d_aoC","j_aoD","(d_aoC, j_aoD)","!(d_aoC, j_aoD)","(!(d_aoC, j_aoD))","d'_aoE","!d'_aoE","(!d'_aoE)","j'_aoF","((!d'_aoE), j'_aoF)","x_aD6","!x_aD6","(!x_aD6)","y_aD7","z_aD8","((!x_aD6), y_aD7, z_aD8)","!((!x_aD6), y_aD7, z_aD8)","(!((!x_aD6), y_aD7, z_aD8))","u_aD9","v_aDa","!v_aDa","(!v_aDa)","w_aDb","!w_aDb","(!w_aDb)","(u_aD9, (!v_aDa), (!w_aDb))","!(u_aD9, (!v_aDa), (!w_aDb))","(!(u_aD9, (!v_aDa), (!w_aDb)))","m_aDc","!m_aDc","(!m_aDc)","b_aDd","s_aDe","r_aDf","!r_aDf","(!r_aDf)","x'_aDg","m_aMn","b_aMo","r_aMp","y'_aMq","y_aMr","v_aMs","yPlane_aMt"]
module Distance (distSurf) where
import GamtebType
import Consts

distSurf :: Point -> Point -> (Value, Indx)
distSurf
  ((norecord@p1_aoj@(norecord@((norecord@x_aok), (norecord@y_aol),
                               (norecord@z_aom)))))
  (norecord@((norecord@p2_aon@(norecord@(u_aoo, (norecord@v_aop),
                                         (norecord@w_aoq))))))
  = (dSurf_aoz + small, surf_aoA)
  where (norecord@((norecord@d1_aor), s1_aos))
          = ((distPlane y_aol v_aop 0), 1)
        (d2_aot, s2_aou) = ((distCyl p1_aoj p2_aon), 2)
        (norecord@(d3_aov, s3_aow)) = ((distPlane y_aol v_aop cylLen), 3)
        (norecord@(d4_aox, (norecord@s4_aoy)))
          = ((distPlane y_aol v_aop cylLen2), 4)
        (norecord@((norecord@dSurf_aoz), (norecord@surf_aoA)))
          = minP_aoB (minP_aoB (d1_aor, s1_aos) (d2_aot, s2_aou))
              (minP_aoB (d3_aov, s3_aow) (d4_aox, s4_aoy))
        minP_aoB (norecord@(d_aoC, j_aoD)) ((norecord@d'_aoE), j'_aoF)
          = if (d_aoC < d'_aoE) then (d_aoC, j_aoD) else (d'_aoE, j'_aoF)

distCyl :: Point -> Point -> Value
distCyl (norecord@((norecord@x_aD6), y_aD7, z_aD8))
  (norecord@(u_aD9, (norecord@v_aDa), (norecord@w_aDb)))
  | (u_aD9 * u_aD9 + w_aDb * w_aDb) == 0 = big
  | (u_aD9 /= 0) =
    let (norecord@m_aDc) = w_aDb / u_aD9
        b_aDd = z_aD8 - m_aDc * x_aD6
        s_aDe = m_aDc * m_aDc + 1
        (norecord@r_aDf) = sqrt (s_aDe - b_aDd * b_aDd)
        x'_aDg
          = if (u_aD9 > 0) then (((-m_aDc) * b_aDd) + r_aDf) / s_aDe else
              (((-m_aDc) * b_aDd) - r_aDf) / s_aDe
      in (x'_aDg - x_aD6) / u_aD9
  | (u_aD9 == 0 && v_aDa /= 0) =
    let m_aMn = w_aDb / v_aDa
        b_aMo = z_aD8 - m_aMn * y_aD7
        r_aMp = sqrt (1 - x_aD6 * x_aD6)
        y'_aMq
          = if (v_aDa > 0) then (r_aMp - b_aMo) / m_aMn else
              ((-r_aMp) - b_aMo) / m_aMn
      in (y'_aMq - y_aD7) / v_aDa
  | w_aDb > 0 = (sqrt (1 - x_aD6 * x_aD6)) - z_aD8
  | otherwise = (-(sqrt (1 - x_aD6 * x_aD6))) - z_aD8

distPlane :: Coord -> Coord -> Value -> Value
distPlane y_aMr v_aMs yPlane_aMt
  | v_aMs == 0 = big
  | y_aMr >= yPlane_aMt = big
  | otherwise = (yPlane_aMt - y_aMr) / v_aMs
STARTLOG
["pos_aox","!pos_aox","(!pos_aox)","dir_aoy","!dir_aoy","(!dir_aoy)","w_aoz","!w_aoz","(!w_aoz)","e_aoA","!e_aoA","(!e_aoA)","eIndx_aoB","!eIndx_aoB","(!eIndx_aoB)","cell_aoC","seed_aoD","Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB) cell_aoC\n  seed_aoD","(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB) cell_aoC\n   seed_aoD)","!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n    cell_aoC seed_aoD)","(!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n     cell_aoC seed_aoD))","((!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n      cell_aoC seed_aoD)))","!((!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n       cell_aoC seed_aoD)))","(!((!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n        cell_aoC seed_aoD))))","r1_aoE","!r1_aoE","(!r1_aoE)","r2_aoF","!r2_aoF","(!r2_aoF)","((!r1_aoE), (!r2_aoF))","!((!r1_aoE), (!r2_aoF))","(!((!r1_aoE), (!r2_aoF)))","seed'_aoG","!seed'_aoG","(!seed'_aoG)","r3_aoH","((!seed'_aoG), r3_aoH)","!((!seed'_aoG), r3_aoH)","(!((!seed'_aoG), r3_aoH))","pos_aD8","dir_aD9","w_aDa","e_aDb","eIndx_aDc","cell_aDd","!cell_aDd","(!cell_aDd)","seed_aDe","Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc (!cell_aDd) seed_aDe","(Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc (!cell_aDd) seed_aDe)","!(Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc (!cell_aDd) seed_aDe)","(!(Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc (!cell_aDd)\n     seed_aDe))","((!(Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc (!cell_aDd)\n      seed_aDe)))","!((!(Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc (!cell_aDd)\n       seed_aDe)))","(!((!(Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc (!cell_aDd)\n        seed_aDe))))","seed1_aDf","!seed1_aDf","(!seed1_aDf)","seed2_aDg","!seed2_aDg","(!seed2_aDg)","((!seed1_aDf), (!seed2_aDg))","!((!seed1_aDf), (!seed2_aDg))","(!((!seed1_aDf), (!seed2_aDg)))"]
module RoulSplit (roulet, split) where
import GamtebType
import Consts
import Utils

roulet :: Particle -> (Particle, [Stat], Bool)
roulet
  (norecord@((norecord@(Part (norecord@pos_aox) (norecord@dir_aoy)
                          (norecord@w_aoz) (norecord@e_aoA) (norecord@eIndx_aoB) cell_aoC
                          seed_aoD))))
  = if (r1_aoE < 0.5) then
      (Part pos_aox dir_aoy (2 * w_aoz) e_aoA eIndx_aoB 1 seed'_aoG,
       [(nr, 1), (wrg, w_aoz)], False)
      else
      (Part pos_aox dir_aoy 0 e_aoA eIndx_aoB 1 seed'_aoG,
       [(nr, 1), (nrk, 1), (wrl, w_aoz)], True)
  where (norecord@((norecord@r1_aoE), (norecord@r2_aoF)))
          = genRand seed_aoD
        (norecord@((norecord@seed'_aoG), r3_aoH)) = genRand r2_aoF

split :: Particle -> (Particle, Particle)
split
  (norecord@((norecord@(Part pos_aD8 dir_aD9 w_aDa e_aDb eIndx_aDc
                          (norecord@cell_aDd) seed_aDe))))
  = (Part pos_aD8 dir_aD9 (0.5 * w_aDa) e_aDb eIndx_aDc 2 seed1_aDf,
     Part pos_aD8 dir_aD9 (0.5 * w_aDa) e_aDb eIndx_aDc 2 seed2_aDg)
  where (norecord@((norecord@seed1_aDf), (norecord@seed2_aDg)))
          = genRand seed_aDe
STARTLOG
STARTLOG
[]
module GamtebType
       (Angle, Coord, Energy, Indx, PartType, Prob, Random, StatType,
        Weight, Value, Result, Stat, Point, Particle(..), Probability)
       where

type Angle = Double

type Coord = Double

type Energy = Double

type Indx = Int

type PartType = Int

type Prob = Double

type Random = Double

type StatType = Int

type Weight = Double

type Value = Double

type Result = ((PartType, Indx), Weight)

type Stat = (StatType, Value)

type Point = (Coord, Coord, Coord)

type Probability = (Prob, Prob, Prob, Prob)

data Particle = Part Point Point Weight Energy Indx Int Random
STARTLOG
["e_awH","safebang@!e_awH","(!e_awH)","logE_awI","!logE_awI","(!logE_awI)","eIndx_awJ","!eIndx_awJ","(!eIndx_awJ)","i_awQ","safebang@!i_awQ","(!i_awQ)","i_aTi","!i_aTi","(!i_aTi)","i_awK","f_awL","pComp_awM","!pComp_awM","(!pComp_awM)","pPair_awN","!pPair_awN","(!pPair_awN)","pPhot_awO","!pPhot_awO","(!pPhot_awO)","seed_a12o","safebang@!seed_a12o","(!seed_a12o)","r1_a12p","!r1_a12p","(!r1_a12p)","r2_a12q","!r2_a12q","(!r2_a12q)","x_a12s","m_a12t","!m_a12t","(!m_a12t)"]
module Utils (xsectInterp, genRand) where
import GamtebType
import Consts
import InitTable
import Data.Array ((!))

xsectInterp :: Energy -> (Indx, Probability)
xsectInterp (!e_awH)
  = (eIndx_awJ,
     (pComp_awM, pPair_awN, pPhot_awO,
      (pComp_awM + pPair_awN + pPhot_awO)))
  where (norecord@logE_awI) = log e_awH
        (norecord@eIndx_awJ) = findIndx_awP 1
          where findIndx_awP (!i_awQ)
                  | (i_awQ < numLev) && (logE_awI > ergs ! i_awQ) =
                    findIndx_awP (i_awQ + 1)
                findIndx_awP (norecord@i_aTi) = i_aTi
        i_awK = (if (eIndx_awJ < 2) then 2 else eIndx_awJ)
        f_awL
          = (logE_awI - ergs ! (i_awK - 1)) /
              (ergs ! i_awK - ergs ! (i_awK - 1))
        (norecord@pComp_awM)
          = exp
              (xComp ! (i_awK - 1) + f_awL *
                 (xComp ! i_awK - xComp ! (i_awK - 1)))
        (norecord@pPair_awN)
          = exp
              (xPair ! (i_awK - 1) + f_awL *
                 (xPair ! i_awK - xPair ! (i_awK - 1)))
        (norecord@pPhot_awO)
          = exp
              (xPhot ! (i_awK - 1) + f_awL *
                 (xPhot ! i_awK - xPhot ! (i_awK - 1)))

genRand :: Random -> (Random, Random)
genRand (!seed_a12o) = (r1_a12p / 65599, r2_a12q / 71123)
  where (norecord@r1_a12p)
          = (314557 * seed_a12o + 2711) `fiRem_a12r` 65599
        (norecord@r2_a12q) = (2711 * seed_a12o + 314557) `fiRem_a12r` 71123
        fiRem_a12r x_a12s (norecord@m_a12t)
          = x_a12s - fromIntegral ((truncate x_a12s `div` m_a12t) * m_a12t)
STARTLOG
["pos_aoy","!pos_aoy","(!pos_aoy)","dir_aoz","!dir_aoz","(!dir_aoz)","w_aoA","!w_aoA","(!w_aoA)","e_aoB","!e_aoB","(!e_aoB)","eIndx_aoC","!eIndx_aoC","(!eIndx_aoC)","cell_aoD","seed_aoE","Part (!pos_aoy) (!dir_aoz) (!w_aoA) (!e_aoB) (!eIndx_aoC) cell_aoD\n  seed_aoE","(Part (!pos_aoy) (!dir_aoz) (!w_aoA) (!e_aoB) (!eIndx_aoC) cell_aoD\n   seed_aoE)","!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) (!e_aoB) (!eIndx_aoC)\n    cell_aoD seed_aoE)","(!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) (!e_aoB) (!eIndx_aoC)\n     cell_aoD seed_aoE))","((!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) (!e_aoB) (!eIndx_aoC)\n      cell_aoD seed_aoE)))","!((!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) (!e_aoB) (!eIndx_aoC)\n       cell_aoD seed_aoE)))","(!((!(Part (!pos_aoy) (!dir_aoz) (!w_aoA) (!e_aoB) (!eIndx_aoC)\n        cell_aoD seed_aoE))))","seed'_aoF","!seed'_aoF","(!seed'_aoF)","r2_aoG","!r2_aoG","(!r2_aoG)","((!seed'_aoF), (!r2_aoG))","!((!seed'_aoF), (!r2_aoG))","(!((!seed'_aoF), (!r2_aoG)))","r3_aoH","!r3_aoH","(!r3_aoH)","r4_aoI","((!r3_aoH), r4_aoI)","!((!r3_aoH), r4_aoI)","(!((!r3_aoH), r4_aoI))","eIn_aoJ","eOut_aoK","angle_aoL","e'_aoM","eIndx'_aoN","prob'_aoO","!prob'_aoO","(!prob'_aoO)","(eIndx'_aoN, (!prob'_aoO))","dir'_aoP","!dir'_aoP","(!dir'_aoP)","u_aMm","safebang@!u_aMm","(!u_aMm)","v_aMn","safebang@!v_aMn","(!v_aMn)","w_aMo","safebang@!w_aMo","(!w_aMo)","((!u_aMm), (!v_aMn), (!w_aMo))","!((!u_aMm), (!v_aMn), (!w_aMo))","(!((!u_aMm), (!v_aMn), (!w_aMo)))","a_aMp","rn_aMq","r'_aMy","!r'_aMy","(!r'_aMy)","t1'_aMz","!t1'_aMz","(!t1'_aMz)","t2'_aMA","wsq_aMB","s_aMC","!s_aMC","(!s_aMC)","u'_aMD","v'_aME","w'_aMF","!w'_aMF","(!w'_aMF)","r1_aMr","r2_aMs","!r2_aMs","(!r2_aMs)","(r1_aMr, (!r2_aMs))","!(r1_aMr, (!r2_aMs))","(!(r1_aMr, (!r2_aMs)))","rn'_aMt","!rn'_aMt","(!rn'_aMt)","r3_aMu","!r3_aMu","(!r3_aMu)","((!rn'_aMt), (!r3_aMu))","t1_aMv","t2_aMw","!t2_aMw","(!t2_aMw)","r_aMx","e_aMG","r_aMH","a'_aMT","b'_aMU","c'_aMV","x'_aMW","c'_aMX","x'_aMY","x'_aMZ","a'_aN0","!a'_aN0","(!a'_aN0)","b'_aN1","c'_aN2","a_aMI","b_aMJ","c_aMK","!c_aMK","(!c_aMK)","d_aML","!d_aML","(!d_aML)","f_aMM","!f_aMM","(!f_aMM)","x2_aMO","!x2_aMO","(!x2_aMO)","x3_aMP","!x3_aMP","(!x3_aMP)","x4_aMQ","!x4_aMQ","(!x4_aMQ)","x5_aMR","x7_aMS"]
module Compton (compton) where
import GamtebType
import Consts
import Utils

compton :: Particle -> (Particle, Probability, Bool)
compton
  (norecord@((norecord@(Part (norecord@pos_aoy) (norecord@dir_aoz)
                          (norecord@w_aoA) (norecord@e_aoB) (norecord@eIndx_aoC) cell_aoD
                          seed_aoE))))
  = if (e'_aoM <= ergCut) then
      (Part pos_aoy dir_aoz w_aoA e'_aoM eIndx'_aoN cell_aoD seed'_aoF,
       prob'_aoO, True)
      else
      (Part pos_aoy dir'_aoP w_aoA e'_aoM eIndx'_aoN cell_aoD seed'_aoF,
       prob'_aoO, False)
  where (norecord@((norecord@seed'_aoF), (norecord@r2_aoG)))
          = genRand seed_aoE
        (norecord@((norecord@r3_aoH), r4_aoI)) = genRand r2_aoG
        eIn_aoJ = 1.956917 * e_aoB
        eOut_aoK = klein eIn_aoJ r3_aoH
        angle_aoL = 1 + 1 / eIn_aoJ - 1 / eOut_aoK
        e'_aoM = 0.511008 * eOut_aoK
        (eIndx'_aoN, (norecord@prob'_aoO)) = xsectInterp e'_aoM
        (norecord@dir'_aoP) = rotas dir_aoz angle_aoL r4_aoI

rotas :: Point -> Angle -> Random -> Point
rotas (norecord@((!u_aMm), (!v_aMn), (!w_aMo))) a_aMp rn_aMq
  = if (r_aMx > 1) then rotas (u_aMm, v_aMn, w_aMo) a_aMp rn'_aMt
      else
      (let (norecord@r'_aMy) = sqrt ((1 - a_aMp * a_aMp) / r_aMx)
           (norecord@t1'_aMz) = t1_aMv * r'_aMy
           t2'_aMA = t2_aMw * r'_aMy
           wsq_aMB = 1 - w_aMo * w_aMo
           (norecord@s_aMC) = sqrt wsq_aMB
           u'_aMD
             = u_aMm * a_aMp + (t1'_aMz * u_aMm * w_aMo - t2'_aMA * v_aMn) /
                 s_aMC
           v'_aME
             = v_aMn * a_aMp + (t1'_aMz * v_aMn * w_aMo - t2'_aMA * u_aMm) /
                 s_aMC
           (norecord@w'_aMF) = w_aMo * a_aMp - t1'_aMz * s_aMC
         in
         if (wsq_aMB < small) then (t1'_aMz, t2'_aMA, (w_aMo * a_aMp)) else
           (u'_aMD, v'_aME, w'_aMF))
  where (norecord@(r1_aMr, (norecord@r2_aMs))) = genRand rn_aMq
        ((norecord@rn'_aMt), (norecord@r3_aMu)) = genRand r2_aMs
        t1_aMv = 2 * r1_aMr - 1
        (norecord@t2_aMw) = 2 * r3_aMu - 1
        r_aMx = t1_aMv * t1_aMv + t2_aMw * t2_aMw

klein :: Energy -> Random -> Energy
klein e_aMG r_aMH
  = if (e_aMG > 1.16666667) then
      (let a'_aMT = 1.65898 + a_aMI * (0.62537 * a_aMI - 1.00796)
           b'_aMU = a'_aMT / f_aMM
         in
         if (r_aMH > b'_aMU) then
           (let c'_aMV = (d_aML - 1.20397) / (1 - b'_aMU)
                x'_aMW = 0.3 * exp (c'_aMV * (b'_aMU - r_aMH))
              in x'_aMW * e_aMG)
           else
           (let c'_aMX
                  = a'_aMT / (3.63333 + a_aMI * (5.44444 * a_aMI - 4.66667))
                x'_aMY = klein1_aMN (r_aMH / b'_aMU) 2.1 c'_aMX 1.4 (0.5 * a'_aMT)
              in x'_aMY * e_aMG))
      else
      (let x'_aMZ
             = klein1_aMN r_aMH (3 * c'_aN2) a'_aN0 (2 * c'_aN2) b'_aN1
           (norecord@a'_aN0) = f_aMM / (b_aMJ + c_aMK)
           b'_aN1 = 0.5 * f_aMM
           c'_aN2 = 1 - c_aMK
         in x'_aMZ * e_aMG)
  where a_aMI = 1 / e_aMG
        b_aMJ = 2 * e_aMG + 1
        (norecord@c_aMK) = 1 / b_aMJ
        (norecord@d_aML) = log b_aMJ
        (norecord@f_aMM)
          = 2 * e_aMG * (1 + e_aMG) * c_aMK * c_aMK + 4 * a_aMI +
              (1 - 2 * a_aMI * (1 + a_aMI))
              * d_aML
        klein1_aMN (norecord@x2_aMO) (norecord@x3_aMP) (norecord@x4_aMQ)
          x5_aMR x7_aMS
          = 1 + x2_aMO *
              (x2_aMO *
                 (2 * x7_aMS + x4_aMQ - x3_aMP + x2_aMO *
                    (x5_aMR - x7_aMS - x4_aMQ))
                 - x7_aMS)
STARTLOG
["pos_aox","!pos_aox","(!pos_aox)","dir_aoy","!dir_aoy","(!dir_aoy)","w_aoz","!w_aoz","(!w_aoz)","e_aoA","!e_aoA","(!e_aoA)","eIndx_aoB","!eIndx_aoB","(!eIndx_aoB)","cell_aoC","seed_aoD","Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB) cell_aoC\n  seed_aoD","(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB) cell_aoC\n   seed_aoD)","!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n    cell_aoC seed_aoD)","(!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n     cell_aoC seed_aoD))","((!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n      cell_aoC seed_aoD)))","!((!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n       cell_aoC seed_aoD)))","(!((!(Part (!pos_aox) (!dir_aoy) (!w_aoz) (!e_aoA) (!eIndx_aoB)\n        cell_aoC seed_aoD))))","seed'_aoE","!seed'_aoE","(!seed'_aoE)","r2_aoF","!r2_aoF","(!r2_aoF)","((!seed'_aoE), (!r2_aoF))","!((!seed'_aoE), (!r2_aoF))","(!((!seed'_aoE), (!r2_aoF)))","r3_aoG","!r3_aoG","(!r3_aoG)","r4_aoH","((!r3_aoG), r4_aoH)","!((!r3_aoG), r4_aoH)","(!((!r3_aoG), r4_aoH))","e'_aoI","eIndx'_aoJ","prob'_aoK","(eIndx'_aoJ, prob'_aoK)","w'_aoL","dir'_aoM","!dir'_aoM","(!dir'_aoM)","r_aDd","r1_aDe","!r1_aDe","(!r1_aDe)","r2_aDf","!r2_aDf","(!r2_aDf)","((!r1_aDe), (!r2_aDf))","!((!r1_aDe), (!r2_aDf))","(!((!r1_aDe), (!r2_aDf)))","r3_aDg","!r3_aDg","(!r3_aDg)","r4_aDh","!r4_aDh","(!r4_aDh)","((!r3_aDg), (!r4_aDh))","t1_aDi","t2_aDj","!t2_aDj","(!t2_aDj)","t1_aDl","safebang@!t1_aDl","(!t1_aDl)","t2_aDm","rsq_aDn","r1_aDo","!r1_aDo","(!r1_aDo)","r2_aDp","((!r1_aDo), r2_aDp)","r3_aDq","!r3_aDq","(!r3_aDq)","r4_aDr","((!r3_aDq), r4_aDr)","!((!r3_aDq), r4_aDr)","(!((!r3_aDq), r4_aDr))","t1_aDs","!t1_aDs","(!t1_aDs)","t2_aDt","!t2_aDt","(!t2_aDt)","u_aDu","!u_aDu","(!u_aDu)","t3_aDv","v_aDw","w_aDx","!w_aDx","(!w_aDx)"]
module Pair (pair) where
import GamtebType
import Consts
import Utils

pair :: Particle -> (Particle, Probability, Bool)
pair
  (norecord@((norecord@(Part (norecord@pos_aox) (norecord@dir_aoy)
                          (norecord@w_aoz) (norecord@e_aoA) (norecord@eIndx_aoB) cell_aoC
                          seed_aoD))))
  = if (e'_aoI <= ergCut) then
      (Part pos_aox dir_aoy w'_aoL e'_aoI eIndx'_aoJ cell_aoC seed'_aoE,
       prob'_aoK, True)
      else
      (Part pos_aox dir'_aoM w'_aoL e'_aoI eIndx'_aoJ cell_aoC seed'_aoE,
       prob'_aoK, False)
  where (norecord@((norecord@seed'_aoE), (norecord@r2_aoF)))
          = genRand seed_aoD
        (norecord@((norecord@r3_aoG), r4_aoH)) = genRand r2_aoF
        e'_aoI = 0.511008
        (eIndx'_aoJ, prob'_aoK) = xsectInterp e'_aoI
        w'_aoL = 2 * w_aoz
        (norecord@dir'_aoM) = isos r3_aoG

isos :: Random -> Point
isos r_aDd
  = isos'_aDk t1_aDi t2_aDj (t1_aDi * t1_aDi + t2_aDj * t2_aDj)
  where (norecord@((norecord@r1_aDe), (norecord@r2_aDf)))
          = genRand r_aDd
        ((norecord@r3_aDg), (norecord@r4_aDh)) = genRand r2_aDf
        t1_aDi = 2 * r4_aDh - 1
        (norecord@t2_aDj) = 2 * r3_aDg - 1
        isos'_aDk (!t1_aDl) t2_aDm rsq_aDn
          | rsq_aDn > 1 =
            let ((norecord@r1_aDo), r2_aDp) = genRand r1_aDo
                (norecord@((norecord@r3_aDq), r4_aDr)) = genRand r2_aDp
                (norecord@t1_aDs) = 2 * r4_aDr - 1
                (norecord@t2_aDt) = 2 * r3_aDq - 1
              in isos'_aDk t1_aDs t2_aDt (t1_aDs * t1_aDs + t2_aDt * t2_aDt)
          | otherwise =
            let (norecord@u_aDu) = 2 * rsq_aDn - 1
                t3_aDv = sqrt (1 - u_aDu * u_aDu) / rsq_aDn
                v_aDw = t1_aDl * t3_aDv
                (norecord@w_aDx) = t2_aDm * t3_aDv
              in (u_aDu, v_aDw, w_aDx)
STARTLOG
["nPart_awZ","safebang@!nPart_awZ","(!nPart_awZ)","stats_ax0","safebang@!stats_ax0","(!stats_ax0)","results_ax1","safebang@!results_ax1","(!results_ax1)","results_aFs","!results_aFs","(!results_aFs)","resArray_aFt","lazydmd@!resArray_aFt","(!resArray_aFt)","stats_aOV","statArray_aOW","statList_aOX","safebang@!statList_aOX","(!statList_aOX)","titles_aOY","!titles_aOY","(!titles_aOY)","[]","![]","(![])","[]","![]","(![])","t_aP0","safebang@!t_aP0","(!t_aP0)","ts_aP1","safebang@!ts_aP1","(!ts_aP1)","(!t_aP0) : (!ts_aP1)","((!t_aP0) : (!ts_aP1))","!((!t_aP0) : (!ts_aP1))","(!((!t_aP0) : (!ts_aP1)))","s_aP2","ss_aP3","s_aP2 : ss_aP3","(s_aP2 : ss_aP3)","[]","i_aP4","safebang@!i_aP4","(!i_aP4)","t_aP5","((!i_aP4), t_aP5)","!((!i_aP4), t_aP5)","(!((!i_aP4), t_aP5))","w_aP6","safebang@!w_aP6","(!w_aP6)","((!((!i_aP4), t_aP5)), (!w_aP6))","!((!((!i_aP4), t_aP5)), (!w_aP6))","(!((!((!i_aP4), t_aP5)), (!w_aP6)))","rs_aP7","safebang@!rs_aP7","(!rs_aP7)","(!((!((!i_aP4), t_aP5)), (!w_aP6))) : (!rs_aP7)","((!((!((!i_aP4), t_aP5)), (!w_aP6))) : (!rs_aP7))","!((!((!((!i_aP4), t_aP5)), (!w_aP6))) : (!rs_aP7))","(!((!((!((!i_aP4), t_aP5)), (!w_aP6))) : (!rs_aP7)))","((!((!((!((!i_aP4), t_aP5)), (!w_aP6))) : (!rs_aP7))))","outXsectTbl"]
module Output (outGamteb) where
import GamtebType
import Consts
import Utils
import InitTable
import Data.Array

outGamteb :: Int -> [Stat] -> [Result] -> [Char]
outGamteb (!nPart_awZ) (!stats_ax0) (!results_ax1)
  = "Number of particles " ++ show nPart_awZ ++ "\n" ++ outXsectTbl
      ++ outResultsRaw results_ax1
      ++ outStats stats_ax0
      ++ outResults results_ax1
outResults (norecord@results_aFs)
  = "\nScatter, Escape, Transit tables:\n" ++ show resArray_aFt
  where (lazydmd@resArray_aFt)
          = accumArray (+) 0 ((1, 1), (numExit, numLev)) results_aFs
outStats stats_aOV = showStats_aOZ titles_aOY statList_aOX
  where statArray_aOW = accumArray (+) 0 (1, numStat) stats_aOV
        (!statList_aOX) = elems statArray_aOW
        (norecord@titles_aOY)
          = ["Number of escapes: ", "Number of transits: ",
             "Number of scatters: ", "Number of energy kills: ",
             "Number of weight kills: ", "Number of roulettes: ",
             "Number of splits: ", "Number of collisions: ",
             "Number of noncollisions: ", "Number of roulettes kills: ",
             "Weight of roulette kills: ", "Weight of roulette gains: "]
        showStats_aOZ (norecord@[]) (norecord@[]) = ""
        showStats_aOZ (norecord@((!t_aP0) : (!ts_aP1))) (s_aP2 : ss_aP3)
          = t_aP0 ++ show s_aP2 ++ "\n" ++ showStats_aOZ ts_aP1 ss_aP3

outResultsRaw :: [Result] -> [Char]
outResultsRaw [] = []
outResultsRaw
  ((norecord@((norecord@((norecord@((!i_aP4), t_aP5)), (!w_aP6))) :
                (!rs_aP7))))
  = "Result: index " ++ show i_aP4 ++ "  type " ++ show t_aP5 ++
      "  weight "
      ++ show w_aP6
      ++ "\n"
      ++ outResultsRaw rs_aP7

outXsectTbl :: [Char]
outXsectTbl
  = "\nEnergy table:\n" ++ show (ergs ! 1) ++ "\nCompton table:\n" ++
      show (xComp ! 1)
      ++ "\nPair table:\n"
      ++ show (xPair ! 1)
      ++ "\nPhoto table:\n"
      ++ show (xPhot ! 1)
      ++ "\n"
STARTLOG
["ergs","erg_axa","!erg_axa","(!erg_axa)","xComp","xc_aAM","!xc_aAM","(!xc_aAM)","xPair","xp_aAN","xPhot","xpe_aAO","!xpe_aAO","(!xpe_aAO)","x_aAP","safebang@!x_aAP","(!x_aAP)","x_aOI","!x_aOI","(!x_aOI)"]
module InitTable (ergs, xComp, xPair, xPhot) where
import GamtebType
import Consts
import Data.Array

ergs :: Array Indx Value
ergs
  = array (1, numLev) (zipWith (,) [1 .. numLev] (map f2 erg_axa))
  where (norecord@erg_axa)
          = [1.0e-3, 1.5e-3, 2.0e-3, 3.0e-3, 4.0e-3, 5.0e-3, 6.0e-3, 8.0e-3,
             1.0e-2, 1.5e-2, 2.0e-2, 3.0e-2, 4.0e-2, 5.0e-2, 6.0e-2, 8.0e-2,
             0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.8, 1.0, 1.5, 2.0, 3.0, 4.0,
             5.0, 6.0, 8.0, 10.0, 15.0, 20.0]

xComp :: Array Indx Value
xComp
  = array (1, numLev) (zipWith (,) [1 .. numLev] (map f1 xc_aAM))
  where (norecord@xc_aAM)
          = [1.5e-2, 2.96e-2, 4.51e-2, 7.17e-2, 9.13e-2, 0.105, 0.115, 0.128,
             0.137, 0.152, 0.16, 0.165, 0.165, 0.163, 0.16, 0.153, 0.146, 0.133,
             0.122, 0.106, 9.53e-2, 8.67e-2, 8.02e-2, 7.07e-2, 6.37e-2, 5.16e-2,
             4.4e-2, 3.46e-2, 2.89e-2, 2.5e-2, 2.21e-2, 1.81e-2, 1.54e-2,
             1.14e-2, 9.13e-3]

xPair :: Array Indx Value
xPair
  = array (1, numLev) (zipWith (,) [1 .. numLev] (map f1 xp_aAN))
  where xp_aAN
          = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
             7.92e-5, 3.16e-4, 9.23e-4, 1.53e-3, 2.08e-3, 2.56e-3, 3.43e-3,
             4.14e-3, 5.47e-3, 6.52e-3]

xPhot :: Array Indx Value
xPhot
  = array (1, numLev) (zipWith (,) [1 .. numLev] (map f1 xpe_aAO))
  where (norecord@xpe_aAO)
          = [2010.0, 632.0, 280.0, 87.7, 37.3, 18.9, 10.4, 4.01, 1.91, 0.489,
             0.192, 4.91e-2, 1.86e-2, 8.87e-3, 4.81e-3, 1.79e-3, 8.62e-4,
             2.34e-4, 9.18e-5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

f1 :: Value -> Value
f1 (!x_aAP)
  = if (x_aAP < small) then nothing else log (2.2 * x_aAP)

f2 :: Value -> Value
f2 (norecord@x_aOI)
  = if (x_aOI < small) then nothing else log x_aOI
STARTLOG
["main"]
module Main where
import Rsa
main
  = interact
      (encrypt
         2036450659413645137870851576872812267542175329986469156678671505255564383842535488743101632280716717779536712424613501441720195827856504007305662157107
         387784473137902876992546516170169092918207676456888779623592396031349415024943784869634893342729620092877891356118467738167515879252473323905128540213)
STARTLOG
["n_avI","safebang@!n_avI","(!n_avI)","e_avJ","n_aHD","safebang@!n_aHD","(!n_aHD)","d_aHE","safebang@!d_aHE","(!d_aHE)","code","x_aOA","y_aOB","!y_aOB","(!y_aOB)","n_a15N","!n_a15N","(!n_a15N)","0","x_a15P","!x_a15P","(!x_a15P)","0","xs_a193","safebang@!xs_a193","(!xs_a193)","n_a194","!n_a194","(!n_a194)","[]","![]","(![])","n_a195","!n_a195","(!n_a195)","xs_a196","!xs_a196","(!xs_a196)","n_a197","p'_a198","safebang@!p'_a198","(!p'_a198)","q'_a199","safebang@!q'_a199","(!q'_a199)","p_a19a","!p_a19a","(!p_a19a)","q_a19b","safebang@!q_a19b","(!q_a19b)","n_a19c","!n_a19c","(!n_a19c)","phi_a19d","!phi_a19d","(!phi_a19d)","d_a19e","a_a19f","odd_a19g","safebang@!odd_a19g","(!odd_a19g)","p_a19i","x_a19j","!x_a19j","(!x_a19j)","n_a1mH","a_a1mI","!a_a1mI","(!a_a1mI)","e_a1mJ","g_a1mK","v_a1mL","0","w_a1mM","g_a1mN","!g_a1mN","(!g_a1mN)","v_a1mO","!v_a1mO","(!v_a1mO)","h_a1mP","!h_a1mP","(!h_a1mP)","w_a1mQ","!w_a1mQ","(!w_a1mQ)","fact_a1mR","0","m_a1mS","safebang@!m_a1mS","(!m_a1mS)","x_a1mT","safebang@!x_a1mT","(!x_a1mT)","n_a1mU","m_a1mV","x_a1mW","!x_a1mW","(!x_a1mW)","x_a1mX","!x_a1mX","(!x_a1mX)"]
module Rsa (encrypt, decrypt, makeKeys) where

encrypt, decrypt :: Integer -> Integer -> String -> String
encrypt (!n_avI) e_avJ
  = unlines . map (show . power e_avJ n_avI . code) .
      collect (size n_avI)
decrypt (!n_aHD) (!d_aHE)
  = concat . map (decode . power d_aHE n_aHD . read) . lines

code :: String -> Integer
code = foldl accum_aOz 0
  where accum_aOz x_aOA (norecord@y_aOB)
          = (128 * x_aOA) + fromIntegral (fromEnum y_aOB)

decode :: Integer -> String
decode (norecord@n_a15N) = reverse (expand_a15O n_a15N)
  where expand_a15O 0 = []
        expand_a15O (norecord@x_a15P)
          = toEnum (fromIntegral (x_a15P `mod` 128)) :
              expand_a15O (x_a15P `div` 128)

collect :: Int -> [a_avH] -> [[a_avH]]
collect 0 (!xs_a193) = []
collect (norecord@n_a194) (norecord@[]) = []
collect (norecord@n_a195) (norecord@xs_a196)
  = take n_a195 xs_a196 : collect n_a195 (drop n_a195 xs_a196)

size :: Integer -> Int
size n_a197 = (length (show n_a197) * 47) `div` 100

makeKeys :: Integer -> Integer -> (Integer, Integer, Integer)
makeKeys (!p'_a198) (!q'_a199)
  = (n_a19c, invert phi_a19d d_a19e, d_a19e)
  where (norecord@p_a19a) = nextPrime p'_a198
        (!q_a19b) = nextPrime q'_a199
        (norecord@n_a19c) = p_a19a * q_a19b
        (norecord@phi_a19d) = (p_a19a - 1) * (q_a19b - 1)
        d_a19e = nextPrime (p_a19a + q_a19b + 1)

nextPrime :: Integer -> Integer
nextPrime a_a19f
  = head (filter prime_a19h [odd_a19g, odd_a19g + 2 ..])
  where (!odd_a19g)
          | even a_a19f = a_a19f + 1
          | True = a_a19f
        prime_a19h p_a19i
          = and
              [power (p_a19i - 1) p_a19i x_a19j == 1 |
               (norecord@x_a19j) <- [3, 5, 7]]

invert :: Integer -> Integer -> Integer
invert n_a1mH (norecord@a_a1mI)
  = if e_a1mJ < 0 then e_a1mJ + n_a1mH else e_a1mJ
  where e_a1mJ = iter n_a1mH 0 a_a1mI 1

iter :: Integer -> Integer -> Integer -> Integer -> Integer
iter g_a1mK v_a1mL 0 w_a1mM = v_a1mL
iter (norecord@g_a1mN) (norecord@v_a1mO) (norecord@h_a1mP)
  (norecord@w_a1mQ)
  = iter h_a1mP w_a1mQ (g_a1mN - fact_a1mR * h_a1mP)
      (v_a1mO - fact_a1mR * w_a1mQ)
  where fact_a1mR = g_a1mN `div` h_a1mP

power :: Integer -> Integer -> Integer -> Integer
power 0 (!m_a1mS) (!x_a1mT) = 1
power n_a1mU m_a1mV (norecord@x_a1mW)
  | even n_a1mU =
    sqr (power (n_a1mU `div` 2) m_a1mV x_a1mW) `mod` m_a1mV
  | True = (x_a1mW * power (n_a1mU - 1) m_a1mV x_a1mW) `mod` m_a1mV

sqr :: Integer -> Integer
sqr (norecord@x_a1mX) = x_a1mX * x_a1mX
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
["xs_aAm","ys_aAn","[]","![]","(![])","y_aGv","x_aGw","safebang@!x_aGw","(!x_aGw)","xs_aGx","(!x_aGw) : xs_aGx","((!x_aGw) : xs_aGx)","!((!x_aGw) : xs_aGx)","(!((!x_aGw) : xs_aGx))","((!((!x_aGw) : xs_aGx)))","y_aGF","!y_aGF","(!y_aGF)"]
module MyList (minus) where

minus :: (Eq x_aAl) => [x_aAl] -> [x_aAl] -> [x_aAl]
minus xs_aAm ys_aAn = foldl rmv xs_aAm ys_aAn

rmv :: (Eq x_amS) => [x_amS] -> x_amS -> [x_amS]
rmv (norecord@[]) y_aGv = []
rmv ((norecord@((!x_aGw) : xs_aGx))) (norecord@y_aGF)
  = if x_aGw == y_aGF then xs_aGx else x_aGw : (xs_aGx `rmv` y_aGF)
STARTLOG
["x_anj","x_ank","Just x_ank","(Just x_ank)","!(Just x_ank)","(!(Just x_ank))","((!(Just x_ank)))","f_anl","safebang@!f_anl","(!f_anl)","Nothing","f_anm","!f_anm","(!f_anm)","x_ann","Just x_ann","(Just x_ann)","!(Just x_ann)","(!(Just x_ann))","((!(Just x_ann)))","kM_ano","Nothing","kM_anp","!kM_anp","(!kM_anp)","failM","x_anq","Just x_anq","(Just x_anq)","yM_anr","Nothing","yM_ans","!yM_ans","(!yM_ans)","b_ant","safebang@!b_ant","(!b_ant)","xM_anu","safebang@!xM_anu","(!xM_anu)","p_anv","xM_anw","x_anx","!x_anx","(!x_anx)","x_any","Just x_any","(Just x_any)","!(Just x_any)","(!(Just x_any))","((!(Just x_any)))","!((!(Just x_any)))","(!((!(Just x_any))))","x_anz","Just x_anz","(Just x_anz)","!(Just x_anz)","(!(Just x_anz))","((!(Just x_anz)))","Nothing","xfail_anA","x_anB","safebang@!x_anB","(!x_anB)","Just (!x_anB)","(Just (!x_anB))","!(Just (!x_anB))","(!(Just (!x_anB)))","((!(Just (!x_anB))))","xfail_anC","Nothing","!Nothing","(!Nothing)"]
module MaybeM
       (Maybe, returnM, eachM, thenM, failM, orM, guardM, filterM, theM,
        existsM, useM)
       where

returnM :: x_ani -> Maybe x_ani
returnM x_anj = Just x_anj

eachM :: Maybe x_ang -> (x_ang -> y_anh) -> Maybe y_anh
eachM ((norecord@(Just x_ank))) (!f_anl) = Just (f_anl x_ank)
eachM Nothing (norecord@f_anm) = Nothing

thenM :: Maybe x_ane -> (x_ane -> Maybe y_anf) -> Maybe y_anf
thenM ((norecord@(Just x_ann))) kM_ano = kM_ano x_ann
thenM Nothing (norecord@kM_anp) = Nothing

failM :: Maybe x_and
failM = Nothing

orM :: Maybe x_anc -> Maybe x_anc -> Maybe x_anc
orM (Just x_anq) yM_anr = Just x_anq
orM Nothing (norecord@yM_ans) = yM_ans

guardM :: Bool -> Maybe x_anb -> Maybe x_anb
guardM (!b_ant) (!xM_anu) = if b_ant then xM_anu else failM

filterM :: (x_ana -> Bool) -> Maybe x_ana -> Maybe x_ana
filterM p_anv xM_anw
  = xM_anw `thenM`
      (\ (norecord@x_anx) -> p_anv x_anx `guardM` returnM x_anx)

theM :: Maybe x_an9 -> x_an9
theM (norecord@((norecord@(Just x_any)))) = x_any

existsM :: Maybe x_an1 -> Bool
existsM ((norecord@(Just x_anz))) = True
existsM Nothing = False

useM :: x_an0 -> Maybe x_an0 -> x_an0
useM xfail_anA ((norecord@(Just (!x_anB)))) = x_anB
useM xfail_anC (norecord@Nothing) = xfail_anC
STARTLOG
STARTLOG
STARTLOG
["emptyFM","a_aB9","b_aBa","safebang@!b_aBa","(!b_aBa)","abs_aBb","MkFM abs_aBb","(MkFM abs_aBb)","!(MkFM abs_aBb)","(!(MkFM abs_aBb))","((!(MkFM abs_aBb)))","a_aBc","safebang@!a_aBc","(!a_aBc)","b_aBd","abs_aBe","safebang@!abs_aBe","(!abs_aBe)","abs_aBf","MkFM abs_aBf","(MkFM abs_aBf)","abs1_aBg","safebang@!abs1_aBg","(!abs1_aBg)","MkFM (!abs1_aBg)","(MkFM (!abs1_aBg))","!(MkFM (!abs1_aBg))","(!(MkFM (!abs1_aBg)))","((!(MkFM (!abs1_aBg))))","abs2_aBh","MkFM abs2_aBh","(MkFM abs2_aBh)","f_aBi","g_aBj","!g_aBj","(!g_aBj)","f_aBk","!f_aBk","(!f_aBk)","a_aBl","safebang@!a_aBl","(!a_aBl)","b_aBn","abs_aBo","MkFM abs_aBo","(MkFM abs_aBo)","!(MkFM abs_aBo)","(!(MkFM abs_aBo))","((!(MkFM abs_aBo)))","a_aBp","safebang@!a_aBp","(!a_aBp)","a'_aF1","safebang@!a'_aF1","(!a'_aF1)","b'_aF2","((!a'_aF1), b'_aF2)","!((!a'_aF1), b'_aF2)","(!((!a'_aF1), b'_aF2))","h_aF3","abs_aF4","MkFM abs_aF4","(MkFM abs_aF4)","!(MkFM abs_aF4)","(!(MkFM abs_aF4))","a_aF5","safebang@!a_aF5","(!a_aF5)","b_aF6","((!a_aF5), b_aF6)","abs_aF7","safebang@!abs_aF7","(!abs_aF7)","MkFM (!abs_aF7)","(MkFM (!abs_aF7))","a_aF8","safebang@!a_aF8","(!a_aF8)","b_aF9","((!a_aF8), b_aF9)","!((!a_aF8), b_aF9)","(!((!a_aF8), b_aF9))","abs_aFa","MkFM abs_aFa","(MkFM abs_aFa)","!(MkFM abs_aFa)","(!(MkFM abs_aFa))","((!(MkFM abs_aFa)))","!((!(MkFM abs_aFa)))","(!((!(MkFM abs_aFa))))","a_aFb","safebang@!a_aFb","(!a_aFb)","b_aFc","((!a_aFb), b_aFc)","f_aFd","!f_aFd","(!f_aFd)","g_aFe","xs_aFf","!xs_aFf","(!xs_aFf)","ys_aFg","!ys_aFg","(!ys_aFg)","x_aLd","!x_aLd","(!x_aLd)"]
module FiniteMap
       (FM, emptyFM, unitFM, extendFM, makeFM, unmakeFM, thenFM, plusFM,
        lookupFM, lookupElseFM, mapFM, domFM, ranFM, disjointFM)
       where

emptyFM :: FM a_aB7 b_aB8
emptyFM = MkFM []

unitFM :: a_aB5 -> b_aB6 -> FM a_aB5 b_aB6
unitFM a_aB9 (!b_aBa) = MkFM [(a_aB9, b_aBa)]

extendFM :: FM a_aB3 b_aB4 -> a_aB3 -> b_aB4 -> FM a_aB3 b_aB4
extendFM ((norecord@(MkFM abs_aBb))) (!a_aBc) b_aBd
  = MkFM ((a_aBc, b_aBd) : abs_aBb)

makeFM :: [(a_aB1, b_aB2)] -> FM a_aB1 b_aB2
makeFM (!abs_aBe) = MkFM abs_aBe

unmakeFM :: FM a_aAZ b_aB0 -> [(a_aAZ, b_aB0)]
unmakeFM (MkFM abs_aBf) = abs_aBf

thenFM :: FM a_aAX b_aAY -> FM a_aAX b_aAY -> FM a_aAX b_aAY
thenFM ((norecord@(MkFM (!abs1_aBg)))) (MkFM abs2_aBh)
  = MkFM (abs2_aBh ++ abs1_aBg)

plusFM ::
         (Eq a_aAV) => FM a_aAV b_aAW -> FM a_aAV b_aAW -> FM a_aAV b_aAW
plusFM f_aBi (norecord@g_aBj)
  | f_aBi `disjointFM` g_aBj = f_aBi `thenFM` g_aBj

lookupFM :: (Eq a_aAT) => FM a_aAT b_aAU -> a_aAT -> b_aAU
lookupFM (norecord@f_aBk) (!a_aBl)
  = lookupElseFM (error "lookup") f_aBk a_aBl

lookupElseFM ::
               (Eq a_aAS) => b_aAR -> FM a_aAS b_aAR -> a_aAS -> b_aAR
lookupElseFM b_aBn ((norecord@(MkFM abs_aBo))) (!a_aBp)
  = head
      ([b'_aF2 | (norecord@((!a'_aF1), b'_aF2)) <- abs_aBo,
        a_aBp == a'_aF1]
         ++ [b_aBn])

mapFM :: (b_aAO -> c_aAP) -> FM a_aAQ b_aAO -> FM a_aAQ c_aAP
mapFM h_aF3 (norecord@(MkFM abs_aF4))
  = MkFM [(a_aF5, h_aF3 b_aF6) | ((!a_aF5), b_aF6) <- abs_aF4]

domFM :: FM a_aAM b_aAN -> [a_aAM]
domFM (MkFM (!abs_aF7))
  = [a_aF8 | (norecord@((!a_aF8), b_aF9)) <- abs_aF7]

ranFM :: FM a_aAK b_aAL -> [b_aAL]
ranFM (norecord@((norecord@(MkFM abs_aFa))))
  = [b_aFc | ((!a_aFb), b_aFc) <- abs_aFa]

disjointFM ::
             (Eq a_aAI) => FM a_aAI b_aAJ -> FM a_aAI b_aAJ -> Bool
disjointFM (norecord@f_aFd) g_aFe
  = domFM f_aFd `disjoint` domFM g_aFe

disjoint :: (Eq a_an8) => [a_an8] -> [a_an8] -> Bool
disjoint (norecord@xs_aFf) (norecord@ys_aFg)
  = and [not (x_aLd `elem` ys_aFg) | (norecord@x_aLd) <- xs_aFf]

data FM a_an6 b_an7 = MkFM [(a_an6, b_an7)]
STARTLOG
STARTLOG
["f_anf","Abs f_anf","(Abs f_anf)","!(Abs f_anf)","(!(Abs f_anf))","x_ang","s_anh","safebang@!s_anh","(!s_anh)","xS_ani","f_anj","safebang@!f_anj","(!f_anj)","s_ank","x_anl","!x_anl","(!x_anl)","s'_anm","((!x_anl), s'_anm)","xS_ann","kS_ano","safebang@!kS_ano","(!kS_ano)","s_anp","safebang@!s_anp","(!s_anp)","x_anq","s'_anr","(x_anq, s'_anr)","s'_ans","s_ant","getS","s_anu","safebang@!s_anu","(!s_anu)","xS_anv","!xS_anv","(!xS_anv)","s_anw","x_anx","s'_any","!s'_any","(!s'_any)","(x_anx, (!s'_any))"]
module State (State, returnS, eachS, thenS, putS, getS, useS) where

rep :: State s_and x_ane -> (s_and -> (x_ane, s_and))
rep (norecord@(Abs f_anf)) = f_anf

returnS :: x_anb -> State s_anc x_anb
returnS x_ang = Abs (\ (!s_anh) -> (x_ang, s_anh))

eachS :: State s_an8 x_an9 -> (x_an9 -> y_ana) -> State s_an8 y_ana
eachS xS_ani (!f_anj)
  = Abs
      (\ s_ank ->
         let ((norecord@x_anl), s'_anm) = rep xS_ani s_ank in
           (f_anj x_anl, s'_anm))

thenS ::
      State s_an5 x_an6 ->
        (x_an6 -> State s_an5 y_an7) -> State s_an5 y_an7
thenS xS_ann (!kS_ano)
  = Abs
      (\ (!s_anp) ->
         let (x_anq, s'_anr) = rep xS_ann s_anp in
           rep (kS_ano x_anq) s'_anr)

putS :: s_an4 -> State s_an4 ()
putS s'_ans = Abs (\ s_ant -> ((), s'_ans))

getS :: State s_an3 s_an3
getS = Abs (\ (!s_anu) -> (s_anu, s_anu))

useS :: State s_an1 x_an2 -> s_an1 -> x_an2
useS (norecord@xS_anv) s_anw
  = let (x_anx, (norecord@s'_any)) = rep xS_anv s_anw in x_anx

data State s_amZ x_an0 = Abs (s_amZ -> (x_an0, s_amZ))
STARTLOG
["xJ_aqX","MkI xJ_aqX","(MkI xJ_aqX)","!(MkI xJ_aqX)","(!(MkI xJ_aqX))","x_aqY","xI_aqZ","safebang@!xI_aqZ","(!xI_aqZ)","f_ar0","xI_ar1","safebang@!xI_ar1","(!xI_ar1)","kI_ar2","failI","xfail_ar3","b_ar4","xI_ar5","s_ar6","!s_ar6","(!s_ar6)","getSubI","c_ar7","getCounterI","t_ar8","s_ar9","t_ara","u_arb","safebang@!u_arb","(!u_arb)","s_arc","!s_arc","(!s_arc)","sM_ard","!sM_ard","(!sM_ard)","()","freshI","c_are","!c_are","(!c_are)","()","0","!0","(!0)","n_aAD","!n_aAD","(!n_aAD)","x_aAE","xs_aAF","!xs_aAF","(!xs_aAF)"]
module InferMonad
       (Infer, returnI, eachI, thenI, guardI, useI, getSubI, substituteI,
        unifyI, freshI, freshesI)
       where
import MaybeM
       (Maybe, returnM, eachM, thenM, failM, guardM, theM, existsM, useM)
import StateX
       (StateX, returnSX, eachSX, thenSX, toSX, putSX, getSX, useSX)
import Type (TVarId, TConId, MonoType(TVar, TCon), freeTVarMono)
import Substitution
       (Sub, applySub, lookupSub, emptySub, extendSub, domSub, unifySub)
rep (norecord@(MkI xJ_aqX)) = xJ_aqX

returnI :: x_aqW -> Infer x_aqW
returnI x_aqY = MkI (returnSX (returnSX returnM) x_aqY)

eachI :: Infer x_aqU -> (x_aqU -> y_aqV) -> Infer y_aqV
eachI (!xI_aqZ) f_ar0
  = MkI (eachSX (eachSX eachM) (rep xI_aqZ) f_ar0)

thenI :: Infer x_aqS -> (x_aqS -> Infer y_aqT) -> Infer y_aqT
thenI (!xI_ar1) kI_ar2
  = MkI (thenSX (thenSX thenM) (rep xI_ar1) (rep . kI_ar2))

failI :: Infer x_aqR
failI = MkI (toSX (eachSX eachM) (toSX eachM failM))

useI :: x_aqQ -> Infer x_aqQ -> x_aqQ
useI xfail_ar3
  = useM xfail_ar3 . useSX eachM 0 . useSX (eachSX eachM) emptySub .
      rep

guardI :: Bool -> Infer x_aqP -> Infer x_aqP
guardI b_ar4 xI_ar5 = if b_ar4 then xI_ar5 else failI

putSubI :: Sub -> Infer ()
putSubI (norecord@s_ar6) = MkI (putSX (returnSX returnM) s_ar6)

getSubI :: Infer Sub
getSubI = MkI (getSX (returnSX returnM))

putCounterI :: Counter -> Infer ()
putCounterI c_ar7 = MkI (toSX (eachSX eachM) (putSX returnM c_ar7))

getCounterI :: Infer Counter
getCounterI = MkI (toSX (eachSX eachM) (getSX returnM))

substituteI :: MonoType -> Infer MonoType
substituteI t_ar8
  = getSubI `thenI` (\ s_ar9 -> returnI (applySub s_ar9 t_ar8))

unifyI :: MonoType -> MonoType -> Infer ()
unifyI t_ara (!u_arb)
  = getSubI `thenI`
      (\ (norecord@s_arc) ->
         let (norecord@sM_ard) = unifySub t_ara u_arb s_arc in
           existsM sM_ard `guardI`
             (putSubI (theM sM_ard) `thenI` (\ () -> returnI ())))

freshI :: Infer MonoType
freshI
  = getCounterI `thenI`
      (\ (norecord@c_are) ->
         putCounterI (c_are + 1) `thenI`
           (\ () -> returnI (TVar ("a" ++ show c_are))))

freshesI :: Int -> Infer [MonoType]
freshesI (norecord@0) = returnI []
freshesI (norecord@n_aAD)
  = freshI `thenI`
      (\ x_aAE ->
         freshesI (n_aAD - 1) `thenI`
           (\ (norecord@xs_aAF) -> returnI (x_aAE : xs_aAF)))

type Counter = Int

data Infer x_aqH = MkI (StateX Sub
                          (StateX Counter (Maybe ((x_aqH, Sub), Counter))))
STARTLOG
["r_avD","showsConcat","showsString","showsChar","showsX_aBL","safebang@!showsX_aBL","(!showsX_aBL)","xs_aBM","s_aBN","safebang@!s_aBN","(!s_aBN)","showsX_aBO","[]","![]","(![])","s_aBP","showsX_aBQ","x_aBR","xs_aBS","!xs_aBS","(!xs_aBS)","x_aBR : (!xs_aBS)","(x_aBR : (!xs_aBS))","!(x_aBR : (!xs_aBS))","(!(x_aBR : (!xs_aBS)))","((!(x_aBR : (!xs_aBS))))","x'_aBT","l_aBU","showsX_aBV","r_aBW","x_aBX","safebang@!x_aBX","(!x_aBX)","showsX_aBY","safebang@!showsX_aBY","(!showsX_aBY)","showsParen","b_aBZ","xS_aC0"]
module Shows
       (Shows, showsEmpty, showsConcat, showsString, showsChar, showsStar,
        showsStarSep, showsSurround, showsListOf, showsParen, showsParenIf)
       where

showsEmpty :: ShowS
showsEmpty r_avD = r_avD

showsConcat :: [ShowS] -> ShowS
showsConcat = foldr (.) showsEmpty

showsString :: Shows String
showsString = (++)

showsChar :: Shows Char
showsChar = (:)

showsStar :: Shows x_avC -> Shows [x_avC]
showsStar (!showsX_aBL) xs_aBM
  = showsConcat (map showsX_aBL xs_aBM)

showsStarSep :: String -> Shows x_avB -> Shows [x_avB]
showsStarSep (!s_aBN) showsX_aBO (norecord@[]) = showsEmpty
showsStarSep s_aBP showsX_aBQ
  ((norecord@(x_aBR : (norecord@xs_aBS))))
  = showsX_aBQ x_aBR .
      showsConcat
        [showString s_aBP . showsX_aBQ x'_aBT | x'_aBT <- xs_aBS]

showsSurround :: String -> Shows x_avA -> String -> Shows x_avA
showsSurround l_aBU showsX_aBV r_aBW (!x_aBX)
  = showString l_aBU . showsX_aBV x_aBX . showString r_aBW

showsListOf :: Shows x_avz -> Shows [x_avz]
showsListOf (!showsX_aBY)
  = showsSurround "[" (showsStarSep ", " showsX_aBY) "]"

showsParen :: ShowS -> ShowS
showsParen = showsSurround "(" id ")"

showsParenIf :: Bool -> ShowS -> ShowS
showsParenIf b_aBZ xS_aC0
  = if b_aBZ then showsParen xS_aC0 else xS_aC0

type Shows x_an1 = x_an1 -> ShowS
STARTLOG
STARTLOG
["f_an2","MkSX f_an2","(MkSX f_an2)","!(MkSX f_an2)","(!(MkSX f_an2))","returnX_an3","x_an4","safebang@!x_an4","(!x_an4)","s_an5","eachX_an6","safebang@!eachX_an6","(!eachX_an6)","xSX_an7","f_an8","safebang@!f_an8","(!f_an8)","s_an9","x_ana","s'_anb","(x_ana, s'_anb)","!(x_ana, s'_anb)","(!(x_ana, s'_anb))","thenX_anc","safebang@!thenX_anc","(!thenX_anc)","xSX_and","kSX_ane","s_anf","x_ang","s'_anh","(x_ang, s'_anh)","!(x_ang, s'_anh)","(!(x_ang, s'_anh))","eachX_ani","safebang@!eachX_ani","(!eachX_ani)","xX_anj","safebang@!xX_anj","(!xX_anj)","s_ank","x_anl","returnX_anm","safebang@!returnX_anm","(!returnX_anm)","s'_ann","s_ano","safebang@!s_ano","(!s_ano)","returnX_anp","safebang@!returnX_anp","(!returnX_anp)","s_anq","eachX_anr","safebang@!eachX_anr","(!eachX_anr)","s_ans","xSX_ant","x_anu","s'_anv","safebang@!s'_anv","(!s'_anv)","(x_anu, (!s'_anv))","!(x_anu, (!s'_anv))","(!(x_anu, (!s'_anv)))"]
module StateX
       (StateX, returnSX, eachSX, thenSX, toSX, putSX, getSX, useSX) where
rep (norecord@(MkSX f_an2)) = f_an2
returnSX returnX_an3 (!x_an4)
  = MkSX (\ s_an5 -> returnX_an3 (x_an4, s_an5))
eachSX (!eachX_an6) xSX_an7 (!f_an8)
  = MkSX
      (\ s_an9 ->
         rep xSX_an7 s_an9 `eachX_an6`
           (\ (norecord@(x_ana, s'_anb)) -> (f_an8 x_ana, s'_anb)))
thenSX (!thenX_anc) xSX_and kSX_ane
  = MkSX
      (\ s_anf ->
         rep xSX_and s_anf `thenX_anc`
           (\ (norecord@(x_ang, s'_anh)) -> rep (kSX_ane x_ang) s'_anh))
toSX (!eachX_ani) (!xX_anj)
  = MkSX (\ s_ank -> xX_anj `eachX_ani` (\ x_anl -> (x_anl, s_ank)))
putSX (!returnX_anm) s'_ann
  = MkSX (\ (!s_ano) -> returnX_anm ((), s'_ann))
getSX (!returnX_anp) = MkSX (\ s_anq -> returnX_anp (s_anq, s_anq))
useSX (!eachX_anr) s_ans xSX_ant
  = rep xSX_ant s_ans `eachX_anr`
      (\ (norecord@(x_anu, (!s'_anv))) -> x_anu)

data StateX s_an0 a_an1 = MkSX (s_an0 -> a_an1)
STARTLOG
["main","a_an6","!a_an6","(!a_an6)","b_an7","!b_an7","(!b_an7)","c_an8","d_an9","!d_an9","(!d_an9)","f_ana","g_anb","h_anc","!h_anc","(!h_anc)","vertices_and","!vertices_and","(!vertices_and)","edges_ane"]
module Main (main) where
import Digraph
main = print (stronglyConnComp edges_ane vertices_and)
  where a_an6, b_an7, c_an8, d_an9, f_ana, g_anb, h_anc :: Int
        (norecord@a_an6) = 1
        (norecord@b_an7) = 2
        c_an8 = 3
        (norecord@d_an9) = 4
        f_ana = 5
        g_anb = 6
        (norecord@h_anc) = 7
        (norecord@vertices_and)
          = [a_an6, b_an7, c_an8, d_an9, f_ana, g_anb, h_anc]
        edges_ane
          = [(b_an7, a_an6), (c_an8, b_an7), (c_an8, d_an9), (c_an8, h_anc),
             (d_an9, c_an8), (f_ana, a_an6), (f_ana, g_anb), (f_ana, h_anc),
             (g_anb, f_ana), (h_anc, g_anb)]
STARTLOG
["es_aAq","vs_aAr","safebang@!vs_aAr","(!vs_aAr)","reversed_edges_aAs","!reversed_edges_aAs","(!reversed_edges_aAs)","x_aAw","y_aAx","safebang@!y_aAx","(!y_aAx)","(x_aAw, (!y_aAx))","[]","w_aAy","!w_aAy","(!w_aAy)","x_aAz","safebang@!x_aAz","(!x_aAz)","y_aAA","((!x_aAz), y_aAA)","xys_aAB","((!x_aAz), y_aAA) : xys_aAB","(((!x_aAz), y_aAA) : xys_aAB)","!(((!x_aAz), y_aAA) : xys_aAB)","(!(((!x_aAz), y_aAA) : xys_aAB))","((!(((!x_aAz), y_aAA) : xys_aAB)))","w_aAJ","r_aAK","safebang@!r_aAK","(!r_aAK)","vs_aAL","safebang@!vs_aAL","(!vs_aAL)","ns_aAM","((!vs_aAL), ns_aAM)","[]","r_aAN","vs_aAO","!vs_aAO","(!vs_aAO)","ns_aAP","!ns_aAP","(!ns_aAP)","((!vs_aAO), (!ns_aAP))","!((!vs_aAO), (!ns_aAP))","(!((!vs_aAO), (!ns_aAP)))","x_aAQ","xs_aAR","!xs_aAR","(!xs_aAR)","x_aAQ : (!xs_aAR)","(x_aAQ : (!xs_aAR))","!(x_aAQ : (!xs_aAR))","(!(x_aAQ : (!xs_aAR)))","((!(x_aAQ : (!xs_aAR))))","!((!(x_aAQ : (!xs_aAR))))","(!((!(x_aAQ : (!xs_aAR)))))","vs'_aAS","ns'_aAT","(vs'_aAS, ns'_aAT)","r_aH7","safebang@!r_aH7","(!r_aH7)","vs_aH8","safebang@!vs_aH8","(!vs_aH8)","ns_aH9","safebang@!ns_aH9","(!ns_aH9)","((!vs_aH8), (!ns_aH9))","[]","![]","(![])","r_aHa","vs_aHb","!vs_aHb","(!vs_aHb)","ns_aHc","((!vs_aHb), ns_aHc)","x_aHd","xs_aHe","!xs_aHe","(!xs_aHe)","x_aHd : (!xs_aHe)","(x_aHd : (!xs_aHe))","vs'_aHf","!vs'_aHf","(!vs'_aHf)","ns'_aHg","((!vs'_aHf), ns'_aHg)"]
module Digraph where

stronglyConnComp ::
                   Eq vertex_aAp =>
                   [Edge vertex_aAp] -> [vertex_aAp] -> [[vertex_aAp]]
stronglyConnComp es_aAq (!vs_aAr)
  = snd
      (span_tree_aAv (new_range_aAu reversed_edges_aAs) ([], [])
         (snd (dfs (new_range_aAu es_aAq) ([], []) vs_aAr)))
  where (norecord@reversed_edges_aAs) = map swap_aAt es_aAq
        swap_aAt (x_aAw, (!y_aAx)) = (y_aAx, x_aAw)
        new_range_aAu [] (norecord@w_aAy) = []
        new_range_aAu ((norecord@(((!x_aAz), y_aAA) : xys_aAB))) w_aAJ
          = if x_aAz == w_aAJ then (y_aAA : (new_range_aAu xys_aAB w_aAJ))
              else (new_range_aAu xys_aAB w_aAJ)
        span_tree_aAv (!r_aAK) ((!vs_aAL), ns_aAM) [] = (vs_aAL, ns_aAM)
        span_tree_aAv r_aAN
          (norecord@((norecord@vs_aAO), (norecord@ns_aAP)))
          (norecord@((norecord@(x_aAQ : (norecord@xs_aAR)))))
          | x_aAQ `elem` vs_aAO = span_tree_aAv r_aAN (vs_aAO, ns_aAP) xs_aAR
          | True =
            span_tree_aAv r_aAN (vs'_aAS, (x_aAQ : ns'_aAT) : ns_aAP) xs_aAR
          where (vs'_aAS, ns'_aAT)
                  = dfs r_aAN (x_aAQ : vs_aAO, []) (r_aAN x_aAQ)

dfs ::
      Eq v_amW =>
      (v_amW -> [v_amW]) ->
        ([v_amW], [v_amW]) -> [v_amW] -> ([v_amW], [v_amW])
dfs (!r_aH7) ((!vs_aH8), (!ns_aH9)) (norecord@[])
  = (vs_aH8, ns_aH9)
dfs r_aHa ((norecord@vs_aHb), ns_aHc) (x_aHd : (norecord@xs_aHe))
  | x_aHd `elem` vs_aHb = dfs r_aHa (vs_aHb, ns_aHc) xs_aHe
  | True = dfs r_aHa (vs'_aHf, (x_aHd : ns'_aHg) ++ ns_aHc) xs_aHe
  where ((norecord@vs'_aHf), ns'_aHg)
          = dfs r_aHa (x_aHd : vs_aHb, []) (r_aHa x_aHd)

type Edge vertex_amV = (vertex_amV, vertex_amV)

type Cycle vertex_amU = [vertex_amU]
STARTLOG
["f_avx","g_avy","a_avz","safebang@!a_avz","(!a_avz)","f_avA","safebang@!f_avA","(!f_avA)","a_avB","l_avC","!l_avC","(!l_avC)","Branch a_avB (!l_avC)","(Branch a_avB (!l_avC))","!(Branch a_avB (!l_avC))","(!(Branch a_avB (!l_avC)))","((!(Branch a_avB (!l_avC))))","!((!(Branch a_avB (!l_avC))))","(!((!(Branch a_avB (!l_avC)))))","0","a_avD","!a_avD","(!a_avD)","l_avE","Branch (!a_avD) l_avE","(Branch (!a_avD) l_avE)","!(Branch (!a_avD) l_avE)","(!(Branch (!a_avD) l_avE))","((!(Branch (!a_avD) l_avE)))","!((!(Branch (!a_avD) l_avE)))","(!((!(Branch (!a_avD) l_avE))))","n_avF","!n_avF","(!n_avF)","a_avG","safebang@!a_avG","(!a_avG)","l_avH","Branch (!a_avG) l_avH","(Branch (!a_avG) l_avH)","!(Branch (!a_avG) l_avH)","(!(Branch (!a_avG) l_avH))"]
module Tree where

repTree ::
        (a_avw -> [a_avw]) -> (a_avw -> [a_avw]) -> a_avw -> (Tree a_avw)
repTree f_avx g_avy (!a_avz)
  = Branch a_avz (map (repTree g_avy f_avx) (f_avx a_avz))

mapTree :: (a_avu -> b_avv) -> (Tree a_avu) -> (Tree b_avv)
mapTree (!f_avA)
  (norecord@((norecord@(Branch a_avB (norecord@l_avC)))))
  = Branch (f_avA a_avB) (map (mapTree f_avA) l_avC)

prune :: Int -> (Tree a_avm) -> (Tree a_avm)
prune 0 (norecord@((norecord@(Branch (norecord@a_avD) l_avE))))
  = Branch a_avD []
prune (norecord@n_avF) (norecord@(Branch (!a_avG) l_avH))
  | n_avF < 0 = error "prune: < 0"
  | otherwise = Branch a_avG (map (prune (n_avF - 1)) l_avH)

data Tree a_amV = Branch a_amV [Tree a_amV]
                deriving Show
STARTLOG
["main","_"]
module Main where
import Prog (prog)
main
  = do _ <- getContents
       putStr (prog "")
STARTLOG
["wins","win1","win2","win3","win4","win5","win6","win7","win8"]
module Wins where

wins :: [Win]
wins = [win1, win2, win3, win4, win5, win6, win7, win8]

win1, win2, win3, win4, win5, win6, win7, win8 :: Win
win1 = [[1, 1, 1], [0, 0, 0], [0, 0, 0]]
win2 = [[0, 0, 0], [1, 1, 1], [0, 0, 0]]
win3 = [[0, 0, 0], [0, 0, 0], [1, 1, 1]]
win4 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
win5 = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
win6 = [[0, 0, 1], [0, 0, 1], [0, 0, 1]]
win7 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
win8 = [[0, 0, 1], [0, 1, 0], [1, 0, 0]]

type Win = [[Int]]
STARTLOG
["_","game_arx","testBoard"]
module Prog (prog) where
import Board
import Wins
import Game
import Tree

prog :: String -> String
prog _ = "OXO\n" ++ concat (map showMove game_arx)
  where game_arx = alternate X max' min' testBoard
testBoard
  = [[Empty, O, Empty], [Empty, X, Empty], [Empty, Empty, Empty]]
STARTLOG
["_","_","_","!_","(!_)","b_ar7","safebang@!b_ar7","(!b_ar7)","_","_","!_","(!_)","_","!_","(!_)","b_ar8","!b_ar8","(!b_ar8)","_","_","!_","(!_)","_","b_aEB","!b_aEB","(!b_aEB)","player_aEC","!player_aEC","(!player_aEC)","f_aED","!f_aED","(!f_aED)","g_aEE","!g_aEE","(!g_aEE)","board_aEF","board'_aEH","eval_aEI","safebang@!eval_aEI","(!eval_aEI)","(board'_aEH, (!eval_aEI))","move_aEG@(board'_aEH, (!eval_aEI))","!move_aEG@(board'_aEH, (!eval_aEI))","(!move_aEG@(board'_aEH, (!eval_aEI)))","scores_aEJ","possibles_aEK","safebang@!possibles_aEK","(!possibles_aEK)","opposition_aEL","!opposition_aEL","(!opposition_aEL)","X","O","f_aET","b_aEU","safebang@!b_aEU","(!b_aEU)","bs_aEV","safebang@!bs_aEV","(!bs_aEV)","(!b_aEU) : (!bs_aEV)","((!b_aEU) : (!bs_aEV))","!((!b_aEU) : (!bs_aEV))","(!((!b_aEU) : (!bs_aEV)))","((!((!b_aEU) : (!bs_aEV))))","s_aEW","safebang@!s_aEW","(!s_aEW)","ss_aEX","(!s_aEW) : ss_aEX","((!s_aEW) : ss_aEX)","!((!s_aEW) : ss_aEX)","(!((!s_aEW) : ss_aEX))","((!((!s_aEW) : ss_aEX)))","!((!((!s_aEW) : ss_aEX)))","(!((!((!s_aEW) : ss_aEX))))","b_aEZ","safebang@!b_aEZ","(!b_aEZ)","s_aF0","safebang@!s_aF0","(!s_aF0)","[]","[]","b_aF1","s_aF2","!s_aF2","(!s_aF2)","b'_aF3","bs_aF4","b'_aF3 : bs_aF4","(b'_aF3 : bs_aF4)","s'_aF5","ss_aF6","safebang@!ss_aF6","(!ss_aF6)","s'_aF5 : (!ss_aF6)","(s'_aF5 : (!ss_aF6))","b_aF7","e_aF8","(b_aF7, e_aF8)","p_aNy","safebang@!p_aNy","(!p_aNy)","f_aNz","safebang@!f_aNz","(!f_aNz)","g_aNA","a_aNB","[]","Branch a_aNB []","(Branch a_aNB [])","!(Branch a_aNB [])","(!(Branch a_aNB []))","((!(Branch a_aNB [])))","!((!(Branch a_aNB [])))","(!((!(Branch a_aNB []))))","x_aNC","Score x_aNC","(Score x_aNC)","!(Score x_aNC)","(!(Score x_aNC))","((!(Score x_aNC)))","l_aND","Branch ((!(Score x_aNC))) l_aND","(Branch ((!(Score x_aNC))) l_aND)","!(Branch ((!(Score x_aNC))) l_aND)","(!(Branch ((!(Score x_aNC))) l_aND))","x_aNE","l_aNF","Branch x_aNE l_aNF","(Branch x_aNE l_aNF)","p_aNG","board_aNH","f_aNI","safebang@!f_aNI","(!f_aNI)","g_aNJ","safebang@!g_aNJ","(!g_aNJ)","a_aNK","[]","Branch a_aNK []","(Branch a_aNK [])","!(Branch a_aNK [])","(!(Branch a_aNK []))","f_aNL","g_aNM","_","l_aNN","Branch _ l_aNN","(Branch _ l_aNN)","!(Branch _ l_aNN)","(!(Branch _ l_aNN))","XWin","!XWin","(!XWin)","_","_","!_","(!_)","XWin","!XWin","(!XWin)","b_aTT","OWin","OWin","b_aTU","!b_aTU","(!b_aTU)","x_aTW","Score x_aTW","(Score x_aTW)","!(Score x_aTW)","(!(Score x_aTW))","a_aTV@(!(Score x_aTW))","y_aTY","!y_aTY","(!y_aTY)","Score (!y_aTY)","(Score (!y_aTY))","!(Score (!y_aTY))","(!(Score (!y_aTY)))","b_aTX@(!(Score (!y_aTY)))","!b_aTX@(!(Score (!y_aTY)))","(!b_aTX@(!(Score (!y_aTY))))","OWin","!OWin","(!OWin)","_","_","!_","(!_)","OWin","!OWin","(!OWin)","b_aTZ","!b_aTZ","(!b_aTZ)","XWin","!XWin","(!XWin)","XWin","!XWin","(!XWin)","b_aU0","!b_aU0","(!b_aU0)","x_aU2","Score x_aU2","(Score x_aU2)","!(Score x_aU2)","(!(Score x_aU2))","a_aU1@(!(Score x_aU2))","!a_aU1@(!(Score x_aU2))","(!a_aU1@(!(Score x_aU2)))","y_aU4","Score y_aU4","(Score y_aU4)","b_aU3@(Score y_aU4)","!b_aU3@(Score y_aU4)","(!b_aU3@(Score y_aU4))"]
module Game where
import Board
import Wins
import Tree

alternate :: Piece -> Player -> Player -> Board -> [Move]
alternate _ _ (norecord@_) (!b_ar7) | fullBoard b_ar7 = []
alternate _ (norecord@_) (norecord@_) (norecord@b_ar8)
  | static b_ar8 == XWin = []
alternate _ (norecord@_) _ (norecord@b_aEB)
  | static b_aEB == OWin = []
alternate (norecord@player_aEC) (norecord@f_aED) (norecord@g_aEE)
  board_aEF
  = move_aEG : alternate opposition_aEL g_aEE f_aED board'_aEH
  where (norecord@move_aEG@(board'_aEH, (!eval_aEI)))
          = best f_aED possibles_aEK scores_aEJ
        scores_aEJ
          = map (bestMove opposition_aEL g_aEE f_aED) possibles_aEK
        (!possibles_aEK) = newPositions player_aEC board_aEF
        (norecord@opposition_aEL) = opposite player_aEC

opposite :: Piece -> Piece
opposite X = O
opposite O = X

best :: Player -> [Board] -> [Evaluation] -> Move
best f_aET ((norecord@((!b_aEU) : (!bs_aEV))))
  (norecord@((norecord@((!s_aEW) : ss_aEX))))
  = best'_aEY b_aEU s_aEW bs_aEV ss_aEX
  where best'_aEY (!b_aEZ) (!s_aF0) [] [] = (b_aEZ, s_aF0)
        best'_aEY b_aF1 (norecord@s_aF2) (b'_aF3 : bs_aF4)
          (s'_aF5 : (!ss_aF6))
          | s_aF2 == (f_aET s_aF2 s'_aF5) =
            best'_aEY b_aF1 s_aF2 bs_aF4 ss_aF6
          | otherwise = best'_aEY b'_aF3 s'_aF5 bs_aF4 ss_aF6

showMove :: Move -> String
showMove (b_aF7, e_aF8) = show e_aF8 ++ "\n" ++ showBoard b_aF7

bestMove :: Piece -> Player -> Player -> Board -> Evaluation
bestMove (!p_aNy) (!f_aNz) g_aNA
  = (mise f_aNz g_aNA) . cropTree . mapTree static . searchTree p_aNy

cropTree :: (Tree Evaluation) -> (Tree Evaluation)
cropTree (norecord@((norecord@(Branch a_aNB []))))
  = (Branch a_aNB [])
cropTree (norecord@(Branch ((norecord@(Score x_aNC))) l_aND))
  = Branch (Score x_aNC) (map cropTree l_aND)
cropTree (Branch x_aNE l_aNF) = Branch x_aNE []

searchTree :: Piece -> Board -> (Tree Board)
searchTree p_aNG board_aNH
  = prune 5
      (repTree (newPositions p_aNG) (newPositions (opposite p_aNG))
         board_aNH)

mise :: Player -> Player -> (Tree Evaluation) -> Evaluation
mise (!f_aNI) (!g_aNJ) (norecord@(Branch a_aNK [])) = a_aNK
mise f_aNL g_aNM (norecord@(Branch _ l_aNN))
  = foldr f_aNL (g_aNM OWin XWin) (map (mise g_aNM f_aNL) l_aNN)

max' :: Evaluation -> Evaluation -> Evaluation
max' (norecord@XWin) _ = XWin
max' (norecord@_) (norecord@XWin) = XWin
max' b_aTT OWin = b_aTT
max' OWin (norecord@b_aTU) = b_aTU
max' a_aTV@(norecord@(Score x_aTW))
  (norecord@b_aTX@(norecord@(Score (norecord@y_aTY))))
  | x_aTW > y_aTY = a_aTV
  | otherwise = b_aTX

min' :: Evaluation -> Evaluation -> Evaluation
min' (norecord@OWin) _ = OWin
min' (norecord@_) (norecord@OWin) = OWin
min' (norecord@b_aTZ) (norecord@XWin) = b_aTZ
min' (norecord@XWin) (norecord@b_aU0) = b_aU0
min' (norecord@a_aU1@(norecord@(Score x_aU2)))
  (norecord@b_aU3@(Score y_aU4))
  | x_aU2 < y_aU4 = a_aU1
  | otherwise = b_aU3

type Player = Evaluation -> Evaluation -> Evaluation

type Move = (Board, Evaluation)
STARTLOG
["r1_aKG","r2_aKH","r3_aKI","safebang@!r3_aKI","(!r3_aKI)","[r1_aKG, r2_aKH, (!r3_aKI)]","![r1_aKG, r2_aKH, (!r3_aKI)]","(![r1_aKG, r2_aKH, (!r3_aKI)])","p1_aKJ","p2_aKK","safebang@!p2_aKK","(!p2_aKK)","p3_aKL","safebang@!p3_aKL","(!p3_aKL)","[p1_aKJ, (!p2_aKK), (!p3_aKL)]","![p1_aKJ, (!p2_aKK), (!p3_aKL)]","(![p1_aKJ, (!p2_aKK), (!p3_aKL)])","X","O","!O","(!O)","Empty","p_aKM","safebang@!p_aKM","(!p_aKM)","board_aKN","safebang@!board_aKN","(!board_aKN)","pos_aKO","!pos_aKO","(!pos_aKO)","p_aKP","!p_aKP","(!p_aKP)","r1_aKQ","r2_aKR","r3_aKS","safebang@!r3_aKS","(!r3_aKS)","[r1_aKQ, r2_aKR, (!r3_aKS)]","1","!1","(!1)","x_aKT","((!1), x_aKT)","!((!1), x_aKT)","(!((!1), x_aKT))","p_aKU","!p_aKU","(!p_aKU)","r1_aKV","r2_aKW","r3_aKX","[r1_aKV, r2_aKW, r3_aKX]","![r1_aKV, r2_aKW, r3_aKX]","(![r1_aKV, r2_aKW, r3_aKX])","2","!2","(!2)","x_aKY","!x_aKY","(!x_aKY)","((!2), (!x_aKY))","p_aKZ","!p_aKZ","(!p_aKZ)","r1_aL0","r2_aL1","!r2_aL1","(!r2_aL1)","r3_aL2","safebang@!r3_aL2","(!r3_aL2)","[r1_aL0, (!r2_aL1), (!r3_aL2)]","![r1_aL0, (!r2_aL1), (!r3_aL2)]","(![r1_aL0, (!r2_aL1), (!r3_aL2)])","3","!3","(!3)","x_aL3","((!3), x_aL3)","p_aL4","p1_aL5","safebang@!p1_aL5","(!p1_aL5)","p2_aL6","p3_aL7","[(!p1_aL5), p2_aL6, p3_aL7]","1","p_aL8","p1_aL9","!p1_aL9","(!p1_aL9)","p2_aLa","p3_aLb","[(!p1_aL9), p2_aLa, p3_aLb]","2","p_aLc","p1_aLd","!p1_aLd","(!p1_aLd)","p2_aLe","!p2_aLe","(!p2_aLe)","p3_aLf","[(!p1_aLd), (!p2_aLe), p3_aLf]","3","1","!1","(!1)","x_aLg","!x_aLg","(!x_aLg)","((!1), (!x_aLg))","r1_aLh","safebang@!r1_aLh","(!r1_aLh)","r2_aLi","r3_aLj","[(!r1_aLh), r2_aLi, r3_aLj]","2","!2","(!2)","x_aLk","((!2), x_aLk)","r1_aLl","r2_aLm","r3_aLn","[r1_aLl, r2_aLm, r3_aLn]","3","!3","(!3)","x_aLo","!x_aLo","(!x_aLo)","((!3), (!x_aLo))","r1_aLp","r2_aLq","r3_aLr","safebang@!r3_aLr","(!r3_aLr)","[r1_aLp, r2_aLq, (!r3_aLr)]","1","Empty","_","_","[Empty, _, _]","![Empty, _, _]","(![Empty, _, _])","2","!2","(!2)","_","Empty","!Empty","(!Empty)","_","!_","(!_)","[_, (!Empty), (!_)]","3","_","_","!_","(!_)","Empty","[_, (!_), Empty]","_","!_","(!_)","_","b_aLs","safebang@!b_aLs","(!b_aLs)","x_aLu","piece_aRC","safebang@!piece_aRC","(!piece_aRC)","board_aRD","safebang@!board_aRD","(!board_aRD)","x_aRE","!x_aRE","(!x_aRE)","y_aRF","initialBoard","3","!3","(!3)","-3","(-3)","!(-3)","(!(-3))","((!(-3)))","!((!(-3)))","(!((!(-3))))","x_aRG","!x_aRG","(!x_aRG)","board_aRH","safebang@!board_aRH","(!board_aRH)","x_aRI","[]","x_aRJ","!x_aRJ","(!x_aRJ)","y_aRK","safebang@!y_aRK","(!y_aRK)","Score (!y_aRK)","l_aRL","Score (!y_aRK) : l_aRL","(Score (!y_aRK) : l_aRL)","!(Score (!y_aRK) : l_aRL)","(!(Score (!y_aRK) : l_aRL))","x_aSK","XWin","l_aSL","XWin : l_aSL","(XWin : l_aSL)","!(XWin : l_aSL)","(!(XWin : l_aSL))","((!(XWin : l_aSL)))","!((!(XWin : l_aSL)))","(!((!(XWin : l_aSL))))","x_aSM","OWin","!OWin","(!OWin)","l_aSN","!l_aSN","(!l_aSN)","(!OWin) : (!l_aSN)","((!OWin) : (!l_aSN))","!((!OWin) : (!l_aSN))","(!((!OWin) : (!l_aSN)))","((!((!OWin) : (!l_aSN))))","!((!((!OWin) : (!l_aSN))))","(!((!((!OWin) : (!l_aSN)))))","board_aSO","win_aSP","X","score_aSQ","lazydmd@!score_aSQ","(!score_aSQ)","Empty","_","O","score_aSR","f_aSS","[]","![]","(![])","x_aST","f_aSU","x_aSV","!x_aSV","(!x_aSV)","[]","f_aSW","!f_aSW","(!f_aSW)","x_aSX","xs_aSY","x_aSX : xs_aSY","(x_aSX : xs_aSY)","!(x_aSX : xs_aSY)","(!(x_aSX : xs_aSY))","((!(x_aSX : xs_aSY)))","!((!(x_aSX : xs_aSY)))","(!((!(x_aSX : xs_aSY))))","y_aSZ","ys_aT0","y_aSZ : ys_aT0","(y_aSZ : ys_aT0)","!(y_aSZ : ys_aT0)","(!(y_aSZ : ys_aT0))"]
module Board where
import Wins

showBoard :: Board -> String
showBoard (norecord@[r1_aKG, r2_aKH, (!r3_aKI)])
  = showRow r1_aKG ++ "\n------\n" ++ showRow r2_aKH ++ "\n------\n"
      ++ showRow r3_aKI
      ++ "\n\n"
showRow (norecord@[p1_aKJ, (!p2_aKK), (!p3_aKL)])
  = showPiece p1_aKJ ++ "|" ++ showPiece p2_aKK ++ "|" ++
      showPiece p3_aKL

showPiece :: Piece -> String
showPiece X = "X"
showPiece (norecord@O) = "O"
showPiece Empty = " "

placePiece :: Piece -> Board -> (Int, Int) -> [Board]
placePiece (!p_aKM) (!board_aKN) (norecord@pos_aKO)
  | not (empty pos_aKO board_aKN) = []
placePiece (norecord@p_aKP) [r1_aKQ, r2_aKR, (!r3_aKS)]
  (norecord@((norecord@1), x_aKT))
  = [[insert p_aKP r1_aKQ x_aKT, r2_aKR, r3_aKS]]
placePiece (norecord@p_aKU) (norecord@[r1_aKV, r2_aKW, r3_aKX])
  ((norecord@2), (norecord@x_aKY))
  = [[r1_aKV, insert p_aKU r2_aKW x_aKY, r3_aKX]]
placePiece (norecord@p_aKZ)
  (norecord@[r1_aL0, (norecord@r2_aL1), (!r3_aL2)])
  ((norecord@3), x_aL3)
  = [[r1_aL0, r2_aL1, insert p_aKZ r3_aL2 x_aL3]]

insert :: Piece -> Row -> Int -> Row
insert p_aL4 [(!p1_aL5), p2_aL6, p3_aL7] 1
  = [p_aL4, p2_aL6, p3_aL7]
insert p_aL8 [(norecord@p1_aL9), p2_aLa, p3_aLb] 2
  = [p1_aL9, p_aL8, p3_aLb]
insert p_aLc [(norecord@p1_aLd), (norecord@p2_aLe), p3_aLf] 3
  = [p1_aLd, p2_aLe, p_aLc]

empty :: (Int, Int) -> Board -> Bool
empty ((norecord@1), (norecord@x_aLg)) [(!r1_aLh), r2_aLi, r3_aLj]
  = empty' x_aLg r1_aLh
empty ((norecord@2), x_aLk) [r1_aLl, r2_aLm, r3_aLn]
  = empty' x_aLk r2_aLm
empty ((norecord@3), (norecord@x_aLo)) [r1_aLp, r2_aLq, (!r3_aLr)]
  = empty' x_aLo r3_aLr

empty' :: Int -> Row -> Bool
empty' 1 (norecord@[Empty, _, _]) = True
empty' (norecord@2) [_, (norecord@Empty), (norecord@_)] = True
empty' 3 [_, (norecord@_), Empty] = True
empty' (norecord@_) _ = False
fullBoard (!b_aLs) = and (map notEmpty_aLt (concat b_aLs))
  where notEmpty_aLt x_aLu = not (x_aLu == Empty)
newPositions (!piece_aRC) (!board_aRD)
  = concat
      (map (placePiece piece_aRC board_aRD)
         [(x_aRE, y_aRF) | (norecord@x_aRE) <- [1 .. 3], y_aRF <- [1 .. 3]])

initialBoard :: Board
initialBoard
  = [[Empty, Empty, Empty], [Empty, Empty, Empty],
     [Empty, Empty, Empty]]
eval (norecord@3) = XWin
eval (norecord@((norecord@(-3)))) = OWin
eval (norecord@x_aRG) = Score x_aRG

static :: Board -> Evaluation
static (!board_aRH) = interpret 0 (map (score board_aRH) wins)

interpret :: Int -> [Evaluation] -> Evaluation
interpret x_aRI [] = (Score x_aRI)
interpret (norecord@x_aRJ) (norecord@(Score (!y_aRK) : l_aRL))
  = interpret (x_aRJ + y_aRK) l_aRL
interpret x_aSK (norecord@((norecord@(XWin : l_aSL)))) = XWin
interpret x_aSM
  (norecord@((norecord@((norecord@OWin) : (norecord@l_aSN))))) = OWin

score :: Board -> Win -> Evaluation
score board_aSO win_aSP
  = eval (sum (map sum (map2 (map2 scorePiece) board_aSO win_aSP)))

scorePiece :: Piece -> Int -> Int
scorePiece X (lazydmd@score_aSQ) = score_aSQ
scorePiece Empty _ = 0
scorePiece O score_aSR = -score_aSR

map2 :: (a_aKD -> b_aKE -> c_aKF) -> [a_aKD] -> [b_aKE] -> [c_aKF]
map2 f_aSS (norecord@[]) x_aST = []
map2 f_aSU (norecord@x_aSV) [] = []
map2 (norecord@f_aSW) (norecord@((norecord@(x_aSX : xs_aSY))))
  (norecord@(y_aSZ : ys_aT0))
  = f_aSW x_aSX y_aSZ : map2 f_aSW xs_aSY ys_aT0

data Piece = X
           | O
           | Empty
           deriving Eq

type Row = [Piece]

type Board = [Row]

data Evaluation = XWin
                | OWin
                | Score Int
                deriving (Show, Eq)
STARTLOG
STARTLOG
["lemmas","[]","![]","(![])","h_avB","safebang@!h_avB","(!h_avB)","t_avC","safebang@!t_avC","(!t_avC)","(!h_avB) : (!t_avC)","((!h_avB) : (!t_avC))","!((!h_avB) : (!t_avC))","(!((!h_avB) : (!t_avC)))","[]","term_avD","h_avE","t_avF","h_avE : t_avF","(h_avE : t_avF)","!(h_avE : t_avF)","(!(h_avE : t_avF))","term_avG","!term_avG","(!term_avG)","Nil","!Nil","(!Nil)","term_avH","!term_avH","(!term_avH)","x_avI","lazydmd@!x_avI","(!x_avI)","Atom (!x_avI)","(Atom (!x_avI))","!(Atom (!x_avI))","(!(Atom (!x_avI)))","((!(Atom (!x_avI))))","term_avJ","x_avL","safebang@!x_avL","(!x_avL)","y_avM","((!x_avL), y_avM)","!((!x_avL), y_avM)","(!((!x_avL), y_avM))","Cons (!((!x_avL), y_avM))","(Cons (!((!x_avL), y_avM)))","term_avN","!term_avN","(!term_avN)","z_avO","safebang@!z_avO","(!z_avO)","term_aJg","!term_aJg","(!term_aJg)","statement","subterm","teststatement","testresult","True","False","main"]
module Main (main) where
import Lisplikefns
import Rewritefns
import Rulebasetext
import Checker

lemmas :: LUT
lemmas = addlemmalst (makelemmas rules) newLUT

makelemmas :: [String] -> [Lisplist]
makelemmas (norecord@[]) = []
makelemmas (norecord@((!h_avB) : (!t_avC)))
  = mkLisplist (strToToken h_avB) : (makelemmas t_avC)

addlemmalst :: [Lisplist] -> LUT -> LUT
addlemmalst [] term_avD = term_avD
addlemmalst (norecord@(h_avE : t_avF)) (norecord@term_avG)
  = addlemmalst t_avF (addlemma h_avE term_avG)

addlemma :: Lisplist -> LUT -> LUT
addlemma (norecord@Nil) (norecord@term_avH) = term_avH
addlemma ((norecord@(Atom (lazydmd@x_avI)))) term_avJ
  = error "Atoms can't be lemmas"
addlemma (Cons (norecord@((!x_avL), y_avM))) (norecord@term_avN)
  | tv x_avL == "equal" && not (atom z_avO) =
    addtoLUT (tv (car z_avO), Cons (x_avL, y_avM), term_avN)
  | otherwise = error "Malformed lemma"
  where (!z_avO) = car y_avM

tautp :: Lisplist -> Bool
tautp (norecord@term_aJg)
  = tautologyp (rewrite term_aJg lemmas, Nil, Nil)

statement :: Lisplist
statement
  = mkLisplist
      (strToToken
         ("( implies ( and ( implies x y )( and ( implies y z )( and ( implies z u )( implies u w ) ) ) )( implies x w ) )"))

subterm :: Lisplist
subterm
  = mkLisplist
      (strToToken
         ("( ( x f ( plus ( plus a b )( plus c ( zero ) ) ) )( y f ( times ( times a b )( plus c d ) ) )( z f ( reverse ( append ( append a b ) ( [] ) ) ) )(u equal ( plus a b ) ( difference x y ) )(w lessp ( remainder a b )( member a ( length b ) ) ) )"))

teststatement :: Lisplist
teststatement = applysubst subterm statement

testresult :: Bool
testresult = tautp teststatement

report :: Bool -> String
report True = "The term is a tautology\n"
report False = "The term is not a tautology\n"
main = putStr (report testresult)
STARTLOG
["rules"]
module Rulebasetext (rules) where

rules :: [String]
rules
  = ["(equal (compile form)(reverse (codegen (optimize form) (nil) ) ) )",
     "(equal (eqp x y)(equal (fix x)(fix y) ) )",
     "(equal (greaterp x y)(lessp y x) )",
     "(equal (lesseqp x y)(not (lessp y x) ) )",
     "(equal (greatereqp x y)(not (lessp y x) ) )",
     "(equal (boolean x)(or (equal x (t) )(equal x (f) ) )",
     "(equal (iff x y)(and (implies x y)(implies y x) ) )",
     "(equal (even1 x)(if (zerop x)(t)(odd (1- x) ) ) )",
     "(equal (countps- l pred)(countps-loop l pred (zero) ) )",
     "(equal (fact- i)(fact-loop i 1) )",
     "(equal (reverse- x)(reverse-loop x (nil) ) )",
     "(equal (divides x y)(zerop (remainder y x) ) )",
     "(equal (assume-true var alist)(cons (cons var (t) )alist) )",
     "(equal (assume-false var alist)(cons (cons var (f) )alist) )",
     "(equal (tautology-checker x)(tautologyp (normalize x)(nil) ) )",
     "(equal (falsify x)(falsify1 (normalize x)(nil) ) )",
     "(equal (prime x)(and (not (zerop x))(not (equal x (add1 (zero) ) ) )(prime1 x (1- x) ) ) )",
     "(equal (and p q)(if p (if q (t) (f) ) (f) ) )",
     "(equal (or p q)(if p (t) (if q (t) (f) ) ) )",
     "(equal (not p)(if p (f) (t) ) )",
     "(equal (implies p q)(if p (if q (t) (f) ) (t) ) )",
     "(equal (fix x)(if (numberp x) x (zero) ) )",
     "(equal (if (if a b c) d e)(if a (if b d e) (if c d e) ) )",
     "(equal (zerop x)(or (equal x (zero) )(not (numberp x) ) ) )",
     "(equal (plus (plus x y) z )(plus x (plus y z) ) )",
     "(equal (equal (plus a b) (zero ) )(and (zerop a) (zerop b) ) )",
     "(equal (difference x x)(zero) )",
     "(equal (equal (plus a b) (plus a c) )(equal (fix b) (fix c) ) )",
     "(equal (equal (zero) (difference x y) )(not (lessp y x) ) )",
     "(equal (equal x (difference x y) )(and (numberp x)(or (equal x (zero) )(zerop y) ) ) )",
     "(equal (meaning (plus-tree (append x y) ) a)(plus (meaning (plus-tree x) a)(meaning (plus-tree y) a) ) )",
     "(equal (meaning (plus-tree (plus-fringe x) ) a)(fix (meaning x a) ) )",
     "(equal (append (append x y) z)(append x (append y z) ) )",
     "(equal (reverse (append a b) )(append (reverse b) (reverse a) ) )",
     "(equal (times x (plus y z) )(plus (times x y)(times x z) ) )",
     "(equal (times (times x y) z)(times x (times y z) ) )",
     "(equal (equal (times x y) (zero) )(or (zerop x)(zerop y) ) )",
     "(equal (exec (append x y)pds envrn)(exec y (exec x pds envrn)envrn) )",
     "(equal (mc-flatten x y)(append (flatten x)y) )",
     "(equal (member x (append a b) )(or (member x a)(member x b) ) )",
     "(equal (member x (reverse y) )(member x y) )",
     "(equal (length (reverse x) )(length x) )",
     "(equal (member a (intersect b c) )(and (member a b)(member a c) ) )",
     "(equal (nth (zero)i)(zero) )",
     "(equal (exp i (plus j k) )(times (exp i j)(exp i k) ) )",
     "(equal (exp i (times j k) )(exp (exp i j)k) )",
     "(equal (reverse-loop x y)(append (reverse x)y) )",
     "(equal (reverse-loop x (nil) )(reverse x) )",
     "(equal (count-list z (sort-lp x y) )(plus (count-list z x)(count-list z y) ) )",
     "(equal (equal (append a b)(append a c) )(equal b c) )",
     "(equal (plus (remainder x y)(times y (quotient x y) ) )(fix x) )",
     "(equal (power-eval (big-plus1 l i base)base)(plus (power-eval l base)i) )",
     "(equal (power-eval (big-plus x y i base)base)(plus i (plus (power-eval x base)(power-eval y base) ) ) )",
     "(equal (remainder y 1)(zero) )",
     "(equal (lessp (remainder x y)y)(not (zerop y) ) )",
     "(equal (remainder x x)(zero) )",
     "(equal (lessp (quotient i j)i)(and (not (zerop i) )(or (zerop j)(not (equal j 1) ) ) ) )",
     "(equal (lessp (remainder x y)x)(and (not (zerop y) )(not (zerop x) )(not (lessp x y) ) ) )",
     "(equal (power-eval (power-rep i base)base)(fix i) )",
     "(equal (power-eval (big-plus (power-rep i base)(power-rep j base)(zero)base)base)(plus i j) )",
     "(equal (gcd x y)(gcd y x) )",
     "(equal (nth (append a b)i)(append (nth a i)(nth b (difference i (length a) ) ) ) )",
     "(equal (difference (plus x y)x)(fix y) )",
     "(equal (difference (plus y x)x)(fix y) )",
     "(equal (difference (plus x y)(plus x z) )(difference y z) )",
     "(equal (times x (difference c w) )(difference (times c x)(times w x) ) )",
     "(equal (remainder (times x z)z)(zero) )",
     "(equal (difference (plus b (plus a c) )a)(plus b c) )",
     "(equal (difference (add1 (plus y z)z)(add1 y) )",
     "(equal (lessp (plus x y)(plus x z ) )(lessp y z) )",
     "(equal (lessp (times x z)(times y z) )(and (not (zerop z) )(lessp x y) ) )",
     "(equal (lessp y (plus x y) )(not (zerop x) ) )",
     "(equal (gcd (times x z)(times y z) )(times z (gcd x y) ) )",
     "(equal (value (normalize x)a)(value x a) )",
     "(equal (equal (flatten x)(cons y (nil) ) )(and (nlistp x)(equal x y) ) )",
     "(equal (listp (gopher x) )(listp x) )",
     "(equal (samefringe x y)(equal (flatten x)(flatten y) ) )",
     "(equal (equal (greatest-factor x y)(zero) )(and (or (zerop y)(equal y 1) )(equal x (zero) ) ) )",
     "(equal (equal (greatest-factor x y)1)(equal x 1) )",
     "(equal (numberp (greatest-factor x y) )(not (and (or (zerop y)(equal y 1) )(not (numberp x) ) ) ) )",
     "(equal (times-list (append x y) )(times (times-list x)(times-list y) ) )",
     "(equal (prime-list (append x y) )(and (prime-list x)(prime-list y) ) )",
     "(equal (equal z (times w z) )(and (numberp z)(or (equal z (zero) )(equal w 1) ) ) )",
     "(equal (greatereqpr x y)(not (lessp x y) ) )",
     "(equal (equal x (times x y) )(or (equal x (zero) )(and (numberp x)(equal y 1) ) ) )",
     "(equal (remainder (times y x)y)(zero) )",
     "(equal (equal (times a b)1)(and (not (equal a (zero) ) )(not (equal b (zero) ) )(numberp a)(numberp b)(equal (1- a)(zero) )(equal (1- b)(zero) ) ) )",
     "(equal (lessp (length (delete x l) )(length l) )(member x l) )",
     "(equal (sort2 (delete x l) )(delete x (sort2 l) ) )",
     "(equal (dsort x)(sort2 x) )",
     "(equal (length(cons x1(cons x2(cons x3(cons x4(cons x5(cons x6 x7) ) ) ) ) ) )(plus 6 (length x7) ) )",
     "(equal (difference (add1 (add1 x) )2)(fix x) )",
     "(equal (quotient (plus x (plus x y) )2)(plus x (quotient y 2) ) )",
     "(equal (sigma (zero)i)(quotient (times i (add1 i) )2) )",
     "(equal (plus x (add1 y) )(if (numberp y)(add1 (plus x y) )(add1 x) ) )",
     "(equal (equal (difference x y)(difference z y) )(if (lessp x y)(not (lessp y z) )(if (lessp z y)(not (lessp y x) )(equal (fix x)(fix z) ) ) ) )",
     "(equal (meaning (plus-tree (delete x y) )a)(if (member x y)(difference (meaning (plus-tree y)a)(meaning x a) )(meaning (plus-tree y)a) ) )",
     "(equal (times x (add1 y) )(if (numberp y)(plus x (times x y) )(fix x) ) )",
     "(equal (nth (nil)i)(if (zerop i)(nil)(zero) ) )",
     "(equal (last (append a b) )(if (listp b)(last b)(if (listp a)(cons (car (last a) )b)b) ) )",
     "(equal (equal (lessp x y)z)(if (lessp x y)(equal t z)(equal f z) ) )",
     "(equal (assignment x (append a b) )(if (assignedp x a)(assignment x a)(assignment x b) ) )",
     "(equal (car (gopher x) )(if (listp x)(car (flatten x) )(zero) ) )",
     "(equal (flatten (cdr (gopher x) ) )(if (listp x)(cdr (flatten x) )(cons (zero)(nil) ) ) )",
     "(equal (quotient (times y x)y)(if (zerop y)(zero)(fix x) ) )",
     "(equal (get j (set i val mem) )(if (eqp j i)val(get j mem) ) )"]
STARTLOG
STARTLOG
STARTLOG
STARTLOG
["main","p0_an0","lazydmd@!p0_an0","(!p0_an0)","t_an2","h_an3","safebang@!h_an3","(!h_an3)","i_an4","safebang@!i_an4","(!i_an4)","r_an5","y_an6","safebang@!y_an6","(!y_an6)","w_an7","safebang@!w_an7","(!w_an7)","e_an8","l_an9","v_ana","safebang@!v_ana","(!v_ana)","n_anb","[t_an2, (!h_an3), (!i_an4), r_an5, (!y_an6), (!w_an7), e_an8,\n l_an9, (!v_ana), n_anb]","![t_an2, (!h_an3), (!i_an4), r_an5, (!y_an6), (!w_an7), e_an8,\n  l_an9, (!v_ana), n_anb]","(![t_an2, (!h_an3), (!i_an4), r_an5, (!y_an6), (!w_an7), e_an8,\n   l_an9, (!v_ana), n_anb])","a_aRh","!a_aRh","(!a_aRh)","b_aRi","!b_aRi","(!b_aRi)","c_aRj","d_aRk","e_aRl","f_aRm","!f_aRm","(!f_aRm)","[]","j_aRn","safebang@!j_aRn","(!j_aRn)","js_aRo","safebang@!js_aRo","(!js_aRo)","(!j_aRn) : (!js_aRo)","((!j_aRn) : (!js_aRo))","!((!j_aRn) : (!js_aRo))","(!((!j_aRn) : (!js_aRo)))","((!((!j_aRn) : (!js_aRo))))","pjs_aRt","r_aRu","[]","k_aRq","!k_aRq","(!k_aRq)","ks_aRr","!ks_aRr","(!ks_aRr)","(!k_aRq) : (!ks_aRr)","((!k_aRq) : (!ks_aRr))","!((!k_aRq) : (!ks_aRr))","(!((!k_aRq) : (!ks_aRr)))","((!((!k_aRq) : (!ks_aRr))))","!((!((!k_aRq) : (!ks_aRr))))","(!((!((!k_aRq) : (!ks_aRr)))))","aks_aRs","!aks_aRs","(!aks_aRs)"]
module Main (main) where
main
  = putStr $ shows (filter condition_an1 $ permutations p0_an0) "\n"
  where (lazydmd@p0_an0) = [0 .. 9] :: [Int]
        condition_an1
          (norecord@[t_an2, (!h_an3), (!i_an4), r_an5, (!y_an6), (!w_an7),
                     e_an8, l_an9, (!v_ana), n_anb])
          = expand t_an2 h_an3 i_an4 r_an5 t_an2 y_an6 + 5 *
              expand t_an2 w_an7 e_an8 l_an9 v_ana e_an8
              == expand n_anb i_an4 n_anb e_an8 t_an2 y_an6
expand (norecord@a_aRh) (norecord@b_aRi) c_aRj d_aRk e_aRl
  (norecord@f_aRm)
  = f_aRm + e_aRl * 10 + d_aRk * 100 + c_aRj * 1000 + b_aRi * 10000 +
      a_aRh
      * 100000
      :: Int

permutations :: [Int] -> [[Int]]
permutations [] = [[]]
permutations ((norecord@((!j_aRn) : (!js_aRo))))
  = [r_aRu | pjs_aRt <- permutations js_aRo,
     r_aRu <- addj_aRp pjs_aRt]
  where addj_aRp [] = [[j_aRn]]
        addj_aRp
          (norecord@((norecord@((norecord@k_aRq) : (norecord@ks_aRr)))))
          = (j_aRn : k_aRq : ks_aRr) :
              [(k_aRq : aks_aRs) | (norecord@aks_aRs) <- addj_aRp ks_aRr]
STARTLOG
STARTLOG
STARTLOG
["env_ap5","safebang@!env_ap5","(!env_ap5)","x_ap6","ps_ap7","Term x_ap6 ps_ap7","(Term x_ap6 ps_ap7)","!(Term x_ap6 ps_ap7)","(!(Term x_ap6 ps_ap7))","p_ap8","env_ap9","!env_ap9","(!env_ap9)","x_apa","Var x_apa","(Var x_apa)","!(Var x_apa)","(!(Var x_apa))","((!(Var x_apa)))","!((!(Var x_apa)))","(!((!(Var x_apa))))","lookup_apb","env_apc","p1_apd","p2_ape","env_apf","safebang@!env_apf","(!env_apf)","[]","env_apg","p1_aph","p2_api","(p1_aph, p2_api)","pairs_apj","(p1_aph, p2_api) : pairs_apj","((p1_aph, p2_api) : pairs_apj)","!((p1_aph, p2_api) : pairs_apj)","(!((p1_aph, p2_api) : pairs_apj))","res_apr","env_aps","safebang@!env_aps","(!env_aps)","x1_apt","ps1_apu","safebang@!ps1_apu","(!ps1_apu)","Term x1_apt (!ps1_apu)","(Term x1_apt (!ps1_apu))","!(Term x1_apt (!ps1_apu))","(!(Term x1_apt (!ps1_apu)))","((!(Term x1_apt (!ps1_apu))))","!((!(Term x1_apt (!ps1_apu))))","(!((!(Term x1_apt (!ps1_apu)))))","x2_apv","ps2_apw","safebang@!ps2_apw","(!ps2_apw)","Term x2_apv (!ps2_apw)","(Term x2_apv (!ps2_apw))","env_aGu","x_aGv","Var x_aGv","(Var x_aGv)","y_aGw","safebang@!y_aGw","(!y_aGw)","Var (!y_aGw)","(Var (!y_aGw))","!(Var (!y_aGw))","(!(Var (!y_aGw)))","((!(Var (!y_aGw))))","!((!(Var (!y_aGw))))","(!((!(Var (!y_aGw)))))","env_aGx","!env_aGx","(!env_aGx)","x_aGy","safebang@!x_aGy","(!x_aGy)","Var (!x_aGy)","(Var (!x_aGy))","!(Var (!x_aGy))","(!(Var (!x_aGy)))","((!(Var (!x_aGy))))","!((!(Var (!x_aGy))))","(!((!(Var (!x_aGy)))))","p_aGz","env_aGA","p_aGB","!p_aGB","(!p_aGB)","x_aGC","Var x_aGC","(Var x_aGC)","!(Var x_aGC)","(!(Var x_aGC))","((!(Var x_aGC)))","v_aGD","safebang@!v_aGD","(!v_aGD)","x_aGE","safebang@!x_aGE","(!x_aGE)","ps_aGF","safebang@!ps_aGF","(!ps_aGF)","Term (!x_aGE) (!ps_aGF)","(Term (!x_aGE) (!ps_aGF))","!(Term (!x_aGE) (!ps_aGF))","(!(Term (!x_aGE) (!ps_aGF)))","((!(Term (!x_aGE) (!ps_aGF))))","!((!(Term (!x_aGE) (!ps_aGF))))","(!((!(Term (!x_aGE) (!ps_aGF)))))","p_aMB","y_aMC","safebang@!y_aMC","(!y_aMC)","Var (!y_aMC)","(Var (!y_aMC))","!(Var (!y_aMC))","(!(Var (!y_aMC)))","((!(Var (!y_aMC))))","x_aMD","Var x_aMD","(Var x_aMD)","p_aME","!p_aME","(!p_aME)","x_aMF","!x_aMF","(!x_aMF)","Var (!x_aMF)","(Var (!x_aMF))","!(Var (!x_aMF))","(!(Var (!x_aMF)))","((!(Var (!x_aMF))))"]
module Match where
import Result
import Table
import Knowledge
subst (!env_ap5) (norecord@(Term x_ap6 ps_ap7))
  = Term x_ap6 [subst env_ap5 p_ap8 | p_ap8 <- ps_ap7]
subst (norecord@env_ap9) (norecord@((norecord@(Var x_apa))))
  = if fails lookup_apb then (Var x_apa) else
      subst env_ap9 (answer lookup_apb)
  where lookup_apb = find env_ap9 x_apa
match env_apc p1_apd p2_ape
  = compear env_apc (subst env_apc p1_apd) (subst env_apc p2_ape)
matchList (!env_apf) [] = success env_apf
matchList env_apg (norecord@((p1_aph, p2_api) : pairs_apj))
  = if fails res_apr then res_apr else
      matchList (answer res_apr) pairs_apj
  where res_apr = match env_apg p1_aph p2_api
compear (!env_aps) (norecord@((norecord@(Term x1_apt (!ps1_apu)))))
  (Term x2_apv (!ps2_apw))
  | x1_apt == x2_apv = matchList env_aps (zip ps1_apu ps2_apw)
  | otherwise = failure "no match"
compear env_aGu (Var x_aGv) (norecord@((norecord@(Var (!y_aGw)))))
  | x_aGv /= y_aGw = success (update env_aGu x_aGv (Var y_aGw))
  | otherwise = success env_aGu
compear (norecord@env_aGx) (norecord@((norecord@(Var (!x_aGy)))))
  p_aGz
  | not (occurs (Var x_aGy) p_aGz) =
    success (update env_aGx x_aGy p_aGz)
  | otherwise = failure "occurs check failed"
compear env_aGA (norecord@p_aGB) ((norecord@(Var x_aGC)))
  = compear env_aGA (Var x_aGC) p_aGB
occurs (!v_aGD) (norecord@((norecord@(Term (!x_aGE) (!ps_aGF)))))
  = or [occurs v_aGD p_aMB | p_aMB <- ps_aGF]
occurs ((norecord@(Var (!y_aMC)))) (Var x_aMD) = y_aMC == x_aMD
occurs (norecord@p_aME) ((norecord@(Var (norecord@x_aMF)))) = False

type Environment = Table String Phrase
STARTLOG
["p_ap9","safebang@!p_ap9","(!p_ap9)","x_apb","Var x_apb","(Var x_apb)","x_apc","safebang@!x_apc","(!x_apc)","ps_apd","Term (!x_apc) ps_apd","(Term (!x_apc) ps_apd)","!(Term (!x_apc) ps_apd)","(!(Term (!x_apc) ps_apd))","((!(Term (!x_apc) ps_apd)))","p_avh","!p_avh","(!p_avh)","x_axG","safebang@!x_axG","(!x_axG)","Var (!x_axG)","(Var (!x_axG))","x_axH","[]","Term x_axH []","(Term x_axH [])","!(Term x_axH [])","(!(Term x_axH []))","((!(Term x_axH [])))","op_axI","p1_axJ","p2_axK","[p1_axJ, p2_axK]","Term op_axI [p1_axJ, p2_axK]","(Term op_axI [p1_axJ, p2_axK])","ws_axL","safebang@!ws_axL","(!ws_axL)","ws_axM","ws_axN","safebang@!ws_axN","(!ws_axN)","verb_axO","w_aB4","!w_aB4","(!w_aB4)","verbs_axP","!verbs_axP","(!verbs_axP)","a_aB5","safebang@!a_aB5","(!a_aB5)","x_aB6","[(!a_aB5), x_aB6]","![(!a_aB5), x_aB6]","(![(!a_aB5), x_aB6])","x_aB7","[x_aB7]","x_aOz","[x_aOz]","ws_aOA","f_aOB","op_aOC","safebang@!op_aOC","(!op_aOC)","g_aOD","safebang@!g_aOD","(!g_aOD)","lhs_aOE","!lhs_aOE","(!lhs_aOE)","rhs_aOF","!rhs_aOF","(!rhs_aOF)","ls_aOG","safebang@!ls_aOG","(!ls_aOG)","v_aOS","!v_aOS","(!v_aOS)","v_aOL","!v_aOL","(!v_aOL)","r_aOM","verbs_aOI","r_aON","!r_aON","(!r_aON)","\"if\"","v_aOO","safebang@!v_aOO","(!v_aOO)","ns_aOP","Term (!v_aOO) ns_aOP","(Term (!v_aOO) ns_aOP)","!(Term (!v_aOO) ns_aOP)","(!(Term (!v_aOO) ns_aOP))","g_aOQ","safebang@!g_aOQ","(!g_aOQ)","[(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)]","![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)]","(![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)])","Term \"if\" (![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)])","(Term \"if\" (![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)]))","!(Term \"if\" (![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)]))","(!(Term \"if\" (![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)])))","((!(Term \"if\" (![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)]))))","!((!(Term \"if\" (![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)]))))","(!((!(Term \"if\" (![(!(Term (!v_aOO) ns_aOP)), (!g_aOQ)])))))","rs_aOK","l_aOR","!l_aOR","(!l_aOR)","defs_aOT","safebang@!defs_aOT","(!defs_aOT)","v_aOU","ns_aOV","Term v_aOU ns_aOV","(Term v_aOU ns_aOV)","lookup_aOW","!lookup_aOW","(!lookup_aOW)"]
module Knowledge where
import Result
import Table
import Data.List (nub)
vars (!p_ap9) = nub (names_apa p_ap9)
  where names_apa (Var x_apb) = [x_apb]
        names_apa ((norecord@(Term (!x_apc) ps_apd)))
          = concat [names_apa p_avh | (norecord@p_avh) <- ps_apd]
showPhrase (Var (!x_axG)) = x_axG
showPhrase ((norecord@(Term x_axH []))) = x_axH
showPhrase (Term op_axI [p1_axJ, p2_axK])
  = showPhrase p1_axJ ++ " " ++ op_axI ++ " " ++ showPhrase p2_axK
rule (!ws_axL) = split ws_axL relation "if" goal
goal ws_axM
  | elem "or" ws_axM = split ws_axM goal "or" goal
  | elem "and" ws_axM = split ws_axM goal "and" goal
  | otherwise = relation ws_axM
relation (!ws_axN) = split ws_axN noun verb_axO noun
  where verb_axO
          = head [w_aB4 | (norecord@w_aB4) <- ws_axN, elem w_aB4 verbs_axP]
        (norecord@verbs_axP) = ["is", "describes", "has", "can", "eats"]
noun (norecord@[(!a_aB5), x_aB6])
  | elem a_aB5 ["a", "an", "the"] = noun [a_aB5 ++ " " ++ x_aB6]
noun [x_aB7]
  | ('A' <= head x_aB7) && (head x_aB7 <= 'Z') = Var x_aB7
noun [x_aOz] = Term x_aOz []
split ws_aOA f_aOB (!op_aOC) (!g_aOD)
  = Term op_aOC [f_aOB lhs_aOE, g_aOD rhs_aOF]
  where (norecord@lhs_aOE) = takeWhile (/= op_aOC) ws_aOA
        (norecord@rhs_aOF) = tail (dropWhile (/= op_aOC) ws_aOA)
definitions (!ls_aOG)
  = updateList newTable
      [(v_aOS, def_aOH v_aOS) | (norecord@v_aOS) <- verbs_aOI]
  where def_aOH (norecord@v_aOL)
          = [r_aOM | r_aOM <- rs_aOK, verb_aOJ r_aOM == v_aOL]
        verbs_aOI = nub [verb_aOJ r_aON | (norecord@r_aON) <- rs_aOK]
        verb_aOJ
          (norecord@((norecord@(Term "if"
                                  (norecord@[(norecord@(Term (!v_aOO) ns_aOP)), (!g_aOQ)])))))
          = v_aOO
        rs_aOK = [rule (words l_aOR) | (norecord@l_aOR) <- ls_aOG]
relevant (!defs_aOT) (Term v_aOU ns_aOV)
  = if fails lookup_aOW then [] else answer lookup_aOW
  where (norecord@lookup_aOW) = find defs_aOT v_aOU

data Phrase = Term String [Phrase]
            | Var String
STARTLOG
STARTLOG
["a_an2","safebang@!a_an2","(!a_an2)","a_an3","Answer a_an3","(Answer a_an3)","_","!_","(!_)","a_anb","Answer a_anb","(Answer a_anb)","!(Answer a_anb)","(!(Answer a_anb))","((!(Answer a_anb)))","r_anc","safebang@!r_anc","(!r_anc)","fails","r_aAF","Reason r_aAF","(Reason r_aAF)","a_aAG","Answer a_aAG","(Answer a_aAG)","!(Answer a_aAG)","(!(Answer a_aAG))","((!(Answer a_aAG)))","_"]
module Result where
success (!a_an2) = Answer a_an2
succeeds (Answer a_an3) = True
succeeds (norecord@_) = False
answer ((norecord@(Answer a_anb))) = a_anb
failure (!r_anc) = Reason r_anc
fails = not . succeeds
reason (Reason r_aAF) = r_aAF
answers ((norecord@(Answer a_aAG))) = [a_aAG]
answers _ = []

data Result a_an0 r_an1 = Answer a_an0
                        | Reason r_an1
STARTLOG
["newTable","Empty","key_ant","left_anu","k_anv","safebang@!k_anv","(!k_anv)","v_anw","((!k_anv), v_anw)","!((!k_anv), v_anw)","(!((!k_anv), v_anw))","right_anx","Fork left_anu (!((!k_anv), v_anw)) right_anx","(Fork left_anu (!((!k_anv), v_anw)) right_anx)","!(Fork left_anu (!((!k_anv), v_anw)) right_anx)","(!(Fork left_anu (!((!k_anv), v_anw)) right_anx))","((!(Fork left_anu (!((!k_anv), v_anw)) right_anx)))","!((!(Fork left_anu (!((!k_anv), v_anw)) right_anx)))","(!((!(Fork left_anu (!((!k_anv), v_anw)) right_anx))))","key_any","Empty","key_aB1","val_aB2","left_aB3","safebang@!left_aB3","(!left_aB3)","k_aB4","v_aB5","(k_aB4, v_aB5)","right_aB6","Fork (!left_aB3) (k_aB4, v_aB5) right_aB6","(Fork (!left_aB3) (k_aB4, v_aB5) right_aB6)","key_aB7","val_aB8","!val_aB8","(!val_aB8)","Empty","key_aB9","!key_aB9","(!key_aB9)","val_aBa","left_aBb","safebang@!left_aBb","(!left_aBb)","k_aBc","safebang@!k_aBc","(!k_aBc)","v_aBd","safebang@!v_aBd","(!v_aBd)","((!k_aBc), (!v_aBd))","right_aBe","safebang@!right_aBe","(!right_aBe)","Fork (!left_aBb) ((!k_aBc), (!v_aBd)) (!right_aBe)","(Fork (!left_aBb) ((!k_aBc), (!v_aBd)) (!right_aBe))","key_aBf","val_aBg","Empty","key_aBh","left_aBi","!left_aBi","(!left_aBi)","k_aBj","safebang@!k_aBj","(!k_aBj)","v_aBk","safebang@!v_aBk","(!v_aBk)","((!k_aBj), (!v_aBk))","!((!k_aBj), (!v_aBk))","(!((!k_aBj), (!v_aBk)))","right_aBl","!right_aBl","(!right_aBl)","Fork (!left_aBi) (!((!k_aBj), (!v_aBk))) (!right_aBl)","(Fork (!left_aBi) (!((!k_aBj), (!v_aBk))) (!right_aBl))","!(Fork (!left_aBi) (!((!k_aBj), (!v_aBk))) (!right_aBl))","(!(Fork (!left_aBi) (!((!k_aBj), (!v_aBk))) (!right_aBl)))","((!(Fork (!left_aBi) (!((!k_aBj), (!v_aBk))) (!right_aBl))))","!((!(Fork (!left_aBi) (!((!k_aBj), (!v_aBk))) (!right_aBl))))","(!((!(Fork (!left_aBi) (!((!k_aBj), (!v_aBk))) (!right_aBl)))))","key_aBm","left_aBp","Empty","!Empty","(!Empty)","left_aBq","right_aBr","!right_aBr","(!right_aBr)","e_aBs","right'_aBt","safebang@!right'_aBt","(!right'_aBt)","(e_aBs, (!right'_aBt))","!(e_aBs, (!right'_aBt))","(!(e_aBs, (!right'_aBt)))","Empty","!Empty","(!Empty)","e_aBu","lazydmd@!e_aBu","(!e_aBu)","r_aBv","!r_aBv","(!r_aBv)","Fork (!Empty) (!e_aBu) (!r_aBv)","(Fork (!Empty) (!e_aBu) (!r_aBv))","!(Fork (!Empty) (!e_aBu) (!r_aBv))","(!(Fork (!Empty) (!e_aBu) (!r_aBv)))","l_aBw","!l_aBw","(!l_aBw)","e_aBx","r_aBy","Fork (!l_aBw) e_aBx r_aBy","(Fork (!l_aBw) e_aBx r_aBy)","e2_aBz","safebang@!e2_aBz","(!e2_aBz)","l'_aBA","safebang@!l'_aBA","(!l'_aBA)","((!e2_aBz), (!l'_aBA))","!((!e2_aBz), (!l'_aBA))","(!((!e2_aBz), (!l'_aBA)))","t_aBB","[]","Empty","e_aBC","!e_aBC","(!e_aBC)","res_aBD","(!e_aBC) : res_aBD","((!e_aBC) : res_aBD)","k_aBL","!k_aBL","(!k_aBL)","left_aBM","e1_aBU","!e1_aBU","(!e1_aBU)","right_aBN","e1_aBV","!e1_aBV","(!e1_aBV)","left_aBW","e_aBX","!e_aBX","(!e_aBX)","right_aBY","safebang@!right_aBY","(!right_aBY)","Fork left_aBW (!e_aBX) (!right_aBY)","(Fork left_aBW (!e_aBX) (!right_aBY))","!(Fork left_aBW (!e_aBX) (!right_aBY))","(!(Fork left_aBW (!e_aBX) (!right_aBY)))","((!(Fork left_aBW (!e_aBX) (!right_aBY))))","es_aBZ","k_aC0","!k_aC0","(!k_aC0)","left'_aC1","!left'_aC1","(!left'_aC1)","e1_aC3","right'_aC2","e1_aC4","!e1_aC4","(!e1_aC4)","t_aC5","es_aC6","[]","es_aC9","left_aCa","!left_aCa","(!left_aCa)","right_aCb","!right_aCb","(!right_aCb)","m_aCc","[]","e_aVO","[e_aVO]","![e_aVO]","(![e_aVO])","k1_aVP","v1_aVQ","(k1_aVP, v1_aVQ)","!(k1_aVP, v1_aVQ)","(!(k1_aVP, v1_aVQ))","k2_aVR","v2_aVS","safebang@!v2_aVS","(!v2_aVS)","(k2_aVR, (!v2_aVS))","!(k2_aVR, (!v2_aVS))","(!(k2_aVR, (!v2_aVS)))","res_aVT","(!(k2_aVR, (!v2_aVS))) : res_aVT","((!(k2_aVR, (!v2_aVS))) : res_aVT)","(!(k1_aVP, v1_aVQ)) : ((!(k2_aVR, (!v2_aVS))) : res_aVT)","((!(k1_aVP, v1_aVQ)) : ((!(k2_aVR, (!v2_aVS))) : res_aVT))","!((!(k1_aVP, v1_aVQ)) : ((!(k2_aVR, (!v2_aVS))) : res_aVT))","(!((!(k1_aVP, v1_aVQ)) : ((!(k2_aVR, (!v2_aVS))) : res_aVT)))","((!((!(k1_aVP, v1_aVQ)) : ((!(k2_aVR, (!v2_aVS))) : res_aVT))))","kvs_aVU","kv_aVW","safebang@!kv_aVW","(!kv_aVW)","[]","![]","(![])","k1_aVX","!k1_aVX","(!k1_aVX)","v1_aVY","!v1_aVY","(!v1_aVY)","((!k1_aVX), (!v1_aVY))","k2_aVZ","v2_aW0","(k2_aVZ, v2_aW0)","res_aW1","(k2_aVZ, v2_aW0) : res_aW1","((k2_aVZ, v2_aW0) : res_aW1)","!((k2_aVZ, v2_aW0) : res_aW1)","(!((k2_aVZ, v2_aW0) : res_aW1))","((!((k2_aVZ, v2_aW0) : res_aW1)))","[]","kvs_aW2","safebang@!kvs_aW2","(!kvs_aW2)","kvs_aW3","[]","![]","(![])","k1_aW4","safebang@!k1_aW4","(!k1_aW4)","v1_aW5","safebang@!v1_aW5","(!v1_aW5)","((!k1_aW4), (!v1_aW5))","kvs1_aW6","((!k1_aW4), (!v1_aW5)) : kvs1_aW6","(((!k1_aW4), (!v1_aW5)) : kvs1_aW6)","k2_aW7","v2_aW8","safebang@!v2_aW8","(!v2_aW8)","(k2_aW7, (!v2_aW8))","kvs2_aW9","(k2_aW7, (!v2_aW8)) : kvs2_aW9","((k2_aW7, (!v2_aW8)) : kvs2_aW9)","!((k2_aW7, (!v2_aW8)) : kvs2_aW9)","(!((k2_aW7, (!v2_aW8)) : kvs2_aW9))","((!((k2_aW7, (!v2_aW8)) : kvs2_aW9)))","!((!((k2_aW7, (!v2_aW8)) : kvs2_aW9)))","(!((!((k2_aW7, (!v2_aW8)) : kvs2_aW9))))","Empty","!Empty","(!Empty)","left_aWa","safebang@!left_aWa","(!left_aWa)","e_aWb","right_aWc","safebang@!right_aWc","(!right_aWc)","Fork (!left_aWa) e_aWb (!right_aWc)","(Fork (!left_aWa) e_aWb (!right_aWc))"]
module Table where
import Result
newTable = Empty
find Empty key_ant = failure "not found"
find
  (norecord@((norecord@(Fork left_anu (norecord@((!k_anv), v_anw))
                          right_anx))))
  key_any
  | key_any < k_anv = find left_anu key_any
  | key_any == k_anv = success v_anw
  | key_any > k_anv = find right_anx key_any
enter Empty key_aB1 val_aB2 = Fork Empty (key_aB1, val_aB2) Empty
enter (Fork (!left_aB3) (k_aB4, v_aB5) right_aB6) key_aB7
  (norecord@val_aB8)
  | key_aB7 < k_aB4 =
    Fork (enter left_aB3 key_aB7 val_aB8) (k_aB4, v_aB5) right_aB6
  | key_aB7 == k_aB4 = Fork left_aB3 (k_aB4, v_aB5) right_aB6
  | key_aB7 > k_aB4 =
    Fork left_aB3 (k_aB4, v_aB5) (enter right_aB6 key_aB7 val_aB8)
update Empty (norecord@key_aB9) val_aBa
  = Fork Empty (key_aB9, val_aBa) Empty
update (Fork (!left_aBb) ((!k_aBc), (!v_aBd)) (!right_aBe)) key_aBf
  val_aBg
  | key_aBf < k_aBc =
    Fork (update left_aBb key_aBf val_aBg) (k_aBc, v_aBd) right_aBe
  | key_aBf == k_aBc = Fork left_aBb (key_aBf, val_aBg) right_aBe
  | key_aBf > k_aBc =
    Fork left_aBb (k_aBc, v_aBd) (update right_aBe key_aBf val_aBg)
delete Empty key_aBh = Empty
delete
  (norecord@((norecord@(Fork (norecord@left_aBi)
                          (norecord@((!k_aBj), (!v_aBk))) (norecord@right_aBl)))))
  key_aBm
  | key_aBm < k_aBj =
    Fork (delete left_aBi key_aBm) (k_aBj, v_aBk) right_aBl
  | key_aBm == k_aBj = graft_aBn left_aBi right_aBl
  | key_aBm > k_aBj =
    Fork left_aBi (k_aBj, v_aBk) (delete right_aBl key_aBm)
  where graft_aBn left_aBp (norecord@Empty) = left_aBp
        graft_aBn left_aBq (norecord@right_aBr)
          = Fork left_aBq e_aBs right'_aBt
          where (norecord@(e_aBs, (!right'_aBt))) = leftmost_aBo right_aBr
        leftmost_aBo
          (norecord@(Fork (norecord@Empty) (lazydmd@e_aBu) (norecord@r_aBv)))
          = (e_aBu, r_aBv)
        leftmost_aBo (Fork (norecord@l_aBw) e_aBx r_aBy)
          = (e2_aBz, Fork l'_aBA e_aBx r_aBy)
          where (norecord@((!e2_aBz), (!l'_aBA))) = leftmost_aBo l_aBw
enterList t_aBB [] = t_aBB
enterList Empty ((norecord@e_aBC) : res_aBD)
  = Fork left_aBM e_aBC right_aBN
  where (norecord@k_aBL) = fst e_aBC
        left_aBM
          = enterList Empty
              [e1_aBU | (norecord@e1_aBU) <- res_aBD, fst e1_aBU < k_aBL]
        right_aBN
          = enterList Empty
              [e1_aBV | (norecord@e1_aBV) <- res_aBD, fst e1_aBV > k_aBL]
enterList
  ((norecord@(Fork left_aBW (norecord@e_aBX) (!right_aBY)))) es_aBZ
  = Fork left'_aC1 e_aBX right'_aC2
  where (norecord@k_aC0) = fst e_aBX
        (norecord@left'_aC1)
          = enterList left_aBW
              [e1_aC3 | e1_aC3 <- es_aBZ, fst e1_aC3 < k_aC0]
        right'_aC2
          = enterList right_aBY
              [e1_aC4 | (norecord@e1_aC4) <- es_aBZ, fst e1_aC4 > k_aC0]
updateList t_aC5 es_aC6
  = balance_aC7
      (mergeKey (entries t_aC5) (unique_aC8 (sortKey es_aC6)))
  where balance_aC7 [] = Empty
        balance_aC7 es_aC9 = Fork left_aCa (es_aC9 !! m_aCc) right_aCb
          where (norecord@left_aCa) = balance_aC7 (take m_aCc es_aC9)
                (norecord@right_aCb) = balance_aC7 (drop (m_aCc + 1) es_aC9)
                m_aCc = length es_aC9 `div` 2
        unique_aC8 [] = []
        unique_aC8 (norecord@[e_aVO]) = [e_aVO]
        unique_aC8
          ((norecord@((norecord@(k1_aVP, v1_aVQ)) :
                        ((norecord@(k2_aVR, (!v2_aVS))) : res_aVT))))
          = if k1_aVP == k2_aVR then unique_aC8 ((k2_aVR, v2_aVS) : res_aVT)
              else (k1_aVP, v1_aVQ) : unique_aC8 ((k2_aVR, v2_aVS) : res_aVT)
sortKey kvs_aVU = foldr insertKey_aVV [] kvs_aVU
  where insertKey_aVV (!kv_aVW) (norecord@[]) = [kv_aVW]
        insertKey_aVV ((norecord@k1_aVX), (norecord@v1_aVY))
          ((norecord@((k2_aVZ, v2_aW0) : res_aW1)))
          | k1_aVX <= k2_aVZ = (k1_aVX, v1_aVY) : (k2_aVZ, v2_aW0) : res_aW1
          | otherwise =
            (k2_aVZ, v2_aW0) : insertKey_aVV (k1_aVX, v1_aVY) res_aW1
mergeKey [] (!kvs_aW2) = kvs_aW2
mergeKey kvs_aW3 (norecord@[]) = kvs_aW3
mergeKey (((!k1_aW4), (!v1_aW5)) : kvs1_aW6)
  (norecord@((norecord@((k2_aW7, (!v2_aW8)) : kvs2_aW9))))
  | k1_aW4 <= k2_aW7 =
    (k1_aW4, v1_aW5) : mergeKey kvs1_aW6 ((k2_aW7, v2_aW8) : kvs2_aW9)
  | otherwise =
    (k2_aW7, v2_aW8) : mergeKey ((k1_aW4, v1_aW5) : kvs1_aW6) kvs2_aW9
entries (norecord@Empty) = []
entries (Fork (!left_aWa) e_aWb (!right_aWc))
  = entries left_aWa ++ [e_aWb] ++ entries right_aWc

data Table k_anr v_ans = Empty
                       | Fork (Table k_anr v_ans) (k_anr, v_ans) (Table k_anr v_ans)
STARTLOG
["env_apw","safebang@!env_apw","(!env_apw)","vs_apx","Soln (!env_apw) vs_apx","(Soln (!env_apw) vs_apx)","p_apy","safebang@!p_apy","(!p_apy)","tab_apz","v_ata","!v_ata","(!v_ata)","xs_apA","n_apB","lazydmd@!n_apB","(!n_apB)","db_az6","safebang@!db_az6","(!db_az6)","q_az7","Question q_az7","(Question q_az7)","g_az8","db_az9","!db_az9","(!db_az9)","soln_aza","\"or\"","g1_azb","g2_azc","[g1_azb, g2_azc]","Term \"or\" [g1_azb, g2_azc]","(Term \"or\" [g1_azb, g2_azc])","db_azd","!db_azd","(!db_azd)","soln_aze","\"and\"","!\"and\"","(!\"and\")","g1_azf","g2_azg","safebang@!g2_azg","(!g2_azg)","[g1_azf, (!g2_azg)]","![g1_azf, (!g2_azg)]","(![g1_azf, (!g2_azg)])","Term (!\"and\") (![g1_azf, (!g2_azg)])","(Term (!\"and\") (![g1_azf, (!g2_azg)]))","!(Term (!\"and\") (![g1_azf, (!g2_azg)]))","(!(Term (!\"and\") (![g1_azf, (!g2_azg)])))","((!(Term (!\"and\") (![g1_azf, (!g2_azg)]))))","res_azh","!res_azh","(!res_azh)","db_azi","soln_azj","g_azk","defs_azl","info_azm","(defs_azl, info_azm)","rs_azn","lazydmd@!rs_azn","(!rs_azn)","db_aMN","safebang@!db_aMN","(!db_aMN)","soln_aMO","safebang@!soln_aMO","(!soln_aMO)","g_aMP","safebang@!g_aMP","(!g_aMP)","rs_aMQ","safebang@!rs_aMQ","(!rs_aMQ)","soln'_aMT","safebang@!soln'_aMT","(!soln'_aMT)","r'_aMU","safebang@!r'_aMU","(!r'_aMU)","((!soln'_aMT), (!r'_aMU))","copies_aMR","r_aMS","!r_aMS","(!r_aMS)","db_aMV","env_aMW","safebang@!env_aMW","(!env_aMW)","vs_aMX","Soln (!env_aMW) vs_aMX","(Soln (!env_aMW) vs_aMX)","!(Soln (!env_aMW) vs_aMX)","(!(Soln (!env_aMW) vs_aMX))","((!(Soln (!env_aMW) vs_aMX)))","!((!(Soln (!env_aMW) vs_aMX)))","(!((!(Soln (!env_aMW) vs_aMX))))","g_aMY","safebang@!g_aMY","(!g_aMY)","\"if\"","!\"if\"","(!\"if\")","p_aMZ","safebang@!p_aMZ","(!p_aMZ)","newg_aN0","[(!p_aMZ), newg_aN0]","![(!p_aMZ), newg_aN0]","(![(!p_aMZ), newg_aN0])","Term (!\"if\") (![(!p_aMZ), newg_aN0])","(Term (!\"if\") (![(!p_aMZ), newg_aN0]))","!(Term (!\"if\") (![(!p_aMZ), newg_aN0]))","(!(Term (!\"if\") (![(!p_aMZ), newg_aN0])))","((!(Term (!\"if\") (![(!p_aMZ), newg_aN0]))))","m_aN1","info_aN2","env_aN3","vs_aN4","safebang@!vs_aN4","(!vs_aN4)","Soln env_aN3 (!vs_aN4)","(Soln env_aN3 (!vs_aN4))","!(Soln env_aN3 (!vs_aN4))","(!(Soln env_aN3 (!vs_aN4)))","((!(Soln env_aN3 (!vs_aN4))))","!((!(Soln env_aN3 (!vs_aN4))))","(!((!(Soln env_aN3 (!vs_aN4)))))","g_aN5","ans_aN6","sp_aN7"]
module Search where
import Result
import Table
import Knowledge
import Match
freshCopy (Soln (!env_apw) vs_apx) (!p_apy)
  = ((Soln env_apw (drop n_apB vs_apx)), subst tab_apz p_apy)
  where tab_apz
          = updateList newTable
              (zip xs_apA [Var v_ata | (norecord@v_ata) <- take n_apB vs_apx])
        xs_apA = vars p_apy
        (lazydmd@n_apB) = length xs_apA
solve (!db_az6) (Question q_az7) g_az8 = [Question q_az7]
solve (norecord@db_az9) soln_aza (Term "or" [g1_azb, g2_azc])
  = solve db_az9 soln_aza g1_azb ++ solve db_az9 soln_aza g2_azc
solve (norecord@db_azd) soln_aze
  ((norecord@(Term (norecord@"and") (norecord@[g1_azf, (!g2_azg)]))))
  = concat
      [solve db_azd res_azh g2_azg |
       (norecord@res_azh) <- solve db_azd soln_aze g1_azf]
solve db_azi soln_azj g_azk
  = if not (null rs_azn) then lookUp db_azi soln_azj g_azk rs_azn
      else ask info_azm soln_azj g_azk
  where (defs_azl, info_azm) = db_azi
        (lazydmd@rs_azn) = relevant defs_azl g_azk
lookUp (!db_aMN) (!soln_aMO) (!g_aMP) (!rs_aMQ)
  = concat
      [try db_aMN soln'_aMT g_aMP r'_aMU |
       ((!soln'_aMT), (!r'_aMU)) <- copies_aMR]
  where copies_aMR
          = [freshCopy soln_aMO r_aMS | (norecord@r_aMS) <- rs_aMQ]
try db_aMV (norecord@((norecord@(Soln (!env_aMW) vs_aMX))))
  (!g_aMY)
  ((norecord@(Term (norecord@"if") (norecord@[(!p_aMZ), newg_aN0]))))
  = if fails m_aN1 then [] else
      solve db_aMV (Soln (answer m_aN1) vs_aMX) newg_aN0
  where m_aN1 = match env_aMW g_aMY p_aMZ
ask info_aN2 (norecord@((norecord@(Soln env_aN3 (!vs_aN4))))) g_aN5
  = Question sp_aN7 : if ans_aN6 then [Soln env_aN3 vs_aN4] else []
  where ans_aN6 = answer (find info_aN2 sp_aN7)
        sp_aN7 = showPhrase (subst env_aN3 g_aN5)

data Solution = Soln Environment [String]
              | Question String
STARTLOG
STARTLOG
STARTLOG
["polling","interval","threshold"]
module Interval where
polling = 5 :: Int
interval = 3 :: Int
threshold = 100 :: Int
STARTLOG
["_","a_aCo","z_aCp","safebang@!z_aCp","(!z_aCp)","_","!_","(!_)","K _ a_aCo (!z_aCp) (!_)","(K _ a_aCo (!z_aCp) (!_))","_","a_aCq","safebang@!a_aCq","(!a_aCq)","x_aCr","_","!_","(!_)","K _ (!a_aCq) x_aCr (!_)","(K _ (!a_aCq) x_aCr (!_))","_","b_aCs","safebang@!b_aCs","(!b_aCs)","y_aCt","safebang@!y_aCt","(!y_aCt)","_","K _ (!b_aCs) (!y_aCt) _","(K _ (!b_aCs) (!y_aCt) _)","!(K _ (!b_aCs) (!y_aCt) _)","(!(K _ (!b_aCs) (!y_aCt) _))","((!(K _ (!b_aCs) (!y_aCt) _)))","c_aDs","x_aDt","safebang@!x_aDt","(!x_aDt)","y_aDu","z_aDv","(y_aDu, z_aDv)","!(y_aDu, z_aDv)","(!(y_aDu, z_aDv))","yzs_aDw","safebang@!yzs_aDw","(!yzs_aDw)","(!(y_aDu, z_aDv)) : (!yzs_aDw)","((!(y_aDu, z_aDv)) : (!yzs_aDw))","!((!(y_aDu, z_aDv)) : (!yzs_aDw))","(!((!(y_aDu, z_aDv)) : (!yzs_aDw)))","((!((!(y_aDu, z_aDv)) : (!yzs_aDw))))","x_aDx","[]","x_aDy","y_aDz","safebang@!y_aDz","(!y_aDz)","z_aDA","safebang@!z_aDA","(!z_aDA)","((!y_aDz), (!z_aDA))","yzs_aDB","((!y_aDz), (!z_aDA)) : yzs_aDB","(((!y_aDz), (!z_aDA)) : yzs_aDB)","freqtab","histo","x_aJK","[]","![]","(![])","x_aJL","y_aJN","safebang@!y_aJN","(!y_aJN)","n_aJO","((!y_aJN), n_aJO)","yn_aJM@((!y_aJN), n_aJO)","yns_aJP","yn_aJM@((!y_aJN), n_aJO) : yns_aJP","(yn_aJM@((!y_aJN), n_aJO) : yns_aJP)","!(yn_aJM@((!y_aJN), n_aJO) : yns_aJP)","(!(yn_aJM@((!y_aJN), n_aJO) : yns_aJP))","maxval","xs_aJQ","ys_aJR","safebang@!ys_aJR","(!ys_aJR)","x_aJS","!x_aJS","(!x_aJS)","xs_aJT","ys_aJU","safebang@!ys_aJU","(!ys_aJU)","y_aJV","attribkeys","k_aJW","h_aNn","safebang@!h_aNn","(!h_aNn)","lo_aNo","hi_aNp","!hi_aNp","(!hi_aNp)","hs_aNq","H lo_aNo (!hi_aNp) hs_aNq","(H lo_aNo (!hi_aNp) hs_aNq)","!(H lo_aNo (!hi_aNp) hs_aNq)","(!(H lo_aNo (!hi_aNp) hs_aNq))","((!(H lo_aNo (!hi_aNp) hs_aNq)))","!((!(H lo_aNo (!hi_aNp) hs_aNq)))","(!((!(H lo_aNo (!hi_aNp) hs_aNq))))","lo'_aNr","hi'_aNs","Nothing","y_aNt","safebang@!y_aNt","(!y_aNt)","x_aNu","Just x_aNu","(Just x_aNu)","!(Just x_aNu)","(!(Just x_aNu))","((!(Just x_aNu)))","y_aNv","!y_aNv","(!y_aNv)","Nothing","!Nothing","(!Nothing)","y_aNw","x_aNx","Just x_aNx","(Just x_aNx)","y_aNy","_","!_","(!_)","[]","![]","(![])","x_aNz","!x_aNz","(!x_aNz)","y_aNA","ys_aNB","safebang@!ys_aNB","(!ys_aNB)","y_aNA : (!ys_aNB)","(y_aNA : (!ys_aNB))","!(y_aNA : (!ys_aNB))","(!(y_aNA : (!ys_aNB)))","cvs_aNC","safebang@!cvs_aNC","(!cvs_aNC)","_","a_aND","z_aNE","safebang@!z_aNE","(!z_aNE)","n_aNF","safebang@!n_aNF","(!n_aNF)","K _ a_aND (!z_aNE) (!n_aNF)","(K _ a_aND (!z_aNE) (!n_aNF))","numberofkeys","p_aNG","x_aNI","!x_aNI","(!x_aNI)","ts_aNJ","safebang@!ts_aNJ","(!ts_aNJ)","fs_aNK","((!ts_aNJ), fs_aNK)","freqsorted","x_aNL","blocked","ds_aNM","safebang@!ds_aNM","(!ds_aNM)","[]","![]","(![])","ds_aNN","!ds_aNN","(!ds_aNN)","k_aNO","ks_aNP","k_aNO : ks_aNP","(k_aNO : ks_aNP)","!(k_aNO : ks_aNP)","(!(k_aNO : ks_aNP))","((!(k_aNO : ks_aNP)))","det_aNQ","rest_aNR","safebang@!rest_aNR","(!rest_aNR)","(det_aNQ, (!rest_aNR))","!(det_aNQ, (!rest_aNR))","(!(det_aNQ, (!rest_aNR)))","x_aNT","ds'_aNS"]
module Auxil where
import Key

ends :: Key -> String
ends (K _ a_aCo (!z_aCp) (norecord@_)) = [a_aCo, z_aCp]

morefreq :: Key -> Key -> Bool
morefreq (K _ (!a_aCq) x_aCr (norecord@_))
  ((norecord@(K _ (!b_aCs) (!y_aCt) _)))
  = freq a_aCq + freq x_aCr > freq b_aCs + freq y_aCt

freq :: Char -> Int
freq c_aDs = assoc c_aDs freqtab

assoc :: (Eq a_aCm) => a_aCm -> [(a_aCm, b_aCn)] -> b_aCn
assoc (!x_aDt)
  ((norecord@((norecord@(y_aDu, z_aDv)) : (!yzs_aDw))))
  = if x_aDt == y_aDu then z_aDv else assoc x_aDt yzs_aDw

assocm :: (Eq a_aCk) => a_aCk -> [(a_aCk, b_aCl)] -> Maybe b_aCl
assocm x_aDx [] = Nothing
assocm x_aDy (((!y_aDz), (!z_aDA)) : yzs_aDB)
  = if x_aDy == y_aDz then Just z_aDA else assocm x_aDy yzs_aDB

freqtab :: [(Char, Int)]
freqtab = histo (concat (map ends attribkeys))

histo :: (Eq a_aCj) => [a_aCj] -> [(a_aCj, Int)]
histo = foldr histins_aJJ []
  where histins_aJJ x_aJK (norecord@[]) = [(x_aJK, 1)]
        histins_aJJ x_aJL (norecord@(yn_aJM@((!y_aJN), n_aJO) : yns_aJP))
          = if x_aJL == y_aJN then (y_aJN, n_aJO + 1) : yns_aJP else
              yn_aJM : histins_aJJ x_aJL yns_aJP

maxval :: Int
maxval = length (freqtab)

subset :: (Eq a_aCi) => [a_aCi] -> [a_aCi] -> Bool
subset xs_aJQ (!ys_aJR)
  = all (\ (norecord@x_aJS) -> member x_aJS ys_aJR) xs_aJQ

union :: (Eq a_aCh) => [a_aCh] -> [a_aCh] -> [a_aCh]
union xs_aJT (!ys_aJU)
  = xs_aJT ++ [y_aJV | y_aJV <- ys_aJU, not (member y_aJV xs_aJT)]

attribkeys :: [Key]
attribkeys
  = map
      (\ k_aJW -> (K k_aJW (head k_aJW) (last k_aJW) (length k_aJW)))
      keys

hinsert :: Int -> HashSet -> Maybe HashSet
hinsert (!h_aNn)
  (norecord@((norecord@(H lo_aNo (norecord@hi_aNp) hs_aNq))))
  = if member h_aNn hs_aNq || 1 + hi'_aNs - lo'_aNr > numberofkeys
      then Nothing else
      Just (H (Just lo'_aNr) (Just hi'_aNs) (h_aNn : hs_aNq))
  where lo'_aNr = minm lo_aNo h_aNn
        hi'_aNs = maxm hi_aNp h_aNn

minm, maxm :: Maybe Int -> Int -> Int
minm Nothing (!y_aNt) = y_aNt
minm ((norecord@(Just x_aNu))) (norecord@y_aNv) = min x_aNu y_aNv
maxm (norecord@Nothing) y_aNw = y_aNw
maxm (Just x_aNx) y_aNy = max x_aNx y_aNy

member :: (Eq a_aoO) => a_aoO -> [a_aoO] -> Bool
member (norecord@_) (norecord@[]) = False
member (norecord@x_aNz) (norecord@(y_aNA : (!ys_aNB)))
  = x_aNz == y_aNA || member x_aNz ys_aNB

hash :: HashFun -> Key -> Int
hash (!cvs_aNC) (K _ a_aND (!z_aNE) (!n_aNF))
  = n_aNF + assoc a_aND cvs_aNC + assoc z_aNE cvs_aNC

numberofkeys :: Int
numberofkeys = length keys

partition' :: (a_aoN -> Bool) -> [a_aoN] -> ([a_aoN], [a_aoN])
partition' p_aNG = foldr select_aNH ([], [])
  where select_aNH (norecord@x_aNI) ((!ts_aNJ), fs_aNK)
          | p_aNG x_aNI = (x_aNI : ts_aNJ, fs_aNK)
          | otherwise = (ts_aNJ, x_aNI : fs_aNK)

freqsorted :: [Key] -> [Key]
freqsorted = \ x_aNL -> x_aNL

blocked :: [Key] -> [Key]
blocked = blocked' []
blocked' (!ds_aNM) (norecord@[]) = []
blocked' (norecord@ds_aNN) ((norecord@(k_aNO : ks_aNP)))
  = k_aNO : det_aNQ ++ blocked' ds'_aNS rest_aNR
  where (norecord@(det_aNQ, (!rest_aNR)))
          = partition' (\ x_aNT -> subset (ends x_aNT) ds'_aNS) ks_aNP
        ds'_aNS = union ds_aNN (ends k_aNO)

data Key = K String Char Char Int

data HashSet = H (Maybe Int) (Maybe Int) [Int]

type HashFun = [(Char, Int)]
STARTLOG
STARTLOG
["m_arb","safebang@!m_arb","(!m_arb)","[]","1","!1","(!1)","l_arc","m_ard","!m_ard","(!m_ard)","n_are","ns_arf","n_are : ns_arf","(n_are : ns_arf)","!(n_are : ns_arf)","(!(n_are : ns_arf))","((!(n_are : ns_arf)))","scores_asl","!scores_asl","(!scores_asl)","sumscores_asm","safebang@!sumscores_asm","(!sumscores_asm)","p_asp","!p_asp","(!p_asp)","threshold_ayo","sum_aBH","safebang@!sum_aBH","(!sum_aBH)","p_aBI","safebang@!p_aBI","(!p_aBI)","((!sum_aBH), (!p_aBI))","name_aPa","safebang@!name_aPa","(!name_aPa)","threshold_aPb","safebang@!threshold_aPb","(!threshold_aPb)","((!name_aPa), (!threshold_aPb))","ps_aPc","scores_aPd","safebang@!scores_aPd","(!scores_aPd)","award_aPf","!award_aPf","(!award_aPf)","sum_aPg","perm_aPh","!perm_aPh","(!perm_aPh)","(sum_aPg, (!perm_aPh))","((!award_aPf), (sum_aPg, (!perm_aPh)))","firstaward_aPe@((!award_aPf), (sum_aPg, (!perm_aPh)))","theawards_aPi","!theawards_aPi","(!theawards_aPi)","competitors_aRx","name_aRy","scores_aRz","safebang@!scores_aRz","(!scores_aRz)","(name_aRy, (!scores_aRz))","competitors","main","n_aRA","_","n_aRA : _","(n_aRA : _)"]
module Main (main) where
import QSort
import Data.List ((\\))
import System.Environment
import Control.Monad
perms (!m_arb) [] = []
perms (norecord@1) l_arc = map (: []) l_arc
perms (norecord@m_ard) ((norecord@(n_are : ns_arf)))
  = map ((:) n_are) (perms (m_ard - 1) ns_arf) ++ perms m_ard ns_arf
awards (norecord@scores_asl)
  = award_aso ("Gold", 70) ++ award_aso ("Silver", 60) ++
      award_aso ("Bronze", 50)
  where (!sumscores_asm)
          = map (\ (norecord@p_asp) -> (sum p_asp, p_asp))
              (perms 3 scores_asl)
        atleast_asn threshold_ayo
          = filter (\ ((!sum_aBH), (!p_aBI)) -> sum_aBH >= threshold_ayo)
              sumscores_asm
        award_aso ((!name_aPa), (!threshold_aPb))
          = map (\ ps_aPc -> (name_aPa, ps_aPc))
              (sort (atleast_asn threshold_aPb))
findawards (!scores_aPd)
  | null theawards_aPi = []
  | otherwise = firstaward_aPe : findawards (scores_aPd \\ perm_aPh)
  where firstaward_aPe@((norecord@award_aPf),
                        (sum_aPg, (norecord@perm_aPh)))
          = head theawards_aPi
        (norecord@theawards_aPi) = awards scores_aPd
findallawards competitors_aRx
  = map
      (\ (name_aRy, (!scores_aRz)) -> (name_aRy, findawards scores_aRz))
      competitors_aRx
competitors
  = [("Simon", [35, 27, 40, 19, 34, 21]),
     ("Hans", [23, 19, 45, 17, 10, 5, 8, 14]),
     ("Phil", [1, 18, 35, 20, 21, 19, 34, 8, 16, 21]),
     ("Kevin", [9, 23, 17, 54, 18, 41, 9, 18, 14])]
main
  = do (n_aRA : _) <- getArgs
       replicateM_ (read n_aRA) $ print (findallawards competitors)
STARTLOG
["le_aAx","safebang@!le_aAx","(!le_aAx)","l_aAy","l_aAz","safebang@!l_aAz","(!l_aAz)","le_aAA","[]","![]","(![])","r_aAB","le_aAC","x_aAD","safebang@!x_aAD","(!x_aAD)","[(!x_aAD)]","r_aAE","!r_aAE","(!r_aAE)","le_aAF","!le_aAF","(!le_aAF)","x_aAG","!x_aAG","(!x_aAG)","xs_aAH","(!x_aAG) : xs_aAH","((!x_aAG) : xs_aAH)","!((!x_aAG) : xs_aAH)","(!((!x_aAG) : xs_aAH))","((!((!x_aAG) : xs_aAH)))","!((!((!x_aAG) : xs_aAH)))","(!((!((!x_aAG) : xs_aAH))))","r_aAI","le_aAJ","safebang@!le_aAJ","(!le_aAJ)","x_aAK","safebang@!x_aAK","(!x_aAK)","[]","rlt_aAL","rge_aAM","!rge_aAM","(!rge_aAM)","r_aAN","safebang@!r_aAN","(!r_aAN)","le_aAO","x_aAP","!x_aAP","(!x_aAP)","y_aAQ","ys_aAR","y_aAQ : ys_aAR","(y_aAQ : ys_aAR)","!(y_aAQ : ys_aAR)","(!(y_aAQ : ys_aAR))","rlt_aAS","rge_aAT","r_aAU","!r_aAU","(!r_aAU)","le_aAV","[]","r_aAW","le_aAX","x_aAY","[x_aAY]","r_aAZ","le_aB0","x_aB1","xs_aB2","x_aB1 : xs_aB2","(x_aB1 : xs_aB2)","r_aB3","le_aB4","x_aB5","[]","rle_aB6","!rle_aB6","(!rle_aB6)","rgt_aB7","r_aB8","safebang@!r_aB8","(!r_aB8)","le_aB9","!le_aB9","(!le_aB9)","x_aBa","y_aBb","ys_aBc","y_aBb : ys_aBc","(y_aBb : ys_aBc)","!(y_aBb : ys_aBc)","(!(y_aBb : ys_aBc))","rle_aBd","rgt_aBe","r_aBf"]
module QSort (sortLe, sort) where

sortLe :: (a_aAp -> a_aAp -> Bool) -> [a_aAp] -> [a_aAp]
sortLe (!le_aAx) l_aAy = qsort le_aAx l_aAy []

sort :: (Ord a_amW) => [a_amW] -> [a_amW]
sort (!l_aAz) = qsort (<=) l_aAz []
qsort le_aAA (norecord@[]) r_aAB = r_aAB
qsort le_aAC [(!x_aAD)] (norecord@r_aAE) = x_aAD : r_aAE
qsort (norecord@le_aAF)
  (norecord@((norecord@((norecord@x_aAG) : xs_aAH)))) r_aAI
  = qpart le_aAF x_aAG xs_aAH [] [] r_aAI
qpart (!le_aAJ) (!x_aAK) [] rlt_aAL (norecord@rge_aAM) (!r_aAN)
  = rqsort le_aAJ rlt_aAL (x_aAK : rqsort le_aAJ rge_aAM r_aAN)
qpart le_aAO (norecord@x_aAP) (norecord@(y_aAQ : ys_aAR)) rlt_aAS
  rge_aAT (norecord@r_aAU)
  = if le_aAO x_aAP y_aAQ then
      qpart le_aAO x_aAP ys_aAR rlt_aAS (y_aAQ : rge_aAT) r_aAU else
      qpart le_aAO x_aAP ys_aAR (y_aAQ : rlt_aAS) rge_aAT r_aAU
rqsort le_aAV [] r_aAW = r_aAW
rqsort le_aAX [x_aAY] r_aAZ = x_aAY : r_aAZ
rqsort le_aB0 (x_aB1 : xs_aB2) r_aB3
  = rqpart le_aB0 x_aB1 xs_aB2 [] [] r_aB3
rqpart le_aB4 x_aB5 [] (norecord@rle_aB6) rgt_aB7 (!r_aB8)
  = qsort le_aB4 rle_aB6 (x_aB5 : qsort le_aB4 rgt_aB7 r_aB8)
rqpart (norecord@le_aB9) x_aBa (norecord@(y_aBb : ys_aBc)) rle_aBd
  rgt_aBe r_aBf
  = if le_aB9 y_aBb x_aBa then
      rqpart le_aB9 x_aBa ys_aBc (y_aBb : rle_aBd) rgt_aBe r_aBf else
      rqpart le_aB9 x_aBa ys_aBc rle_aBd (y_aBb : rgt_aBe) r_aBf
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
["x_anK","safebang@!x_anK","(!x_anK)","s_anL","!s_anL","(!s_anL)","m_anM","f_anN","s_anO","safebang@!s_anO","(!s_anO)","s'_anP","a_anQ","(s'_anP, a_anQ)","m_anR","s_anS","s'_anT","ma_anU","(s'_anT, ma_anU)","!(s'_anT, ma_anU)","(!(s'_anT, ma_anU))","f_anV","m_anW","safebang@!m_anW","(!m_anW)","s_anX","s'_anY","a_anZ","!a_anZ","(!a_anZ)","(s'_anY, (!a_anZ))","f_ao0","[]","![]","(![])","f_ao1","a_ao2","as_ao3","safebang@!as_ao3","(!as_ao3)","a_ao2 : (!as_ao3)","(a_ao2 : (!as_ao3))","!(a_ao2 : (!as_ao3))","(!(a_ao2 : (!as_ao3)))","((!(a_ao2 : (!as_ao3))))","b_ao4","!b_ao4","(!b_ao4)","bs_ao5","f_ao6","[]","![]","(![])","f_ao7","!f_ao7","(!f_ao7)","x_ao8","!x_ao8","(!x_ao8)","xs_ao9","!xs_ao9","(!xs_ao9)","(!x_ao8) : (!xs_ao9)","((!x_ao8) : (!xs_ao9))","ys_aoa","!ys_aoa","(!ys_aoa)","y_aob","!y_aob","(!y_aob)","f_aoc","safebang@!f_aoc","(!f_aoc)","a_aod","[]","f_aoe","!f_aoe","(!f_aoe)","a_aof","!a_aof","(!a_aof)","x_aog","!x_aog","(!x_aog)","xs_aoh","(!x_aog) : xs_aoh","((!x_aog) : xs_aoh)","!((!x_aog) : xs_aoh)","(!((!x_aog) : xs_aoh))","((!((!x_aog) : xs_aoh)))","fax_aoi","f_aoj","a_aok","[]","![]","(![])","f_aol","a_aom","x_aon","xs_aoo","!xs_aoo","(!xs_aoo)","x_aon : (!xs_aoo)","(x_aon : (!xs_aoo))","!(x_aon : (!xs_aoo))","(!(x_aon : (!xs_aoo)))","((!(x_aon : (!xs_aoo))))","!((!(x_aon : (!xs_aoo))))","(!((!(x_aon : (!xs_aoo)))))","y_aop","!y_aop","(!y_aop)","c_aoq","t_aor","f_aos","cond_aot","m_aou","safebang@!m_aou","(!m_aou)","v_aov","safebang@!v_aov","(!v_aov)","final_aow","!final_aow","(!final_aow)","answer_aox","((!final_aow), answer_aox)","fetch","s_aoy","f_aoz","safebang@!f_aoz","(!f_aoz)","s_aoA","f_aoB","safebang@!f_aoB","(!f_aoB)","s_aoC","s'_aoD","s_aoE","incr"]
module StateMonad where

retURN :: a_anI -> SM s_anJ a_anI
retURN (!x_anK) = \ (norecord@s_anL) -> (s_anL, x_anK)

bind ::
     SM s_anF a_anG -> (a_anG -> SM s_anF b_anH) -> SM s_anF b_anH
bind m_anM f_anN
  = \ (!s_anO) ->
      let (s'_anP, a_anQ) = m_anM s_anO in f_anN a_anQ s'_anP

join :: SM s_anD (SM s_anD a_anE) -> SM s_anD a_anE
join m_anR
  = \ s_anS ->
      let (norecord@(s'_anT, ma_anU)) = m_anR s_anS in ma_anU s'_anT

mmap :: (a_anA -> b_anB) -> (SM s_anC a_anA -> SM s_anC b_anB)
mmap f_anV (!m_anW)
  = \ s_anX ->
      let (s'_anY, (norecord@a_anZ)) = m_anW s_anX in
        (s'_anY, f_anV a_anZ)

mmapl :: (a_anx -> SM s_any b_anz) -> ([a_anx] -> SM s_any [b_anz])
mmapl f_ao0 (norecord@[]) = retURN []
mmapl f_ao1 ((norecord@(a_ao2 : (!as_ao3))))
  = f_ao1 a_ao2 `bind`
      \ (norecord@b_ao4) ->
        mmapl f_ao1 as_ao3 `bind` \ bs_ao5 -> retURN (b_ao4 : bs_ao5)

mmapr :: (a_anu -> SM s_anv b_anw) -> ([a_anu] -> SM s_anv [b_anw])
mmapr f_ao6 (norecord@[]) = retURN []
mmapr (norecord@f_ao7) ((norecord@x_ao8) : (norecord@xs_ao9))
  = mmapr f_ao7 xs_ao9 `bind`
      \ (norecord@ys_aoa) ->
        f_ao7 x_ao8 `bind` \ (norecord@y_aob) -> retURN (y_aob : ys_aoa)

mfoldl ::
       (a_anr -> b_ans -> SM s_ant a_anr) ->
         a_anr -> [b_ans] -> SM s_ant a_anr
mfoldl (!f_aoc) a_aod [] = retURN a_aod
mfoldl (norecord@f_aoe) (norecord@a_aof)
  ((norecord@((norecord@x_aog) : xs_aoh)))
  = f_aoe a_aof x_aog `bind` \ fax_aoi -> mfoldl f_aoe fax_aoi xs_aoh

mfoldr ::
       (a_ano -> b_anp -> SM s_anq b_anp) ->
         b_anp -> [a_ano] -> SM s_anq b_anp
mfoldr f_aoj a_aok (norecord@[]) = retURN a_aok
mfoldr f_aol a_aom
  (norecord@((norecord@(x_aon : (norecord@xs_aoo)))))
  = mfoldr f_aol a_aom xs_aoo `bind`
      \ (norecord@y_aop) -> f_aol x_aon y_aop

mif ::
    SM s_anm Bool -> SM s_anm a_ann -> SM s_anm a_ann -> SM s_anm a_ann
mif c_aoq t_aor f_aos
  = c_aoq `bind` \ cond_aot -> if cond_aot then t_aor else f_aos

startingWith :: SM s_ank a_anl -> s_ank -> a_anl
startingWith (!m_aou) (!v_aov) = answer_aox
  where ((norecord@final_aow), answer_aox) = m_aou v_aov

fetch :: SM s_anj s_anj
fetch = \ s_aoy -> (s_aoy, s_aoy)

fetchWith :: (s_anh -> a_ani) -> SM s_anh a_ani
fetchWith (!f_aoz) = \ s_aoA -> (s_aoA, f_aoz s_aoA)

update :: (s_ang -> s_ang) -> SM s_ang s_ang
update (!f_aoB) = \ s_aoC -> (f_aoB s_aoC, s_aoC)

set :: s_anf -> SM s_anf s_anf
set s'_aoD = \ s_aoE -> (s'_aoD, s_aoE)

incr :: SM Int Int
incr = update (1 +)

type SM s_an6 a_an7 = s_an6 -> (s_an6, a_an7)
STARTLOG
["main","trim","x_aYL","!x_aYL","(!x_aYL)","xs_aYM","!xs_aYM","(!xs_aYM)","punct_aYK","!punct_aYK","(!punct_aYK)","rs_aYN","prev_aYO","safebang@!prev_aYO","(!prev_aYO)","[]","![]","(![])","rs_aYP","!rs_aYP","(!rs_aYP)","prev_aYQ","!prev_aYQ","(!prev_aYQ)","l_aYR","ls_aYS","l_aYR : ls_aYS","(l_aYR : ls_aYS)","!(l_aYR : ls_aYS)","(!(l_aYR : ls_aYS))","((!(l_aYR : ls_aYS)))","!((!(l_aYR : ls_aYS)))","(!((!(l_aYR : ls_aYS))))","response_aYT","rs'_aYU","!rs'_aYU","(!rs'_aYU)","(response_aYT, (!rs'_aYU))","!(response_aYT, (!rs'_aYU))","(!(response_aYT, (!rs'_aYU)))","st_aYV","l_aYW","!l_aYW","(!l_aYW)","response_aYX","safebang@!response_aYX","(!response_aYX)","kt_aYY","safebang@!kt_aYY","(!kt_aYY)","((!response_aYX), (!kt_aYY))","!((!response_aYX), (!kt_aYY))","(!((!response_aYX), (!kt_aYY)))","e_aZ1","r_aZ2","es_aZ3","safebang@!es_aZ3","(!es_aZ3)","(r_aZ2, (!es_aZ3))","!(r_aZ2, (!es_aZ3))","(!(r_aZ2, (!es_aZ3)))","e_aZ4","!e_aZ4","(!e_aZ4)","es_aZ5","safebang@!es_aZ5","(!es_aZ5)","(!e_aZ4) : (!es_aZ5)","((!e_aZ4) : (!es_aZ5))","rs_aZ6","key_aZ7","a_aZ8","as_aZ9","a_aZ8 : as_aZ9","(a_aZ8 : as_aZ9)","!(a_aZ8 : as_aZ9)","(!(a_aZ8 : as_aZ9))","(key_aZ7, (!(a_aZ8 : as_aZ9)))","!(key_aZ7, (!(a_aZ8 : as_aZ9)))","(!(key_aZ7, (!(a_aZ8 : as_aZ9))))","key_aZa","!key_aZa","(!key_aZa)","l_aZb","[]","xs_aZc","safebang@!xs_aZc","(!xs_aZc)","x_aZd","xs_aZe","x_aZd : xs_aZe","(x_aZd : xs_aZe)","!(x_aZd : xs_aZe)","(!(x_aZd : xs_aZe))","[]","x_aZf","!x_aZf","(!x_aZf)","xs_aZg","(!x_aZf) : xs_aZg","((!x_aZf) : xs_aZg)","!((!x_aZf) : xs_aZg)","(!((!x_aZf) : xs_aZg))","((!((!x_aZf) : xs_aZg)))","y_aZh","ys_aZi","y_aZh : ys_aZi","(y_aZh : ys_aZi)","!(y_aZh : ys_aZi)","(!(y_aZh : ys_aZi))","((!(y_aZh : ys_aZi)))","!((!(y_aZh : ys_aZi)))","(!((!(y_aZh : ys_aZi))))","[]","![]","(![])","xs_aZj","!xs_aZj","(!xs_aZj)","ucase","d_aZG","!d_aZG","(!d_aZG)","d_aZK","xs_aZL","w_aZM","w'_aZO","safebang@!w'_aZO","(!w'_aZO)","m_aZP","safebang@!m_aZP","(!m_aZP)","((!w'_aZO), (!m_aZP))","!((!w'_aZO), (!m_aZP))","(!((!w'_aZO), (!m_aZP)))","uw_aZN","!uw_aZN","(!uw_aZN)","trailingI_aZJ","!trailingI_aZJ","(!trailingI_aZJ)","x_aZR","!x_aZR","(!x_aZR)","xs_aZS","conjugates","x_aZY","y_aZZ","(x_aZY, y_aZZ)","oneways_aZT","bothways_aZU","prepare_aZV","!prepare_aZV","(!prepare_aZV)","w_aZW","r_aZX","(w_aZW, r_aZX)","!(w_aZW, r_aZX)","(!(w_aZW, r_aZX))","kt_a100","!kt_a100","(!kt_a100)","r_a101","safebang@!r_a101","(!r_a101)","rp_a102","safebang@!rp_a102","(!rp_a102)","(!r_a101) : (!rp_a102)","((!r_a101) : (!rp_a102))","((!kt_a100), ((!r_a101) : (!rp_a102)))","!((!kt_a100), ((!r_a101) : (!rp_a102)))","(!((!kt_a100), ((!r_a101) : (!rp_a102))))","kt'_a103","kt_a104","!kt_a104","(!kt_a104)","rp_a105","((!kt_a104), rp_a105)","kt_a106","!kt_a106","(!kt_a106)","rp_a107","((!kt_a106), rp_a107)","'?'","cs_a108","!cs_a108","(!cs_a108)","'?' : (!cs_a108)","('?' : (!cs_a108))","!('?' : (!cs_a108))","(!('?' : (!cs_a108)))","((!('?' : (!cs_a108))))","us_a109","!us_a109","(!us_a109)","'.'","cs_a10a","!cs_a10a","(!cs_a10a)","'.' : (!cs_a10a)","('.' : (!cs_a10a))","us_a10b","cs_a10c","!cs_a10c","(!cs_a10c)","us_a10d","initial","k_a10e","rs_a10f","(k_a10e, rs_a10f)","repeatMsgs","respMsgs","canYou_a10g","canI_a10h","!canI_a10h","(!canI_a10h)","youAre_a10i","!youAre_a10i","(!youAre_a10i)","iDont_a10j","iFeel_a10k","whyDont_a10l","!whyDont_a10l","(!whyDont_a10l)","whyCant_a10m","!whyCant_a10m","(!whyCant_a10m)","areYou_a10n","iCant_a10o","!iCant_a10o","(!iCant_a10o)","iAm_a10p","you_a10q","!you_a10q","(!you_a10q)","yes_a10r","no_a10s","!no_a10s","(!no_a10s)","computer_a10t","iWant_a10u","!iWant_a10u","(!iWant_a10u)","question_a10v","!question_a10v","(!question_a10v)","name_a10w","!name_a10w","(!name_a10w)","because_a10x","sorry_a10y","dream_a10z","hello_a10A","maybe_a10B","your_a10C","always_a10D","think_a10E","!think_a10E","(!think_a10E)","alike_a10F","!alike_a10F","(!alike_a10F)","friend_a10G","!friend_a10G","(!friend_a10G)","nokeyMsgs_a10H"]
module Main (main) where
import Data.Char
import Prelude hiding (Word)
main
  = interact
      (("\nHi! I'm Eliza. I am your personal therapy computer.\nPlease tell me your problem.\n\n" ++)
         . session initial []
         . filter (not . null)
         . map (words . trim)
         . lines)

trim :: String -> String
trim = foldr cons_aYJ "" . dropWhile (`elem` punct_aYK)
  where cons_aYJ (norecord@x_aYL) (norecord@xs_aYM)
          | x_aYL `elem` punct_aYK && null xs_aYM = []
          | otherwise = x_aYL : xs_aYM
        (norecord@punct_aYK) = [' ', '.', '!', '?', ',']

session :: State -> Words -> [Words] -> String
session rs_aYN (!prev_aYO) (norecord@[]) = []
session (norecord@rs_aYP) (norecord@prev_aYQ)
  (norecord@((norecord@(l_aYR : ls_aYS))))
  = response_aYT ++ "\n\n" ++ session rs'_aYU l_aYR ls_aYS
  where (norecord@(response_aYT, (norecord@rs'_aYU)))
          | prev_aYQ == l_aYR = repeated rs_aYP
          | otherwise = answer rs_aYP l_aYR

answer :: State -> Words -> (String, State)
answer st_aYV (norecord@l_aYW)
  = (response_aYX, newKeyTab kt_aYY st_aYV)
  where (norecord@((!response_aYX), (!kt_aYY)))
          = ans_aZ0 (keyTabOf st_aYV)
        cons_aYZ e_aZ1 (norecord@(r_aZ2, (!es_aZ3)))
          = (r_aZ2, e_aZ1 : es_aZ3)
        ans_aZ0 ((norecord@e_aZ4) : (!es_aZ5))
          | null rs_aZ6 = e_aZ4 `cons_aYZ` ans_aZ0 es_aZ5
          | otherwise =
            (makeResponse a_aZ8 (head rs_aZ6), (key_aZ7, as_aZ9) : es_aZ5)
          where rs_aZ6 = replies key_aZ7 l_aYW
                (norecord@(key_aZ7, (norecord@(a_aZ8 : as_aZ9)))) = e_aZ4

replies :: Words -> Words -> [String]
replies (norecord@key_aZa) l_aZb
  = (map (conjug l_aZb . drop (length key_aZa)) .
       filter (prefix key_aZa . map ucase)
       . tails)
      l_aZb

prefix :: Eq a_auT => [a_auT] -> [a_auT] -> Bool
prefix [] (!xs_aZc) = True
prefix (norecord@(x_aZd : xs_aZe)) [] = False
prefix ((norecord@((norecord@x_aZf) : xs_aZg)))
  (norecord@((norecord@(y_aZh : ys_aZi))))
  = x_aZf == y_aZh && (xs_aZg `prefix` ys_aZi)

tails :: [a_auS] -> [[a_auS]]
tails (norecord@[]) = []
tails (norecord@xs_aZj) = xs_aZj : tails (tail xs_aZj)

ucase :: String -> String
ucase = map toUpper

conjug :: Words -> Words -> String
conjug (norecord@d_aZG)
  = unwords . trailingI_aZJ . map conj_aZI . maybe_aZH d_aZG
  where maybe_aZH d_aZK xs_aZL
          = if null xs_aZL then d_aZK else xs_aZL
        conj_aZI w_aZM
          = head
              ([m_aZP | (norecord@((!w'_aZO), (!m_aZP))) <- conjugates,
                uw_aZN == w'_aZO]
                 ++ [w_aZM])
          where (norecord@uw_aZN) = ucase w_aZM
        (norecord@trailingI_aZJ) = foldr cons_aZQ []
          where cons_aZQ (norecord@x_aZR) xs_aZS
                  | x_aZR == "I" && null xs_aZS = ["me"]
                  | otherwise = x_aZR : xs_aZS

conjugates :: [(Word, Word)]
conjugates
  = prepare_aZV
      (oneways_aZT ++
         concat
           [[(x_aZY, y_aZZ), (y_aZZ, x_aZY)] |
            (x_aZY, y_aZZ) <- bothways_aZU])
  where oneways_aZT = [("me", "you")]
        bothways_aZU
          = [("are", "am"), ("we're", "was"), ("you", "I"), ("your", "my"),
             ("I've", "you've"), ("I'm", "you're")]
        (norecord@prepare_aZV)
          = map (\ (norecord@(w_aZW, r_aZX)) -> (ucase w_aZW, r_aZX))

repeated :: State -> (String, State)
repeated (norecord@((norecord@kt_a100), ((!r_a101) : (!rp_a102))))
  = (r_a101, (kt_a100, rp_a102))

newKeyTab :: KeyTable -> State -> State
newKeyTab kt'_a103 ((norecord@kt_a104), rp_a105)
  = (kt'_a103, rp_a105)

keyTabOf :: State -> KeyTable
keyTabOf ((norecord@kt_a106), rp_a107) = kt_a106

makeResponse :: String -> String -> String
makeResponse ((norecord@('?' : (norecord@cs_a108))))
  (norecord@us_a109) = cs_a108 ++ " " ++ us_a109 ++ "?"
makeResponse ('.' : (norecord@cs_a10a)) us_a10b
  = cs_a10a ++ " " ++ us_a10b ++ "."
makeResponse (norecord@cs_a10c) us_a10d = cs_a10c

initial :: State
initial
  = ([(words k_a10e, cycle rs_a10f) | (k_a10e, rs_a10f) <- respMsgs],
     cycle repeatMsgs)
repeatMsgs
  = ["Why did you repeat yourself?",
     "Do you expect a different answer by repeating yourself?",
     "Come, come, elucidate your thoughts.",
     "Please don't repeat yourself!"]
respMsgs
  = [("CAN YOU", canYou_a10g), ("CAN I", canI_a10h),
     ("YOU ARE", youAre_a10i), ("YOU'RE", youAre_a10i),
     ("I DON'T", iDont_a10j), ("I FEEL", iFeel_a10k),
     ("WHY DON'T YOU", whyDont_a10l), ("WHY CAN'T I", whyCant_a10m),
     ("ARE YOU", areYou_a10n), ("I CAN'T", iCant_a10o),
     ("I AM", iAm_a10p), ("I'M", iAm_a10p), ("YOU", you_a10q),
     ("YES", yes_a10r), ("NO", no_a10s), ("COMPUTER", computer_a10t),
     ("COMPUTERS", computer_a10t), ("I WANT", iWant_a10u),
     ("WHAT", question_a10v), ("HOW", question_a10v),
     ("WHO", question_a10v), ("WHERE", question_a10v),
     ("WHEN", question_a10v), ("WHY", question_a10v),
     ("NAME", name_a10w), ("BECAUSE", because_a10x),
     ("CAUSE", because_a10x), ("SORRY", sorry_a10y),
     ("DREAM", dream_a10z), ("DREAMS", dream_a10z), ("HI", hello_a10A),
     ("HELLO", hello_a10A), ("MAYBE", maybe_a10B), ("YOUR", your_a10C),
     ("ALWAYS", always_a10D), ("THINK", think_a10E),
     ("ALIKE", alike_a10F), ("FRIEND", friend_a10G),
     ("FRIENDS", friend_a10G), ("", nokeyMsgs_a10H)]
  where canYou_a10g
          = ["?Don't you believe that I can",
             "?Perhaps you would like to be able to",
             "?You want me to be able to"]
        (norecord@canI_a10h)
          = ["?Perhaps you don't want to", "?Do you want to be able to"]
        (norecord@youAre_a10i)
          = ["?What makes you think I am",
             "?Does it please you to believe I am",
             "?Perhaps you would like to be", "?Do you sometimes wish you were"]
        iDont_a10j
          = ["?Don't you really", "?Why don't you",
             "?Do you wish to be able to", "Does that trouble you?"]
        iFeel_a10k
          = ["Tell me more about such feelings.", "?Do you often feel",
             "?Do you enjoy feeling"]
        (norecord@whyDont_a10l)
          = ["?Do you really believe I don't",
             ".Perhaps in good time I will", "?Do you want me to"]
        (norecord@whyCant_a10m)
          = ["?Do you think you should be able to", "?Why can't you"]
        areYou_a10n
          = ["?Why are you interested in whether or not I am",
             "?Would you prefer if I were not",
             "?Perhaps in your fantasies I am"]
        (norecord@iCant_a10o)
          = ["?How do you know you can't", "Have you tried?",
             "?Perhaps you can now"]
        iAm_a10p
          = ["?Did you come to me because you are",
             "?How long have you been", "?Do you believe it is normal to be",
             "?Do you enjoy being"]
        (norecord@you_a10q)
          = ["We were discussing you --not me.", "?Oh,",
             "You're not really talking about me, are you?"]
        yes_a10r
          = ["You seem quite positive.", "Are you Sure?", "I see.",
             "I understand."]
        (norecord@no_a10s)
          = ["Are you saying no just to be negative?",
             "You are being a bit negative.", "Why not?", "Are you sure?",
             "Why no?"]
        computer_a10t
          = ["Do computers worry you?",
             "Are you talking about me in particular?",
             "Are you frightened by machines?", "Why do you mention computers?",
             "What do you think machines have to do with your problems?",
             "Don't you think computers can help people?",
             "What is it about machines that worries you?"]
        (norecord@iWant_a10u)
          = ["?Why do you want", "?What would it mean to you if you got",
             "?Suppose you got", "?What if you never got",
             ".I sometimes also want"]
        (norecord@question_a10v)
          = ["Why do you ask?", "Does that question interest you?",
             "What answer would please you the most?", "What do you think?",
             "Are such questions on your mind often?",
             "What is it that you really want to know?",
             "Have you asked anyone else?",
             "Have you asked such questions before?",
             "What else comes to mind when you ask that?"]
        (norecord@name_a10w)
          = ["Names don't interest me.",
             "I don't care about names --please go on."]
        because_a10x
          = ["Is that the real reason?",
             "Don't any other reasons come to mind?",
             "Does that reason explain anything else?",
             "What other reasons might there be?"]
        sorry_a10y
          = ["Please don't apologise!", "Apologies are not necessary.",
             "What feelings do you have when you apologise?",
             "Don't be so defensive!"]
        dream_a10z
          = ["What does that dream suggest to you?", "Do you dream often?",
             "What persons appear in your dreams?",
             "Are you disturbed by your dreams?"]
        hello_a10A = ["How do you...please state your problem."]
        maybe_a10B
          = ["You don't seem quite certain.", "Why the uncertain tone?",
             "Can't you be more positive?", "You aren't sure?",
             "Don't you know?"]
        your_a10C
          = ["?Why are you concerned about my", "?What about your own"]
        always_a10D
          = ["Can you think of a specific example?", "When?",
             "What are you thinking of?", "Really, always?"]
        (norecord@think_a10E)
          = ["Do you really think so?", "?But you are not sure you",
             "?Do you doubt you"]
        (norecord@alike_a10F)
          = ["In what way?", "What resemblence do you see?",
             "What does the similarity suggest to you?",
             "What other connections do you see?",
             "Cound there really be some connection?", "How?"]
        (norecord@friend_a10G)
          = ["Why do you bring up the topic of friends?",
             "Do your friends worry you?", "Do your friends pick on you?",
             "Are you sure you have any friends?",
             "Do you impose on your friends?",
             "Perhaps your love for friends worries you."]
        nokeyMsgs_a10H
          = ["I'm not sure I understand you fully.",
             "What does that suggest to you?", "I see.",
             "Can you elaborate on that?",
             "Say, do you have any psychological problems?"]

type Word = String

type Words = [Word]

type Replies = [String]

type Key = Words

type KeyTable = [(Key, Replies)]

type State = (KeyTable, Replies)
STARTLOG
["main","n_ap3","safebang@!n_ap3","(!n_ap3)","_","(!n_ap3) : _","((!n_ap3) : _)","!((!n_ap3) : _)","(!((!n_ap3) : _))","((!((!n_ap3) : _)))","n_atA","xs_atB","p_aD7","!p_aD7","(!p_aD7)","p_aD9","safebang@!p_aD9","(!p_aD9)","q_aDa","safebang@!q_aDa","(!q_aDa)","Dis (!p_aD9) (!q_aDa)","(Dis (!p_aD9) (!q_aDa))","!(Dis (!p_aD9) (!q_aDa))","(!(Dis (!p_aD9) (!q_aDa)))","((!(Dis (!p_aD9) (!q_aDa))))","x_aDb","s_aDc","Sym s_aDc","(Sym s_aDc)","!(Sym s_aDc)","(!(Sym s_aDc))","c_aDd","a_aDe","safebang@!a_aDe","(!a_aDe)","(c_aDd, (!a_aDe))","!(c_aDd, (!a_aDe))","(!(c_aDd, (!a_aDe)))","s_aDf","Sym s_aDf","(Sym s_aDf)","Not (Sym s_aDf)","(Not (Sym s_aDf))","!(Not (Sym s_aDf))","(!(Not (Sym s_aDf)))","((!(Not (Sym s_aDf))))","!((!(Not (Sym s_aDf))))","(!((!(Not (Sym s_aDf)))))","c_aDg","a_aDh","safebang@!a_aDh","(!a_aDh)","(c_aDg, (!a_aDh))","clauses","p_aDi","safebang@!p_aDi","(!p_aDi)","q_aDj","safebang@!q_aDj","(!q_aDj)","Con (!p_aDi) (!q_aDj)","(Con (!p_aDi) (!q_aDj))","!(Con (!p_aDi) (!q_aDj))","(!(Con (!p_aDi) (!q_aDj)))","p_aDk","!p_aDk","(!p_aDk)","p_aDl","safebang@!p_aDl","(!p_aDl)","q_aDm","r_aDn","Con q_aDm r_aDn","(Con q_aDm r_aDn)","!(Con q_aDm r_aDn)","(!(Con q_aDm r_aDn))","((!(Con q_aDm r_aDn)))","Dis (!p_aDl) ((!(Con q_aDm r_aDn)))","(Dis (!p_aDl) ((!(Con q_aDm r_aDn))))","!(Dis (!p_aDl) ((!(Con q_aDm r_aDn))))","(!(Dis (!p_aDl) ((!(Con q_aDm r_aDn)))))","((!(Dis (!p_aDl) ((!(Con q_aDm r_aDn))))))","!((!(Dis (!p_aDl) ((!(Con q_aDm r_aDn))))))","(!((!(Dis (!p_aDl) ((!(Con q_aDm r_aDn)))))))","p_aDo","safebang@!p_aDo","(!p_aDo)","q_aDp","Con (!p_aDo) q_aDp","(Con (!p_aDo) q_aDp)","!(Con (!p_aDo) q_aDp)","(!(Con (!p_aDo) q_aDp))","r_aDq","lazydmd@!r_aDq","(!r_aDq)","Dis (!(Con (!p_aDo) q_aDp)) (!r_aDq)","(Dis (!(Con (!p_aDo) q_aDp)) (!r_aDq))","p_aDr","safebang@!p_aDr","(!p_aDr)","q_aDs","safebang@!q_aDs","(!q_aDs)","Dis (!p_aDr) (!q_aDs)","(Dis (!p_aDr) (!q_aDs))","!(Dis (!p_aDr) (!q_aDs))","(!(Dis (!p_aDr) (!q_aDs)))","((!(Dis (!p_aDr) (!q_aDs))))","!((!(Dis (!p_aDr) (!q_aDs))))","(!((!(Dis (!p_aDr) (!q_aDs)))))","dp_aDt","dq_aDu","!dq_aDu","(!dq_aDu)","p_aQW","safebang@!p_aQW","(!p_aQW)","q_aQX","Con (!p_aQW) q_aQX","(Con (!p_aQW) q_aQX)","p_aQY","!p_aQY","(!p_aQY)","l_aQZ","r_aR0","safebang@!r_aR0","(!r_aR0)","(l_aQZ, (!r_aR0))","s_aR1","safebang@!s_aR1","(!s_aR1)","Sym (!s_aR1)","(Sym (!s_aR1))","p_aR2","safebang@!p_aR2","(!p_aR2)","Not (!p_aR2)","(Not (!p_aR2))","!(Not (!p_aR2))","(!(Not (!p_aR2)))","p_aR3","q_aR4","safebang@!q_aR4","(!q_aR4)","Dis p_aR3 (!q_aR4)","(Dis p_aR3 (!q_aR4))","!(Dis p_aR3 (!q_aR4))","(!(Dis p_aR3 (!q_aR4)))","((!(Dis p_aR3 (!q_aR4))))","p_aR5","safebang@!p_aR5","(!p_aR5)","q_aR6","Con (!p_aR5) q_aR6","(Con (!p_aR5) q_aR6)","!(Con (!p_aR5) q_aR6)","(!(Con (!p_aR5) q_aR6))","((!(Con (!p_aR5) q_aR6)))","!((!(Con (!p_aR5) q_aR6)))","(!((!(Con (!p_aR5) q_aR6))))","p_aR7","q_aR8","safebang@!q_aR8","(!q_aR8)","Imp p_aR7 (!q_aR8)","(Imp p_aR7 (!q_aR8))","!(Imp p_aR7 (!q_aR8))","(!(Imp p_aR7 (!q_aR8)))","((!(Imp p_aR7 (!q_aR8))))","f_aR9","safebang@!f_aR9","(!f_aR9)","f'_aRa","safebang@!f'_aRa","(!f'_aRa)","Eqv (!f_aR9) (!f'_aRa)","(Eqv (!f_aR9) (!f'_aRa))","x_aRb","[]","x_aRc","y_aRe","ys_aRf","y_aRe : ys_aRf","(y_aRe : ys_aRf)","p_aRd@(y_aRe : ys_aRf)","x_aRg","safebang@!x_aRg","(!x_aRg)","xs_aRh","(!x_aRg) : xs_aRh","((!x_aRg) : xs_aRh)","!((!x_aRg) : xs_aRh)","(!((!x_aRg) : xs_aRh))","((!((!x_aRg) : xs_aRh)))","ys_aRi","[]","_","!_","(!_)","p_aRj","Not p_aRj","(Not p_aRj)","!(Not p_aRj)","(!(Not p_aRj))","((!(Not p_aRj)))","Not ((!(Not p_aRj)))","(Not ((!(Not p_aRj))))","!(Not ((!(Not p_aRj))))","(!(Not ((!(Not p_aRj)))))","p_aRk","q_aRl","safebang@!q_aRl","(!q_aRl)","Con p_aRk (!q_aRl)","(Con p_aRk (!q_aRl))","!(Con p_aRk (!q_aRl))","(!(Con p_aRk (!q_aRl)))","Not (!(Con p_aRk (!q_aRl)))","(Not (!(Con p_aRk (!q_aRl))))","!(Not (!(Con p_aRk (!q_aRl))))","(!(Not (!(Con p_aRk (!q_aRl)))))","((!(Not (!(Con p_aRk (!q_aRl))))))","p_aRm","q_aRn","Dis p_aRm q_aRn","(Dis p_aRm q_aRn)","!(Dis p_aRm q_aRn)","(!(Dis p_aRm q_aRn))","((!(Dis p_aRm q_aRn)))","Not ((!(Dis p_aRm q_aRn)))","(Not ((!(Dis p_aRm q_aRn))))","p_aRo","safebang@!p_aRo","(!p_aRo)","q_aRp","safebang@!q_aRp","(!q_aRp)","Dis (!p_aRo) (!q_aRp)","(Dis (!p_aRo) (!q_aRp))","!(Dis (!p_aRo) (!q_aRp))","(!(Dis (!p_aRo) (!q_aRp)))","((!(Dis (!p_aRo) (!q_aRp))))","!((!(Dis (!p_aRo) (!q_aRp))))","(!((!(Dis (!p_aRo) (!q_aRp)))))","p_aRq","safebang@!p_aRq","(!p_aRq)","q_aRr","Con (!p_aRq) q_aRr","(Con (!p_aRq) q_aRr)","!(Con (!p_aRq) q_aRr)","(!(Con (!p_aRq) q_aRr))","p_aRs","!p_aRs","(!p_aRs)","'('","'='","!'='","(!'=')","'>'","'|'","!'|'","(!'|')","'&'","'~'","t_aRt","f_aRu","Ast f_aRu","[Ast f_aRu]","[]","s_aRv","safebang@!s_aRv","(!s_aRv)","' '","t_aRw","!t_aRw","(!t_aRw)","' ' : (!t_aRw)","(' ' : (!t_aRw))","!(' ' : (!t_aRw))","(!(' ' : (!t_aRw)))","s_aRx","!s_aRx","(!s_aRx)","'('","!'('","(!'(')","t_aRy","(!'(') : t_aRy","((!'(') : t_aRy)","!((!'(') : t_aRy)","(!((!'(') : t_aRy))","((!((!'(') : t_aRy)))","s_aRz","!s_aRz","(!s_aRz)","')'","!')'","(!')')","t_aRA","(!')') : t_aRA","((!')') : t_aRA)","!((!')') : t_aRA)","(!((!')') : t_aRA))","((!((!')') : t_aRA)))","!((!((!')') : t_aRA)))","(!((!((!')') : t_aRA))))","s_aRB","!s_aRB","(!s_aRB)","x_aRC","'('","!'('","(!'(')","Lex (!'(')","(Lex (!'('))","!(Lex (!'('))","(!(Lex (!'(')))","s'_aRD","safebang@!s'_aRD","(!s'_aRD)","(!(Lex (!'('))) : (!s'_aRD)","((!(Lex (!'('))) : (!s'_aRD))","!((!(Lex (!'('))) : (!s'_aRD))","(!((!(Lex (!'('))) : (!s'_aRD)))","x_aRC : (!((!(Lex (!'('))) : (!s'_aRD)))","(x_aRC : (!((!(Lex (!'('))) : (!s'_aRD))))","!(x_aRC : (!((!(Lex (!'('))) : (!s'_aRD))))","(!(x_aRC : (!((!(Lex (!'('))) : (!s'_aRD)))))","((!(x_aRC : (!((!(Lex (!'('))) : (!s'_aRD))))))","c_aRE","!c_aRE","(!c_aRE)","t_aRF","(!c_aRE) : t_aRF","((!c_aRE) : t_aRF)","s_aRG","!s_aRG","(!s_aRG)","p_aZM","Ast p_aZM","'='","!'='","(!'=')","Lex (!'=')","q_aZN","Ast q_aZN","s_aZO","lazydmd@!s_aZO","(!s_aZO)","Ast q_aZN : (!s_aZO)","(Ast q_aZN : (!s_aZO))","Lex (!'=') : (Ast q_aZN : (!s_aZO))","(Lex (!'=') : (Ast q_aZN : (!s_aZO)))","!(Lex (!'=') : (Ast q_aZN : (!s_aZO)))","(!(Lex (!'=') : (Ast q_aZN : (!s_aZO))))","Ast p_aZM : (!(Lex (!'=') : (Ast q_aZN : (!s_aZO))))","(Ast p_aZM : (!(Lex (!'=') : (Ast q_aZN : (!s_aZO)))))","!(Ast p_aZM : (!(Lex (!'=') : (Ast q_aZN : (!s_aZO)))))","(!(Ast p_aZM : (!(Lex (!'=') : (Ast q_aZN : (!s_aZO))))))","((!(Ast p_aZM : (!(Lex (!'=') : (Ast q_aZN : (!s_aZO)))))))","p_aZP","safebang@!p_aZP","(!p_aZP)","Ast (!p_aZP)","'>'","Lex '>'","q_aZQ","safebang@!q_aZQ","(!q_aZQ)","Ast (!q_aZQ)","(Ast (!q_aZQ))","!(Ast (!q_aZQ))","(!(Ast (!q_aZQ)))","s_aZR","lazydmd@!s_aZR","(!s_aZR)","(!(Ast (!q_aZQ))) : (!s_aZR)","((!(Ast (!q_aZQ))) : (!s_aZR))","!((!(Ast (!q_aZQ))) : (!s_aZR))","(!((!(Ast (!q_aZQ))) : (!s_aZR)))","Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR)))","(Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR))))","Ast (!p_aZP) : (Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR))))","(Ast (!p_aZP) : (Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR)))))","!(Ast (!p_aZP) : (Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR)))))","(!(Ast (!p_aZP) : (Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR))))))","((!(Ast (!p_aZP) : (Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR)))))))","!((!(Ast (!p_aZP) :\n       (Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR)))))))","(!((!(Ast (!p_aZP) :\n        (Lex '>' : (!((!(Ast (!q_aZQ))) : (!s_aZR))))))))","p_aZS","Ast p_aZS","'|'","!'|'","(!'|')","Lex (!'|')","q_aZT","Ast q_aZT","s_aZU","Ast q_aZT : s_aZU","(Ast q_aZT : s_aZU)","!(Ast q_aZT : s_aZU)","(!(Ast q_aZT : s_aZU))","Lex (!'|') : (!(Ast q_aZT : s_aZU))","(Lex (!'|') : (!(Ast q_aZT : s_aZU)))","!(Lex (!'|') : (!(Ast q_aZT : s_aZU)))","(!(Lex (!'|') : (!(Ast q_aZT : s_aZU))))","Ast p_aZS : (!(Lex (!'|') : (!(Ast q_aZT : s_aZU))))","(Ast p_aZS : (!(Lex (!'|') : (!(Ast q_aZT : s_aZU)))))","!(Ast p_aZS : (!(Lex (!'|') : (!(Ast q_aZT : s_aZU)))))","(!(Ast p_aZS : (!(Lex (!'|') : (!(Ast q_aZT : s_aZU))))))","((!(Ast p_aZS : (!(Lex (!'|') : (!(Ast q_aZT : s_aZU)))))))","p_aZV","Ast p_aZV","'&'","!'&'","(!'&')","Lex (!'&')","q_aZW","Ast q_aZW","(Ast q_aZW)","!(Ast q_aZW)","(!(Ast q_aZW))","s_aZX","(!(Ast q_aZW)) : s_aZX","((!(Ast q_aZW)) : s_aZX)","!((!(Ast q_aZW)) : s_aZX)","(!((!(Ast q_aZW)) : s_aZX))","Lex (!'&') : (!((!(Ast q_aZW)) : s_aZX))","(Lex (!'&') : (!((!(Ast q_aZW)) : s_aZX)))","Ast p_aZV : (Lex (!'&') : (!((!(Ast q_aZW)) : s_aZX)))","(Ast p_aZV : (Lex (!'&') : (!((!(Ast q_aZW)) : s_aZX))))","!(Ast p_aZV : (Lex (!'&') : (!((!(Ast q_aZW)) : s_aZX))))","(!(Ast p_aZV : (Lex (!'&') : (!((!(Ast q_aZW)) : s_aZX)))))","((!(Ast p_aZV : (Lex (!'&') : (!((!(Ast q_aZW)) : s_aZX))))))","p_aZY","safebang@!p_aZY","(!p_aZY)","Ast (!p_aZY)","'~'","Lex '~'","s_aZZ","safebang@!s_aZZ","(!s_aZZ)","Lex '~' : (!s_aZZ)","(Lex '~' : (!s_aZZ))","Ast (!p_aZY) : (Lex '~' : (!s_aZZ))","(Ast (!p_aZY) : (Lex '~' : (!s_aZZ)))","!(Ast (!p_aZY) : (Lex '~' : (!s_aZZ)))","(!(Ast (!p_aZY) : (Lex '~' : (!s_aZZ))))","((!(Ast (!p_aZY) : (Lex '~' : (!s_aZZ)))))","!((!(Ast (!p_aZY) : (Lex '~' : (!s_aZZ)))))","(!((!(Ast (!p_aZY) : (Lex '~' : (!s_aZZ))))))","redstar","spaces","p_a100","!p_a100","(!p_a100)","p_a102","q_a103","safebang@!q_a103","(!q_a103)","Con p_a102 (!q_a103)","(Con p_a102 (!q_a103))","!(Con p_a102 (!q_a103))","(!(Con p_a102 (!q_a103)))","((!(Con p_a102 (!q_a103))))","a_a104","safebang@!a_a104","(!a_a104)","p_a105","a_a106","!a_a106","(!a_a106)","x_a107","Ast x_a107","c_a108","!c_a108","(!c_a108)","Lex (!c_a108)","(Lex (!c_a108))","!(Lex (!c_a108))","(!(Lex (!c_a108)))","s_a109","lazydmd@!s_a109","(!s_a109)","(!(Lex (!c_a108))) : (!s_a109)","((!(Lex (!c_a108))) : (!s_a109))","Ast x_a107 : ((!(Lex (!c_a108))) : (!s_a109))","(Ast x_a107 : ((!(Lex (!c_a108))) : (!s_a109)))","!(Ast x_a107 : ((!(Lex (!c_a108))) : (!s_a109)))","(!(Ast x_a107 : ((!(Lex (!c_a108))) : (!s_a109))))","((!(Ast x_a107 : ((!(Lex (!c_a108))) : (!s_a109)))))","s_a10a","!s_a10a","(!s_a10a)","c_a10b","a_a10c","safebang@!a_a10c","(!a_a10c)","(c_a10b, (!a_a10c))","!(c_a10b, (!a_a10c))","(!(c_a10b, (!a_a10c)))","x_a10d","a_a10e","p_a10g","x_a10h","cp_a10i","p_a10j","safebang@!p_a10j","(!p_a10j)","f_a10k","safebang@!f_a10k","(!f_a10k)","x_a10l","safebang@!x_a10l","(!x_a10l)"]
module Main (main) where
import Data.Ix
import System.Environment
main
  = do ((norecord@((!n_ap3) : _))) <- getArgs
       putStr (res (read n_ap3))
res n_atA = concat (map clauses xs_atB)
  where xs_atB
          = take n_atA (repeat "(a = a = a) = (a = a = a) = (a = a = a)")
        
        {-# NOINLINE xs_atB #-}
clause (norecord@p_aD7) = clause'_aD8 p_aD7 ([], [])
  where clause'_aD8 ((norecord@(Dis (!p_aD9) (!q_aDa)))) x_aDb
          = clause'_aD8 p_aD9 (clause'_aD8 q_aDa x_aDb)
        clause'_aD8 (norecord@(Sym s_aDc)) (norecord@(c_aDd, (!a_aDe)))
          = (insert s_aDc c_aDd, a_aDe)
        clause'_aD8 (norecord@((norecord@(Not (Sym s_aDf)))))
          (c_aDg, (!a_aDh)) = (c_aDg, insert s_aDf a_aDh)
clauses
  = concat . map disp . unicl . split . disin . negin . elim . parse
conjunct (norecord@(Con (!p_aDi) (!q_aDj))) = True
conjunct (norecord@p_aDk) = False
disin
  (norecord@((norecord@(Dis (!p_aDl)
                          ((norecord@(Con q_aDm r_aDn)))))))
  = Con (disin (Dis p_aDl q_aDm)) (disin (Dis p_aDl r_aDn))
disin (Dis (norecord@(Con (!p_aDo) q_aDp)) (lazydmd@r_aDq))
  = Con (disin (Dis p_aDo r_aDq)) (disin (Dis q_aDp r_aDq))
disin (norecord@((norecord@(Dis (!p_aDr) (!q_aDs)))))
  = if conjunct dp_aDt || conjunct dq_aDu then
      disin (Dis dp_aDt dq_aDu) else (Dis dp_aDt dq_aDu)
  where dp_aDt = disin p_aDr
        (norecord@dq_aDu) = disin q_aDs
disin (Con (!p_aQW) q_aQX) = Con (disin p_aQW) (disin q_aQX)
disin (norecord@p_aQY) = p_aQY
disp (l_aQZ, (!r_aR0))
  = interleave l_aQZ spaces ++ "<=" ++ interleave spaces r_aR0 ++
      "\n"
elim (Sym (!s_aR1)) = Sym s_aR1
elim (norecord@(Not (!p_aR2))) = Not (elim p_aR2)
elim ((norecord@(Dis p_aR3 (!q_aR4))))
  = Dis (elim p_aR3) (elim q_aR4)
elim (norecord@((norecord@(Con (!p_aR5) q_aR6))))
  = Con (elim p_aR5) (elim q_aR6)
elim ((norecord@(Imp p_aR7 (!q_aR8))))
  = Dis (Not (elim p_aR7)) (elim q_aR8)
elim (Eqv (!f_aR9) (!f'_aRa))
  = Con (elim (Imp f_aR9 f'_aRa)) (elim (Imp f'_aRa f_aR9))
insert x_aRb [] = [x_aRb]
insert x_aRc p_aRd@(y_aRe : ys_aRf)
  = if x_aRc < y_aRe then x_aRc : p_aRd else
      if x_aRc > y_aRe then y_aRe : insert x_aRc ys_aRf else p_aRd
interleave ((norecord@((!x_aRg) : xs_aRh))) ys_aRi
  = x_aRg : interleave ys_aRi xs_aRh
interleave [] (norecord@_) = []
negin (norecord@(Not ((norecord@(Not p_aRj))))) = negin p_aRj
negin ((norecord@(Not (norecord@(Con p_aRk (!q_aRl))))))
  = Dis (negin (Not p_aRk)) (negin (Not q_aRl))
negin (Not ((norecord@(Dis p_aRm q_aRn))))
  = Con (negin (Not p_aRm)) (negin (Not q_aRn))
negin (norecord@((norecord@(Dis (!p_aRo) (!q_aRp)))))
  = Dis (negin p_aRo) (negin q_aRp)
negin (norecord@(Con (!p_aRq) q_aRr))
  = Con (negin p_aRq) (negin q_aRr)
negin (norecord@p_aRs) = p_aRs
opri '(' = 0
opri (norecord@'=') = 1
opri '>' = 2
opri (norecord@'|') = 3
opri '&' = 4
opri '~' = 5
parse t_aRt = f_aRu
  where [Ast f_aRu] = parse' t_aRt []
parse' [] (!s_aRv) = redstar s_aRv
parse' (norecord@(' ' : (norecord@t_aRw))) (norecord@s_aRx)
  = parse' t_aRw s_aRx
parse' ((norecord@((norecord@'(') : t_aRy))) (norecord@s_aRz)
  = parse' t_aRy (Lex '(' : s_aRz)
parse' (norecord@((norecord@((norecord@')') : t_aRA))))
  (norecord@s_aRB) = parse' t_aRA (x_aRC : s'_aRD)
  where ((norecord@(x_aRC :
                      (norecord@((norecord@(Lex (norecord@'('))) : (!s'_aRD))))))
          = redstar s_aRB
parse' ((norecord@c_aRE) : t_aRF) (norecord@s_aRG)
  = if inRange ('a', 'z') c_aRE then
      parse' t_aRF (Ast (Sym c_aRE) : s_aRG) else
      if spri s_aRG > opri c_aRE then parse' (c_aRE : t_aRF) (red s_aRG)
        else parse' t_aRF (Lex c_aRE : s_aRG)
red
  ((norecord@(Ast p_aZM :
                (norecord@(Lex (norecord@'=') : (Ast q_aZN : (lazydmd@s_aZO)))))))
  = Ast (Eqv q_aZN p_aZM) : s_aZO
red
  (norecord@((norecord@(Ast (!p_aZP) :
                          (Lex '>' :
                             (norecord@((norecord@(Ast (!q_aZQ))) : (lazydmd@s_aZR))))))))
  = Ast (Imp q_aZQ p_aZP) : s_aZR
red
  ((norecord@(Ast p_aZS :
                (norecord@(Lex (norecord@'|') : (norecord@(Ast q_aZT : s_aZU)))))))
  = Ast (Dis q_aZT p_aZS) : s_aZU
red
  ((norecord@(Ast p_aZV :
                (Lex (norecord@'&') :
                   (norecord@((norecord@(Ast q_aZW)) : s_aZX))))))
  = Ast (Con q_aZW p_aZV) : s_aZX
red (norecord@((norecord@(Ast (!p_aZY) : (Lex '~' : (!s_aZZ))))))
  = Ast (Not p_aZY) : s_aZZ
redstar = while ((/=) 0 . spri) red
spaces = repeat ' '
split (norecord@p_a100) = split'_a101 p_a100 []
  where split'_a101 ((norecord@(Con p_a102 (!q_a103)))) (!a_a104)
          = split'_a101 p_a102 (split'_a101 q_a103 a_a104)
        split'_a101 p_a105 (norecord@a_a106) = p_a105 : a_a106
spri
  ((norecord@(Ast x_a107 :
                ((norecord@(Lex (norecord@c_a108))) : (lazydmd@s_a109)))))
  = opri c_a108
spri (norecord@s_a10a) = 0
tautclause (norecord@(c_a10b, (!a_a10c)))
  = [x_a10d | x_a10d <- c_a10b, x_a10d `elem` a_a10c] /= []
unicl a_a10e = foldr unicl'_a10f [] a_a10e
  where unicl'_a10f p_a10g x_a10h
          = if tautclause cp_a10i then x_a10h else insert cp_a10i x_a10h
          where cp_a10i = clause p_a10g
while (!p_a10j) (!f_a10k) (!x_a10l)
  = if p_a10j x_a10l then while p_a10j f_a10k (f_a10k x_a10l) else
      x_a10l

data Formula = Sym Char
             | Not Formula
             | Dis Formula Formula
             | Con Formula Formula
             | Imp Formula Formula
             | Eqv Formula Formula

data StackFrame = Ast Formula
                | Lex Char
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
STARTLOG
["p_aCN","!p_aCN","(!p_aCN)","p_aIM","above","beside","stack","spread","h_aM5","w_aM6","!w_aM6","(!w_aM6)","(h_aM5, (!w_aM6))","n_aM7","safebang@!n_aM7","(!n_aM7)","n_aM8","n_aM9","[]","n_aMa","!n_aMa","(!n_aMa)","xs_aMb","m_aMc","n_aMd","(m_aMc, n_aMd)","!(m_aMc, n_aMd)","(!(m_aMc, n_aMd))","p_aMe","h_aMf","!h_aMf","(!h_aMf)","w_aMg","!w_aMg","(!w_aMg)","year_aNf","safebang@!year_aNf","(!year_aNf)","feb_aNg","!feb_aNg","(!feb_aNg)","year_aNh","monthNames","year_a19P","last_a19Q","!last_a19Q","(!last_a19Q)","year_a19R","fd_a19S","ml_a19T","!ml_a19T","(!ml_a19T)","ml_a19V","!ml_a19V","(!ml_a19V)","d_a19W","!d_a19W","(!d_a19W)","calendar","mn_a1io","yr_a1ip","fd_a1iq","ml_a1ir","(mn_a1io, yr_a1ip, fd_a1iq, ml_a1ir)","mn_a1is","yr_a1it","fd_a1iu","!fd_a1iu","(!fd_a1iu)","ml_a1iv","daynames_a1il","fd_a1iw","!fd_a1iw","(!fd_a1iw)","ml_a1ix","!ml_a1ix","(!ml_a1ix)","year_a1iy","!year_a1iy","(!year_a1iy)","year_a1kM","yr_a1kY","body_a1kO","mn_a1kZ","fd_a1l0","ml_a1l1","(mn_a1kZ, fd_a1l0, ml_a1l1)","p_a1l2","side_a1kR","end_a1kS","mn_a1l3","fd_a1l4","ml_a1l5","daynames_a1kV","fd_a1l6","ml_a1l7","year_a1l8","main","year_a1l9","safebang@!year_a1l9","(!year_a1l9)","n_a1la","_","n_a1la : _","(n_a1la : _)","!(n_a1la : _)","(!(n_a1la : _))","(!year_a1l9) : (!(n_a1la : _))","((!year_a1l9) : (!(n_a1la : _)))","!((!year_a1l9) : (!(n_a1la : _)))","(!((!year_a1l9) : (!(n_a1la : _))))","year_a1lZ","illFormed_a1m0","ds_a1m1","rs_a1m2","(ds_a1m1, rs_a1m2)","yr_a1m3","lazydmd@!yr_a1m3","(!yr_a1m3)","s_a1ms","!s_a1ms","(!s_a1ms)","a_a1mt","!a_a1mt","(!a_a1mt)","d_a1mu","!d_a1mu","(!d_a1mu)","d_a1mv","n_a1DL","x_a1DM","n_a1DN","safebang@!n_a1DN","(!n_a1DN)","s_a1DO","m_a1DP","halfm_a1DQ","n_a1DR","!n_a1DR","(!n_a1DR)","s_a1DS","!s_a1DS","(!s_a1DS)","n_a1DT","!n_a1DT","(!n_a1DT)","s_a1DU","!s_a1DU","(!s_a1DU)","n_a1DV","!n_a1DV","(!n_a1DV)"]
module Main (main) where
import System.IO
import Data.List
import Data.Char
import System.Environment
import Control.Monad

infixr 5 `above`

infixr 5 `beside`

height, width :: Picture -> Int
height (norecord@p_aCN) = length p_aCN
width p_aIM = length (head p_aIM)

above, beside :: Picture -> Picture -> Picture
above = (++)
beside = zipWith (++)

stack, spread :: [Picture] -> Picture
stack = foldr1 above
spread = foldr1 beside

emptyPic :: (Int, Int) -> Picture
emptyPic (h_aM5, (norecord@w_aM6)) = copy h_aM5 (copy w_aM6 ' ')

block, blockT :: Int -> [Picture] -> Picture
block (!n_aM7) = stack . map spread . groop n_aM7
blockT n_aM8 = spread . map stack . groop n_aM8

groop :: Int -> [a_aCM] -> [[a_aCM]]
groop n_aM9 [] = []
groop (norecord@n_aMa) xs_aMb
  = take n_aMa xs_aMb : groop n_aMa (drop n_aMa xs_aMb)

lframe :: (Int, Int) -> Picture -> Picture
lframe (norecord@(m_aMc, n_aMd)) p_aMe
  = (p_aMe `beside` emptyPic (h_aMf, n_aMd - w_aMg)) `above`
      emptyPic (m_aMc - h_aMf, n_aMd)
  where (norecord@h_aMf) = height p_aMe
        (norecord@w_aMg) = width p_aMe
monthLengths (!year_aNf)
  = [31, feb_aNg, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  where (norecord@feb_aNg)
          | leap year_aNf = 29
          | otherwise = 28
leap year_aNh
  = if year_aNh `mod` 100 == 0 then year_aNh `mod` 400 == 0 else
      year_aNh `mod` 4 == 0
monthNames
  = ["January", "February", "March", "April", "May", "June", "July",
     "August", "September", "October", "November", "December"]
jan1st year_a19P
  = (year_a19P + last_a19Q `div` 4 - last_a19Q `div` 100 + last_a19Q
       `div` 400)
      `mod` 7
  where (norecord@last_a19Q) = year_a19P - 1
firstDays year_a19R
  = take 12
      (map (`mod` 7)
         (scanl (+) (jan1st year_a19R) (monthLengths year_a19R)))
dates fd_a19S (norecord@ml_a19T)
  = map (date_a19U ml_a19T) [1 - fd_a19S .. 42 - fd_a19S]
  where date_a19U (norecord@ml_a19V) (norecord@d_a19W)
          | d_a19W < 1 || ml_a19V < d_a19W = ["   "]
          | otherwise = [rjustify 3 (show d_a19W)]

calendar :: Int -> String
calendar = unlines . block 3 . map picture_a1ii . months_a1in
  where picture_a1ii (mn_a1io, yr_a1ip, fd_a1iq, ml_a1ir)
          = title_a1ij mn_a1io yr_a1ip `above` table_a1ik fd_a1iq ml_a1ir
        title_a1ij mn_a1is yr_a1it
          = lframe (2, 25) [mn_a1is ++ " " ++ show yr_a1it]
        table_a1ik (norecord@fd_a1iu) ml_a1iv
          = lframe (8, 25)
              (daynames_a1il `beside` entries_a1im fd_a1iu ml_a1iv)
        daynames_a1il = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
        entries_a1im (norecord@fd_a1iw) (norecord@ml_a1ix)
          = blockT 7 (dates fd_a1iw ml_a1ix)
        months_a1in (norecord@year_a1iy)
          = zip4 monthNames (copy 12 year_a1iy) (firstDays year_a1iy)
              (monthLengths year_a1iy)
cal year_a1kM
  = unlines (banner_a1kN year_a1kM `above` body_a1kO year_a1kM)
  where banner_a1kN yr_a1kY
          = [cjustify 75 (show yr_a1kY)] `above` emptyPic (1, 75)
        body_a1kO = block 3 . map (pad_a1kQ . pic_a1kP) . months_a1kX
        pic_a1kP (mn_a1kZ, fd_a1l0, ml_a1l1)
          = title_a1kT mn_a1kZ `above` table_a1kU fd_a1l0 ml_a1l1
        pad_a1kQ p_a1l2
          = (side_a1kR `beside` p_a1l2 `beside` side_a1kR) `above` end_a1kS
        side_a1kR = emptyPic (8, 2)
        end_a1kS = emptyPic (1, 25)
        title_a1kT mn_a1l3 = [cjustify 21 mn_a1l3]
        table_a1kU fd_a1l4 ml_a1l5
          = daynames_a1kV `above` entries_a1kW fd_a1l4 ml_a1l5
        daynames_a1kV = [" Su Mo Tu We Th Fr Sa"]
        entries_a1kW fd_a1l6 ml_a1l7 = block 7 (dates fd_a1l6 ml_a1l7)
        months_a1kX year_a1l8
          = zip3 monthNames (firstDays year_a1l8) (monthLengths year_a1l8)
main
  = do (norecord@((!year_a1l9) : (norecord@(n_a1la : _)))) <- getArgs
       replicateM_ (read n_a1la) (calFor year_a1l9)
calFor year_a1lZ
  | illFormed_a1m0 = ioError (userError "Bad argument")
  | otherwise = print (length (cal yr_a1m3))
  where illFormed_a1m0 = null ds_a1m1 || not (null rs_a1m2)
        (ds_a1m1, rs_a1m2) = span isDigit year_a1lZ
        (lazydmd@yr_a1m3) = atoi_a1m4 ds_a1m1
        atoi_a1m4 (norecord@s_a1ms)
          = foldl
              (\ (norecord@a_a1mt) (norecord@d_a1mu) -> 10 * a_a1mt + d_a1mu)
              0
              (map toDigit_a1m5 s_a1ms)
        toDigit_a1m5 d_a1mv = fromEnum d_a1mv - fromEnum '0'

copy :: Int -> a_aCL -> [a_aCL]
copy n_a1DL x_a1DM = take n_a1DL (repeat x_a1DM)

cjustify, ljustify, rjustify :: Int -> String -> String
cjustify (!n_a1DN) s_a1DO
  = space halfm_a1DQ ++ s_a1DO ++ space (m_a1DP - halfm_a1DQ)
  where m_a1DP = n_a1DN - length s_a1DO
        halfm_a1DQ = m_a1DP `div` 2
ljustify (norecord@n_a1DR) (norecord@s_a1DS)
  = s_a1DS ++ space (n_a1DR - length s_a1DS)
rjustify (norecord@n_a1DT) (norecord@s_a1DU)
  = space (n_a1DT - length s_a1DU) ++ s_a1DU

space :: Int -> String
space (norecord@n_a1DV) = copy n_a1DV ' '

type Picture = [[Char]]
STARTLOG
STARTLOG
["x1_anB","safebang@!x1_anB","(!x1_anB)","y1_anC","safebang@!y1_anC","(!y1_anC)","((!x1_anB), (!y1_anC))","x2_anD","safebang@!x2_anD","(!x2_anD)","y2_anE","safebang@!y2_anE","(!y2_anE)","((!x2_anD), (!y2_anE))","!((!x2_anD), (!y2_anE))","(!((!x2_anD), (!y2_anE)))","x1_aoD","y1_aoE","!y1_aoE","(!y1_aoE)","(x1_aoD, (!y1_aoE))","!(x1_aoD, (!y1_aoE))","(!(x1_aoD, (!y1_aoE)))","x2_aoF","y2_aoG","safebang@!y2_aoG","(!y2_aoG)","(x2_aoF, (!y2_aoG))","x_aoH","safebang@!x_aoH","(!x_aoH)","y_aoI","safebang@!y_aoI","(!y_aoI)","((!x_aoH), (!y_aoI))","!((!x_aoH), (!y_aoI))","(!((!x_aoH), (!y_aoI)))","a_aoJ","b_aoK","p_tile","q_tile","r_tile","s_tile","a_axU","b_axV","c_axW","m_axX","n_axY","!n_axY","(!n_axY)","segments_axZ","safebang@!segments_axZ","(!segments_axZ)","a_ay0","b_ay1","c_ay2","x0_ay3","safebang@!x0_ay3","(!x0_ay3)","y0_ay4","safebang@!y0_ay4","(!y0_ay4)","x1_ay5","safebang@!x1_ay5","(!x1_ay5)","y1_ay6","((!x0_ay3), (!y0_ay4), (!x1_ay5), y1_ay6)","!((!x0_ay3), (!y0_ay4), (!x1_ay5), y1_ay6)","(!((!x0_ay3), (!y0_ay4), (!x1_ay5), y1_ay6))","p_ay7","a_ay8","safebang@!a_ay8","(!a_ay8)","b_ay9","c_aya","safebang@!c_aya","(!c_aya)","m_ayb","n_ayc","p_ayd","q_aye","a_ayf","b_ayg","c_ayh","!c_ayh","(!c_ayh)","m_ayi","!m_ayi","(!m_ayi)","n_ayj","p_ayk","q_ayl","a_aym","!a_aym","(!a_aym)","b_ayn","!b_ayn","(!b_ayn)","c_ayo","a_ayp","!a_ayp","(!a_ayp)","b_ayq","((!a_ayp), b_ayq)","!((!a_ayp), b_ayq)","(!((!a_ayp), b_ayq))","c_ayr","!c_ayr","(!c_ayr)","d_ays","!d_ays","(!d_ays)","((!c_ayr), (!d_ays))","tile_to_grid","p","q","r","s","a_ayt","safebang@!a_ayt","(!a_ayt)","b_ayu","safebang@!b_ayu","(!b_ayu)","c_ayv","d_ayw","safebang@!d_ayw","(!d_ayw)","t","p1_ayx","u","side1","side2","corner1","corner2","pseudocorner","pseudolimit","p1_ayy","!p1_ayy","(!p1_ayy)","p2_ayz","p3_ayA","!p3_ayA","(!p3_ayA)","p4_ayB","p5_ayC","p6_ayD","p7_ayE","p8_ayF","p9_ayG","!p9_ayG","(!p9_ayG)","corner","squarelimit","[]","![]","(![])","x_ayH","xs_ayI","x_ayH : xs_ayI","(x_ayH : xs_ayI)","[]","s_ayK","x_aH9","xs_aHa","safebang@!xs_aHa","(!xs_aHa)","x_aH9 : (!xs_aHa)","(x_aH9 : (!xs_aHa))","!(x_aH9 : (!xs_aHa))","(!(x_aH9 : (!xs_aHa)))","((!(x_aH9 : (!xs_aHa))))","s_aHb","!s_aHb","(!s_aHb)","main"]
module Main (main) where

vec_add :: Vec -> Vec -> Vec
vec_add ((!x1_anB), (!y1_anC)) (norecord@((!x2_anD), (!y2_anE)))
  = (x1_anB + x2_anD, y1_anC + y2_anE)

vec_sub :: Vec -> Vec -> Vec
vec_sub (norecord@(x1_aoD, (norecord@y1_aoE))) (x2_aoF, (!y2_aoG))
  = (x1_aoD - x2_aoF, y1_aoE - y2_aoG)

scale_vec2 :: Vec -> Int -> Int -> Vec
scale_vec2 (norecord@((!x_aoH), (!y_aoI))) a_aoJ b_aoK
  = ((x_aoH * a_aoJ) `div` b_aoK, (y_aoI * a_aoJ) `div` b_aoK)

p_tile :: [(Int, Int, Int, Int)]

q_tile :: [(Int, Int, Int, Int)]

r_tile :: [(Int, Int, Int, Int)]

s_tile :: [(Int, Int, Int, Int)]
p_tile
  = [(0, 3, 3, 4), (3, 4, 0, 8), (0, 8, 0, 3), (6, 0, 4, 4),
     (4, 5, 4, 10), (4, 10, 7, 6), (7, 6, 4, 5), (11, 0, 10, 4),
     (10, 4, 9, 6), (9, 6, 8, 8), (8, 8, 4, 13), (4, 13, 0, 16),
     (0, 16, 6, 15), (6, 15, 8, 16), (8, 16, 12, 12), (12, 12, 16, 12),
     (10, 16, 12, 14), (12, 14, 16, 13), (12, 16, 13, 15),
     (13, 15, 16, 14), (14, 16, 16, 15), (8, 12, 16, 10), (8, 8, 12, 9),
     (12, 9, 16, 8), (9, 6, 12, 7), (12, 7, 16, 6), (10, 4, 13, 5),
     (13, 5, 16, 4), (11, 0, 14, 2), (14, 2, 16, 2)]
q_tile
  = [(0, 8, 4, 7), (4, 7, 6, 7), (6, 7, 8, 8), (8, 8, 12, 10),
     (12, 10, 16, 16), (0, 12, 3, 13), (3, 13, 5, 14), (5, 14, 7, 15),
     (7, 15, 8, 16), (2, 16, 3, 13), (4, 16, 5, 14), (6, 16, 7, 15),
     (0, 10, 7, 11), (9, 13, 8, 15), (8, 15, 11, 15), (11, 15, 9, 13),
     (10, 10, 8, 12), (8, 12, 12, 12), (12, 12, 10, 10), (2, 0, 4, 5),
     (4, 5, 4, 7), (4, 0, 6, 5), (6, 5, 6, 7), (6, 0, 8, 5),
     (8, 5, 8, 8), (10, 0, 14, 11), (12, 0, 13, 4), (13, 4, 16, 8),
     (16, 8, 15, 10), (15, 10, 16, 16), (13, 0, 16, 6), (14, 0, 16, 4),
     (15, 0, 16, 2), (0, 0, 8, 0), (12, 0, 16, 0), (0, 0, 0, 8),
     (0, 12, 0, 16)]
r_tile
  = [(0, 0, 8, 8), (12, 12, 16, 16), (0, 4, 5, 10), (0, 8, 2, 12),
     (0, 12, 1, 14), (16, 6, 11, 10), (11, 10, 6, 16), (16, 4, 14, 6),
     (14, 6, 8, 8), (8, 8, 5, 10), (5, 10, 2, 12), (2, 12, 0, 16),
     (16, 8, 12, 12), (12, 12, 11, 16), (1, 1, 4, 0), (2, 2, 8, 0),
     (3, 3, 8, 2), (8, 2, 12, 0), (5, 5, 12, 3), (12, 3, 16, 0),
     (11, 16, 12, 12), (12, 12, 16, 8), (13, 13, 16, 10),
     (14, 14, 16, 12), (15, 15, 16, 14)]
s_tile
  = [(0, 0, 4, 2), (4, 2, 8, 2), (8, 2, 16, 0), (0, 4, 2, 1),
     (0, 6, 7, 4), (0, 8, 8, 6), (0, 10, 7, 8), (0, 12, 7, 10),
     (0, 14, 7, 13), (13, 13, 16, 14), (14, 11, 16, 12),
     (15, 9, 16, 10), (16, 0, 10, 4), (10, 4, 8, 6), (8, 6, 7, 8),
     (7, 8, 7, 13), (7, 13, 8, 16), (12, 16, 13, 13), (13, 13, 14, 11),
     (14, 11, 15, 9), (15, 9, 16, 8), (10, 16, 11, 10), (12, 4, 10, 6),
     (10, 6, 12, 7), (12, 7, 12, 4), (15, 5, 13, 7), (13, 7, 15, 8),
     (15, 8, 15, 5)]
nil a_axU b_axV c_axW = []

grid ::
     Int -> Int -> [Line_segment] -> Vec -> Vec -> Vec -> [Line_segment]
grid m_axX (norecord@n_axY) (!segments_axZ) a_ay0 b_ay1 c_ay2
  = [tup2
       (a_ay0 `vec_add` (scale_vec2 b_ay1 x0_ay3 m_axX) `vec_add`
          (scale_vec2 c_ay2 y0_ay4 n_axY))
       (a_ay0 `vec_add` (scale_vec2 b_ay1 x1_ay5 m_axX) `vec_add`
          (scale_vec2 c_ay2 y1_ay6 n_axY))
     |
     (norecord@((!x0_ay3), (!y0_ay4), (!x1_ay5),
                y1_ay6)) <- segments_axZ]
rot p_ay7 (!a_ay8) b_ay9 (!c_aya)
  = p_ay7 (a_ay8 `vec_add` b_ay9) c_aya ((0, 0) `vec_sub` b_ay9)
beside m_ayb n_ayc p_ayd q_aye a_ayf b_ayg (norecord@c_ayh)
  = p_ayd a_ayf (scale_vec2 b_ayg m_ayb (m_ayb + n_ayc)) c_ayh ++
      q_aye (a_ayf `vec_add` (scale_vec2 b_ayg m_ayb (m_ayb + n_ayc)))
        (scale_vec2 b_ayg n_ayc (n_ayc + m_ayb))
        c_ayh
above (norecord@m_ayi) n_ayj p_ayk q_ayl (norecord@a_aym)
  (norecord@b_ayn) c_ayo
  = p_ayk (a_aym `vec_add` (scale_vec2 c_ayo n_ayj (m_ayi + n_ayj)))
      b_ayn
      (scale_vec2 c_ayo m_ayi (n_ayj + m_ayi))
      ++ q_ayl a_aym b_ayn (scale_vec2 c_ayo n_ayj (m_ayi + n_ayj))

tup2 ::
     (a_anx, b_any) -> (c_anz, d_anA) -> (a_anx, b_any, c_anz, d_anA)
tup2 (norecord@((norecord@a_ayp), b_ayq))
  ((norecord@c_ayr), (norecord@d_ays)) = (a_ayp, b_ayq, c_ayr, d_ays)
tile_to_grid = grid 16 16
p = tile_to_grid p_tile
q = tile_to_grid q_tile
r = tile_to_grid r_tile
s = tile_to_grid s_tile
quartet (!a_ayt) (!b_ayu) c_ayv (!d_ayw)
  = above 1 1 (beside 1 1 a_ayt b_ayu) (beside 1 1 c_ayv d_ayw)
t = quartet p q r s
cycle' p1_ayx
  = quartet p1_ayx (rot (rot (rot p1_ayx))) (rot p1_ayx)
      (rot (rot p1_ayx))
u = cycle' (rot q)
side1 = quartet nil nil (rot t) t
side2 = quartet side1 side1 (rot t) t
corner1 = quartet nil nil nil u
corner2 = quartet corner1 side1 (rot side1) u
pseudocorner = quartet corner2 side2 (rot side2) (rot t)
pseudolimit = cycle' pseudocorner
nonet (norecord@p1_ayy) p2_ayz (norecord@p3_ayA) p4_ayB p5_ayC
  p6_ayD p7_ayE p8_ayF (norecord@p9_ayG)
  = above 1 2 (beside 1 2 p1_ayy (beside 1 1 p2_ayz p3_ayA))
      (above 1 1 (beside 1 2 p4_ayB (beside 1 1 p5_ayC p6_ayD))
         (beside 1 2 p7_ayE (beside 1 1 p8_ayF p9_ayG)))
corner
  = nonet corner2 side2 side2 (rot side2) u (rot t) (rot side2)
      (rot t)
      (rot q)
squarelimit = cycle' corner
fmt (norecord@[]) = "[]"
fmt (x_ayH : xs_ayI)
  = (showString "[\n" . showsPrec 0 x_ayH . showl_ayJ xs_ayI) ""
  where showl_ayJ [] s_ayK = showChar ']' s_ayK
        showl_ayJ ((norecord@(x_aH9 : (!xs_aHa)))) (norecord@s_aHb)
          = (showString ",\n" . showsPrec 0 x_aH9 . showl_ayJ xs_aHa) s_aHb
main = putStrLn (fmt (pseudolimit (0, 0) (640, 0) (0, 640)))

type Vec = (Int, Int)

type Line_segment = (Int, Int, Int, Int)

type Picture = Vec -> Vec -> Vec -> [Line_segment]
STARTLOG
["start","n_ana","board_anb","last_anc","safebang@!last_anc","(!last_anc)","this_and","safebang@!this_and","(!this_and)","next_ane","safebang@!next_ane","(!next_ane)","((!last_anc), (!this_and), (!next_ane))","!((!last_anc), (!this_and), (!next_ane))","(!((!last_anc), (!this_and), (!next_ane)))","a_aqQ","b_aqR","c_aqS","(a_aqQ, b_aqR, c_aqS)","d_aqT","e_aqU","f_aqV","(d_aqT, e_aqU, f_aqV)","g_aqW","h_aqX","i_aqY","safebang@!i_aqY","(!i_aqY)","(g_aqW, h_aqX, (!i_aqY))","tot_aqZ","x_aFq","xs_aFr","x_aFs","xs_aFt","x_aFu","!x_aFu","(!x_aFu)","xs_aFv","0","!0","(!0)","x_aFw","safebang@!x_aFw","(!x_aFw)","n_aFx","x_aFy","!x_aFy","(!x_aFy)","gen_aFz","!gen_aFz","(!gen_aFz)","xss_aFA","!xss_aFA","(!xss_aFA)","((!gen_aFz), (!xss_aFA))","0","1","s_aLx","!s_aLx","(!s_aLx)","xs_aLy","ys_aLz","!ys_aLz","(!ys_aLz)","x_aLA","safebang@!x_aLA","(!x_aLA)","y_aLB","xs_aLC","y_aLB : xs_aLC","(y_aLB : xs_aLC)","!(y_aLB : xs_aLC)","(!(y_aLB : xs_aLC))","(!x_aLA) : (!(y_aLB : xs_aLC))","((!x_aLA) : (!(y_aLB : xs_aLC)))","!((!x_aLA) : (!(y_aLB : xs_aLC)))","(!((!x_aLA) : (!(y_aLB : xs_aLC))))","((!((!x_aLA) : (!(y_aLB : xs_aLC)))))","main","sz_aLD","generations_aLE","lazydmd@!generations_aLE","(!generations_aLE)"]
module Main (main) where

start :: [[Int]]
start
  = [[], [], [], [], [], [], [], [], [], [], [], [], [], [],
     [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1,
      1, 1, 1, 1, 0]]
gen n_ana board_anb = map row (shift (copy n_ana 0) board_anb)
row (norecord@((!last_anc), (!this_and), (!next_ane)))
  = zipWith3 elt (shift 0 last_anc) (shift 0 this_and)
      (shift 0 next_ane)
elt (a_aqQ, b_aqR, c_aqS) (d_aqT, e_aqU, f_aqV)
  (g_aqW, h_aqX, (!i_aqY))
  | tot_aqZ < 2 || tot_aqZ > 3 = 0
  | tot_aqZ == 3 = 1
  | otherwise = e_aqU
  where tot_aqZ
          = a_aqQ + b_aqR + c_aqS + d_aqT + f_aqV + g_aqW + h_aqX + i_aqY
shiftr x_aFq xs_aFr = [x_aFq] ++ init xs_aFr
shiftl x_aFs xs_aFt = tail xs_aFt ++ [x_aFs]
shift (norecord@x_aFu) xs_aFv
  = zip3 (shiftr x_aFu xs_aFv) xs_aFv (shiftl x_aFu xs_aFv)
copy (norecord@0) (!x_aFw) = []
copy n_aFx (norecord@x_aFy) = x_aFy : copy (n_aFx - 1) x_aFy
disp ((norecord@gen_aFz), (norecord@xss_aFA))
  = gen_aFz ++ "\n\n" ++
      (foldr (glue "\n") "" . map (concat . map star)) xss_aFA
star 0 = "  "
star 1 = " o"
glue (norecord@s_aLx) xs_aLy (norecord@ys_aLz)
  = xs_aLy ++ s_aLx ++ ys_aLz
limit ((norecord@((!x_aLA) : (norecord@(y_aLB : xs_aLC)))))
  | x_aLA == y_aLB = [x_aLA]
  | otherwise = x_aLA : limit (y_aLB : xs_aLC)
main = putStr (last generations_aLE)
  where sz_aLD = 30
        (lazydmd@generations_aLE)
          = (map disp . zip (map show [0 ..]) . limit . iterate (gen sz_aLD))
              (take sz_aLD
                 (map (take sz_aLD . (++ (copy sz_aLD 0))) start ++
                    copy sz_aLD (copy sz_aLD 0)))
STARTLOG
["main","stuff_azo","say","join_azp","xs_aFt","safebang@!xs_aFt","(!xs_aFt)","ys_aFu","c_aHS","!c_aHS","(!c_aHS)","c'_a179","safebang@!c'_a179","(!c'_a179)","letter_a17a","((!c'_a179), letter_a17a)","!((!c'_a179), letter_a17a)","(!((!c'_a179), letter_a17a))","blank","slant","nothing","punct","digits","alphas"]
module Main (main) where
import Data.Char
import Data.List
main
  = do stuff_azo <- getContents
       putStr (say stuff_azo)
say = ('\n' :) . unlines . map join_azp . transpose . map picChar
  where join_azp
          = foldr1 (\ (!xs_aFt) ys_aFu -> xs_aFt ++ "  " ++ ys_aFu)
picChar (norecord@c_aHS)
  | isUpper c_aHS = alphas !! (fromEnum c_aHS - fromEnum 'A')
  | isLower c_aHS = alphas !! (fromEnum c_aHS - fromEnum 'a')
  | isSpace c_aHS = blank
  | isDigit c_aHS = digits !! (fromEnum c_aHS - fromEnum '0')
  | c_aHS == '/' = slant
  | c_aHS == '\\' = reverse slant
  | otherwise =
    head
      ([letter_a17a | (norecord@((!c'_a179), letter_a17a)) <- punct,
        c'_a179 == c_aHS]
         ++ [nothing])
blank = ["     ", "     ", "     ", "     ", "     "]
slant = ["    ", "   ", "  ", " ", ""]
nothing = repeat ""
punct
  = [('.', ["     ", "     ", "     ", "  .. ", "  .. "]),
     ('?', [" ??? ", "?   ?", "   ? ", "  ?  ", "  .  "]),
     ('!', ["  !  ", "  !  ", "  !  ", "  !  ", "  .  "]),
     ('-', ["     ", "     ", "-----", "     ", "     "]),
     ('+', ["  +  ", "  +  ", "+++++", "  +  ", "  +  "]),
     (':', ["     ", "  :: ", "     ", "  :: ", "     "]),
     (';', ["     ", "  ;; ", "     ", "  ;; ", " ;;  "])]
digits
  = [[" OOO ", "0  00", "0 0 0", "00  0", " 000 "],
     ["  1  ", " 11  ", "  1  ", "  1  ", "11111"],
     [" 222 ", "2   2", "   2 ", "  2  ", "22222"],
     ["3333 ", "    3", " 333 ", "    3", "3333 "],
     ["   4 ", "  44 ", " 4 4 ", "44444", "   4 "],
     ["55555", "5    ", "5555 ", "    5", "5555 "],
     ["   66", "  6  ", " 666 ", "6   6", " 666 "],
     ["77777", "    7", "   7 ", "   7 ", "  7  "],
     [" 888 ", "8   8", " 888 ", "8   8", " 888 "],
     [" 999 ", "9   9", " 999 ", "  9  ", "99   "]]
alphas
  = [["  A  ", " A A ", "AAAAA", "A   A", "A   A"],
     ["BBBB ", "B   B", "BBBB ", "B   B", "BBBB "],
     [" CCCC", "C    ", "C    ", "C    ", " CCCC"],
     ["DDDD ", "D   D", "D   D", "D   D", "DDDD "],
     ["EEEEE", "E    ", "EEEEE", "E    ", "EEEEE"],
     ["FFFFF", "F    ", "FFFF ", "F    ", "F    "],
     [" GGGG", "G    ", "G  GG", "G   G", " GGG "],
     ["H   H", "H   H", "HHHHH", "H   H", "H   H"],
     ["IIIII", "  I  ", "  I  ", "  I  ", "IIIII"],
     ["JJJJJ", "   J ", "   J ", "J  J ", " JJ  "],
     ["K   K", "K  K ", "KKK  ", "K  K ", "K   K"],
     ["L    ", "L    ", "L    ", "L    ", "LLLLL"],
     ["M   M", "MM MM", "M M M", "M   M", "M   M"],
     ["N   N", "NN  N", "N N N", "N  NN", "N   N"],
     [" OOO ", "O   O", "O   O", "O   O", " OOO "],
     ["PPPP ", "P   P", "PPPP ", "P    ", "P    "],
     [" QQQ ", "Q   Q", "Q Q Q", "Q  Q ", " QQ Q"],
     ["RRRR ", "R   R", "RRRR ", "R  R ", "R   R"],
     [" SSSS", "S    ", " SSS ", "    S", "SSSS "],
     ["TTTTT", "  T  ", "  T  ", "  T  ", "  T  "],
     ["U   U", "U   U", "U   U", "U   U", " UUU "],
     ["V   V", "V   V", "V   V", " V V ", "  V  "],
     ["W   W", "W   W", "W   W", "W W W", " W W "],
     ["X   X", " X X ", "  X  ", " X X ", "X   X"],
     ["Y   Y", " Y Y ", "  Y  ", "  Y  ", "  Y  "],
     ["ZZZZZ", "   Z ", "  Z  ", " Z   ", "ZZZZZ"]]
STARTLOG
["main","pretty_stuff_aoL","pp_words_aoM","pp_word_aoN"]
module Main where
import Pretty
main = putStr ((ppShow (80 :: Int) pretty_stuff_aoL) ++ "\n")
  where pretty_stuff_aoL
          = ppAboves
              [ppBesides [ppInt (-42), ppChar '@', ppStr "This is a string"],
               pp'SP,
               ppHang (ppStr "This is the label") (8 :: Int)
                 (ppCat (take (50 :: Int) pp_words_aoM))]
        pp_words_aoM = pp_word_aoN : pp_words_aoM
        pp_word_aoN = ppStr "xxxxx"
STARTLOG
["width_awz","p_awA","seq_awB","ll_awC","emp_awD","safebang@!emp_awD","(!emp_awD)","sl_awE","MkPrettyRep seq_awB ll_awC (!emp_awD) sl_awE","(MkPrettyRep seq_awB ll_awC (!emp_awD) sl_awE)","!(MkPrettyRep seq_awB ll_awC (!emp_awD) sl_awE)","(!(MkPrettyRep seq_awB ll_awC (!emp_awD) sl_awE))","p_awF","seq_awG","ll_awH","emp_awI","sl_awJ","MkPrettyRep seq_awG ll_awH emp_awI sl_awJ","(MkPrettyRep seq_awG ll_awH emp_awI sl_awJ)","!(MkPrettyRep seq_awG ll_awH emp_awI sl_awJ)","(!(MkPrettyRep seq_awG ll_awH emp_awI sl_awJ))","((!(MkPrettyRep seq_awG ll_awH emp_awI sl_awJ)))","width_awK","is_vert_awL","s_aKd","width_aKe","is_vert_aKf","safebang@!is_vert_aKf","(!is_vert_aKf)","ls_aKg","!ls_aKg","(!ls_aKg)","c_aQo","safebang@!c_aQo","(!c_aQo)","width_aQp","safebang@!width_aQp","(!width_aQp)","is_vert_aQq","n_aQr","safebang@!n_aQr","(!n_aQr)","n_aYS","safebang@!n_aYS","(!n_aYS)","n_aYT","safebang@!n_aYT","(!n_aYT)","ppSP","pp'SP","ppLbrack","ppRbrack","ppLparen","ppRparen","ppSemi","ppComma","sep_aYU","ps_aYV","safebang@!ps_aYV","(!ps_aYV)","[]","![]","(![])","x_aYX","[x_aYX]","x_aYY","!x_aYY","(!x_aYY)","xs_aYZ","(!x_aYY) : xs_aYZ","((!x_aYY) : xs_aYZ)","!((!x_aYY) : xs_aYZ)","(!((!x_aYY) : xs_aYZ))","((!((!x_aYY) : xs_aYZ)))","p1_aZ0","p2_aZ1","width_aZ2","safebang@!width_aZ2","(!width_aZ2)","is_vert_aZ3","seq1_aZ4","safebang@!seq1_aZ4","(!seq1_aZ4)","ll1_aZ5","emp1_aZ6","sl1_aZ7","MkPrettyRep (!seq1_aZ4) ll1_aZ5 emp1_aZ6 sl1_aZ7","(MkPrettyRep (!seq1_aZ4) ll1_aZ5 emp1_aZ6 sl1_aZ7)","!(MkPrettyRep (!seq1_aZ4) ll1_aZ5 emp1_aZ6 sl1_aZ7)","(!(MkPrettyRep (!seq1_aZ4) ll1_aZ5 emp1_aZ6 sl1_aZ7))","seq2_aZ8","ll2_aZ9","emp2_aZa","!emp2_aZa","(!emp2_aZa)","sl2_aZb","MkPrettyRep seq2_aZ8 ll2_aZ9 (!emp2_aZa) sl2_aZb","[]","ps_a103","p1_a104","p2_a105","safebang@!p2_a105","(!p2_a105)","width_a106","is_vert_a107","safebang@!is_vert_a107","(!is_vert_a107)","seq1_a108","!seq1_a108","(!seq1_a108)","ll1_a109","!ll1_a109","(!ll1_a109)","emp1_a10a","sl1_a10b","MkPrettyRep (!seq1_a108) (!ll1_a109) emp1_a10a sl1_a10b","seq2_a10c","ll2_a10d","emp2_a10e","sl2_a10f","MkPrettyRep seq2_a10c ll2_a10d emp2_a10e sl2_a10f","li_a10g","wi_a10h","!wi_a10h","(!wi_a10h)","sp_a10i","[]","ps_a10j","p1_a10k","safebang@!p1_a10k","(!p1_a10k)","p2_a10l","safebang@!p2_a10l","(!p2_a10l)","width_a10m","is_vert_a10n","nl_a10o","!nl_a10o","(!nl_a10o)","seq1_a10p","ll1_a10q","!ll1_a10q","(!ll1_a10q)","emp1_a10r","sl1_a10s","!sl1_a10s","(!sl1_a10s)","MkPrettyRep seq1_a10p (!ll1_a10q) emp1_a10r (!sl1_a10s)","seq2_a10t","safebang@!seq2_a10t","(!seq2_a10t)","ll2_a10u","emp2_a10v","sl2_a10w","safebang@!sl2_a10w","(!sl2_a10w)","MkPrettyRep (!seq2_a10t) ll2_a10u emp2_a10v (!sl2_a10w)","(MkPrettyRep (!seq2_a10t) ll2_a10u emp2_a10v (!sl2_a10w))","!(MkPrettyRep (!seq2_a10t) ll2_a10u emp2_a10v (!sl2_a10w))","(!(MkPrettyRep (!seq2_a10t) ll2_a10u emp2_a10v (!sl2_a10w)))","[]","ps_a10x","n_a10y","safebang@!n_a10y","(!n_a10y)","p_a10z","safebang@!p_a10z","(!p_a10z)","width_a10A","False","!False","(!False)","n_a10B","!n_a10B","(!n_a10B)","p_a10C","!p_a10C","(!p_a10C)","width_a10D","!width_a10D","(!width_a10D)","True","seq_a10E","ll_a10F","emp_a10G","safebang@!emp_a10G","(!emp_a10G)","sl_a10H","safebang@!sl_a10H","(!sl_a10H)","MkPrettyRep seq_a10E ll_a10F (!emp_a10G) (!sl_a10H)","(MkPrettyRep seq_a10E ll_a10F (!emp_a10G) (!sl_a10H))","!(MkPrettyRep seq_a10E ll_a10F (!emp_a10G) (!sl_a10H))","(!(MkPrettyRep seq_a10E ll_a10F (!emp_a10G) (!sl_a10H)))","p1_a10I","safebang@!p1_a10I","(!p1_a10I)","n_a10J","p2_a10K","width_a10L","safebang@!width_a10L","(!width_a10L)","is_vert_a10M","seq1_a10N","ll1_a10O","!ll1_a10O","(!ll1_a10O)","emp1_a10P","!emp1_a10P","(!emp1_a10P)","sl1_a10Q","MkPrettyRep seq1_a10N (!ll1_a10O) (!emp1_a10P) sl1_a10Q","seq2_a10R","ll2_a10S","emp2_a10T","sl2_a10U","safebang@!sl2_a10U","(!sl2_a10U)","MkPrettyRep seq2_a10R ll2_a10S emp2_a10T (!sl2_a10U)","(MkPrettyRep seq2_a10R ll2_a10S emp2_a10T (!sl2_a10U))","!(MkPrettyRep seq2_a10R ll2_a10S emp2_a10T (!sl2_a10U))","(!(MkPrettyRep seq2_a10R ll2_a10S emp2_a10T (!sl2_a10U)))","seq2'_a10V","!seq2'_a10V","(!seq2'_a10V)","ll2'_a10W","emp2'_a10X","sl2'_a10Y","MkPrettyRep (!seq2'_a10V) ll2'_a10W emp2'_a10X sl2'_a10Y","[]","width_a10Z","is_vert_a110","p_a111","safebang@!p_a111","(!p_a111)","[(!p_a111)]","![(!p_a111)]","(![(!p_a111)])","width_a112","!width_a112","(!width_a112)","is_vert_a113","!is_vert_a113","(!is_vert_a113)","ps_a114","!ps_a114","(!ps_a114)","width_a115","is_vert_a116","!is_vert_a116","(!is_vert_a116)","seq_a118","ll_a119","!ll_a119","(!ll_a119)","emp_a11a","sl_a11b","MkPrettyRep seq_a118 (!ll_a119) emp_a11a sl_a11b","(MkPrettyRep seq_a118 (!ll_a119) emp_a11a sl_a11b)","!(MkPrettyRep seq_a118 (!ll_a119) emp_a11a sl_a11b)","(!(MkPrettyRep seq_a118 (!ll_a119) emp_a11a sl_a11b))","((!(MkPrettyRep seq_a118 (!ll_a119) emp_a11a sl_a11b)))","pr_a117@((!(MkPrettyRep seq_a118 (!ll_a119) emp_a11a sl_a11b)))","False","x_a11c","True","!True","(!True)","x_a11d","!x_a11d","(!x_a11d)","True","x_a11e","!x_a11e","(!x_a11e)","False","x_a11f"]
module Pretty
       (Pretty, PprStyle(..), ppNil, ppStr, ppChar, ppInt, ppInteger,
        ppDouble, ppSP, pp'SP, ppLbrack, ppRbrack, ppLparen, ppRparen,
        ppSemi, ppComma, ppCat, ppBeside, ppBesides, ppAbove, ppAboves,
        ppNest, ppSep, ppHang, ppInterleave, ppShow, ppUnformatted,
        PrettyRep)
       where
import CharSeq

ppNil :: Pretty

ppSP, pp'SP, ppLbrack, ppRbrack, ppLparen, ppRparen, ppSemi,
      ppComma :: Pretty

ppStr :: [Char] -> Pretty

ppChar :: Char -> Pretty

ppInt :: Int -> Pretty

ppInteger :: Integer -> Pretty

ppDouble :: Double -> Pretty

ppBeside :: Pretty -> Pretty -> Pretty

ppBesides :: [Pretty] -> Pretty

ppBesideSP :: Pretty -> Pretty -> Pretty

ppCat :: [Pretty] -> Pretty

ppAbove :: Pretty -> Pretty -> Pretty

ppAboves :: [Pretty] -> Pretty

ppInterleave :: Pretty -> [Pretty] -> Pretty

ppSep :: [Pretty] -> Pretty

ppHang :: Pretty -> Int -> Pretty -> Pretty

ppNest :: Int -> Pretty -> Pretty

ppShow :: Int -> Pretty -> [Char]

ppUnformatted :: Pretty -> [Char]
ppShow width_awz p_awA = cShow seq_awB
  where (norecord@(MkPrettyRep seq_awB ll_awC (!emp_awD) sl_awE))
          = p_awA width_awz False
ppUnformatted p_awF = cShow seq_awG
  where ((norecord@(MkPrettyRep seq_awG ll_awH emp_awI sl_awJ)))
          = p_awF 80 False
ppNil width_awK is_vert_awL
  = MkPrettyRep cNil 0 True (width_awK >= 0)
ppStr s_aKd width_aKe (!is_vert_aKf)
  = MkPrettyRep (cStr s_aKd) ls_aKg False (width_aKe >= ls_aKg)
  where (norecord@ls_aKg) = length s_aKd
ppChar (!c_aQo) (!width_aQp) is_vert_aQq
  = MkPrettyRep (cCh c_aQo) 1 False (width_aQp >= 1)
ppInt (!n_aQr) = ppStr (show n_aQr)
ppInteger (!n_aYS) = ppStr (show n_aYS)
ppDouble (!n_aYT) = ppStr (show n_aYT)
ppSP = ppChar ' '
pp'SP = ppStr ", "
ppLbrack = ppChar '['
ppRbrack = ppChar ']'
ppLparen = ppChar '('
ppRparen = ppChar ')'
ppSemi = ppChar ';'
ppComma = ppChar ','
ppInterleave sep_aYU (!ps_aYV) = ppSep (pi_aYW ps_aYV)
  where pi_aYW (norecord@[]) = []
        pi_aYW [x_aYX] = [x_aYX]
        pi_aYW ((norecord@((norecord@x_aYY) : xs_aYZ)))
          = (ppBeside x_aYY sep_aYU) : pi_aYW xs_aYZ
ppBeside p1_aZ0 p2_aZ1 (!width_aZ2) is_vert_aZ3
  = MkPrettyRep (seq1_aZ4 `cAppend` (cIndent ll1_aZ5 seq2_aZ8))
      (ll1_aZ5 + ll2_aZ9)
      (emp1_aZ6 `andL` emp2_aZa)
      ((width_aZ2 >= 0) `andL` (sl1_aZ7 `andL` sl2_aZb))
  where (norecord@(MkPrettyRep (!seq1_aZ4) ll1_aZ5 emp1_aZ6 sl1_aZ7))
          = p1_aZ0 width_aZ2 False
        MkPrettyRep seq2_aZ8 ll2_aZ9 (norecord@emp2_aZa) sl2_aZb
          = p2_aZ1 (width_aZ2 - ll1_aZ5) False
ppBesides [] = ppNil
ppBesides ps_a103 = foldr1 ppBeside ps_a103
ppBesideSP p1_a104 (!p2_a105) width_a106 (!is_vert_a107)
  = MkPrettyRep
      (seq1_a108 `cAppend`
         (sp_a10i `cAppend` (cIndent li_a10g seq2_a10c)))
      (li_a10g + ll2_a10d)
      (emp1_a10a `andL` emp2_a10e)
      ((width_a106 >= wi_a10h) `andL` (sl1_a10b `andL` sl2_a10f))
  where MkPrettyRep (norecord@seq1_a108) (norecord@ll1_a109)
          emp1_a10a sl1_a10b
          = p1_a104 width_a106 False
        MkPrettyRep seq2_a10c ll2_a10d emp2_a10e sl2_a10f
          = p2_a105 (width_a106 - li_a10g) False
        
        li_a10g, wi_a10h :: Int
        li_a10g = if emp1_a10a then 0 else ll1_a109 + 1
        (norecord@wi_a10h) = if emp1_a10a then 0 else 1
        sp_a10i = if emp1_a10a `orL` emp2_a10e then cNil else (cCh ' ')
ppCat [] = ppNil
ppCat ps_a10j = foldr1 ppBesideSP ps_a10j
ppAbove (!p1_a10k) (!p2_a10l) width_a10m is_vert_a10n
  = MkPrettyRep (seq1_a10p `cAppend` (nl_a10o `cAppend` seq2_a10t))
      ll2_a10u
      (emp1_a10r `andL` emp2_a10v)
      False
  where (norecord@nl_a10o)
          = if emp1_a10r `orL` emp2_a10v then cNil else cNL
        MkPrettyRep seq1_a10p (norecord@ll1_a10q) emp1_a10r
          (norecord@sl1_a10s)
          = p1_a10k width_a10m True
        (norecord@(MkPrettyRep (!seq2_a10t) ll2_a10u emp2_a10v
                     (!sl2_a10w)))
          = p2_a10l width_a10m True
ppAboves [] = ppNil
ppAboves ps_a10x = foldr1 ppAbove ps_a10x
ppNest (!n_a10y) (!p_a10z) width_a10A (norecord@False)
  = p_a10z width_a10A False
ppNest (norecord@n_a10B) (norecord@p_a10C) (norecord@width_a10D)
  True
  = MkPrettyRep (cIndent n_a10B seq_a10E) (ll_a10F + n_a10B) emp_a10G
      sl_a10H
  where (norecord@(MkPrettyRep seq_a10E ll_a10F (!emp_a10G)
                     (!sl_a10H)))
          = p_a10C (width_a10D - n_a10B) True
ppHang (!p1_a10I) n_a10J p2_a10K (!width_a10L) is_vert_a10M
  = if emp1_a10P then p2_a10K width_a10L is_vert_a10M else
      if (ll1_a10O <= n_a10J) `orL` sl2_a10U then
        MkPrettyRep
          (seq1_a10N `cAppend` (cCh ' ') `cAppend`
             (cIndent (ll1_a10O + 1) seq2_a10R))
          (ll1_a10O + 1 + ll2_a10S)
          False
          (sl1_a10Q `andL` sl2_a10U)
        else
        MkPrettyRep
          (seq1_a10N `cAppend` (cNL `cAppend` (cIndent n_a10J seq2'_a10V)))
          ll2'_a10W
          False
          False
  where MkPrettyRep seq1_a10N (norecord@ll1_a10O)
          (norecord@emp1_a10P) sl1_a10Q
          = p1_a10I width_a10L False
        (norecord@(MkPrettyRep seq2_a10R ll2_a10S emp2_a10T (!sl2_a10U)))
          = p2_a10K (width_a10L - (ll1_a10O + 1)) False
        MkPrettyRep (norecord@seq2'_a10V) ll2'_a10W emp2'_a10X sl2'_a10Y
          = p2_a10K (width_a10L - n_a10J) False
ppSep [] width_a10Z is_vert_a110 = ppNil width_a10Z is_vert_a110
ppSep (norecord@[(!p_a111)]) (norecord@width_a112)
  (norecord@is_vert_a113) = p_a111 width_a112 is_vert_a113
ppSep (norecord@ps_a114) width_a115 (norecord@is_vert_a116)
  = if sl_a11b then pr_a117 else
      ppAboves ps_a114 width_a115 is_vert_a116
  where pr_a117@((norecord@(MkPrettyRep seq_a118 (norecord@ll_a119)
                              emp_a11a sl_a11b)))
          = ppCat ps_a114 width_a115 is_vert_a116

andL :: Bool -> Bool -> Bool
andL False x_a11c = False
andL (norecord@True) (norecord@x_a11d) = x_a11d

orL :: Bool -> Bool -> Bool
orL True (norecord@x_a11e) = True
orL False x_a11f = x_a11f

data PrettyRep = MkPrettyRep CSeq Int Bool Bool

type Pretty = Int -> Bool -> PrettyRep

data PprStyle = PprForUser
              | PprDebug
              | PprShowAll
              | PprInterface
STARTLOG
["cNil","cs1_ane","cs2_anf","n_ang","cs_anh","safebang@!cs_anh","(!cs_anh)","cNL","cStr","cCh","seq_ani","n_anj","nlp_ank","CNil","seqs_anl","n_anm","!n_anm","(!n_anm)","nlp_ann","seq1_ano","seq2_anp","CAppend seq1_ano seq2_anp","(CAppend seq1_ano seq2_anp)","seqs_anq","!seqs_anq","(!seqs_anq)","n_anr","!n_anr","(!n_anr)","nlp_ans","!nlp_ans","(!nlp_ans)","n'_ant","safebang@!n'_ant","(!n'_ant)","seq_anu","CIndent (!n'_ant) seq_anu","(CIndent (!n'_ant) seq_anu)","!(CIndent (!n'_ant) seq_anu)","(!(CIndent (!n'_ant) seq_anu))","((!(CIndent (!n'_ant) seq_anu)))","!((!(CIndent (!n'_ant) seq_anu)))","(!((!(CIndent (!n'_ant) seq_anu))))","seqs_anv","!seqs_anv","(!seqs_anv)","n_aou","!n_aou","(!n_aou)","nlp_aov","CNewline","!CNewline","(!CNewline)","seqs_aow","n_aox","False","s_aoy","CStr s_aoy","(CStr s_aoy)","seqs_aoz","!seqs_aoz","(!seqs_aoz)","n_aoA","!n_aoA","(!n_aoA)","False","c_aoB","CCh c_aoB","(CCh c_aoB)","!(CCh c_aoB)","(!(CCh c_aoB))","((!(CCh c_aoB)))","seqs_aoC","!seqs_aoC","(!seqs_aoC)","n_aoD","True","s_aoE","CStr s_aoE","(CStr s_aoE)","!(CStr s_aoE)","(!(CStr s_aoE))","((!(CStr s_aoE)))","seqs_aoF","!seqs_aoF","(!seqs_aoF)","n_aoG","True","c_aoH","CCh c_aoH","(CCh c_aoH)","!(CCh c_aoH)","(!(CCh c_aoH))","((!(CCh c_aoH)))","seqs_aoI","nlp_aoJ","!nlp_aoJ","(!nlp_aoJ)","[]","nlp_aoK","col_aoL","seq_aoM","(col_aoL, seq_aoM)","seqs_aoN","!seqs_aoN","(!seqs_aoN)","(col_aoL, seq_aoM) : (!seqs_aoN)","((col_aoL, seq_aoM) : (!seqs_aoN))","!((col_aoL, seq_aoM) : (!seqs_aoN))","(!((col_aoL, seq_aoM) : (!seqs_aoN)))","0","!0","(!0)","s_aoO","lazydmd@!s_aoO","(!s_aoO)","n_aoP","s_aoQ"]
module CharSeq
       (CSeq, cNil, cAppend, cIndent, cNL, cStr, cCh, cShow) where

cShow :: CSeq -> [Char]

cNil :: CSeq

cAppend :: CSeq -> CSeq -> CSeq

cIndent :: Int -> CSeq -> CSeq

cNL :: CSeq

cStr :: [Char] -> CSeq

cCh :: Char -> CSeq
cNil = CNil
cAppend cs1_ane cs2_anf = CAppend cs1_ane cs2_anf
cIndent n_ang (!cs_anh) = CIndent n_ang cs_anh
cNL = CNewline
cStr = CStr
cCh = CCh
cShow seq_ani = flatten 0 True seq_ani []

flatten :: Int -> Bool -> CSeq -> [(Int, CSeq)] -> String
flatten n_anj nlp_ank CNil seqs_anl = flattenS nlp_ank seqs_anl
flatten (norecord@n_anm) nlp_ann (CAppend seq1_ano seq2_anp)
  (norecord@seqs_anq)
  = flatten n_anm nlp_ann seq1_ano ((n_anm, seq2_anp) : seqs_anq)
flatten (norecord@n_anr) (norecord@nlp_ans)
  (norecord@((norecord@(CIndent (!n'_ant) seq_anu))))
  (norecord@seqs_anv)
  = flatten (n'_ant + n_anr) nlp_ans seq_anu seqs_anv
flatten (norecord@n_aou) nlp_aov (norecord@CNewline) seqs_aow
  = '\n' : flattenS True seqs_aow
flatten n_aox False (CStr s_aoy) (norecord@seqs_aoz)
  = s_aoy ++ flattenS False seqs_aoz
flatten (norecord@n_aoA) False ((norecord@(CCh c_aoB)))
  (norecord@seqs_aoC) = c_aoB : flattenS False seqs_aoC
flatten n_aoD True ((norecord@(CStr s_aoE))) (norecord@seqs_aoF)
  = mkIndent n_aoD (s_aoE ++ flattenS False seqs_aoF)
flatten n_aoG True ((norecord@(CCh c_aoH))) seqs_aoI
  = mkIndent n_aoG (c_aoH : flattenS False seqs_aoI)

flattenS :: Bool -> [(Int, CSeq)] -> String
flattenS (norecord@nlp_aoJ) [] = ""
flattenS nlp_aoK
  (norecord@((col_aoL, seq_aoM) : (norecord@seqs_aoN)))
  = flatten col_aoL nlp_aoK seq_aoM seqs_aoN

mkIndent :: Int -> String -> String
mkIndent (norecord@0) (lazydmd@s_aoO) = s_aoO
mkIndent n_aoP s_aoQ
  = if (n_aoP >= 8) then '\t' : mkIndent (n_aoP - 8) s_aoQ else
      ' ' : mkIndent (n_aoP - 1) s_aoQ

data CSeq = CNil
          | CAppend CSeq CSeq
          | CIndent Int CSeq
          | CNewline
          | CStr [Char]
          | CCh Char
STARTLOG
STARTLOG
["main","l_aNq","!l_aNq","(!l_aNq)","[]","![]","(![])","'<'","x_aTn","!x_aTn","(!x_aTn)","'<' : (!x_aTn)","('<' : (!x_aTn))","!('<' : (!x_aTn))","(!('<' : (!x_aTn)))","((!('<' : (!x_aTn))))","!((!('<' : (!x_aTn))))","(!((!('<' : (!x_aTn)))))","'['","!'['","(!'[')","x_aTo","(!'[') : x_aTo","((!'[') : x_aTo)","x_aTp","!x_aTp","(!x_aTp)","c_aTq","rest_aTr","c_aTq : rest_aTr","(c_aTq : rest_aTr)","!(c_aTq : rest_aTr)","(!(c_aTq : rest_aTr))","((!(c_aTq : rest_aTr)))","!((!(c_aTq : rest_aTr)))","(!((!(c_aTq : rest_aTr))))","z_aTs","a_aTt","'-'","b_aTu","safebang@!b_aTu","(!b_aTu)","']'","!']'","(!']')","rest_aTv","(!']') : rest_aTv","((!']') : rest_aTv)","!((!']') : rest_aTv)","(!((!']') : rest_aTv))","(!b_aTu) : (!((!']') : rest_aTv))","((!b_aTu) : (!((!']') : rest_aTv)))","'-' : ((!b_aTu) : (!((!']') : rest_aTv)))","('-' : ((!b_aTu) : (!((!']') : rest_aTv))))","a_aTt : ('-' : ((!b_aTu) : (!((!']') : rest_aTv))))","(a_aTt : ('-' : ((!b_aTu) : (!((!']') : rest_aTv)))))","!(a_aTt : ('-' : ((!b_aTu) : (!((!']') : rest_aTv)))))","(!(a_aTt : ('-' : ((!b_aTu) : (!((!']') : rest_aTv))))))","c_a16X","!c_a16X","(!c_a16X)","z_a16Y","!z_a16Y","(!z_a16Y)","c_a16Z","z_a170","x_a171","i_a18e","!i_a18e","(!i_a18e)","z_a18f","!z_a18f","(!z_a18f)","p_a172","_","q_a173","_ : q_a173","(p_a172, _ : q_a173)","r_a174","!r_a174","(!r_a174)","_","s_a175","!s_a175","(!s_a175)","_ : (!s_a175)","((!r_a174), _ : (!s_a175))","u_a176","!u_a176","(!u_a176)","v_a177","!v_a177","(!v_a177)","((!u_a176), (!v_a177))","s_a17b","!s_a17b","(!s_a17b)","u_a17c","safebang@!u_a17c","(!u_a17c)","c_a17d","s_a18c","i_a18d","width_a17a"]
module Main (main) where
import Data.Char
main
  = interact
      (("Enter a generator: " ++) . show . numchars . expand . head .
         lines)

numchars :: [String] -> Int
numchars (norecord@l_aNq) = sum $ map length l_aNq
expand (norecord@[]) = [""]
expand (norecord@((norecord@('<' : (norecord@x_aTn)))))
  = numericRule x_aTn
expand ((norecord@'[') : x_aTo) = alphabeticRule x_aTo
expand (norecord@x_aTp) = constantRule x_aTp
constantRule (norecord@((norecord@(c_aTq : rest_aTr))))
  = [c_aTq : z_aTs | z_aTs <- expand rest_aTr]
alphabeticRule
  (norecord@(a_aTt :
               ('-' : ((!b_aTu) : (norecord@((norecord@']') : rest_aTv))))))
  | a_aTt <= b_aTu =
    [c_a16X : z_a16Y | (norecord@c_a16X) <- [a_aTt .. b_aTu],
     (norecord@z_a16Y) <- expand rest_aTv]
  | otherwise =
    [c_a16Z : z_a170 | c_a16Z <- reverse [b_aTu .. a_aTt],
     z_a170 <- expand rest_aTv]
numericRule x_a171
  = [pad_a179 (show i_a18e) ++ z_a18f |
     (norecord@i_a18e) <- if u_a176 < v_a177 then [u_a176 .. v_a177]
                            else [u_a176, u_a176 - 1 .. v_a177],
     (norecord@z_a18f) <- expand s_a175]
  where (p_a172, _ : q_a173) = span (/= '-') x_a171
        ((norecord@r_a174), _ : (norecord@s_a175)) = span (/= '>') q_a173
        ((norecord@u_a176), (norecord@v_a177))
          = (mknum_a178 p_a172, mknum_a178 r_a174)
        mknum_a178 (norecord@s_a17b)
          = foldl
              (\ (!u_a17c) c_a17d -> u_a17c * 10 + (ord c_a17d - ord '0'))
              0
              s_a17b
        pad_a179 s_a18c
          = ['0' | i_a18d <- [1 .. (width_a17a - (length s_a18c))]] ++ s_a18c
        width_a17a = max (length (show u_a176)) (length (show v_a177))
STARTLOG
["main","arg_axG","[arg_axG]","n_aRg","n_aRh","!n_aRh","(!n_aRh)"]
module Main (main) where
import Data.Complex
import System.Environment
main
  = do [arg_axG] <- getArgs
       print
         (round (realPart (sum [f n_aRg | n_aRg <- [1 .. (read arg_axG)]])))

f :: Int -> Complex Double
f (norecord@n_aRh)
  = mkPolar 1 ((2 * pi) / fromIntegral n_aRh) ^ n_aRh
STARTLOG
["primes","s_aoB","ms_aoC","ns_aoD","Wheel s_aoB ms_aoC ns_aoD","(Wheel s_aoB ms_aoC ns_aoD)","!(Wheel s_aoB ms_aoC ns_aoD)","(!(Wheel s_aoB ms_aoC ns_aoD))","ws_aoE","(!(Wheel s_aoB ms_aoC ns_aoD)) : ws_aoE","((!(Wheel s_aoB ms_aoC ns_aoD)) : ws_aoE)","ps_aoF","qs_aoG","o_aoM","n_avR","!n_avR","(!n_avR)","rs_avS","o_aJk","n_aJl","rs_aJm","n'_aJn","!n'_aJn","(!n'_aJn)","sp_aoK","q_aoL","squares","p_aMN","!p_aMN","(!p_aMN)","wheels","s_aMO","safebang@!s_aMO","(!s_aMO)","ms_aMP","ns_aMQ","safebang@!ns_aMQ","(!ns_aMQ)","Wheel (!s_aMO) ms_aMP (!ns_aMQ)","(Wheel (!s_aMO) ms_aMP (!ns_aMQ))","!(Wheel (!s_aMO) ms_aMP (!ns_aMQ))","(!(Wheel (!s_aMO) ms_aMP (!ns_aMQ)))","p_aMR","!p_aMR","(!p_aMR)","q_aMS","xs_aMT","ns'_aMU","!ns'_aMU","(!ns'_aMU)","(xs_aMT, (!ns'_aMU))","ms'_aMV","0","_","t_aMZ","o_aN0","!o_aN0","(!o_aN0)","n_aN1","rs_aN2","o_aW9","n_aWa","!n_aWa","(!n_aWa)","rs_aWb","n'_aWc","!n'_aWc","(!n'_aWc)","main","arg_aWd","[arg_aWd]","![arg_aWd]","(![arg_aWd])"]
module Main (main) where
import System.Environment

primes :: [Int]
primes = spiral wheels primes squares
spiral ((norecord@(Wheel s_aoB ms_aoC ns_aoD)) : ws_aoE) ps_aoF
  qs_aoG = foldr turn0_aoI (roll_aoH s_aoB) ns_aoD
  where roll_aoH o_aoM
          = foldr (turn_aoJ o_aoM)
              (foldr (turn_aoJ o_aoM) (roll_aoH (o_aoM + s_aoB)) ns_aoD)
              ms_aoC
        turn0_aoI (norecord@n_avR) rs_avS
          = if n_avR < q_aoL then n_avR : rs_avS else sp_aoK
        turn_aoJ o_aJk n_aJl rs_aJm
          = let (norecord@n'_aJn) = o_aJk + n_aJl in
              if n'_aJn == 2 || n'_aJn < q_aoL then n'_aJn : rs_aJm else
                dropWhile (< n'_aJn) sp_aoK
        sp_aoK = spiral ws_aoE (tail ps_aoF) (tail qs_aoG)
        q_aoL = head qs_aoG

squares :: [Int]
squares = [p_aMN * p_aMN | (norecord@p_aMN) <- primes]

wheels :: [Wheel]
wheels = Wheel 1 [1] [] : zipWith3 nextSize wheels primes squares
nextSize (norecord@(Wheel (!s_aMO) ms_aMP (!ns_aMQ)))
  (norecord@p_aMR) q_aMS = Wheel (s_aMO * p_aMR) ms'_aMV ns'_aMU
  where (xs_aMT, (norecord@ns'_aMU))
          = span (<= q_aMS)
              (foldr turn0_aMX (roll_aMW (p_aMR - 1) s_aMO) ns_aMQ)
        ms'_aMV = foldr turn0_aMX xs_aMT ms_aMP
        roll_aMW 0 _ = []
        roll_aMW t_aMZ (norecord@o_aN0)
          = foldr (turn_aMY o_aN0)
              (foldr (turn_aMY o_aN0) (roll_aMW (t_aMZ - 1) (o_aN0 + s_aMO))
                 ns_aMQ)
              ms_aMP
        turn0_aMX n_aN1 rs_aN2
          = if n_aN1 `mod` p_aMR > 0 then n_aN1 : rs_aN2 else rs_aN2
        turn_aMY o_aW9 (norecord@n_aWa) rs_aWb
          = let (norecord@n'_aWc) = o_aW9 + n_aWa in
              if n'_aWc `mod` p_aMR > 0 then n'_aWc : rs_aWb else rs_aWb
main
  = do (norecord@[arg_aWd]) <- getArgs
       print (primes !! ((read arg_aWd) :: Int))

data Wheel = Wheel Int [Int] [Int]
STARTLOG
["x_aoy","n_apx","!n_apx","(!n_apx)","x_apy","!x_apy","(!x_apy)","n_aM6","ns_aM7","safebang@!ns_aM7","(!ns_aM7)","n_aM6 : (!ns_aM7)","(n_aM6 : (!ns_aM7))","!(n_aM6 : (!ns_aM7))","(!(n_aM6 : (!ns_aM7)))","primes","main","arg_aPH","safebang@!arg_aPH","(!arg_aPH)","[(!arg_aPH)]"]
module Main (main) where
import System.Environment

suCC :: Int -> Int
suCC x_aoy = x_aoy + 1

isdivs :: Int -> Int -> Bool
isdivs (norecord@n_apx) (norecord@x_apy) = mod x_apy n_apx /= 0

the_filter :: [Int] -> [Int]
the_filter (norecord@(n_aM6 : (!ns_aM7)))
  = filter (isdivs n_aM6) ns_aM7

primes :: [Int]
primes = map head (iterate the_filter (iterate suCC 2))
main
  = do [(!arg_aPH)] <- getArgs
       print $ primes !! (read arg_aPH)
STARTLOG
["Z","x_aLo","S x_aLo","(S x_aLo)","x_aLp","Z","x_aLq","!x_aLq","(!x_aLq)","y_aLr","!y_aLr","(!y_aLr)","S (!y_aLr)","(S (!y_aLr))","main","power_aLs","safebang@!power_aLs","(!power_aLs)","[(!power_aLs)]","Z","!Z","(!Z)","y_aPZ","x_aQ0","safebang@!x_aQ0","(!x_aQ0)","S (!x_aQ0)","(S (!x_aQ0))","y_aQ1","x_aQ2","safebang@!x_aQ2","(!x_aQ2)","Z","!Z","(!Z)","x_aQ3","!x_aQ3","(!x_aQ3)","y_aQ4","safebang@!y_aQ4","(!y_aQ4)","S (!y_aQ4)","(S (!y_aQ4))","x_aQ5"]
module Main (main) where
import System.Environment

infix 8 ^^^

int :: Nat -> Int
int Z = 0
int (S x_aLo) = 1 + int x_aLo
x_aLp ^^^ Z = S Z
(norecord@x_aLq) ^^^ (S (norecord@y_aLr))
  = x_aLq * (x_aLq ^^^ y_aLr)
main
  = do [(!power_aLs)] <- getArgs
       print $ int (3 ^^^ (fromInteger $ read power_aLs))

data Nat = Z
         | S Nat
         deriving (Eq, Ord, Show)

instance Num Nat where
        (norecord@Z) + y_aPZ = y_aPZ
        (S (!x_aQ0)) + y_aQ1 = S (x_aQ0 + y_aQ1)
        (!x_aQ2) * (norecord@Z) = Z
        (norecord@x_aQ3) * (S (!y_aQ4)) = x_aQ3 * y_aQ4 + x_aQ3
        fromInteger x_aQ5
          = if x_aQ5 < 1 then Z else S (fromInteger (x_aQ5 - 1))
STARTLOG
STARTLOG
["main","arg_aoo","[arg_aoo]","![arg_aoo]","(![arg_aoo])","nq_asV","x_at5","d_at6","[]","![]","(![])","x_at7","!x_at7","(!x_at7)","d_at8","q_at9","!q_at9","(!q_at9)","l_ata","(!q_at9) : l_ata","((!q_at9) : l_ata)","0","n_aHA","b_aHB","q_aHC"]
module Main (main) where
import System.Environment
main
  = do (norecord@[arg_aoo]) <- getArgs
       print $ nsoln $ read arg_aoo
nsoln nq_asV = length (gen_asX nq_asV)
  where safe_asW :: Int -> Int -> [Int] -> Bool
        safe_asW x_at5 d_at6 (norecord@[]) = True
        safe_asW (norecord@x_at7) d_at8 ((norecord@q_at9) : l_ata)
          = x_at7 /= q_at9 && x_at7 /= q_at9 + d_at8 && x_at7 /= q_at9 -
              d_at8
              && safe_asW x_at7 (d_at8 + 1) l_ata
        
        gen_asX :: Int -> [[Int]]
        gen_asX 0 = [[]]
        gen_asX n_aHA
          = [(q_aHC : b_aHB) | b_aHB <- gen_asX (n_aHA - 1),
             q_aHC <- [1 .. nq_asV], safe_asW q_aHC 1 b_aHB]
STARTLOG
STARTLOG
["primes","s_aoC","ns_aoD","Wheel s_aoC ns_aoD","ws_aoE","Wheel s_aoC ns_aoD : ws_aoE","(Wheel s_aoC ns_aoD : ws_aoE)","!(Wheel s_aoC ns_aoD : ws_aoE)","(!(Wheel s_aoC ns_aoD : ws_aoE))","ps_aoF","qs_aoG","o_aGG","!o_aGG","(!o_aGG)","n_aGH","n'_aGI","!n'_aGI","(!n'_aGI)","noFactor_aoH","lazydmd@!noFactor_aoH","(!noFactor_aoH)","p_aGJ","ps_aGK","p_aGJ : ps_aGK","(p_aGJ : ps_aGK)","q_aGL","safebang@!q_aGL","(!q_aGL)","qs_aGM","(!q_aGL) : qs_aGM","((!q_aGL) : qs_aGM)","n_aGN","safebang@!n_aGN","(!n_aGN)","squares","p_aPU","!p_aPU","(!p_aPU)","wheels","s_aPV","ns_aPW","Wheel s_aPV ns_aPW","(Wheel s_aPV ns_aPW)","!(Wheel s_aPV ns_aPW)","(!(Wheel s_aPV ns_aPW))","p_aPX","!p_aPX","(!p_aPX)","ns'_aPY","!ns'_aPY","(!ns'_aPY)","o_aPZ","n_aQ0","!n_aQ0","(!n_aQ0)","n'_aQ1","!n'_aQ1","(!n'_aQ1)","main","arg_aQ2","[arg_aQ2]"]
module Main (main) where
import System.Environment

primes :: [Int]
primes = sieve wheels primes squares
sieve (norecord@(Wheel s_aoC ns_aoD : ws_aoE)) ps_aoF qs_aoG
  = [n'_aGI |
     (norecord@o_aGG) <- s_aoC :
                           [s_aoC * 2, s_aoC * 3 .. (head ps_aoF - 1) * s_aoC],
     n_aGH <- ns_aoD, (norecord@n'_aGI) <- [n_aGH + o_aGG],
     noFactor_aoH n'_aGI]
      ++ sieve ws_aoE (tail ps_aoF) (tail qs_aoG)
  where (lazydmd@noFactor_aoH)
          = if s_aoC <= 2 then const True else notDivBy ps_aoF qs_aoG
notDivBy (p_aGJ : ps_aGK) ((!q_aGL) : qs_aGM) (!n_aGN)
  = q_aGL > n_aGN || n_aGN `mod` p_aGJ > 0 &&
      notDivBy ps_aGK qs_aGM n_aGN

squares :: [Int]
squares = [p_aPU * p_aPU | (norecord@p_aPU) <- primes]

wheels :: [Wheel]
wheels = Wheel 1 [1] : zipWith nextSize wheels primes
nextSize (norecord@(Wheel s_aPV ns_aPW)) (norecord@p_aPX)
  = Wheel (s_aPV * p_aPX) ns'_aPY
  where (norecord@ns'_aPY)
          = [n'_aQ1 | o_aPZ <- [0, s_aPV .. (p_aPX - 1) * s_aPV],
             (norecord@n_aQ0) <- ns_aPW, (norecord@n'_aQ1) <- [n_aQ0 + o_aPZ],
             n'_aQ1 `mod` p_aPX > 0]
main
  = do [arg_aQ2] <- getArgs
       print (primes !! ((read arg_aQ2) :: Int))

data Wheel = Wheel Int [Int]
STARTLOG
["x_aov","safebang@!x_aov","(!x_aov)","y_aow","z_aox","safebang@!z_aox","(!z_aox)","main","xs_aCX","ys_aCY","zs_aCZ","safebang@!zs_aCZ","(!zs_aCZ)","[xs_aCX, ys_aCY, (!zs_aCZ)]","![xs_aCX, ys_aCY, (!zs_aCZ)]","(![xs_aCX, ys_aCY, (!zs_aCZ)])"]
module Main (main) where
import System.Environment

tak :: Int -> Int -> Int -> Int
tak (!x_aov) y_aow (!z_aox)
  = if not (y_aow < x_aov) then z_aox else
      tak (tak (x_aov - 1) y_aow z_aox) (tak (y_aow - 1) z_aox x_aov)
        (tak (z_aox - 1) x_aov y_aow)
main
  = do (norecord@[xs_aCX, ys_aCY, (!zs_aCZ)]) <- getArgs
       print (tak (read xs_aCX) (read ys_aCY) (read zs_aCZ))
STARTLOG
["main","arg_aov","[arg_aov]","n_at2"]
module Main (main) where
import System.Environment
main
  = do [arg_aov] <- getArgs
       print $ nfib $ read arg_aov

nfib :: Double -> Double
nfib n_at2
  = if n_at2 <= 1 then 1 else nfib (n_at2 - 1) + nfib (n_at2 - 2) + 1
STARTLOG
["l_aoG","safebang@!l_aoG","(!l_aoG)","u_aoH","f_aoI","safebang@!f_aoI","(!f_aoI)","d_aoJ","!d_aoJ","(!d_aoJ)","l1_aEX","u1_aEY","l2_aEZ","!l2_aEZ","(!l2_aEZ)","u2_aF0","!u2_aF0","(!u2_aF0)","f_aF1","y_aF2","safebang@!y_aF2","(!y_aF2)","x_aF3","u_aF4","v_aF5","x_aF6","y_aF7","ints","zarks","rtotals","n_aIx","is","itotals","n_aIy","!n_aIy","(!n_aIy)","es","n_aIz","!n_aIz","(!n_aIz)","main","range_aIA","[range_aIA]"]
module Main (integrate1D, main) where
import System.Environment

integrate1D :: Double -> Double -> (Double -> Double) -> Double
integrate1D (!l_aoG) u_aoH (!f_aoI)
  = let (norecord@d_aoJ) = (u_aoH - l_aoG) / 8.0 in
      d_aoJ *
        sum
          [(f_aoI l_aoG) * 0.5, f_aoI (l_aoG + d_aoJ),
           f_aoI (l_aoG + (2.0 * d_aoJ)), f_aoI (l_aoG + (3.0 * d_aoJ)),
           f_aoI (l_aoG + (4.0 * d_aoJ)), f_aoI (u_aoH - (3.0 * d_aoJ)),
           f_aoI (u_aoH - (2.0 * d_aoJ)), f_aoI (u_aoH - d_aoJ),
           (f_aoI u_aoH) * 0.5]
integrate2D l1_aEX u1_aEY (norecord@l2_aEZ) (norecord@u2_aF0) f_aF1
  = integrate1D l2_aEZ u2_aF0
      (\ (!y_aF2) ->
         integrate1D l1_aEX u1_aEY (\ x_aF3 -> f_aF1 x_aF3 y_aF2))
zark u_aF4 v_aF5
  = integrate2D 0.0 u_aF4 0.0 v_aF5
      (\ x_aF6 -> (\ y_aF7 -> x_aF6 * y_aF7))
ints = [1.0 ..] :: [Double]
zarks = zipWith zark ints (map (2.0 *) ints)
rtotals = head zarks : zipWith (+) (tail zarks) rtotals
rtotal n_aIx = rtotals !! n_aIx
is = map (^ 4) ints
itotals = head is : zipWith (+) (tail is) itotals
itotal (norecord@n_aIy) = itotals !! n_aIy
es = map (^ 2) (zipWith (-) rtotals itotals)
etotal (norecord@n_aIz) = sum (take n_aIz es)
main
  = do [range_aIA] <- getArgs
       putStrLn $ show $ etotal $ read range_aIA
